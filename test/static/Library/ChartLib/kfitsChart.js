import {
    CreateIndicator,
    CMAGroupPropertyInfo
} from './Indicator.js'

import { sprintf } from '../common/utils.js'

import {
    CLineTool,
    CHozrLineTool,
    CVertLineTool,
    CCrossLineTool,
    CRectTool,
    CCircleTool,
    CTriangleTool,
} from './Tools.js'

import colorTable from '../../raw/color.json'
import DefaultIndicatorTable from '../../raw/default_indicators.json'

import MobileTool from '../mobile/tool'

import {init as i18nInit, default as t} from '../common/i18n'

/////////////////////////////////////////////////////////////////////////////////
//주기
export const CYCLE_DAY = 1;
export const CYCLE_WEEK = 2;
export const CYCLE_MONTH = 3;
export const CYCLE_YEAR = 4;
export const CYCLE_MIN = 5;
export const CYCLE_SECOND = 6;


export const DEFAULT_INDICATOR_KEY = "9999999999";

//지표추가 타입
export const APPEND_TYPE = 0;
export const OVERLAY_TYPE = 1;

// 20190115 전중현 : 라인 그리기 타입 정의
export const PS_SOLID      = 0;  // 실선
export const PS_DOT        = 1;  // .......
export const PS_DASH       = 2;  // -------
export const PS_DASHDOT    = 3;  // _._._._
export const PS_DASHDOTDOT = 4;  // _.._.._
export const PS_LINETYPE_GROUPS = [
    {strText: "chart.solidline", nValue: PS_SOLID},
    {strText: "chart.dotline", nValue: PS_DOT},
    {strText: "chart.dashline", nValue: PS_DASH},
    {strText: "chart.dashdotline", nValue: PS_DASHDOT},
    {strText: "chart.dashdotdotline", nValue: PS_DASHDOTDOT}
];

// 라인 두께 타입 정의
export const PS_1PT = 1;
export const PS_2PT = 2;
export const PS_3PT = 3;
export const PS_4PT = 4;
export const PS_5PT = 5;
export const PS_THICKNESS_GROUPS = [
    {strText: "chart.1point", nValue: PS_1PT},
    {strText: "chart.2point", nValue: PS_2PT},
    {strText: "chart.3point", nValue: PS_3PT},
    {strText: "chart.4point", nValue: PS_4PT},
    {strText: "chart.5point", nValue: PS_5PT}
];

///////////////////////////////////////////////////////////////////
//가격타입 관련 정의
export const PRICE_TYPE_OPEN_NAME = "_OPEN_";
export const PRICE_TYPE_HIGH_NAME = "_HIGH_";
export const PRICE_TYPE_LOW_NAME = "_LOW_";
export const PRICE_TYPE_CLOSE_NAME = "_CLOSE_";
export const PRICE_TYPE_HL2_NAME = "_HL2_";
export const PRICE_TYPE_HLC3_NAME = "_HLC3_";

export const PRICE_TYPE_OPEN_INDEX = 0;
export const PRICE_TYPE_HIGH_INDEX = 1;
export const PRICE_TYPE_LOW_INDEX = 2;
export const PRICE_TYPE_CLOSE_INDEX = 3;
export const PRICE_TYPE_HL2_INDEX = 4;
export const PRICE_TYPE_HLC3_INDEX = 5;

export const PRICE_TYPE_GROUPS = [
    { strText: "chart.open", strValue: PRICE_TYPE_OPEN_NAME, nValue: PRICE_TYPE_OPEN_INDEX},
    { strText: "chart.high", strValue: PRICE_TYPE_HIGH_NAME, nValue: PRICE_TYPE_HIGH_INDEX},
    { strText: "chart.low", strValue: PRICE_TYPE_LOW_NAME, nValue: PRICE_TYPE_LOW_INDEX},
    { strText: "chart.close", strValue: PRICE_TYPE_CLOSE_NAME, nValue: PRICE_TYPE_CLOSE_INDEX },
    { strText: "chart.div2highlow", strValue: PRICE_TYPE_HL2_NAME, nValue: PRICE_TYPE_HL2_INDEX },
    { strText: "chart.div3openhighlow", strValue: PRICE_TYPE_HLC3_NAME, nValue: PRICE_TYPE_HLC3_INDEX }
];

//서브그래프 타입
export const PRICE_SUBGRAPH_TYPE = 0;//가격 서브그래프(CPriceSubGraph)
export const VOLUME_SUBGRAPH_TYPE = 1;//거래량 서브그래프(CVolumeSubGraph)
export const INDICATOR_SUBGRAPH_TYPE = 2;//일반 서브그래프 타입(CIndicatorSubGraph)
export const HOGADEPTH_SUBGRAPH_TYPE = 3;//호가잔량 서브그래프 타입(CHogaDepthSubGraph)

//가격 서브그래프 서브타입
export const PRICE_SUBGRAPH_CANDLE_TYPE = 0;
export const PRICE_SUBGRAPH_LINE_TYPE = 1;
export const PRICE_SUBGRAPH_BAR_TYPE = 2;
export const PRICE_SUBGRAPH_PANDF_TYPE = 3;
export const PRICE_SUBGRAPH_THREEELINE_TYPE = 4;

//거래량 서브그래프 서브타입
export const VOLUME_SUBGRAPH_BAR_TYPE = 0;
export const VOLUME_SUBGRAPH_LINE_TYPE = 1;

//일반 서브그래프 서브타입
export const INDICATOR_SUBGRAPH_LINE_TYPE = 0;
export const INDICATOR_SUBGRAPH_BAR_TYPE = 1;

//호가잔량 서브그래프 서브타입
export const HOGADEPTH_SUBGRAPH_DEPTH_TYPE = 0;

//막대 색 비교타입
export const COMPARE_TYPE_NO = 0;
export const COMPARE_TYPE_ZERO = 1;
export const COMPARE_TYPE_PREV_VALUE = 2;
export const COMPARE_TYPE_PREV_CLOSE = 3;
export const COMPARE_TYPE_PREV_HIGH = 4;
export const COMPARE_TYPE_CUR_OPEN = 5;
export const COMPARE_TYPE_CANDLE = 6;
export const COMPARE_TYPE_GROUPS = [
	{ strText : 'chart.compno', nValue : COMPARE_TYPE_NO},
	{ strText : 'chart.compzero', nValue : COMPARE_TYPE_ZERO},
	{ strText : 'chart.compprevvalue', nValue : COMPARE_TYPE_PREV_VALUE},
	{ strText : 'chart.compprevclose', nValue : COMPARE_TYPE_PREV_CLOSE},
	{ strText : 'chart.compprevhigh', nValue : COMPARE_TYPE_PREV_HIGH},
	{ strText : 'chart.compcuropen', nValue : COMPARE_TYPE_CUR_OPEN},
	{ strText : 'chart.compcandle', nValue : COMPARE_TYPE_CANDLE},
];

//가격 보합타입
export const PRICE_STEADY_TYPE_GROUPS = [
    { strText: 'chart.change2preclose', nValue:true }, // 전일종가 대비 등락
    { strText: 'chart.generalblack', nValue: false } // 일반(흑색)
];

//이평 타입
export const MV_TYPE_SIMPLE = 0;
export const MV_TYPE_EXP= 1;
export const MV_TYPE_WEIGHT = 2;
export const MV_TYPE_GEOMETRIC = 3;
export const MV_TYPE_HARMONIC = 4;
export const MV_TYPE_TRI = 5;
export const MV_TYPE_FIT = 6;
export const MV_TYPE_GROUPS = [
    { strText: 'chart.simple', nValue: MV_TYPE_SIMPLE },
    { strText: 'chart.exp', nValue: MV_TYPE_EXP },
    { strText: 'chart.weight', nValue: MV_TYPE_WEIGHT },
    //{ label: 'chart.geometric', value: MV_TYPE_GEOMETRIC },
    //{ label: 'chart.harmonic', value: MV_TYPE_HARMONIC },
    //{ label: 'chart.tri', value: MV_TYPE_TRI },
    //{ label: 'chart.fit', value: MV_TYPE_FIT },
];

///////////////////////////////////////////////////////////////////
//SubGraph Type
export const TEXT_LEFT_ALIGN = 0x01;
export const TEXT_RIGHT_ALIGN = 0x02;

//공현욱 스크롤컨트롤 타입 추가
export const SCROLL_GENERAL_TYPE = 0;    // 일반 스크롤
export const SCROLL_THIN_TYPE = 1;       // 얇은 스크롤

export const INPUT_PACKET_USE_TYPE = 0x01;       //외부에서 입력되는 데이터 패킷(예:날짜, 시,고,저,종,거래량 등)
export const CALC_PACKET_USE_TYPE = 0x02;        //입력데이터를 이용해서 계산되는 데이터 패킷(예:_HL2_, _HLC3_ 등)
export const INDICATOR_PACKET_USE_TYPE = 0x04;   //지표 계산결과 저장하는 패킷

//YScale 현재가 옵션
export const HIDE_VALUE_YOPTION = 0x1000;//숨김
export const SHOW_VALUE_YOPTION = 0x2000;//보이기

export const CURPRICE_VALUE_YOPTION = 0x0001;//현재가격
export const LASTDATA_VALUE_YOPTION = 0x0002//보이는 영역 최신 데이터(가격지표를 제외하고는 강제로 해당옵션처리됨)

export const PREVPRICE_RATE_YOPTION = 0x0010;//가격 전일종가등락율
export const PREVDATA_RATE_YOPTION = 0x0020;//전봉대비등락율(가격 제외하고는 무조건 전봉대비 등락율)

//블록타입
export const VERT_BLOCK_TYPE = 0;
export const HORZ_BLOCK_TYPE = 1;

//실시간 데이터 타입
export const PRICE_REAL_TYPE = 1;

//패킷데이터 타입
export const NUMERIC_TYPE = 1;
export const DATETIME_TYPE = 2;
export const STRING_TYPE = 3;
export const SIGNAL_TYPE= 4;

//스크롤타입
export const SCROLL_HORZ = 0;
export const SCROLL_VERT = 1;

export const gSelectSignBetween = 80;
export const gSelectSignSize = 2;

export const gToolTipMarginX = 6;
export const gToolTipMarginY = 15;

export const gDateLangKeyArray = ["chart.sunday", "chart.monday", "chart.tuesday", "chart.wednesday", "chart.thursday", "chart.friday", "chart.saturday"];
export const gDateArray = ["일", "월", "화", "수", "목", "금", "토"];

export const DatePerMonthArray = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

export var gResultPos = new CPoint(0, 0);
export var gResultBlockPos = new CBlockPosInfo(0, 0, 0);

//십자선 기능에서 사용되는 사각박스 위치 정보(마우스 이벤트시 매번 동적메모리생성하지 않고 전역으로 선언한 개체를 재활용한다)
export var gRectXTitleBox = new CRect();
export var gRectLeftYValueBox = new CRect();
export var gRectRightYValueBox = new CRect();
export var gLeftYTextPos = new CPoint(0, 0);
export var gRightYTextPos = new CPoint(0, 0);

export var gTempDate = new Date();
export var gTempDate1 = new Date();
export var gTempStartDate = new Date();
export var gTempEndDate = new Date();
export var DayDate = new Date('1/2/1970 09:00:00');
export var WeekDate = new Date('1/8/1970 09:00:00');
export var MinDate = new Date('1/1/1970 09:01:00');
export var SecDate = new Date('1/1/1970 09:00:01');

export var gNextTime = new CTimeT();//실시간머지시점에 임시로 사용

export var gPoint = new CPoint(0, 0);

export var gPointStart = new CPoint(0, 0);
export var gPointEnd = new CPoint(0, 0);
export var gPointTemp1 = new CPoint(0, 0);
export var gPointTemp2 = new CPoint(0, 0);

export var gBarInfoTemp = new CBarInfo();
export var gBarInfo1 = new CBarInfo();
export var gBarInfo2 = new CBarInfo();
export var gBarInfo3 = new CBarInfo();
export var gBarInfo4 = new CBarInfo();
export var gBarInfo5 = new CBarInfo();
export var gBarInfo6 = new CBarInfo();

export var gBongInfo1 = new CBongInfo();
export var gBongInfo2 = new CBongInfo();
export var gBongInfo3 = new CBongInfo();
export var gBongInfo4 = new CBongInfo();
export var gBongInfo5 = new CBongInfo();
export var gBongInfo6 = new CBongInfo();

export var gMinMaxInfo = new CMinMaxInfo();

export var gCloneGlobalProperty = new CGlobalProperty();//외부에서 차트통합설정내용을 참조할 때 사용

var gChartFullProperty = new CChartFullProperty();
////////////////////////////////////////////////////////////////////////
//공용전역함수 START
////////////////////////////////////////////////////////////////////////

// 숫자 타입에서 쓸 수 있도록 format() 함수 추가
Number.prototype.format = function () {
    if (this === 0)
        return 0;

    var reg = /(^[+-]?\d+)(\d{3})/;
    var n = (this + '');

    while (reg.test(n))
        n = n.replace(reg, '$1' + ',' + '$2');

    return n;
};

// 문자열 타입에서 쓸 수 있도록 format() 함수 추가
String.prototype.format = function () {
    var num = parseFloat(this);
    if (isNaN(num))
        return "0";

    return num.format();
};

//////////////////////////////////////////////////////
//숫자데이터를 log값으로 변환하는 함수(음수와 0값 예외처리 고려)
//////////////////////////////////////////////////////
export function Log(Number) {
    
    if (Number > 0)
        return Math.log(Number + 0.00000001) + 8;
    else if (Number < 0)
        return - 8 - Math.log(-Number + 0.00000001);
    else
        return 0;
}

export function Exp(Number) {

    if (Number > 0)
        return Math.exp(Number - 8) - 0.00000001;
    else if (Number < 0)
        return 0.00000001 - Math.exp(-Number - 8);
    else
        return 0;
}
//////////////////////////////////////////////////////
//소수점 특정자리에서 올림,반올림,절삭처리하는 함수
//////////////////////////////////////////////////////
function decimalAdjust(type, value, exp) {
    // If the exp is undefined or zero...
    if (typeof exp === 'undefined' || +exp === 0) {
        return Math[type](value);
    }
    value = +value;
    exp = +exp;
    // If the value is not a number or the exp is not an integer...
    if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
        return NaN;
    }
    // Shift
    value = value.toString().split('e');
    value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
    // Shift back
    value = value.toString().split('e');
    return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
}

//예제
// Round
/*
round(55.55, -1);   // 55.6
round(55.549, -1);  // 55.5
round(55, 1);       // 60
round(54.9, 1);     // 50
round(-55.55, -1);  // -55.5
round(-55.551, -1); // -55.6
round(-55, 1);      // -50
round(-55.1, 1);    // -60
// Floor
floor(55.59, -1);   // 55.5
floor(59, 1);       // 50
floor(-55.51, -1);  // -55.6
floor(-51, 1);      // -60
// Ceil
ceil(55.51, -1);    // 55.6
ceil(51, 1);        // 60
ceil(-55.59, -1);   // -55.5
ceil(-59, 1);       // -50
*/

function round(value, exp) {
    return decimalAdjust('round', value, exp);
}

function floor(value, exp) {
    return decimalAdjust('floor', value, exp);
}

function ceil(value, exp) {
    return decimalAdjust('ceil', value, exp);
}


//글자 폭과 높이 계산하는 함수(실시간 처리시 가능하면 호출 자제할 것 - 한 글자에 대한 폭과 높이 미리 얻어놓고 실시간에서는 곱해서 대략적인 크기 얻어낼 것!!!
//사용예: var size = MeasureText("test", true, "굴림", 10); var nWidth = size[0], nHeight= size[1];
function MeasureText(text, bold, font, size) {

    // This global variable is used to cache repeated calls with the same arguments
    var str = text + ':' + bold + ':' + font + ':' + size;
    var __measuretext_cache__;
    if (typeof (__measuretext_cache__) === 'object' && __measuretext_cache__[str]) {
        return __measuretext_cache__[str];
    }

    var div = document.createElement('DIV');
    div.innerHTML = text;
    div.style.position = 'absolute';
    div.style.top = '-100px';
    div.style.left = '-100px';
    div.style.fontFamily = font;
    div.style.fontWeight = bold ? 'bold' : 'normal';
    div.style.fontSize = size + 'pt';
    document.body.appendChild(div);

    var sz = [div.offsetWidth, div.offsetHeight];

    document.body.removeChild(div);

    // Add the sizes to the cache as adding DOM elements is costly and can cause slow downs
    if (typeof (__measuretext_cache__) !== 'object') {
        __measuretext_cache__ = [];
    }
    __measuretext_cache__[str] = sz;

    return sz;
}

//strFormat(소수점 2자리 => 0.01, 소수점 5자리=>0.00001, 정수 1단위=> 1, 정수 10단위 => 10)
//결과값은 자리수를 숫자로 리턴(ex: 0.01 => -2, 0.00001 => -5, 1 => 1, 10 => 2, 100=> 3, 1000 => 4
function GetDigit(strFormat) {

    if (strFormat.length <= 0)
        return 0;

    //처리속도 관계상 소수점 위치만 가지고 자리수 계산함
    var nPos = strFormat.indexOf('.');
    if (nPos < 0) {//정수표현
        return strFormat.length - 1;
    }
    else {//소수점표현
        return ((nPos + 1) - strFormat.length);
    }
}

function InsertCommaInNumText(NumText) {
    var nFindPos = NumText.indexOf('.');
    if (nFindPos >= 3) {

        var strNumInt = NumText.substr(0, nFindPos);
        var strDigit = NumText.substr(nFindPos, NumText.length - nFindPos);

        strNumInt = strNumInt.replace(/\B(?=(\d{3})+(?!\d))/g, ",");

        return strNumInt + strDigit;
    }
    else if (nFindPos < 0 && 3 < NumText.length) {
        return NumText.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }
    return NumText;
}

//1:Chrome, 2:IE, 3:Opera, 4:Firefox, 5:Safari
function CheckBrowser() {

    var browser = "Chrome";
    var ua = window.navigator.userAgent;
    if (ua.indexOf('MSIE') > 0 || ua.indexOf('Trident') > 0)
        browser = "IE";
    else if (ua.indexOf('Opera') > 0 || ua.indexOf('OPR') > 0)
        browser = "Opera";
    else if (ua.indexOf('Firefix') > 0)
        browser = "Firefox";
    else if (ua.indexOf('Safari') > 0) {
        if (ua.indexOf('Chrome') > 0)
            browser = "Chrome";
        else
            browser = "Safari";
    }
    return browser;
}

function fMultiply(Number1, Number2) {

    var s1, s2;

    s1 = "" + Number1;
    var nPos = s1.indexOf('e');
    if (nPos >= 0) {
    
        s1 = "" + Number1.toFixed(20);//부동형표현으로 나오도록 설정
        s1 = s1.replace(/0+$/, '');
        if (s1.charAt(s1.length - 1) === '.')
            s1 = s1.substring(0, s1.length - 1);
    }

    s2 = "" + Number2;
    nPos = s2.indexOf('e');
    if (nPos >= 0) {
    
        s2 = "" + Number2.toFixed(20);//부동형표현으로 나오도록 설정
        s2 = s2.replace(/0+$/, '');
        if (s2.charAt(s2.length - 1) === '.')
            s2 = s2.substring(0, s2.length - 1);
    }
    
    var n1, n2, Result;

    var nPoint1Pos = s1.indexOf('.');
    var nPoint1 = 0;
    if (nPoint1Pos > -1) {
        nPoint1 = s1.length - nPoint1Pos - 1;
        s1 = s1.replace(".", "");
        n1 = Number(s1);
    }
    else
        n1 = Number1;

    var nPoint2Pos = s2.indexOf('.');
    var nPoint2 = 0;
    if (nPoint2Pos > -1) {
        nPoint2 = s2.length - nPoint2Pos - 1;
        s2 = s2.replace(".", "");
        n2 = Number(s2);
    }
    else
        n2 = Number2;

    var nTotalPoint = nPoint1 + nPoint2;

    Result = n1 * n2;
    if (nTotalPoint === 0)//정수 * 정수인 경우
        return Result;

    var sResult = "" + Result;
    var nLen = sResult.length;
    
    var nResult;
    if (nLen > nTotalPoint) {
        var nSplitPos = nLen - nTotalPoint;
        nResult = Number(sResult.substring(0, nSplitPos) + "." + sResult.substring(nSplitPos));
    }
    else if (nLen === nTotalPoint) {
        nResult = Number("0." + sResult);
    }
    else {
        var nDiff = nTotalPoint - nLen;
        //nResult = Number("0." + "0".repeat(nDiff) + sResult);
        nResult = Number("0." + Array(nDiff + 1).join("0") + sResult);
    }
    return nResult;
}

function fDivide(Number1, Number2) {

    if (Number2 === 0)
        return null;

    var s1, s2;

    s1 = "" + Number1;
    var nPos = s1.indexOf('e');
    if (nPos >= 0) {

        s1 = "" + Number1.toFixed(20);
        s1 = s1.replace(/0+$/, '');
        if (s1.charAt(s1.length - 1) === '.')
            s1 = s1.substring(0, s1.length - 1);
    }

    s2 = "" + Number2;
    nPos = s2.indexOf('e');
    if (nPos >= 0) {

        s2 = "" + Number2.toFixed(20);
        s2 = s2.replace(/0+$/, '');
        if (s2.charAt(s2.length - 1) === '.')
            s2 = s2.substring(0, s2.length - 1);
    }

    var n1, n2, Result;

    var nPoint1Pos = s1.indexOf('.');
    var nPoint1 = 0;
    if (nPoint1Pos > -1) {
        nPoint1 = s1.length - nPoint1Pos - 1;
    }
    
    var nPoint2Pos = s2.indexOf('.');
    var nPoint2 = 0;
    if (nPoint2Pos > -1) {
        nPoint2 = s2.length - nPoint2Pos - 1;
    }
    
    if (nPoint1 > nPoint2) {
        var nLen = nPoint1 - nPoint2;
        //s2 = s2 + "0".repeat(nLen);
        s2 = s2 + Array(nLen + 1).join("0");
        if(nPoint2 > 0)
            s2 = s2.replace(".", "");

        s1 = s1.replace(".", "");
    }
    else if (nPoint1 < nPoint2) {

        var nLen = nPoint2 - nPoint1;
        //s1 = s1 + "0".repeat(nLen);
        s1 = s1 + Array(nLen + 1).join("0");
        if (nPoint1 > 0)
            s1 = s1.replace(".", "");

        s2 = s2.replace(".", "");
    }
    else {
        if (nPoint1 === 0) {
            return Number1 / Number2;
        }
        else {
            s1 = s1.replace(".", "");
            s2 = s2.replace(".", "");
        }
    }

    Result = Number(s1) / Number(s2);
    return Result;
}

function fPlus(Number1, Number2) {

    var s1, s2;

    s1 = "" + Number1;
    var nPos = s1.indexOf('e');
    if (nPos >= 0) {

        s1 = "" + Number1.toFixed(20);
        s1 = s1.replace(/0+$/, '');
        if (s1.charAt(s1.length - 1) === '.')
            s1 = s1.substring(0, s1.length - 1);
    }

    s2 = "" + Number2;
    nPos = s2.indexOf('e');
    if (nPos >= 0) {

        s2 = "" + Number2.toFixed(20);
        s2 = s2.replace(/0+$/, '');
        if (s2.charAt(s2.length - 1) === '.')
            s2 = s2.substring(0, s2.length - 1);
    }

    var n1, n2, Result;

    var nPoint1Pos = s1.indexOf('.');
    var nPoint1 = 0;
    if (nPoint1Pos > -1) {
        nPoint1 = s1.length - nPoint1Pos - 1;
    }

    var nPoint2Pos = s2.indexOf('.');
    var nPoint2 = 0;
    if (nPoint2Pos > -1) {
        nPoint2 = s2.length - nPoint2Pos - 1;
    }

    var nMaxPoint = nPoint1;
    if (nPoint1 > nPoint2) {
        var nLen = nPoint1 - nPoint2;
        //s2 = s2 + "0".repeat(nLen);
        s2 = s2 + Array(nLen + 1).join("0");
        if (nPoint2 > 0)
            s2 = s2.replace(".", "");

        s1 = s1.replace(".", "");
    }
    else if (nPoint1 < nPoint2) {

        var nLen = nPoint2 - nPoint1;
        //s1 = s1 + "0".repeat(nLen);
        s1 = s1 + Array(nLen + 1).join("0");
        if (nPoint1 > 0)
            s1 = s1.replace(".", "");

        s2 = s2.replace(".", "");

        nMaxPoint = nPoint2;
    }
    else {
        if (nPoint1 === 0) {
            return Number1 + Number2;
        }
        else {
            s1 = s1.replace(".", "");
            s2 = s2.replace(".", "");
        }
    }

    Result = Number(s1) + Number(s2);
    if (nMaxPoint === 0)
        return Result;
    else {
        var sResult = "" + Result;
        var nPos = sResult.length - nMaxPoint;
        sResult = sResult.substring(0, nPos) + "." + sResult.substring(nPos);
        Result = Number(sResult);
        return Result;
    }
}
//Number : 출력할 숫자
//nDec : 진법(10:10진법, 16:16진법..)
//divisor : 표현 단위(1:들어온 숫자단위 그대로, 10:들어온 숫자를 10으로 나눈 단위로 표현, 0.01:들어온 숫자를 0.01으로 나눈 단위로 표현)
//nDigit:표현 소수점 자리수(ex:소수점2자리 => -2), 양수인 경우(ex: 3 => 천원단위로 표현할 경우(1234을 1000로 표현))
//nRoundType:1(올림), 0(반올림), -1(내림)
export function ConvertNumToDigitText(Number, nDec, divisor, nDigit, nRoundType, bThousandComma) {

    var Count, Num, ResultNum;
    var strResultNum;

    if (divisor !== 1) {//예:10000을 1000단위로 표시하려는 경우 10000 / 1000 = 10으로 표기)
        Number /= divisor;
    }

    switch (nDec) {
        case 10://10진법 표기
            {
                if (nDigit < 0)//[표현해야 하는 소수점 자리수가 존재하는 경우(예:0.01)]
                {
                    //Count = Math.pow(10, (-nDigit - 1));
                    Count = Math.pow(10, -nDigit);

                    switch (nRoundType) {
                        case 1:
                            //Num = Math.ceil(fMultiply(Number , Count)) / Count; break;//overflow가 발생해서 주석처리
                            Num = Math.ceil(Number * Count) / Count; break; 
                        case 0:
                            //Num = Math.round(fMultiply(Number , Count)) / Count; break;
                            Num = Math.round(Number * Count) / Count; break;
                        case -1:
                            //Num = Math.floor(fMultiply(Number , Count)) / Count; break;
                            Num = Math.floor(Number * Count) / Count; break;
                        default:
                            //Num = Math.round(fMultiply(Number , Count)) / Count; break;
                            Num = Math.round(Number , Count) / Count; break;
                    }

                    ResultNum = Num.toFixed(-nDigit);

                    strResultNum = bThousandComma !== false ? InsertCommaInNumText(ResultNum) : ResultNum;
                }
                else if (nDigit === 0) {//정수로 표기

                    switch (nRoundType) {
                        case 1:
                            ResultNum = "" + Math.ceil(Number); break;
                        case 0:
                            ResultNum = "" + Math.round(Number); break;
                        case -1:
                            ResultNum = "" + Math.floor(Number); break;
                        default:
                            ResultNum = "" + Math.round(Number); break;
                    }

                    strResultNum = bThousandComma !== false ? InsertCommaInNumText(ResultNum) : ResultNum;
                }
                else {//ex) 1234 => 1000으로 표기

                    Count = Math.pow(10, nDigit);

                    switch (nRoundType) {
                        case 1:
                            //ResultNum = "" + Math.ceil(fDivide(Number , Count)) * Count; break;
                            ResultNum = "" + Math.ceil(Number / Count) * Count; break;
                        case 0:
                            //ResultNum = "" + Math.round(fDivide(Number , Count)) * Count; break;
                            ResultNum = "" + Math.round(Number /Count) * Count; break;
                        case -1:
                            //ResultNum = "" + Math.floor(fDivide(Number , Count)) * Count; break;
                            ResultNum = "" + Math.floor(Number / Count) * Count; break;
                        default:
                            //ResultNum = "" + Math.round(fDivide(Number , Count)) * Count; break;
                            ResultNum = "" + Math.round(Number , Count) * Count; break;
                    }

                    strResultNum = bThousandComma !== false ? InsertCommaInNumText(ResultNum) : ResultNum;
                }
            }
            break;
    }

    return strResultNum;
}

export function GetXIndexByXPos(XPos, rectGraphRegion, nViewStartIndex, nViewEndIndex) {
    return Math.floor((XPos - rectGraphRegion.m_nLeft) * ((nViewEndIndex - nViewStartIndex + 1) / rectGraphRegion.Width()) + nViewStartIndex);
}

export function GetYValueByYPos(YPos, rectGraphRegion, MinMaxInfo, bLog, bInvert)
{
    var yMin, yMax, yDiff;
    if( bLog === true )
    {
        yMin = Log(MinMaxInfo.m_LowerLimit);
        yMax = Log(MinMaxInfo.m_UpperLimit);
        yDiff = yMax - yMin;

        if (bInvert === true)
            return (Exp(yMax - (rectGraphRegion.m_nBottom - YPos) / rectGraphRegion.Height() * yDiff));
        else
            return (Exp((rectGraphRegion.m_nBottom - YPos) / rectGraphRegion.Height() * yDiff + yMin));
    }
    else
    {
        yMin = MinMaxInfo.m_LowerLimit;
        yMax = MinMaxInfo.m_UpperLimit;
        yDiff = yMax - yMin;

        if (bInvert === true)
            return (yMax - (rectGraphRegion.m_nBottom - YPos) / rectGraphRegion.Height() * yDiff);
        else
            return ((rectGraphRegion.m_nBottom - YPos) / rectGraphRegion.Height() * yDiff + yMin);
    }
}

//최대공약수
function CalcGCD(u, v) {
    var t;
    while (v) {
        t = u % v;
        u = v;
        v = t;
    }
    return u;
}
//최소공배수
function CalcLCM(a, b) {
    return a * b / gcd(a, b);
}

function CalcInterval(t1, t2, nCycle) {
    switch (nCycle) {
        case 1://일
            {
                var t = (t1 > t2 ? t1 - t2 : t2 - t1);
                return t / (60 * 60 * 24);
            }
        case 2://주
            {
                var t = (t1 > t2 ? t1 - t2 : t2 - t1);
                return t / (60 * 60 * 24 * 7);
            }
        case 3://월
            {
                var tm1 = gTempStartDate;
                var tm2 = gTempEndDate;

                tm1.setTime(t1 * 1000);
                tm2.setTime(t2 * 1000);

                if (t1 < t2)
                    return (tm2.getFullYear() - 1) * 12 + tm2.getMonth() - (tm1.getFullYear() - 1) * 12 + tm1.getMonth();
                else
                    return (tm1.getFullYear() - 1) * 12 + tm1.getMonth() - (tm2.getFullYear() - 1) * 12 + tm2.getMonth();
            }
        case 4://년
            {
                var t = (t1 > t2 ? t1 - t2 : t2 - t1);
                return t / (60 * 60 * 24 * 365);
            }
        case 5://분
            {
                var t = (t1 > t2 ? t1 - t2 : t2 - t1);
                return t / 60;
            }
        case 6://초
            {
                return (t1 > t2 ? t1 - t2 : t2 - t1);
            }
        default:
            return -1;
    }
}

//t1과 t2(t1보다 큰시간) 사이 시간간격을 strType 구분값('Y':년, 'M':월, 'D':일, 'H':시, 'm':분, 'S':초) 기준으로 계산하여 반환
function CalcDiffTimes(t1, t2, strType) {

    if (t1 > t2)
        return null;

    if (t1 === t2)
        return 0;

    var nResultDiff = null;
    switch (strType) {
        case 'Y'://년
            gTempDate.setTime(t1);
            gTempDate1.setTime(t2);
            var Y = gTempDate.getFullYear();
            var Y1 = gTempDate1.getFullYear();
            nResultDiff = (Y1 - Y);
            break;
        case 'M'://월
            gTempDate.setTime(t1);
            gTempDate1.setTime(t2);
            var Y = gTempDate.getFullYear();
            var M = gTempDate.getMonth() + 1;
            var Y1 = gTempDate1.getFullYear();
            var M1 = gTempDate1.getMonth() + 1;
            var nDiffY = Y1 - Y - 1;
            nResultDiff = (nDiffY >= 0 ? (12 - M) + nDiffY * 12 + M1 : M1 - M);
            break;
        case 'D'://일
            nResultDiff = Math.ceil((t2 - t1) / 86400000);//(t2-t1)/1000/60/60/24
            break;
        case 'H'://시
            nResultDiff = Math.ceil((t2 - t1) / 3600000);//(t2-t1)/1000/60/60
            break;
        case 'm'://분
            nResultDiff = Math.ceil((t2 - t1) / 60000);//(t2-t1)/1000/60
            break;
        case 'S'://초
            nResultDiff = Math.ceil((t2 - t1) / 1000);//(t2-t1)/1000
            break;
        default:
            return null;
    }

    return nResultDiff;
}

function CalcDateTimeT(tStart, nCycle, nInterval) {
    var tEnd = 0;
    var llTime = 0;
    switch (nCycle) {
        case 1://일
            llTime = 86400 * nInterval; break;
        case 2://주
            llTime = 604800 * nInterval; break;
        case 3://월
            {
                gTempDate.setTime(tStart * 1000);

                var month = gTempDate.getMonth();
                var NextMonth = month + nInterval;
                var date = gTempDate.getDate();
                var NextDate = DatePerMonthArray[NextMonth % 12];
                if (NextDate < date)
                    gTempDate.setDate(NextDate);

                gTempDate.setMonth(NextMonth);

                tEnd = gTempDate.getTime() / 1000;
            }
            return tEnd;
        case 4://년
            llTime = 31536000 * nInterval; break;
        case 5://분
            llTime = 60 * nInterval; break;
        case 6://초
            llTime = nInterval; break;
        default:
            return 0;
    }
    tEnd = tStart + llTime;
    return tEnd;
}

//tStart로 부터 가장 가까우면서 tEnd 포함하는 다음 Start지점
function CalcNextStart(tStart, tEnd, nCycle, nInterval) {
    switch (nCycle) {
        case 1://일
            {
                var t = tEnd - tStart;
                var nDayPeriod = 60 * 60 * 24 * nInterval;
                return tStart + (Math.floor(t / nDayPeriod) + (t % nDayPeriod ? 1 : 0)) * nDayPeriod;
            }
        case 2://주
            {
                var t = tEnd - tStart;
                var nWeekPeriod = 60 * 60 * 24 * 7 * nInterval;
                return tStart + (Math.floor(t / nWeekPeriod) + (t % nWeekPeriod ? 1 : 0)) * nWeekPeriod;
            }
        case 3://월
            {
                var tmStart, tmEnd, tmNextStart;
                tmStart = gTempStartDate;
                tmStart.setTime(tStart * 1000);

                tmEnd = gTempEndDate;
                tmEnd.setTime(tEnd * 1000);

                var date = tmStart.getDate();
                var nMonthStart = ((tmStart.getFullYear() - 1) * 12 + tmStart.getMonth() + 1);
                var nMonthEnd = ((tmEnd.getFullYear() - 1) * 12 + tmEnd.getMonth() + 1);
                var nMonthDiff = nMonthEnd - nMonthStart;
                var nNextMonth = nMonthStart + (Math.floor(nMonthDiff / nInterval) + nMonthDiff % nInterval ? 1 : 0) * nInterval;

                tmNextStart = gTempDate;
                tmNextStart.setTime(tmStart.getTime());

                tmNextStart.setYear(Math.floor(nNextMonth / 12));

                var month = nNextMonth % 12;
                var DatePerMonth = DatePerMonthArray[month];
                if (DatePerMonth < date)
                    tmNextStart.setDate(DatePerMonth);

                tmNextStart.setMonth(month);

                if (tmEnd.getFullYear() === tmNextStart.getFullYear() && tmEnd.getMonth() === tmNextStart.getMonth() &&
                    ((tmEnd.getDate() * 24 + tmEnd.getHours()) * 60 + tmEnd.getMinutes()) * 60 > ((tmNextStart.getDate() * 24 + tmNextStart.getHours()) * 60 + tmNextStart.getMinutes()) * 60) {
                    tmNextStart.setMonth(tmNextStart.getMonth() + 1);
                }

                return tmNextStart.getTime() / 1000;
            }
        case 4://년
            {
                var t = tEnd - tStart;
                var nYearPeriod = 60 * 60 * 24 * 365 * nInterval;
                return tStart + (Math.floor(t / nYearPeriod) + (t % nYearPeriod ? 1 : 0)) * nYearPeriod;
            }
        case 5://분
            {
                var t = tEnd - tStart;
                var nMinPeriod = 60 * nInterval;
                return tStart + (Math.floor(t / nMinPeriod) + (t % nMinPeriod ? 1 : 0)) * nMinPeriod;
            }
        case 6://초
            {
                var t = tEnd - tStart;
                var nSecondPeriod = nInterval;
                return tStart + (Math.floor(t / nSecondPeriod) + (t % nSecondPeriod ? 1 : 0)) * nSecondPeriod;
            }
        default:
            return -1;
    }
}

//tEnd로 부터 가장 가까우면서 tStart를 포함하는 시작 위치
function CalcPrevStart(tStart, tEnd, nCycle, nInterval) {
    switch (nCycle) {
        case 1://일
            {
                var t = tEnd - tStart;
                var nDayPeriod = 60 * 60 * 24 * nInterval;
                return tEnd - (Math.floor(t / nDayPeriod) + (t % nDayPeriod ? 1 : 0)) * nDayPeriod;
            }
        case 2://주
            {
                var t = tEnd - tStart;
                var nWeekPeriod = 60 * 60 * 24 * 7 * nInterval;
                return tEnd - (Math.floor(t / nWeekPeriod) + (t % nWeekPeriod ? 1 : 0)) * nWeekPeriod;
            }
        case 3://월
            {
                var dateStart = gTempStartDate;
                dateStart.setTime(tStart * 1000);

                var dateEnd = gTempEndDate;
                dateEnd.setTime(tEnd * 1000);

                var nMonthStart = (dateStart.getFullYear() - 1) * 12 + (dateStart.getMonth() + 1);
                var nMonthEnd = (dateEnd.getFullYear() - 1) * 12 + (dateEnd.getMonth() + 1);
                var nMonthDiff = nMonthEnd - nMonthStart;
                var nPrevMonth = nMonthDiff - (Math.floor(nMonthDiff / nInterval) + nMonthDiff % nInterval ? 1 : 0) * nInterval;

                var datePrevStart = gTempDate;
                datePrevStart.setTime(dateEnd.getTime());

                datePrevStart.setYear(Math.floor(nPrevMonth / 12));

                var PrevM = nPrevMonth % 12 - 1;
                var DatePerMonth = DatePerMonthArray[PrevM];
                var date = datePrevStart.getDate();
                if (DatePerMonth < date)
                    datePrevStart.setDate(DatePerMonth);

                datePrevStart.setMonth();

                if (dateStart.getFullYear() === datePrevStart.getFullYear() && dateStart.getMonth() === datePrevStart.getMonth() &&
                    ((dateStart.getDate() * 24 + dateStart.getHours()) * 60 + dateStart.getMinutes()) * 60 > ((datePrevStart.getDate() * 24 + datePrevStart.getHours()) * 60 + datePrevStart.getMinutes()) * 60) {
                    tmPrevStart.tm_mon--;
                    datePrevStart.setMonth(datePrevStart.getMonth() - 1);
                }

                return datePrevStart.getTime() / 1000;
            }
        case 4://년
            {
                var t = tEnd - tStart;
                var nYearPeriod = 60 * 60 * 24 * 365 * nInterval;
                return tEnd - (Math.floor(t / nYearPeriod) + (t % nYearPeriod ? 1 : 0)) * nYearPeriod;
            }
        case 5://분
            {
                var t = tEnd - tStart;
                var nMinPeriod = 60 * nInterval;
                return tEnd - (Math.floor(t / nMinPeriod) + (t % nMinPeriod ? 1 : 0)) * nMinPeriod;
            }
        case 6://초
            {
                var t = tEnd - tStart;
                var nSecondPeriod = nInterval;
                return tEnd - (Math.floor(t / nSecondPeriod) + (t % nSecondPeriod ? 1 : 0)) * nSecondPeriod;
            }
        default:
            return -1;
    }
}

//tEnd를 포함하지 않으면서 tStart로 부터 가장 먼 Start지점(tEnd가 주기로 나눠 떨어지면 포함)
function CalcNextStartExclusiveEnd(tStart, tEnd, nCycle, nInterval) {
    switch (nCycle) {
        case 1://일
            {
                var t = tEnd - tStart;
                var nDayPeriod = 86400 * nInterval;//60*60*24
                var nRest = t % nDayPeriod;
                return tStart + (Math.floor(t / nDayPeriod)) * nDayPeriod;
            }
        case 2://주
            {
                var t = tEnd - tStart;
                var nWeekPeriod = 604800 * nInterval;//60 * 60 * 24 * 7
                return tStart + (Math.floor(t / nWeekPeriod)) * nWeekPeriod;
            }
        case 3://월
            {
                var tmStart, tmEnd, tmNextStart;
                tmStart = gTempStartDate;
                tmStart.setTime(tStart * 1000);

                tmEnd = gTempEndDate;
                tmEnd.setTime(tEnd * 1000);

                var nMonthStart = ((tmStart.getFullYear() - 1) * 12 + tmStart.getMonth() + 1);
                var nMonthEnd = ((tmEnd.getFullYear() - 1) * 12 + tmEnd.getMonth() + 1);
                var nMonthDiff = nMonthEnd - nMonthStart;
                var nNextMonth = nMonthStart + (Math.floor(nMonthDiff / nInterval)) * nInterval;

                tmNextStart = gTempDate;
                tmNextStart.setTime(tmStart.getTime());

                var date = tmNextStart.getDate();

                tmNextStart.setYear(Math.floor(nNextMonth / 12));

                var month = nNextMonth % 12;
                month = (month === 0 ? 11 : month - 1);
                var DatePerMonth = DatePerMonthArray[month];
                if (DatePerMonth < date)
                    tmNextStart.setDate(DatePerMonth);

                tmNextStart.setMonth(month);

                if (tmEnd.getFullYear() === tmNextStart.getFullYear() && tmEnd.getMonth() === tmNextStart.getMonth() &&
                    ((tmEnd.getDate() * 24 + tmEnd.getHours()) * 60 + tmEnd.getMinutes()) * 60 > ((tmNextStart.getDate() * 24 + tmNextStart.getHours()) * 60 + tmNextStart.getMinutes()) * 60) {
                    tmNextStart.setMonth(tmNextStart.getMonth() + 1);
                }

                return tmNextStart.getTime() / 1000;
            }
        case 4://년
            {
                var t = tEnd - tStart;
                var nYearPeriod = 31536000 * nInterval;//60 * 60 * 24 * 365
                return tStart + (Math.floor(t / nYearPeriod)) * nYearPeriod;
            }
        case 5://분
            {
                var t = tEnd - tStart;
                var nMinPeriod = 60 * nInterval;
                return tStart + (Math.floor(t / nMinPeriod)) * nMinPeriod;
            }
        case 6://초
            {
                var t = tEnd - tStart;
                var nSecondPeriod = nInterval;
                return tStart + (Math.floor(t / nSecondPeriod)) * nSecondPeriod;
            }
        default:
            return -1;
    }
}

function CalcNextTime(tCurTime, nCycle, nInterval) {
    switch (nCycle) {
        case 1://일
            {
                var nDayPeriod = 60 * 60 * 24 * nInterval;
                return tCurTime + nDayPeriod;
            }
        case 2://주
            {
                var nWeekPeriod = 60 * 60 * 24 * 7 * nInterval;
                return tCurTime + nWeekPeriod;
            }
        case 3://월
            {
                var date = gTempDate;
                date.setTime(tCurTime * 1000);

                var d = date.getDate();
                var NextM = (date.getMonth() + nInterval) % 12;
                var DatePerMonth = DatePerMonthArray[NextM];
                if (DatePerMonth < d)
                    date.setDate(DatePerMonth);

                date.setMonth(NextM);

                var tTime = date.getTime() / 1000;
                return tTime;
            }
        case 4://년
            {
                var nYearPeriod = 60 * 60 * 24 * 365 * nInterval;
                return tCurTime + nYearPeriod;
            }
        case 5://분
            {
                var nMinPeriod = 60 * nInterval;
                return tCurTime + nMinPeriod;
            }
        case 6://초
            {
                var nSecondPeriod = nInterval;
                return tCurTime + nSecondPeriod;
            }
        default:
            return -1;
    }
}

function CalcPrevTime(tCurTime, nCycle, nInterval) {
    switch (nCycle) {
        case 1://일
            {
                var nDayPeriod = 60 * 60 * 24 * nInterval;
                return tCurTime - nDayPeriod;
            }
        case 2://주
            {
                var nWeekPeriod = 60 * 60 * 24 * 7 * nInterval;
                return tCurTime - nWeekPeriod;
            }
        case 3://월
            {
                var date = gTempDate;
                date.setTime(tCurTime * 1000);

                var d = date.getDate();
                var PrevM = ((date.getFullYear() - 1) * 12 + date.getMonth() - nInterval) % 12;
                var DatePerMonth = DatePerMonthArray[PrevM];
                if (DatePerMonth < d)
                    date.setDate(DatePerMonth);

                date.setMonth(PrevM);

                var tTime = date.getTime() / 1000;
                return tTime;
            }
        case 4://년
            {
                var nYearPeriod = 60 * 60 * 24 * 365 * nInterval;
                return tCurTime - nYearPeriod;
            }
        case 5://분
            {
                var nMinPeriod = 60 * nInterval;
                return tCurTime - nMinPeriod;
            }
        case 6://초
            {
                var nSecondPeriod = nInterval;
                return tCurTime - nSecondPeriod;
            }
        default:
            return -1;
    }
}

function CreateXScaleMng(rChart, strXScalePacketName, nXScaleType) {
    var XScaleMng = null;
    if (nXScaleType === DATETIME_TYPE) {
        XScaleMng = new CDateTimeXScaleMng(rChart);
        XScaleMng.SetXScalePacketName(strXScalePacketName);
    }
    else if(nXScaleType === NUMERIC_TYPE)
    {
        if(strXScalePacketName === "_HOGA_")
        {
            XScaleMng = new CHogaXScaleMng(rChart);
            XScaleMng.SetXScalePacketName(strXScalePacketName);
        }
    }
    return XScaleMng;
}

function InsertBefore(rArray, Iterator, NewItem) {
    if (0 > Iterator.m_nIndex || rArray.length <= Iterator.m_nIndex)
        return -1;

    var nIndex = Iterator.m_nIndex;
    if (nIndex >= 0) {
        rArray.splice(nIndex, 0, NewItem);
    }
    else {
        rArray.unshift(NewItem);
        nIndex = 0;
    }
    Iterator.m_nIndex++;
    return nIndex;
}

function InsertAfter(rArray, nPos, NewItem) {
    if (0 > nPos || rArray.length <= nPos)
        return -1;

    var nIndex = nPos + 1;
    if (nIndex <= rArray.length - 1) {
        rArray.splice(nIndex, 0, NewItem);
    }
    else if (nIndex > rArray.length - 1) {
        rArray.push(NewItem);
        nIndex = rArray.length - 1;
    }
    return nIndex;
}

function clone(obj) {
    if (obj === null || typeof (obj) !== 'object')
        return obj;

    //var copy = obj.constructor();
    var copy = {};

    for (var attr in obj) {
        if (obj.hasOwnProperty(attr)) {
            copy[attr] = clone(obj[attr]);
        }
    }
    return copy;
}

// tTime -> string DateTime(YYYYMMDDHHMMSS)
// UniversalTime : 세계시간
// tDateTiem : 밀리세컨드시간
// nCycle : 주기
// bUseFormat : 날짜포멧 변환사용 (사용시 YYYY/MM/DD HH MM SS)
export function GetStrDateTimeBytTime( UniversalTime, tDateTime, nCycle, bUseFormat ) {

    gTempDate.setTime(tDateTime * 1000);

    var nYear, nMonth, nDay, nH, nM, nS;
    if (UniversalTime !== 9)
    {
        gTempDate.setUTCMinutes(gTempDate.getUTCMinutes() + UniversalTime * 60);
        nYear = gTempDate.getUTCFullYear();
        nMonth = gTempDate.getUTCMonth() + 1;
        nDay = gTempDate.getUTCDate();
        nH = gTempDate.getUTCHours();
        nM = gTempDate.getUTCMinutes();
        nS = gTempDate.getUTCSeconds();

        gTempDate.setFullYear(nYear, nMonth, nDay);
        gTempDate.setHours(nH, nM, nS);
    }
    
    nYear = gTempDate.getFullYear();
    nMonth = gTempDate.getMonth() + 1;
    nDay = gTempDate.getDate();
    nH = gTempDate.getHours();
    nM = gTempDate.getMinutes();
    nS = gTempDate.getSeconds();
    var strDate = gDateArray[gTempDate.getDay()];

    var strDateTime;
    if( bUseFormat )
    {
        switch (nCycle)
        {
            case 1://일
            case 2://주
                strDateTime = "" + nYear + "/" + (nMonth >= 10 ? nMonth : "0" + nMonth) + "/" + (nDay >= 10 ? nDay : "0" + nDay) + " (" + strDate + ")"; break;
            case 3://월
                strDateTime = "" + nYear + "/" + (nMonth >= 10 ? nMonth : "0" + nMonth); break;
            case 4://년
                strDateTime = "" + nYear; break;
            case 5://분
                strDateTime = "" + nYear + "/" + (nMonth >= 10 ? nMonth : "0" + nMonth) + "/" + (nDay >= 10 ? nDay : "0" + nDay) + " " + (nH >= 10 ? nH : "0" + nH) + " " + (nM >= 10 ? nM : "0" + nM); break;
            case 6://초
                strDateTime = "" + nYear + "/" + (nMonth >= 10 ? nMonth : "0" + nMonth) + "/" + (nDay >= 10 ? nDay : "0" + nDay) + " " + (nH >= 10 ? nH : "0" + nH) + " " + (nM >= 10 ? nM : "0" + nM) + " " + (nS >= 10 ? nS : "0" + nS); break;
        }
    }
    else
    {
        switch (nCycle)
        {
            case 1://일
            case 2://주
                strDateTime = "" + nYear +  (nMonth >= 10 ? nMonth : "0" + nMonth) +  (nDay >= 10 ? nDay : "0" + nDay); break;
            case 3://월
                strDateTime = "" + nYear +  (nMonth >= 10 ? nMonth : "0" + nMonth); break;
            case 4://년
                strDateTime = "" + nYear; break;
            case 5://분
                strDateTime = "" + nYear +  (nMonth >= 10 ? nMonth : "0" + nMonth) +  (nDay >= 10 ? nDay : "0" + nDay) + (nH >= 10 ? nH : "0" + nH) + (nM >= 10 ? nM : "0" + nM); break;
            case 6://초
                strDateTime = "" + nYear +  (nMonth >= 10 ? nMonth : "0" + nMonth) +  (nDay >= 10 ? nDay : "0" + nDay) + (nH >= 10 ? nH : "0" + nH) + (nM >= 10 ? nM : "0" + nM) + (nS >= 10 ? nS : "0" + nS); break;
        }
    }

    return strDateTime;
}

export function GetDateTimeByString( strDateTime, strDateTimeType, nCycle, strMaretStartTime ) {

    var bAddHHMMSS = false;
    var nYear, nMonth, nDay, nHour, nMin, nSecond;

    if (strDateTimeType === "YYYYMMDDHHMMSS" )
        bAddHHMMSS = true;

    switch ( nCycle )
    {
    // 일, 주 주기
    case 1 :
    case 2 :
        {
            if( bAddHHMMSS === true )
                strDateTime += strMaretStartTime;
        }break;
    // 월 주기
    case 3 :
        {
            strDateTime = strDateTime + "01";
            if( bAddHHMMSS === true )
                strDateTime += strMaretStartTime;
        }break;
    // 년 주기
    case 4 :
        {
            strDateTime = strDateTime + "0101";
            if( bAddHHMMSS === true )
                strDateTime += strMaretStartTime;
        }break;
    // 분 주기
    case 5 :
        {
            strDateTime = strDateTime + "00";
        }break;
    // 초 주기
    case 6 : break;
    }

    if (strDateTimeType == "YYYYMM") {
        nYear = parseInt(strDateTime.slice(0, 4));
        nMonth = parseInt(strDateTime.slice(4, 6)) - 1;
        nDay = 1;
        nHour = 0;
        nMin = 0;
        nSecond = 0;
    }
    else if (strDateTimeType == "YYYYMMDD") {
        nYear = parseInt(strDateTime.slice(0, 4));
        nMonth = parseInt(strDateTime.slice(4, 6)) - 1;
        nDay = parseInt(strDateTime.slice(6));
        nHour = 0;
        nMin = 0;
        nSecond = 0;
    }
    else if (strDateTimeType == "YYYYMMDDHHMMSS") {
        nYear = parseInt(strDateTime.slice(0, 4));
        nMonth = parseInt(strDateTime.slice(4, 6)) - 1;
        nDay = parseInt(strDateTime.slice(6, 8));
        nHour = parseInt(strDateTime.slice(8, 10));
        nMin = parseInt(strDateTime.slice(10, 12));
        nSecond = parseInt(strDateTime.slice(12, 14));
    }
    else {
        return -1;
    }

    if (nCycle == 3)//월주기인 경우 일자를 모두 1일자로 맞춘다
        nDay = 1;

    gTempDate.setFullYear(nYear, nMonth, nDay);
    gTempDate.setHours(nHour, nMin, nSecond);

    if (nCycle == 2) {
        gTempDate.setDate(nDay - gTempDate.getDay() + 1);

        nYear = gTempDate.getFullYear();
        nMonth = gTempDate.getMonth();
        nDay = gTempDate.getDate();
        nHour = gTempDate.getHours();
        nMin = gTempDate.getMinutes();
        nSecond = gTempDate.getSeconds();
    }

    var tDateTime = gTempDate.getTime() / 1000;
    return tDateTime;
}

//LKY 세계시간 적용 처리 함수 >>>>>>>>>
export function ChangeGlobalTime(UniversalTime, tDateTime) { //Index : 세계시간 Index, tDateTiem : 밀리세컨드시간, bFlag : true 일 경우 Date형태로 반환 , False 일 경우 밀리세컨드로 반환

    if (UniversalTime === 9) {//한국시간

        gTempDate.setTime(tDateTime * 1000);
        return gTempDate;
    }

    gTempDate1.setTime(tDateTime * 1000);
    gTempDate.setUTCMinutes(gTempDate1.getUTCMinutes() + UniversalTime * 60);

    var nYear = gTempDate.getUTCFullYear();
    var nMonth = gTempDate.getUTCMonth();
    var nDay = gTempDate.getUTCDate();
    var nHour = gTempDate.getUTCHours();
    var nMinute = gTempDate.getUTCMinutes();
    var nSecond = gTempDate.getUTCSeconds();
    //console.log(nMinute + "," + nSecond);

    gTempDate.setFullYear(nYear, nMonth, nDay);
    gTempDate.setHours(nHour, nMinute, nSecond);

    return gTempDate;
}
//LKY 세계시간 적용 처리 함수 <<<<<<<<<
////////////////////////////////////////////////////////////////////////
//공용전역함수 END
////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////
//공용 클래스 START
////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////
//CPoint
export function CPoint(X, Y) {
    this.m_X = X;
    this.m_Y = Y;
}
CPoint.prototype.SetPoint = function (X, Y) {
    this.m_X = X;
    this.m_Y = Y;
}

//////////////////////////////////////////////
//CCrossPoint
export const PRICE_CROSS_POINT_TYPE = 0;
export const HOGA_DEPTH_CROSS_POINT_TYPE = 1;

export function CCrossPoint(X, Y, nType) {
    this.m_X = X;
    this.m_Y = Y;
    this.m_nType = nType;
}
CCrossPoint.prototype.SetPoint = function (X, Y) {
    this.m_X = X;
    this.m_Y = Y;
}
CCrossPoint.prototype.SetType = function(nType){
    this.m_nType = nType;
}
//////////////////////////////////////////////
//CBlockPosInfo
export function CBlockPosInfo(X, Y, nVertScaleIndex){
    this.m_X = X;
    this.m_Y = Y;
    this.m_nVertScaleIndex = nVertScaleIndex;
}

/////////////////////////////
function CXScalePosInfo() {
    this.m_nXPos = null;
    this.m_nPosIndex = 0;
    this.m_strScaleText = "";
    this.m_nScaleTextLen = null;
    this.m_tDateTime = null;
    this.m_bKeyPosition = false;
    this.m_strLastDataText = null;//마지막 XScalePosInfo인 경우 x축과 y축 겹치는 공간 끝 부분에 보여주는 데이터를 저장해 둠(x축에 보여주는 데이터가 아님)

    this.m_nYear = null;
    this.m_nMonth = null;
    this.m_nDate = null;
    this.m_nHour = null;
}

export const DRAW_CASE_TR = 0x0001;
export const DRAW_CASE_REAL = 0x0002;
export const DRAW_CASE_SCROLL = 0x0004;
export const DRAW_CASE_RESIZE = 0x0008;
export const DRAW_CASE_CHANGE_PROPERTY = 0x0008;//RESIZE와 동일한 플래그값
export const DRAW_CASE_ADD_CHARTBLOCK = 0x0010;
export const DRAW_CASE_DEL_CHARTBLOCK = 0x0020;
export const DRAW_CASE_SELECT_SUBGRAPH = 0x0040;
export const DRAW_CASE_SET_GLOBAL_PROPERTY = 0x0080;//차트설정을 변경시 다시 그리기

/////////////////////////////
function CDrawingInfo() {

    this.m_nDrawCase = 0;//0x0001:조회 또는 데이터계산 직후 그리기, 0x0002:실시간데이터 또는 실시간데이터계산 직후 그리기, 0x0004:스크롤이동시 그리기, 0x0008:크기변경시 그리기, 0x0010:지표박스 추가, 0x0020:지표박스 삭제
    this.m_strCanvasId = "";
    this.m_ScreenCanvas = null;
    this.m_ScreenContext = null;
    this.m_Canvas = null;
    this.m_Context = null;
    this.m_nFontSize = 0;//폰트크기
    this.m_strFontName = "";
    this.m_nFontHeight = 0;//해당폰트의 대략적인 글자높이
    this.m_rectChart = null;
    this.m_rectGraphRegion = new CRect();
    this.m_rectGraphBackground = new CRect();
    this.m_DrawSelectedSubGraph = null;//선택된 서브그래프 선택표시를 하기 위해 필요
    this.m_rChartParentDIV = null;

    this.m_strCursorName = "default"; // 커서
}

/////////////////////////////
function CIterator(nIndex) {
    this.m_nIndex = nIndex;
}
////////////////////////////
function CRect() {
    this.m_nLeft = 0;
    this.m_nTop = 0;
    this.m_nRight = 0;
    this.m_nBottom = 0;
}
CRect.prototype.Initial = function () {
    this.m_nLeft = 0;
    this.m_nTop = 0;
    this.m_nRight = 0;
    this.m_nBottom = 0;
}
CRect.prototype.SetRect = function (nLeft, nTop, nRight, nBottom) {
    this.m_nLeft = nLeft;
    this.m_nTop = nTop;
    this.m_nRight = nRight;
    this.m_nBottom = nBottom;
}
CRect.prototype.Width = function () {
    return (this.m_nRight > this.m_nLeft ? this.m_nRight - this.m_nLeft : this.m_nLeft - this.m_nRight);
}
CRect.prototype.Height = function () {
    return (this.m_nBottom > this.m_nTop ? this.m_nBottom - this.m_nTop : this.m_nTop - this.m_nBottom);
}
CRect.prototype.Normalization = function () {
    var nTemp = 0;
    if (this.m_nLeft > this.m_nRight) {
        nTemp = this.m_nLeft;
        this.m_nLeft = this.m_nRight;
        this.m_nRight = nTemp;
    }
    if (this.m_nTop > this.m_nBottom) {
        nTemp = this.m_nTop;
        this.m_nTop = this.m_nBottom;
        this.m_nBottom = nTemp;
    }
}

//LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 >>>>>>>>>
function CDragInfo() {
    this.m_bClickFlag = false;
    this.m_nSelectChartIndex = null;
    this.m_nSelectNextChartIndex = null;
}
//LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 <<<<<<<<<

////////////////////////////
function CString() {
    this.m_string = "";
}

////////////////////////////
function CTimeT() {
    this.m_tTime = 0;
}

////////////////////////////
function CMinMaxInfo() {
    this.m_Min = null;
    this.m_Max = null;
    this.m_UpperLimit = null;//상한선
    this.m_LowerLimit = null;//하한선
    this.m_nStartIndex = -1;//최대,최소 검색 범위 시작index
    this.m_nEndIndex = -1;//최대,최소 검색 범위 끝index
    this.m_bZeroBaseLine = false;
}
CMinMaxInfo.prototype.Init = function () {
    this.m_Min = null;
    this.m_Max = null;
    this.m_UpperLimit = null;//상한선
    this.m_LowerLimit = null;//하한선
    this.m_nStartIndex = -1;//최대,최소 검색 범위 시작index
    this.m_nEndIndex = -1;//최대,최소 검색 범위 끝index
    this.m_bZeroBaseLine = false;
}

////////////////////////////////////////////////////////////////////////
//CFindInfo
export function CFindInfo() {
    this.m_strRQ = "";
    this.m_strXTitle = "";
    this.m_strXData = "";
    this.m_XDataInfo = null;//X축의 종류에 따라 데이터 종류가 달라지므로 각 케이별 타입이 다를 것이다(XScaleMng가 DateTime인 경우는 CRQPacketsItem 이 된다)
    this.m_rFindSubGraph = null;
}

////////////////////////////////////////////////////////////////////////
//CSubGraphFindSubData
function CSubGraphFindSubData() {
    
    this.m_strSubGraphTitle = "";
    this.m_strSubGraphFindData = "";
    this.m_strSubGraphFindSubData = "";//주식차트에서는 대비율 저장
}

////////////////////////////////////////////////////////////////////////
//CSubGraphFindData
function CSubGraphFindData(rSubGraph) {
    this.m_rSubGraph = rSubGraph;
    if (rSubGraph !== undefined)
        this.m_strSubGraphName = rSubGraph.m_strSubGraphName;
    else
        this.m_strSubGraphName = null;

    this.m_SubGraphFindSubDataArray = [];
}

////////////////////////////////////////////////////////////////////////
//CGraphData
function CGraphFindData(rGraph) {
    this.m_rGraph = rGraph;
    if (rGraph !== undefined) {
        this.m_strGraphName = rGraph.m_strGraphName;
        this.m_strGraphKey = rGraph.m_strGraphKey;
    }
    else {
        this.m_strGraphName = null;
        this.m_strGraphKey = null;
    }

    this.m_strVariableList = "";

    this.m_arrSubGraphFindData = [];
}
CGraphFindData.prototype.GetSubGraphFindData = function (strSubGraphName) {
    var i, nLen = this.m_arrSubGraphFindData.length;
    for (i = 0; i < nLen; i++) {
        var rSubGraphFindData = this.m_arrSubGraphFindData[i];
        if (rSubGraphFindData.m_strSubGraphName === strSubGraphName)
            return rSubGraphFindData;
    }
    return null;
}

////////////////////////////////////////////////////////////////////////
//CRQGraphData
function CRQGraphFindData(rRQSet) {

    this.m_rRQSet = rRQSet;
    if (rRQSet !== undefined)
        this.m_strRQ = rRQSet.m_strRQ;
    else
        this.m_strRQ = null;
    
    this.m_strXTitle = "";
    this.m_strXData = "";

    this.m_arrGraphFindData = [];
}
CRQGraphFindData.prototype.GetGraphFindData = function (strGraphKey) {

    var i, nLen = this.m_arrGraphFindData.length;
    for (i = 0; i < nLen; i++) {
        var rGraphFindData = this.m_arrGraphFindData[i];
        if (rGraphFindData.m_strGraphKey === strGraphKey)
            return rGraphFindData;
    }
    return null;
}
////////////////////////////////////////////////////////////////////////
//CRQGraphDataPerXScaleMng (수치조회, 툴팁사용)
function CRQGraphFindDataPerXScaleMng(rXScaleMng) {
    
    this.m_nFindXIndex = null;
    this.m_strFindToolTipRQ = null;
    this.m_rXScaleMng = rXScaleMng;
    this.m_arrRQGraphFindData = [];
}

CRQGraphFindDataPerXScaleMng.prototype.Init = function (rXScaleMng) {
    
    this.m_nFindXIndex = null;
    this.m_strFindToolTipRQ = null;
    this.m_rXScaleMng = rXScaleMng;
    this.m_arrRQGraphFindData.length = 0;
}

CRQGraphFindDataPerXScaleMng.prototype.SetXScaleMng = function (rXScaleMng) {
    this.m_rXScaleMng = rXScaleMng;
}
CRQGraphFindDataPerXScaleMng.prototype.GetRQGraphFindData = function (strRQ) {

    var nLen = this.m_arrRQGraphFindData.length;
    for (var i = 0; i < nLen; i++) {

        var rRQGraphFindData = this.m_arrRQGraphFindData[i];
        if (rRQGraphFindData.m_strRQ === strRQ)
            return rRQGraphFindData;
    }
    return null;
}
CRQGraphFindDataPerXScaleMng.prototype.AddRQGraphFindData = function (rRQGraphFindData) {
    this.m_arrRQGraphFindData[this.m_arrRQGraphFindData.length] = rRQGraphFindData;
}

//////////////////////////////////////////////////////////////////
//차트 저장/불러오기 관련 클래스
/////////////////////////////////////////////////////////////////
//CChartFullProperty
export function CChartFullProperty() {

    this.m_RQPropertyArray = [];//배열로 구성(등록된 차례대로 조회진행 할 수 있도록)
    this.m_MainBlockProperty = null;
    this.m_GlobalProperty = null;
    this.m_mapAllToolProperty = null;
}

//CRQProperty
export function CRQProperty() {
    this.m_strRQ = null;
    this.m_strCode = null;
    this.m_strName = null;
    this.m_nCycle = null;
    this.m_nInterval = null;
    this.m_nRequestDataCnt = null;
    this.m_bRealBong = null;
    this.m_strStartDateTime = null;
    this.m_strEndDateTime = null;
}
CRQProperty.prototype.SetProperty = function (strRQ, strCode, strName, nCycle, nInterval, nRequestDataCnt, bRealBong, strStartDateTime, strEndDateTime) {
    this.m_strRQ = strRQ;
    this.m_strCode = strCode;
    this.m_strName = strName;
    this.m_nCycle = nCycle;
    this.m_nInterval = nInterval;
    this.m_nRequestDataCnt = nRequestDataCnt;
    this.m_bRealBong = bRealBong;
    this.m_strStartDateTime = strStartDateTime;
    this.m_strEndDateTime = strEndDateTime;
}
/////////////////////////////////////////////////////////////////
//CMainBlockProperty
export function CMainBlockProperty() {
    this.m_nBlockType = null;
    this.m_bBlockMaximize = null;
    this.m_ChartBlockPropertyArray = [];
}
CMainBlockProperty.prototype.SetProperty = function (nBlockType, bBlockMaximize, ChartBlockPropertyArray) {

    this.m_nBlockType = nBlockType;
    this.m_bBlockMaximize = bBlockMaximize;
    this.m_ChartBlockPropertyArray = ChartBlockPropertyArray;
}
/////////////////////////////////////////////////////////////////
//CChartBlockProperty
export function CChartBlockProperty() {
    this.m_nColIndex = null;
    this.m_nRowIndex = null;
    this.m_nBlockRatio = null;
    this.m_BlockSizeRatio = null;
    this.m_bBlockMaximize = null;
    this.m_GraphPropertyArray = [];
}
CChartBlockProperty.prototype.SetProperty = function (nColIndex, nRowIndex, nBlockRatio, BlockSizeRatio, bBlockMaximize, GraphPropertyArray) {

    this.m_nColIndex = nColIndex;
    this.m_nRowIndex = nRowIndex;
    this.m_nBlockRatio = nBlockRatio;
    this.m_BlockSizeRatio = BlockSizeRatio;
    this.m_bBlockMaximize = bBlockMaximize;
    this.m_GraphPropertyArray = GraphPropertyArray;
}
/////////////////////////////////////////////////////////////////
//CGraphProperty
export function CGraphProperty() {

    this.m_strRQ = null;
    this.m_strGraphName = null;
    this.m_strGraphKey = null;
    this.m_nColIndex = null;
    this.m_nRowIndex = null;
    this.m_nVertScaleIndex = null;
    this.m_nBlockRatio = null;
    this.m_PropertyInfo = null;
}

CGraphProperty.prototype.SetProperty = function (strRQ, strGraphName, strGraphKey, nColIndex, nRowIndex, nVertScaleIndex, nBlockRatio, PropertyInfo) {

    this.m_strRQ = strRQ;
    this.m_strGraphName = strGraphName;
    this.m_strGraphKey = strGraphKey;
    this.m_nColIndex = nColIndex;
    this.m_nRowIndex = nRowIndex;
    this.m_nVertScaleIndex = nVertScaleIndex;
    this.m_nBlockRatio = nBlockRatio;
    this.m_PropertyInfo = PropertyInfo;
}
////////////////////////////////////////////////////////////////////////
//공용 클래스 END
////////////////////////////////////////////////////////////////////////

/////////////////////////////
export function CRQInfo() {
    //console.log('RQInfo');

    this.m_strItemCode = "";
    this.m_strItemName = "";
    this.m_nCycle = 1;//1:일, 2:주
    this.m_nInterval = 1;//N 간격
    this.m_nRequestDataCnt = 100;
    this.m_bRealBong = true;//실봉(true)/허봉(false) 구분

    this.m_strMarketStartTime = "";
    this.m_strMarketEndTime = "";
    this.m_strPriceDigit = null;//가격 표현 단위("0", "0.01", "0.00000001" 등 셋팅)
    this.m_strOrderUnitQty = null;//최소주문수량단위( ex: "0.0001" 입력 ) => 거래량 자리수 표현에 사용

    this.m_CurPrice = null;//현재가(숫자데이터)
    this.m_PrevPrice = null;//전일종가(숫자데이터)
    this.m_PriceChange = null;//대비(숫자데이터)
    this.m_ChangeRatio = null;//등락율(숫자데이터)
    this.m_CumulativeVolume = null;//누적등락율(숫자데이터)


    // 20190115 전중현 : 기준선 사용 Data 기준선 사용시 데이터를 넣어야지 그릴수 있음
    this.m_OpenPrice = null;    // 시가(숫자데이터)
    this.m_HighPrice = null;    // 고가(숫자데이터)
    this.m_LowPrice = null;    // 저가(숫자데이터)

    this.m_PreOpenPrice = null;    // 전일시가(숫자데이터)
    this.m_PreHighPrice = null;    // 전일고가(숫자데이터)
    this.m_PreLowPrice = null;    // 전일저가(숫자데이터)

    this.m_OHL3Price = null;   // 시고저/3
    this.m_HL2Price = null;   // 고저/2

    this.m_UpperPrice = null;   // 상한가(숫자데이터)
    this.m_LowerPrice = null;   // 하한가(숫자데이터)

    //strNextKey 추가 LJH 2019.01.02
    this.m_strNextKey = null;

    //스마트 시그널 조회시 사용
    this.m_TrStartDateTime = null;
    this.m_TrEndDateTime = null;
}

function RQInfoForScroll() {

    this.m_strItemCode = "";
    this.m_nCycle = 1;
    this.m_nInterval = 1;
    this.m_strNextKey = "";
}

///////////////////////////
function CBlockProperty() {
    tihs.m_clrBack = "#000000";
}

////////////////////////////
export function CVariable() {
    this.m_strName = "";//변수명
    this.m_strTitle = "";//설정창 표기용도
    this.m_strTitleLangKey = "";

    this.m_nType = NUMERIC_TYPE;//1:NUMERIC_TYPE(숫자형), 2:DATETIME_TYPE(시간형), 3:STRING_TYPE(문자형)
    this.m_strData = 0;//변수값

    this.m_bCalc = false;//설정변경시 재계산을 해야 하는지 여부, 설정창에서 설정을 셋팅하는 과정에서만 사용된다
}

CVariable.prototype.ChangeLang = function(){

    if(this.m_strTitleLangKey && this.m_strTitleLangKey.length > 0)
        this.m_strTitle = t(this.m_strTitleLangKey);
}
CVariable.prototype.SetPropertyInfo = function (rSrcVariable, bSetup) {
    if (rSrcVariable === undefined)
        return false;

    this.m_bCalc = false;
    if (this.m_strData !== rSrcVariable.m_strData)
        this.m_bCalc = true;

    this.m_strName = rSrcVariable.m_strName;

    if(rSrcVariable.m_strTitleLangKey && rSrcVariable.m_strTitleLangKey.length > 0)
        this.m_strTitle = t(rSrcVariable.m_strTitleLangKey);
    else
        this.m_strTitle = rSrcVariable.m_strTitle;

        this.m_nType = rSrcVariable.m_nType;
    this.m_strData = rSrcVariable.m_strData;

    return true;
}

CVariable.prototype.Copy = function ( rCopyVariable )
{
    if( rCopyVariable === undefined )
        rCopyVariable = new CVariable();

    rCopyVariable.m_strName = this.m_strName;
    rCopyVariable.m_strTitle = this.m_strTitle;
    rCopyVariable.m_strTitleLangKey = this.m_strTitleLangKey;
    rCopyVariable.m_nType = this.m_nType;
    rCopyVariable.m_strData = this.m_strData;

    return rCopyVariable;
}

////////////////////////////////////////////////////////////
//CSubGraphTitleInfo
function CSubGraphTitleInfo() {
    this.m_strTitle = "";
    this.m_clrTitle = "#000000";
}
export function CGraphTitleInfo() {
    this.m_strGraphTitle = "";
    this.m_VariableArray = [];
    this.m_SubGraphTitleInfoArray = [];
}

/////////////////////////////////////////////////////////////
//CSubGraphPropertyInfo
function CSubGraphPropertyInfo() {
    this.m_strSubGraphName = "";//프로그램 내부에서 사용하게 될 서브그래프 구분명칭 (예:"Sto_SlowK" => 실제로 보여지는 Title은 "Sto Slow%K")
    this.m_strSubGraphTitle = "";//차트블록 좌측상단, 툴팁, 수치조회 등에 보여지는 이름
    this.m_strSubGraphTitleLangKey = "";
    this.m_nSubGraphType = INDICATOR_SUBGRAPH_TYPE;//지표서브그래프(INDICATOR_SUBGRAPH_TYPE), 가격 서브그래프(PRICE_SUBGRAPH_TYPE), 거래량 서브그래프(VOLUME_SUBGRAPH_TYPE)
    this.m_nSubGraphSubType = 0;//Type에 따른 세부 타입 지정 필요시 사용
    this.m_bShow = true;
}
CSubGraphPropertyInfo.prototype.ChangeLang = function(){

    if(this.m_strSubGraphTitleLangKey && this.m_strSubGraphTitleLangKey.length > 0)
        this.m_strSubGraphTitle = t(this.m_strSubGraphTitleLangKey);
}
CSubGraphPropertyInfo.prototype.SetPropertyInfo = function (rSrcSubGraphProperty, bSetup) {
    if (rSrcSubGraphProperty === undefined)
        return false;

    this.m_strSubGraphName = rSrcSubGraphProperty.m_strSubGraphName;
    if(rSrcSubGraphProperty.m_strSubGraphTitleLangKey && rSrcSubGraphProperty.m_strSubGraphTitleLangKey.length > 0)
        this.m_strSubGraphTitle = t(rSrcSubGraphProperty.m_strSubGraphTitleLangKey);
    else
        this.m_strSubGraphTitle = rSrcSubGraphProperty.m_strSubGraphTitle;

    this.m_strSubGraphTitleLangKey = rSrcSubGraphProperty.m_strSubGraphTitleLangKey;

    this.m_nSubGraphType = rSrcSubGraphProperty.m_nSubGraphType;
    this.m_nSubGraphSubType = rSrcSubGraphProperty.m_nSubGraphSubType;
    this.m_bShow = rSrcSubGraphProperty.m_bShow;

    return true;
}
CSubGraphPropertyInfo.prototype.Copy = function ( rCopySubGraphProperty )
{
    if( rCopySubGraphProperty === undefined )
        rCopySubGraphProperty = new CSubGraphPropertyInfo();

    rCopySubGraphProperty.m_strSubGraphName = this.m_strSubGraphName;
    rCopySubGraphProperty.m_strSubGraphTitle = this.m_strSubGraphTitle;
    rCopySubGraphProperty.m_strSubGraphTitleLangKey = this.m_strSubGraphTitleLangKey;
    rCopySubGraphProperty.m_nSubGraphType = this.m_nSubGraphType;
    rCopySubGraphProperty.m_nSubGraphSubType = this.m_nSubGraphSubType;
    rCopySubGraphProperty.m_bShow = this.m_bShow;

    return rCopySubGraphProperty;
}

////////////////////////////
function CSubGraph(Graph) {

    this.m_Graph = Graph;
    this.m_rChart = Graph ? Graph.m_rChart : null;
    this.m_rGlobalProperty = (this.m_rChart !== null ? this.m_rChart.GetGlobalProperty() : null);

    this.m_strSubGraphName = "";//프로그램 내부에서 사용하게 될 서브그래프 구분명칭 (예:"Sto_SlowK" => 실제로 보여지는 Title은 "Sto Slow%K")
    this.m_strSubGraphTitle = "";//서브그래프별 타이틀
    this.m_strSubGraphTitleLangKey = "";

    this.m_rRQSet = null;//Graph.GetRQSet();
    this.m_nSubGraphType = INDICATOR_SUBGRAPH_TYPE;//지표서브그래프(INDICATOR_SUBGRAPH_TYPE), 가격 서브그래프(PRICE_SUBGRAPH_TYPE), 거래량 서브그래프(VOLUME_SUBGRAPH_TYPE)
    this.m_nSubGraphSubType = 0;//SubGraphType에 따라 세부타입결정

    this.m_strPacketName = "";
    this.m_rPacketData = null;

    this.m_MinMaxInfo = new CMinMaxInfo();
    this.m_bSelected = false;
    this.m_bShow = true;

    this.m_TitleDiv = null;
    this.m_TitleId = null;
    this.m_strTitle = "";//실제 출력되는 서브그래프 타이틀 저장 변수
    this.m_strTitleLangKey = "";

    this.m_SaveDataArray = [];//이평합산 값 등을 임시저장했다가 다시 꺼내 사용할 경우 등 다양한 처리 도중 필요하면 사용

    //보이는 영역에서 최근 데이터 Y축에 보이기 처리관련 변수
    this.m_ViewLatestData = null;
    this.m_ViewPrevData = null;
    this.m_clrViewLatestData = null;

    //속도개선처리
    this.m_BongTypeInfo = [];
    this.m_yMin = null;
    this.m_yMax = null;
    this.m_yDiff = null;
    this.m_PrevClose = null;
    this.m_rPrevBongPosInfo = null;
    this.m_bRenderingBreak = false;
    this.m_rRQInCol = null;

    //선택그래프 표시기능
    this.m_SignBongInfoArray = [];

    //툴팁 또는 수치조회 기능 메모리 절약을 위해 미리 메모리 풀방식 사용
    this.m_SubGraphFindData4ToolTip = new CSubGraphFindData(this);
    this.m_SubGraphFindData4ToolTip.m_SubGraphFindSubDataArray[0] = new CSubGraphFindSubData();

    this.m_rPriceSubGraphPropertyInfo = null;//특수한 서브그래프의 경우 가격 서브그래프의 설정을 참조하는 경우 발생

}

CSubGraph.prototype.ChangeLang = function(){

    if(this.m_strSubGraphTitleLangKey && this.m_strSubGraphTitleLangKey.length > 0)
        this.m_strSubGraphTitle = t(this.m_strSubGraphTitleLangKey);
    
    if(this.m_strTitleLangKey && this.m_strTitleLangKey.length > 0)
        this.m_strTitle = t(this.m_strTitleLangKey);
}

CSubGraph.prototype.CreateDrawer = function () {
    return true;
}
CSubGraph.prototype.SetPropertyInfoToDrawer = function () {
}
CSubGraph.prototype.ChangeSubGraphSubType = function (nSubGraphSubType) {

    this.m_nSubGraphSubType = nSubGraphSubType;
    this.CreateDrawer();
}
CSubGraph.prototype.SetGlobalPropertyToChart = function () {
}

CSubGraph.prototype.GetLog = function () {
    return this.m_Graph.GetLog();
}

CSubGraph.prototype.GetInvert = function () {
    return this.m_Graph.GetInvert();
}

CSubGraph.prototype.ReadyRendering = function (DrawingInfo) {
    this.m_bRenderingBreak = false;
}
CSubGraph.prototype.InitRendering = function () {

    this.m_ViewLatestData = null;
    this.m_ViewPrevData = null;
    this.m_clrViewLatestData = null;
    
    this.m_BongTypeInfo.length = 0;

    if (this.GetLog() === true) {

        this.m_yMin = Log(this.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit);
        this.m_yMax = Log(this.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit);
    }
    else {

	    this.m_yMin = this.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit;
	    this.m_yMax = this.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit;
    }

    this.m_yDiff = this.m_yMax - this.m_yMin;
   
    this.m_PrevClose = null;

    this.m_rPrevBongPosInfo = null;
    this.m_SignBongInfoArray.length = 0;

    this.m_bRenderingBreak = false;
}

CSubGraph.prototype.RenderingInLoop = function (RenderingInfo) {
}
CSubGraph.prototype.RenderingOnLast = function (RenderingInfo) {
    return true;
}
CSubGraph.prototype.AddSelectPosInfo = function () {
}
CSubGraph.prototype.SetUpdateMinMax = function (bUpdateMinMax) {
    this.m_Graph.SetUpdateMinMax(bUpdateMinMax);
}
CSubGraph.prototype.IsDrawSelected = function (rDrawingInfo) {
    return (rDrawingInfo.m_DrawSelectedSubGraph === this);
}
CSubGraph.prototype.GetTitleDiv = function (TitleDiv) {
    return this.m_TitleDiv;
}
CSubGraph.prototype.SetSubGraphTitle = function (strSubGraphTitle) {
    this.m_strSubGraphTitle = strSubGraphTitle;
}
CSubGraph.prototype.GetSubGraphTitle = function (strSubGraphTitle) {
    return this.m_strSubGraphTitle;
}
CSubGraph.prototype.GetTitleColor = function () {
    return "#000000";
}
CSubGraph.prototype.SetTitle = function (strTitle) {
    this.m_strTitle = strTitle;
}
CSubGraph.prototype.GetTitle = function () {
    return this.m_strTitle;
}
CSubGraph.prototype.ShowTitle = function (StartPt, LayoutInfo) {

    if (this.m_TitleDiv)
        this.DestroyTitle();
    return this.CreateTitle(StartPt, LayoutInfo);
}
CSubGraph.prototype.CreateTitle = function (StartPt, LayoutInfo) {

    if (!this.m_bShow)
        return null;

    var nDivHeight = LayoutInfo.m_nFontHeight;
    this.m_TitleId = this.m_Graph.m_strKey + "_" + this.m_strSubGraphName + "_Title";
    this.m_TitleDiv = document.createElement('DIV');
    this.m_TitleDiv.id = this.m_TitleId;
    this.m_TitleDiv.type = 'text';
    this.m_TitleDiv.style.position = 'absolute';
    this.m_TitleDiv.style.padding = '1px 1px 1px 1px';

    this.m_TitleDiv.style.lineHeight = nDivHeight + "px";
    this.m_TitleDiv.style.display = 'inline';
    this.m_TitleDiv.style.left = StartPt.m_X + 'px';
    this.m_TitleDiv.style.top = StartPt.m_Y + 'px';
    this.m_TitleDiv.style.height = nDivHeight + 'px';
    this.m_TitleDiv.style.zIndex = 5;
    this.m_TitleDiv.style.background = "rgba(255, 255, 255, 0)";//"#e4e4e4";
    this.m_TitleDiv.style.fontSize = LayoutInfo.m_nFontSize + "px";
    this.m_TitleDiv.style.fontFamily = LayoutInfo.m_strFontName;//'굴림';
    this.m_TitleDiv.style.borderRadius = '';//'5px';
    this.m_TitleDiv.style.textAlign = 'left';
    this.m_TitleDiv.style.cursor = 'Pointer';

    this.m_TitleDiv.style.display = 'none';//생성시점에는 보이지 않도록 처리(chartblock에서 위치조정 후 show(='inline'셋팅)

    //div.style.pointer= 'crosshair';
    //div.style.boxShadow='rgba(96,96,96,0.5) 0 0 5px';
    this.m_TitleDiv.style.filter = "alpha(opacity=100)";
    this.m_TitleDiv.className = "no-select";
    this.m_TitleDiv.style.color = this.GetTitleColor();

    this.m_TitleDiv.innerHTML = "" + this.GetTitle();

    LayoutInfo.m_rChartParentDIV.appendChild(this.m_TitleDiv);

    var self = this;
    
    this.m_TitleDiv.addEventListener('dblclick', function (e) {

        self.OnDblClickTitle();
    });

    this.m_TitleDiv.addEventListener('mousemove', function (e) {

        self.OnMouseMove();
    });

    this.m_TitleDiv.addEventListener('mouseout', function (e) {

        self.OnMouseOut();
    });

    this.m_TitleDiv.addEventListener('click', function (e) {

        self.OnClickTitle();
    });


    StartPt.m_X += (this.m_TitleDiv.offsetWidth + 5);

    return this.m_TitleDiv;
}
CSubGraph.prototype.OnMouseMove = function () {

    if (this.m_TitleDiv) {

        this.m_TitleDiv.style.border = '1px';
        this.m_TitleDiv.style.borderStyle = 'solid';
        this.m_TitleDiv.style.borderColor = '#000000';
    }
}
CSubGraph.prototype.OnMouseOut = function () {

    if (this.m_TitleDiv) {

        this.m_TitleDiv.style.border = '';
        this.m_TitleDiv.style.borderStyle = '';
        this.m_TitleDiv.style.borderColor = '';
    }
}

CSubGraph.prototype.OnDblClickTitle = function () {
    
    this.m_rChart.ShowModalSetting(this.m_Graph.m_strKey);
}

CSubGraph.prototype.OnClickTitle = function () {

    this.m_Graph.m_rBlock.m_rMainBlock.m_DrawSelectedSubGraph = this;
    this.m_Graph.m_rBlock.m_rMainBlock.m_rChart.Draw(DRAW_CASE_SELECT_SUBGRAPH);
    this.m_Graph.SendEvent("Event_SelectGraph", this.m_Graph);
}

CSubGraph.prototype.DestroyTitle = function () {

    if (this.m_TitleDiv && this.m_TitleDiv.parentNode) {

        this.m_TitleDiv.parentNode.removeChild(this.m_TitleDiv);

        var strID = "#" + this.m_TitleId;
        $(strID).remove();

        this.m_TitleDiv = null;
    }
}

CSubGraph.prototype.SetPropertyInfo = function (PropertyInfo, bSetup) {

    if (this.m_strSubGraphName !== PropertyInfo.m_strSubGraphName)
        return false;

        this.m_strSubGraphTitleLangKey

    if(PropertyInfo.m_strSubGraphTitleLangKey && PropertyInfo.m_strSubGraphTitleLangKey.length > 0)
        this.m_strSubGraphTitle = t(PropertyInfo.m_strSubGraphTitleLangKey);
    else
        this.m_strSubGraphTitle = PropertyInfo.m_strSubGraphTitle;

    this.m_strSubGraphTitleLangKey = PropertyInfo.m_strSubGraphTitleLangKey;
   	this.m_nSubGraphType = PropertyInfo.m_nSubGraphType;
    this.m_nSubGraphSubType = PropertyInfo.m_nSubGraphSubType;
    this.m_bShow = PropertyInfo.m_bShow;

    return true;
}
CSubGraph.prototype.GetPropertyInfo = function (SubGraphPropertyInfo) {

    if (SubGraphPropertyInfo === undefined)
        SubGraphPropertyInfo = new CSubGraphPropertyInfo();

    SubGraphPropertyInfo.m_strSubGraphName = this.m_strSubGraphName;
    SubGraphPropertyInfo.m_strSubGraphTitle = this.m_strSubGraphTitle;
    SubGraphPropertyInfo.m_strSubGraphTitleLangKey = this.m_strSubGraphTitleLangKey;

    SubGraphPropertyInfo.m_nSubGraphType = this.m_nSubGraphType;
    SubGraphPropertyInfo.m_nSubGraphSubType = this.m_nSubGraphSubType;
    SubGraphPropertyInfo.m_bShow = this.m_bShow;

    return SubGraphPropertyInfo;
}

CSubGraph.prototype.GetSubGraphTitleInfo = function () {

    //그래프명 저장
    var SubGraphTitleInfo = new CSubGraphTitleInfo();
    SubGraphTitleInfo.m_strTitle = this.m_strSubGraphTitle;

    return SubGraphTitleInfo;
}
CSubGraph.prototype.GetRQGraphFindDataPerXScaleMng = function (rRQPackets) {

    var rPacketItemData = rRQPackets.m_Packets[this.m_rPacketData.m_nPacketIndex];
    if (rPacketItemData === undefined) {
        return null;
    }

    var SubGraphFindData = this.m_SubGraphFindData4ToolTip;
    SubGraphFindData.m_SubGraphFindSubDataArray[0].m_strSubGraphTitle = this.m_strSubGraphTitle;
    SubGraphFindData.m_SubGraphFindSubDataArray[0].m_strSubGraphFindData = ConvertNumToDigitText(rPacketItemData.m_Data, rPacketItemData.m_rPacketData.m_nDec, 1, rPacketItemData.m_rPacketData.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

    return SubGraphFindData;
}
CSubGraph.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {

    var rPacketItemData = rRQPackets.m_Packets[this.m_rPacketData.m_nPacketIndex];
    if (rPacketItemData === undefined) {
        return false;
    }
    return false;
}

CSubGraph.prototype.GetTitleAndPacketName = function (strTitleArray, strPacketNameArray) {
    strTitleArray[strTitleArray.length] = this.m_strSubGraphTitle;
    strPacketNameArray[strPacketNameArray.length] = this.m_strPacketName;
}
CSubGraph.prototype.Select = function (bSelected) {
    this.m_bSelected = bSelected;
}
CSubGraph.prototype.IsSelected = function () {
    return this.m_bSelected;
}
CSubGraph.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {
}

CSubGraph.prototype.SetRQSet = function (rRQSet) {
    this.m_rRQSet = rRQSet;
}
CSubGraph.prototype.GetRQSet = function () {
    return this.m_rRQSet;
}

CSubGraph.prototype.SetSubGraphName = function (strSubGraphName) {

    this.m_strSubGraphName = strSubGraphName;
    this.m_SubGraphFindData4ToolTip.m_strSubGraphName = this.m_strSubGraphName;
}

CSubGraph.prototype.SetPacketData = function (strPacketDataName) {


    if (this.m_rRQSet) {
        this.m_strPacketName = strPacketDataName;
        var rPacketData = this.m_rRQSet.GetPacketData(this.m_strPacketName);
        if (rPacketData) {
            this.m_rPacketData = rPacketData;
            this.m_rPacketData.AddSubGraph(this);
            return rPacketData;
        }
    }
    return null;
}

CSubGraph.prototype.DeleteSubGraphInPacketData = function () {
    if (this.m_rPacketData)
        return this.m_rPacketData.DeleteSubGraph(this);
    return false;
}
//일반 서브그래프 그리기 처리함수
CSubGraph.prototype.Draw = function (DrawingInfo) {
}

CSubGraph.prototype.SetPriceSubGraphPropertyInfo = function (rPriceSubGraphPropertyInfo) {
    this.m_rPriceSubGraphPropertyInfo = rPriceSubGraphPropertyInfo;
}

///////////////////////////////////////////////////////////////////////////////
//증권용 라인차트정보
export function CIndicatorLineTypeInfo() {

    this.m_strKeyOfClrLine = null;
    this.m_clrLine = null;//라인색상
    this.m_nThickness = 1;//라인두께
    this.m_nLineType = PS_SOLID;//라인타입(0:실선, 1:제일 촘촘한 점선, ... )

    this.m_strOverheat = "";//과열값
    this.m_strDoldrums = "";//침체값

    this.m_strKeyOfClrOverheat = null;
    this.m_clrOverheat = null; //#F52D49";// "#ff0000";

    this.m_strKeyOfClrDoldrums = null;
    this.m_clrDoldrums = null; //"#0B7EFF"//"#0000ff";
}
CIndicatorLineTypeInfo.prototype.ChangeLang = function(){

}
CIndicatorLineTypeInfo.prototype.SetProperty = function (strKeyOfClrLine, clrLine, nThickness, nLineType, strOverheat, strDoldrums,
    strKeyOfClrOverheat, clrOverheat, strKeyOfClrDoldrums, clrDoldrums) {

    this.m_strKeyOfClrLine = strKeyOfClrLine;
    this.m_clrLine = clrLine;//라인색상
    this.m_nThickness = nThickness;//라인두께
    this.m_nLineType = nLineType;//라인타입(0:실선, 1:제일 촘촘한 점선, ... )

    this.m_strOverheat = strOverheat;//과열값
    this.m_strDoldrums = strDoldrums;//침체값

    this.m_strKeyOfClrOverheat = strKeyOfClrOverheat;
    this.m_clrOverheat = clrOverheat; //#F52D49";// "#ff0000";

    this.m_strKeyOfClrDoldrums = strKeyOfClrDoldrums;
    this.m_clrDoldrums = clrDoldrums; //"#0B7EFF"//"#0000ff";
}
CIndicatorLineTypeInfo.prototype.SetClrLine = function (clrLine) {

    this.m_strKeyOfClrLine = null;
    this.m_clrLine = clrLine;
}
CIndicatorLineTypeInfo.prototype.SetClrOverheat = function (clrOverheat) {

    this.m_strKeyOfClrOverheat = null;
    this.m_clrOverheat = clrOverheat;
}
CIndicatorLineTypeInfo.prototype.SetClrDoldrums = function (clrDoldrums) {

    this.m_strKeyOfClrDoldrums = null;
    this.m_clrDoldrums = clrDoldrums;
}
CIndicatorLineTypeInfo.prototype.SetPropertyInfo = function (rSrcTypeInfo, bSetup) {

    if (rSrcTypeInfo === undefined)
        return false;

    this.m_strKeyOfClrLine = rSrcTypeInfo.m_strKeyOfClrLine;
    this.m_clrLine = rSrcTypeInfo.m_clrLine;//라인색상
    this.m_nThickness = rSrcTypeInfo.m_nThickness;//라인두께
    this.m_nLineType = rSrcTypeInfo.m_nLineType;//라인타입(0:실선, 1:제일 촘촘한 점선, ... )

    this.m_strOverheat = rSrcTypeInfo.m_strOverheat;//과열값
    this.m_strDoldrums = rSrcTypeInfo.m_strDoldrums;//침체값

    this.m_strKeyOfClrOverheat = rSrcTypeInfo.m_strKeyOfClrOverheat;
    this.m_clrOverheat = rSrcTypeInfo.m_clrOverheat; //#F52D49";// "#ff0000";

    this.m_strKeyOfClrDoldrums = rSrcTypeInfo.m_strKeyOfClrDoldrums;
    this.m_clrDoldrums = rSrcTypeInfo.m_clrDoldrums; //"#0B7EFF"//"#0000ff";

    return true;
}
CIndicatorLineTypeInfo.prototype.Copy = function (rCopyTypeInfo) {

    if (rCopyTypeInfo === undefined)
        rCopyTypeInfo = new CIndicatorLineTypeInfo();

    rCopyTypeInfo.m_strKeyOfClrLine = this.m_strKeyOfClrLine ;
    rCopyTypeInfo.m_clrLine = this.m_clrLine ;//라인색상
    rCopyTypeInfo.m_nThickness = this.m_nThickness ;//라인두께
    rCopyTypeInfo.m_nLineType = this.m_nLineType ;//라인타입(0:실선, 1:제일 촘촘한 점선, ... )

    rCopyTypeInfo.m_strOverheat = this.m_strOverheat ;//과열값
    rCopyTypeInfo.m_strDoldrums = this.m_strDoldrums ;//침체값

    rCopyTypeInfo.m_strKeyOfClrOverheat = this.m_strKeyOfClrOverheat ;
    rCopyTypeInfo.m_clrOverheat = this.m_clrOverheat ; //#F52D49";// "#ff0000";

    rCopyTypeInfo.m_strKeyOfClrDoldrums = this.m_strKeyOfClrDoldrums ;
    rCopyTypeInfo.m_clrDoldrums = this.m_clrDoldrums; //"#0B7EFF"//"#0000ff";

    return rCopyTypeInfo;
}

//////////////////////////////////////////////////////////////////////////////////
//CIndicatorBarTypeInfo
export function CIndicatorBarTypeInfo() {

    this.m_nCompareType = COMPARE_TYPE_ZERO;//0:비교없음, 1:0값비교, 2:이전값비교, 3:이전종가, 4:이전고가, 5:현재시가, 6:가격차트
    this.m_clrBar = "#CC0000";//"#F52D49";//막대의 기본색상
    this.m_clrUp = "#CC0000";//"#F52D49";//막대 비교 상승색상
    this.m_clrDown = "#1155CC";//"#0B7EFF";//막대 비교 하락색상

    this.m_strKeyOfClrBar = "clrBar";
    this.m_strKeyOfClrUp = "clrUp";
    this.m_strKeyOfCrDown = "clrDown";

    this.m_bFill = true;//막대바 채우기
}
CIndicatorBarTypeInfo.prototype.ChangeLang = function(){

}
CIndicatorBarTypeInfo.prototype.SetClrBar = function (clrBar) {

    this.m_strKeyOfClrBar = null;
    this.m_clrBar = clrBar;
}
CIndicatorBarTypeInfo.prototype.SetClrUp = function (clrUp) {

    this.m_strKeyOfClrUp = null;
    this.m_clrUp = clrUp;
}
CIndicatorBarTypeInfo.prototype.SetClrDown = function (clrDown) {

    this.m_strKeyOfClrDown = null;
    this.m_clrDown = clrDown;
}
CIndicatorBarTypeInfo.prototype.SetPropertyInfo = function (rSrcBarTypeInfo, bSetup) {

    if (rSrcBarTypeInfo === undefined)
        return false;

    this.m_nCompareType = Number(rSrcBarTypeInfo.m_nCompareType);
    this.m_clrBar = rSrcBarTypeInfo.m_clrBar;
    this.m_clrUp = rSrcBarTypeInfo.m_clrUp;
    this.m_clrDown = rSrcBarTypeInfo.m_clrDown;

    this.m_strKeyOfClrBar = rSrcBarTypeInfo.m_strKeyOfClrBar;
    this.m_strKeyOfClrUp = rSrcBarTypeInfo.m_strKeyOfClrUp;
    this.m_strKeyOfCrDown = rSrcBarTypeInfo.m_strKeyOfCrDown;

    this.m_bFill = rSrcBarTypeInfo.m_bFill;//막대바 채우기

    return true;
}
CIndicatorBarTypeInfo.prototype.Copy = function (rCopyBarTypeInfo) {

    if (rCopyBarTypeInfo === undefined)
        rCopyBarTypeInfo = new CIndicatorBarTypeInfo();

    rCopyBarTypeInfo.m_nCompareType = this.m_nCompareType;
    rCopyBarTypeInfo.m_clrBar = this.m_clrBar;
    rCopyBarTypeInfo.m_clrUp = this.m_clrUp;
    rCopyBarTypeInfo.m_clrDown = this.m_clrDown;

    rCopyBarTypeInfo.m_strKeyOfClrBar = this.m_strKeyOfClrBar;
    rCopyBarTypeInfo.m_strKeyOfClrUp = this.m_strKeyOfClrUp;
    rCopyBarTypeInfo.m_strKeyOfCrDown = this.m_strKeyOfCrDown;

    rCopyBarTypeInfo.m_bFill = this.m_bFill;//막대바 채우기

    return rCopyBarTypeInfo;
}

////////////////////////////////////////////////////////////////////////////////////
//CIndicatorSubGraphPropertyInfo
export function CIndicatorSubGraphPropertyInfo() {
    CSubGraphPropertyInfo.call(this);

    this.m_nSubGraphType = INDICATOR_SUBGRAPH_TYPE;//지표서브그래프(INDICATOR_SUBGRAPH_TYPE), 가격 서브그래프(PRICE_SUBGRAPH_TYPE), 거래량 서브그래프(VOLUME_SUBGRAPH_TYPE)
    this.m_nSubGraphSubType = INDICATOR_SUBGRAPH_LINE_TYPE;//Type에 따른 세부 타입 지정 필요시 사용

    this.m_LineTypeInfo = null;
    this.m_BarTypeInfo = null;
}
CIndicatorSubGraphPropertyInfo.prototype = new CSubGraphPropertyInfo();
CIndicatorSubGraphPropertyInfo.prototype.constructor = CIndicatorSubGraphPropertyInfo;

CIndicatorSubGraphPropertyInfo.prototype.ChangeLang = function(){

    CSubGraphPropertyInfo.prototype.ChangeLang.call(this);

    if(this.m_LineTypeInfo)
        this.m_LineTypeInfo.ChangeLang();
    if(this.m_BarTypeInfo)
        this.m_BarTypeInfo.ChangeLang();
}
CIndicatorSubGraphPropertyInfo.prototype.SetLineProperty = function (strKeyOfClrLine, clrLine, nThickness, nLineType, strOverheat, strDoldrums,
    strKeyOfClrOverheat, clrOverheat, strKeyOfClrDoldrums, clrDoldrums) {

    if (this.m_LineTypeInfo === null)
        this.m_LineTypeInfo = new CIndicatorLineTypeInfo();

    this.m_LineTypeInfo.SetProperty(strKeyOfClrLine, clrLine, nThickness, nLineType, strOverheat, strDoldrums,
        strKeyOfClrOverheat, clrOverheat, strKeyOfClrDoldrums, clrDoldrums);
}
CIndicatorSubGraphPropertyInfo.prototype.SetBarProperty = function () {

    if (this.m_BarTypeInfo === null)
        this.m_BarTypeInfo = new CIndicatorBarTypeInfo();

    this.m_BarTypeInfo.SetProperty();
}
CIndicatorSubGraphPropertyInfo.prototype.SetPropertyInfo = function (rSrcIndiPropertyInfo, bSetup) {

    if (rSrcIndiPropertyInfo === undefined)
        return false;

    CSubGraphPropertyInfo.prototype.SetPropertyInfo.call(this, rSrcIndiPropertyInfo, bSetup);

    //CIndicatorLineTypeInfo
    if (this.m_LineTypeInfo === null && rSrcIndiPropertyInfo.m_LineTypeInfo !== null)
        this.m_LineTypeInfo = new CIndicatorLineTypeInfo();
    else if (this.m_LineTypeInfo !== null && rSrcIndiPropertyInfo.m_LineTypeInfo === null)
        this.m_LineTypeInfo = null;

    if (this.m_LineTypeInfo)
        this.m_LineTypeInfo.SetPropertyInfo(rSrcIndiPropertyInfo.m_LineTypeInfo, bSetup);

    //CIndicatorBarTypeInfo
    if (this.m_BarTypeInfo === null && rSrcIndiPropertyInfo.m_BarTypeInfo !== null)
        this.m_BarTypeInfo = new CIndicatorBarTypeInfo();
    else if (this.m_BarTypeInfo !== null && rSrcIndiPropertyInfo.m_BarTypeInfo === null)
        this.m_BarTypeInfo = null;

    if (this.m_BarTypeInfo)
        this.m_BarTypeInfo.SetPropertyInfo(rSrcIndiPropertyInfo.m_BarTypeInfo, bSetup);

    return true;
}
CIndicatorSubGraphPropertyInfo.prototype.Copy = function ( rCopySubGraph )
{
    if (rCopySubGraph === undefined )
        rCopySubGraph = new CIndicatorSubGraphPropertyInfo();

    rCopySubGraph = CSubGraphPropertyInfo.prototype.Copy.call(this, rCopySubGraph );

    if(this.m_LineTypeInfo !== null)
        rCopySubGraph.m_LineTypeInfo = this.m_LineTypeInfo.Copy();

    if (this.m_BarTypeInfo !== null)
        rCopySubGraph.m_BarTypeInfo = this.m_BarTypeInfo.Copy();

    return rCopySubGraph;
}
///////////////////////////////////////////////////////////////////////////////
//증권용 라인차트
export function CIndicatorSubGraph(Graph, nSubGraphSubType) {

    CSubGraph.call(this, Graph);

    //서브그래프 타입
    this.m_nSubGraphType = INDICATOR_SUBGRAPH_TYPE;//지표서브그래프(INDICATOR_SUBGRAPH_TYPE), 가격 서브그래프(PRICE_SUBGRAPH_TYPE), 거래량 서브그래프(VOLUME_SUBGRAPH_TYPE)
    this.m_nSubGraphSubType = nSubGraphSubType ? nSubGraphSubType : INDICATOR_SUBGRAPH_LINE_TYPE;//Type에 따른 세부 타입 지정 필요시 사용

    this.m_LineTypeInfo = new CIndicatorLineTypeInfo();
    this.m_BarTypeInfo = new CIndicatorBarTypeInfo();

    //바인 경우 상황에 따라 가격차트 색상설정을 참조해야 하는 경우 발생
    var rPriceSubGraphPropertyInfo = Graph.m_rRQSet.m_CommonInfo["PriceSubGraphPropertyInfo"];
    if (rPriceSubGraphPropertyInfo !== undefined)
        this.m_rPriceSubGraphPropertyInfo = rPriceSubGraphPropertyInfo;

    this.m_yZeroPos = null;//바인 경우 사용

    this.m_Drawer = null;
    this.CreateDrawer();
}
CIndicatorSubGraph.prototype = new CSubGraph();
CIndicatorSubGraph.prototype.constructor = CIndicatorSubGraph;

CIndicatorSubGraph.prototype.ChangeLang = function(){

    CSubGraph.prototype.ChangeLang.call(this);

}

CIndicatorSubGraph.prototype.CreateDrawer = function () {

    switch (this.m_nSubGraphSubType) {

        case INDICATOR_SUBGRAPH_LINE_TYPE:
            this.m_Drawer = new CIndicatorLineDrawer(this);
            return true;
        case INDICATOR_SUBGRAPH_BAR_TYPE:
            this.m_Drawer = new CIndicatorBarDrawer(this);
            return true;
        default:
            this.m_Drawer = null;
            return false;
    }
}
CIndicatorSubGraph.prototype.SetPropertyInfoToDrawer = function(){

    switch (this.m_nSubGraphSubType) {

        case INDICATOR_SUBGRAPH_LINE_TYPE:
            this.m_Drawer.m_rPropertyInfo = this.m_LineTypeInfo;
            return true;
        case INDICATOR_SUBGRAPH_BAR_TYPE:
            this.m_Drawer.m_rPropertyInfo = this.m_BarTypeInfo;
            return true;
        default:
            return false;
    }
}
CIndicatorSubGraph.prototype.GetTitleColor = function () {
    return this.m_LineTypeInfo.m_clrLine;
}
CIndicatorSubGraph.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {

    this.m_Drawer.ExtractYScaleMinMax(rXScaleMng, SubGraphMinMaxInfo, bFullScan);
}

CIndicatorSubGraph.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {

    return this.m_Drawer.FindRQGraphDataPerXScaleMng(X, Y, rRQPackets, rXScaleMng, rectGraphRegion);
}

CIndicatorSubGraph.prototype.GetSubGraphTitleInfo = function () {

    //그래프명 저장
    var SubGraphTitleInfo = new CSubGraphTitleInfo();
    SubGraphTitleInfo.m_strTitle = this.m_strSubGraphTitle;
    SubGraphTitleInfo.m_clrTitle = this.m_LineTypeInfo.m_clrLine;
    return SubGraphTitleInfo;
}

CIndicatorSubGraph.prototype.GetPropertyInfo = function (SubGraphPropertyInfo) {

    if (SubGraphPropertyInfo === undefined)
        SubGraphPropertyInfo = new CIndicatorSubGraphPropertyInfo();

    CSubGraph.prototype.GetPropertyInfo.call(this, SubGraphPropertyInfo);

    SubGraphPropertyInfo.m_LineTypeInfo = this.m_LineTypeInfo;
    SubGraphPropertyInfo.m_BarTypeInfo = this.m_BarTypeInfo;//라인색상
    
    return SubGraphPropertyInfo;
}

CIndicatorSubGraph.prototype.SetPropertyInfo = function (SubGraphPropertyInfo, bSetup) {

    if (SubGraphPropertyInfo === undefined)
        return false;

    var bChangeSubGraphSubType = this.m_nSubGraphSubType !== SubGraphPropertyInfo.m_nSubGraphSubType;

    if (CSubGraph.prototype.SetPropertyInfo.call(this, SubGraphPropertyInfo, bSetup) === false)
        return false;

    //CIndicatorLineTypeInfo
    if (this.m_LineTypeInfo === null && SubGraphPropertyInfo.m_LineTypeInfo !== null)
        this.m_LineTypeInfo = new CIndicatorLineTypeInfo();
    else if (this.m_LineTypeInfo !== null && SubGraphPropertyInfo.m_LineTypeInfo === null)
        this.m_LineTypeInfo = null;

    if (this.m_LineTypeInfo)
        this.m_LineTypeInfo.SetPropertyInfo(SubGraphPropertyInfo.m_LineTypeInfo, bSetup);

    //CIndicatorBarTypeInfo
    if (this.m_BarTypeInfo === null && SubGraphPropertyInfo.m_BarTypeInfo !== null)
        this.m_BarTypeInfo = new CIndicatorBarTypeInfo();
    else if(this.m_BarTypeInfo !== null && SubGraphPropertyInfo.m_BarTypeInfo === null)
        this.m_BarTypeInfo = null;

    if (this.m_BarTypeInfo)
        this.m_BarTypeInfo.SetPropertyInfo(SubGraphPropertyInfo.m_BarTypeInfo, bSetup);


    if (bChangeSubGraphSubType)
        this.CreateDrawer();
    else
        this.SetPropertyInfoToDrawer();

    return true;
}
CIndicatorSubGraph.prototype.InitRendering = function () {

    this.m_ViewLatestData = null;
    this.m_ViewPrevData = null;
    this.m_clrViewLatestData = null;

    if (this.GetLog() === true) {

        this.m_yMin = Log(this.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit);
        this.m_yMax = Log(this.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit);
    }
    else {

	    this.m_yMin = this.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit;
    	this.m_yMax = this.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit;
    }

    this.m_yDiff = this.m_yMax - this.m_yMin;

    var rectGraphRegion = this.m_Graph.m_rBlock.m_rectGraphRegion;
    this.m_yZeroPos = rectGraphRegion.m_nBottom - (0 - this.m_yMin) / this.m_yDiff * rectGraphRegion.Height();
    if (this.GetInvert() === true)
        this.m_yZeroPos = rectGraphRegion.m_nBottom - this.m_yZeroPos + rectGraphRegion.m_nTop;

    this.m_PrevClose = null;

    this.m_bRenderingBreak = false;

    this.m_Drawer.InitRendering();
}
CIndicatorSubGraph.prototype.AddSelectPosInfo = function () {
    this.m_Drawer.AddSelectPosInfo();
}
CIndicatorSubGraph.prototype.RenderingInLoop = function (RenderingInfo) {

    this.m_Drawer.RenderingInLoop(RenderingInfo);
}

CIndicatorSubGraph.prototype.Draw = function (DrawingInfo) {

    this.m_Drawer.Draw(DrawingInfo);
}

//////////////////////////////////////////////////////////////////////////////
//
function CBarPosInfo() {

    this.m_BongXPosInfo = null;

    //this.m_Left = -1;
    this.m_Top = -1;
    //this.m_Right = -1;
    this.m_Bottom = -1;

    this.m_Width = null;
}

function CBarInfo() {
    this.m_clrBar = "#CC0000";//#F52D49";
    this.m_clrLine = "#CC0000";//테두리경계선
    this.m_bFill = true;
    this.m_BarPosInfoArray = [];
}
CBarInfo.prototype.init = function () {
    this.m_BarPosInfoArray.length = 0;
}

///////////////////////////////////////////////////////////////////////////////
//증권용 거래량바 설정정보
function CVolumeBarTypeInfo() {

    this.m_nCompareType = COMPARE_TYPE_CANDLE;//0:비교없음, 1:0값비교, 2:이전값비교, 3:이전종가, 4:이전고가, 5:현재시가, 6:가격차트
    this.m_clrBar = "#CC0000";//"#F52D49";//막대의 기본색상
    this.m_clrUp = "#CC0000";//"#F52D49";//막대 비교 상승색상
    this.m_clrDown = "#1155CC";//"#0B7EFF";//막대 비교 하락색상

    this.m_strKeyOfClrBar = "clrBar";
    this.m_strKeyOfClrUp = "clrUp";
    this.m_strKeyOfCrDown = "clrDown";

    this.m_bFill = true;//막대바 채우기
}
CVolumeBarTypeInfo.prototype.ChangeLang = function(){

}
CVolumeBarTypeInfo.prototype.SetClrBar = function (clrBar) {

    this.m_strKeyOfClrBar = null;
    this.m_clrBar = clrBar;
}
CVolumeBarTypeInfo.prototype.SetClrUp = function (clrUp) {

    this.m_strKeyOfClrUp = null;
    this.m_clrUp = clrUp;
}
CVolumeBarTypeInfo.prototype.SetClrDown = function (clrDown) {

    this.m_strKeyOfClrDown = null;
    this.m_clrDown = clrDown;
}
CVolumeBarTypeInfo.prototype.SetPropertyInfo = function (rSrcVolumeBarTypeInfo, bSetup) {

    if (rSrcVolumeBarTypeInfo === undefined)
        return false;

    this.m_nCompareType = Number(rSrcVolumeBarTypeInfo.m_nCompareType);
    this.m_clrBar = rSrcVolumeBarTypeInfo.m_clrBar;
    this.m_clrUp = rSrcVolumeBarTypeInfo.m_clrUp;
    this.m_clrDown = rSrcVolumeBarTypeInfo.m_clrDown;

    this.m_strKeyOfClrBar = rSrcVolumeBarTypeInfo.m_strKeyOfClrBar;
    this.m_strKeyOfClrUp = rSrcVolumeBarTypeInfo.m_strKeyOfClrUp;
    this.m_strKeyOfCrDown = rSrcVolumeBarTypeInfo.m_strKeyOfCrDown;

    this.m_bFill = rSrcVolumeBarTypeInfo.m_bFill;//막대바 채우기

    return true;
}
CVolumeBarTypeInfo.prototype.Copy = function (rCopyVolumeBarTypeInfo) {

    if (rCopyVolumeBarTypeInfo === undefined)
        rCopyVolumeBarTypeInfo = new CVolumeBarTypeInfo();

    rCopyVolumeBarTypeInfo.m_nCompareType = this.m_nCompareType ;
    rCopyVolumeBarTypeInfo.m_clrBar = this.m_clrBar ;
    rCopyVolumeBarTypeInfo.m_clrUp = this.m_clrUp ;
    rCopyVolumeBarTypeInfo.m_clrDown = this.m_clrDown ;

    rCopyVolumeBarTypeInfo.m_strKeyOfClrBar = this.m_strKeyOfClrBar ;
    rCopyVolumeBarTypeInfo.m_strKeyOfClrUp = this.m_strKeyOfClrUp ;
    rCopyVolumeBarTypeInfo.m_strKeyOfCrDown = this.m_strKeyOfCrDown ;

    rCopyVolumeBarTypeInfo.m_bFill = this.m_bFill;//막대바 채우기

    return rCopyVolumeBarTypeInfo;
}

/////////////////////////////////////////////////////////////////////////////////
////증권용 거래량라인 설정정보
//function CVolumeLineTypeInfo() {

//    this.m_clrLine = null;
//    this.m_strKeyOfClrLine = null;
//}
//CVolumeLineTypeInfo.prototype.SetClrLine = function (clrLine) {

//    this.m_strKeyOfClrLine = null;
//    this.m_clrLine = clrLine;
//}
//CVolumeLineTypeInfo.prototype.SetPropertyInfo = function (rSrcVolumeLineTypeInfo, bSetup) {

//    if (rSrcVolumeLineTypeInfo === undefined)
//        return false;

//    this.m_clrLine = rSrcVolumeLineTypeInfo.m_clrLine;
//    this.m_strKeyOfClrLine = rSrcVolumeLineTypeInfo.m_strKeyOfClrLine;

//    return true;
//}
//CVolumeLineTypeInfo.prototype.Copy = function (rCopyVolumeLineTypeInfo) {
//    if (rCopyVolumeLineTypeInfo === undefined)
//        rCopyVolumeLineTypeInfo = new CVolumeLineTypeInfo();

//    rCopyVolumeLineTypeInfo.m_clrLine = this.m_clrLine;
//    rCopyVolumeLineTypeInfo.m_strKeyOfClrLine = this.m_strKeyOfClrLine;

//    return rCopyVolumeLineTypeInfo;
//}

///////////////////////////////////////////////////////////////////////////////
//증권용 거래량차트 설정정보
function CVolumeSubGraphPropertyInfo() {

    CSubGraphPropertyInfo.call(this);
    
	//서브그래프 타입
    this.m_nSubGraphType = VOLUME_SUBGRAPH_TYPE;
    this.m_nSubGraphSubType = VOLUME_SUBGRAPH_BAR_TYPE;//Type에 따른 세부 타입 지정 필요시 사용

    this.m_VolumeBarTypeInfo = new CVolumeBarTypeInfo();
    this.m_VolumeLineTypeInfo = new CIndicatorLineTypeInfo();
}
CVolumeSubGraphPropertyInfo.prototype = new CSubGraphPropertyInfo();
CVolumeSubGraphPropertyInfo.prototype.constructor = CVolumeSubGraphPropertyInfo;

CVolumeSubGraphPropertyInfo.prototype.Copy = function ( rCopySubGraph )
{
    if (rCopySubGraph === undefined )
        rCopySubGraph = new CVolumeSubGraphPropertyInfo();

    rCopySubGraph = CSubGraphPropertyInfo.prototype.Copy.call(this, rCopySubGraph );

    rCopySubGraph.m_VolumeBarTypeInfo = this.m_VolumeBarTypeInfo.Copy();
    rCopySubGraph.m_VolumeLineTypeInfo = this.m_VolumeLineTypeInfo.Copy();

    return rCopySubGraph;
}

CVolumeSubGraphPropertyInfo.prototype.SetPropertyInfo = function (rSubGraphPropertyInfo, bSetup) {
    
    if (!CSubGraphPropertyInfo.prototype.SetPropertyInfo.call(this, rSubGraphPropertyInfo, bSetup))
        return false;

    this.m_VolumeBarTypeInfo.SetPropertyInfo(rSubGraphPropertyInfo.m_VolumeBarTypeInfo);
    this.m_VolumeLineTypeInfo.SetPropertyInfo(rSubGraphPropertyInfo.m_VolumeLineTypeInfo);

    return true;
}
///////////////////////////////////////////////////////////////////////////////
//증권용가격차트에서 사용되는 막대바 서브그래프(시,고,저,종 패킷의 값 비교기능 포함)
export function CVolumeSubGraph(Graph, nSubGraphSubType) {

    CSubGraph.call(this, Graph);

    this.m_nSubGraphType = VOLUME_SUBGRAPH_TYPE;
    this.m_nSubGraphSubType = nSubGraphSubType ? nSubGraphSubType : VOLUME_SUBGRAPH_BAR_TYPE;//Type에 따른 세부 타입 지정 필요시 사용

    this.m_VolumeBarTypeInfo = new CVolumeBarTypeInfo();//거래량 설정창에서 "바"를 선택한 경우
    this.m_VolumeLineTypeInfo = new CIndicatorLineTypeInfo();//거래량 설정창에서 "라인"을 선택한 경우
    
    //바인 경우 상황에 따라 가격차트 색상설정을 참조해야 하는 경우 발생
    var rPriceSubGraphPropertyInfo = Graph.m_rRQSet.m_CommonInfo["PriceSubGraphPropertyInfo"];
    if (rPriceSubGraphPropertyInfo !== undefined)
        this.m_rPriceSubGraphPropertyInfo = rPriceSubGraphPropertyInfo;

    this.m_yZeroPos = null;
    this.m_PrevClose = null;
    this.m_Drawer = null;
    this.CreateDrawer();
}
CVolumeSubGraph.prototype = new CSubGraph();
CVolumeSubGraph.prototype.constructor = CVolumeSubGraph;

CVolumeSubGraph.prototype.ChangeLang = function(){

    CSubGraph.prototype.ChangeLang.call(this);

    if(this.m_VolumeBarTypeInfo)
        this.m_VolumeBarTypeInfo.ChangeLang();
    if(this.m_VolumeLineTypeInfo)
    this.m_VolumeLineTypeInfo.ChangeLang();
}
CVolumeSubGraph.prototype.CreateDrawer = function () {

    switch (this.m_nSubGraphSubType) {

        case VOLUME_SUBGRAPH_BAR_TYPE:
            this.m_Drawer = new CVolumeBarDrawer(this);
            return true;
        case VOLUME_SUBGRAPH_LINE_TYPE:
            this.m_Drawer = new CIndicatorLineDrawer(this);
            return true;
        default:
            this.m_Drawer = null;
            return false;
    }
}
CVolumeSubGraph.prototype.SetPropertyInfoToDrawer = function(){

    switch (this.m_nSubGraphSubType) {

        case VOLUME_SUBGRAPH_BAR_TYPE:
            this.m_Drawer.m_rPropertyInfo = this.m_VolumeBarTypeInfo;
            return true;
        case VOLUME_SUBGRAPH_LINE_TYPE:
            this.m_Drawer.m_rPropertyInfo = this.m_VolumeLineTypeInfo;
            return true;
        default:
            return false;
    }
}
CVolumeSubGraph.prototype.GetPropertyInfo = function (SubGraphPropertyInfo) {

    if (SubGraphPropertyInfo === undefined)
        SubGraphPropertyInfo = new CVolumeSubGraphPropertyInfo();

    CSubGraph.prototype.GetPropertyInfo.call(this, SubGraphPropertyInfo);

    SubGraphPropertyInfo.m_VolumeBarTypeInfo = this.m_VolumeBarTypeInfo;
    SubGraphPropertyInfo.m_VolumeLineTypeInfo = this.m_VolumeLineTypeInfo;

    return SubGraphPropertyInfo;
}
CVolumeSubGraph.prototype.SetPropertyInfo = function (SubGraphPropertyInfo, bSetup) {

    if (SubGraphPropertyInfo === undefined)
        return false;

    var bChangeSubGraphSubType = this.m_nSubGraphSubType !== SubGraphPropertyInfo.m_nSubGraphSubType;

    if (CSubGraph.prototype.SetPropertyInfo.call(this, SubGraphPropertyInfo, bSetup) === false)
        return false;

    this.m_VolumeBarTypeInfo.SetPropertyInfo(SubGraphPropertyInfo.m_VolumeBarTypeInfo, bSetup);
    this.m_VolumeLineTypeInfo.SetPropertyInfo(SubGraphPropertyInfo.m_VolumeLineTypeInfo, bSetup);

    if (bChangeSubGraphSubType)
        this.CreateDrawer();
    else
        this.SetPropertyInfoToDrawer();

    return true;
}

CVolumeSubGraph.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {

    this.m_Drawer.ExtractYScaleMinMax(rXScaleMng, SubGraphMinMaxInfo, bFullScan);
}

CVolumeSubGraph.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {

    return this.m_Drawer.FindRQGraphDataPerXScaleMng(X, Y, rRQPackets, rXScaleMng, rectGraphRegion);
}
CVolumeSubGraph.prototype.GetRQGraphFindDataPerXScaleMng = function (rRQPackets) {

    var rPacketItemData = rRQPackets.m_Packets[this.m_rPacketData.m_nPacketIndex];
    if (rPacketItemData === undefined) {
        return null;
    }

    var SubGraphFindData = this.m_SubGraphFindData4ToolTip;
    SubGraphFindData.m_SubGraphFindSubDataArray[0].m_strSubGraphTitle = this.m_strSubGraphTitle;
    SubGraphFindData.m_SubGraphFindSubDataArray[0].m_strSubGraphFindData = ConvertNumToDigitText(rPacketItemData.m_Data, rPacketItemData.m_rPacketData.m_nDec, 1, rPacketItemData.m_rPacketData.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

    if (rRQPackets.m_rPrevRQPacketsItem !== null) {
        var rPrevPacketItemData = rRQPackets.m_rPrevRQPacketsItem.m_Packets[this.m_rPacketData.m_nPacketIndex];
        if (rPrevPacketItemData !== undefined) {
            ////test
            //SubGraphFindData.m_SubGraphFindSubDataArray[0].m_strSubGraphFindSubData = ConvertNumToDigitText(((rPacketItemData.m_Data - rPrevPacketItemData.m_Data) / rPrevPacketItemData.m_Data * 100), 10, 1, -2, -1, this.m_rGlobalProperty.m_bShowThousandComma);
        }
    }

    return SubGraphFindData;
}
CVolumeSubGraph.prototype.InitRendering = function () {

    this.m_ViewLatestData = null;
    this.m_ViewPrevData = null;
    this.m_clrViewLatestData = null;

    var bLog = this.GetLog();
    var bInvert = this.GetInvert();
    if (bLog === true) {

        this.m_yMin = Log(this.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit);
        this.m_yMax = Log(this.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit);
    }
    else {

	    this.m_yMin = this.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit;
    	this.m_yMax = this.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit;
    }
    this.m_yDiff = this.m_yMax - this.m_yMin;

    var rectGraphRegion = this.m_Graph.m_rBlock.m_rectGraphRegion;
    this.m_yZeroPos = rectGraphRegion.m_nBottom - (0 - this.m_yMin) / this.m_yDiff * rectGraphRegion.Height();
    if (bInvert === true)
        this.m_yZeroPos = rectGraphRegion.m_nBottom - this.m_yZeroPos + rectGraphRegion.m_nTop;

    this.m_PrevClose = null;

    this.m_bRenderingBreak = false;

    this.m_Drawer.InitRendering();
    
}
CVolumeSubGraph.prototype.AddSelectPosInfo = function () {
    this.m_Drawer.AddSelectPosInfo();
}
CVolumeSubGraph.prototype.RenderingInLoop = function (RenderingInfo) {

    this.m_Drawer.RenderingInLoop(RenderingInfo);
    
}

CVolumeSubGraph.prototype.Draw = function (DrawingInfo) {

    this.m_Drawer.Draw(DrawingInfo);
}
///////////////////////////////////////////////////////////////////////////////
//CDepthSubGraph(호가잔량 서브그래프)
///////////////////////////////////////////////////////////////////////////////
//호가잔량 깊이차트 설정정보
export function CHogaDepthTypeInfo() {
    
    this.m_clrBuyRange = "#1155CC";//매수호가 영역색
    this.m_clrSellRange = "#CC0000";//매도호가 영역색
    this.m_clrBuyLine = "#1155CC";//매수호가 라인색
    this.m_clrSellLine = "#CC0000";//매도호가 라인색

    this.m_strKeyOfClrBuyRange = "clrBuyRange";
    this.m_strKeyOfClrSellRange = "clrSellRange";
    this.m_strKeyOfClrBuyLine = "clrBuyLine";
    this.m_strKeyOfClrSellLine = "clrSellLine";    
}
CHogaDepthTypeInfo.prototype.ChangeLang = function(){

}
CHogaDepthTypeInfo.prototype.SetClrBuyRange = function (clrBuyRange) {

    this.m_strKeyOfClrBuyRange = null;
    this.m_clrBuyRange = clrBuyRange;
}
CHogaDepthTypeInfo.prototype.SetClrSellRange = function (clrSellRange) {

    this.m_strKeyOfClrSellRange = null;
    this.m_clrSellRange = clrSellRange;
}
CHogaDepthTypeInfo.prototype.SetClrBuyLine = function (clrBuyLine) {

    this.m_strKeyOfClrBuyLine = null;
    this.m_clrBuyLine = clrBuyLine;
}
CHogaDepthTypeInfo.prototype.SetClrSellLine = function (clrSellLine) {

    this.m_strKeyOfClrSellLine = null;
    this.m_clrSellLine = clrSellLine;
}
CHogaDepthTypeInfo.prototype.SetPropertyInfo = function (rSrcHogaDepthTypeInfo, bSetup) {

    if (rSrcHogaDepthTypeInfo === undefined)
        return false;

    this.m_clrBuyRange = rSrcHogaDepthTypeInfo.m_clrBuyRange;//매수호가 영역색
    this.m_clrSellRange = rSrcHogaDepthTypeInfo.m_clrSellRange ;//매도호가 영역색
    this.m_clrBuyLine = rSrcHogaDepthTypeInfo.m_clrBuyLine;//매수호가 라인색
    this.m_clrSellLine = rSrcHogaDepthTypeInfo.m_clrSellLine;//매도호가 라인색

    this.m_strKeyOfClrBuyRange = rSrcHogaDepthTypeInfo.m_strKeyOfClrBuyRange;
    this.m_strKeyOfClrSellRange = rSrcHogaDepthTypeInfo.m_strKeyOfClrSellRange;
    this.m_strKeyOfClrBuyLine = rSrcHogaDepthTypeInfo.m_strKeyOfClrBuyLine;
    this.m_strKeyOfClrSellLine = rSrcHogaDepthTypeInfo.m_strKeyOfClrSellLine;
    
    return true;
}
CHogaDepthTypeInfo.prototype.Copy = function (rCopyHogaRestDepthTypeInfo) {

    if (rCopyHogaRestDepthTypeInfo === undefined)
        rCopyHogaRestDepthTypeInfo = new CHogaDepthTypeInfo();

    rCopyHogaRestDepthTypeInfo.m_clrBuyRange = this.m_clrBuyRange ;//매수호가 영역색
    rCopyHogaRestDepthTypeInfo.m_clrSellRange = this.m_clrSellRange;//매도호가 영역색
    rCopyHogaRestDepthTypeInfo.m_clrBuyLine = this.m_clrBuyLine ;//매수호가 라인색
    rCopyHogaRestDepthTypeInfo.m_clrSellLine = this.m_clrSellLine;//매도호가 라인색

    rCopyHogaRestDepthTypeInfo.m_strKeyOfClrBuyRange = this.m_strKeyOfClrBuyRange;
    rCopyHogaRestDepthTypeInfo.m_strKeyOfClrSellRange = this.m_strKeyOfClrSellRange;
    rCopyHogaRestDepthTypeInfo.m_strKeyOfClrBuyLine = this.m_strKeyOfClrBuyLine;
    rCopyHogaRestDepthTypeInfo.m_strKeyOfClrSellLine = this.m_strKeyOfClrSellLine;

    return rCopyHogaRestDepthTypeInfo;
}

////////////////////////////////////////////////////////////////////////////
//CHogaDepthSubGraphPropertyInfo
export function CHogaDepthSubGraphPropertyInfo() {

    CSubGraphPropertyInfo.call(this);
    
	//서브그래프 타입
    this.m_nSubGraphType = HOGADEPTH_SUBGRAPH_TYPE;
    this.m_nSubGraphSubType = HOGADEPTH_SUBGRAPH_DEPTH_TYPE;//Type에 따른 세부 타입 지정 필요시 사용

    this.m_HogaDepthTypeInfo = new CHogaDepthTypeInfo();    
}
CHogaDepthSubGraphPropertyInfo.prototype = new CSubGraphPropertyInfo();
CHogaDepthSubGraphPropertyInfo.prototype.constructor = CHogaDepthSubGraphPropertyInfo;

CHogaDepthSubGraphPropertyInfo.prototype.Copy = function ( rCopySubGraph )
{
    if (rCopySubGraph === undefined )
        rCopySubGraph = new CHogaDepthSubGraphPropertyInfo();

    rCopySubGraph = CSubGraphPropertyInfo.prototype.Copy.call(this, rCopySubGraph );
    rCopySubGraph.m_HogaDepthTypeInfo = this.m_HogaDepthTypeInfo.Copy();
    
    return rCopySubGraph;
}

CHogaDepthSubGraphPropertyInfo.prototype.SetPropertyInfo = function (rSubGraphPropertyInfo, bSetup) {
    
    if (!CSubGraphPropertyInfo.prototype.SetPropertyInfo.call(this, rSubGraphPropertyInfo, bSetup))
        return false;

    this.m_HogaDepthTypeInfo.SetPropertyInfo(rSubGraphPropertyInfo.m_HogaDepthTypeInfo);    

    return true;
}
///////////////////////////////////////////////////////////////////////////////
//증권용가격차트에서 사용되는 막대바 서브그래프(시,고,저,종 패킷의 값 비교기능 포함)
export function CHogaDepthSubGraph(Graph, nSubGraphSubType) {

    CSubGraph.call(this, Graph);

    this.m_SubGraphFindData4ToolTip.m_SubGraphFindSubDataArray[1] = new CSubGraphFindSubData();//수량
    this.m_SubGraphFindData4ToolTip.m_SubGraphFindSubDataArray[2] = new CSubGraphFindSubData();//금액

    this.m_nSubGraphType = HOGADEPTH_SUBGRAPH_TYPE;
    this.m_nSubGraphSubType = nSubGraphSubType ? nSubGraphSubType : HOGADEPTH_SUBGRAPH_DEPTH_TYPE;//Type에 따른 세부 타입 지정 필요시 사용

    this.m_HogaDepthTypeInfo = new CHogaDepthTypeInfo();
    
    this.m_rSellFlagPacketData = null;
    this.m_rHogaAmountPacketData = null;
    this.m_strSubGraphSubTitle = null;
    this.m_strSubGraphSubTitleLangKey = null;

    this.m_yZeroPos = null;
    this.m_Drawer = null;
    this.CreateDrawer();
}
CHogaDepthSubGraph.prototype = new CSubGraph();
CHogaDepthSubGraph.prototype.constructor = CHogaDepthSubGraph;

CHogaDepthSubGraph.prototype.ChangeLang = function(){

    CSubGraph.prototype.ChangeLang.call(this);

    if(this.m_strSubGraphSubTitleLangKey && this.m_strSubGraphSubTitleLangKey.length > 0)
        this.m_strSubGraphSubTitle = t(this.m_strSubGraphSubTitleLangKey);

    if(this.m_HogaDepthTypeInfo)
        this.m_HogaDepthTypeInfo.ChangeLang();    
}
CHogaDepthSubGraph.prototype.CreateDrawer = function () {

    switch (this.m_nSubGraphSubType) {

        case HOGADEPTH_SUBGRAPH_DEPTH_TYPE:
            this.m_Drawer = new CHogaDepthDrawer(this);
            return true;
        default:
            this.m_Drawer = new CHogaDepthDrawer(this);
            return true;
    }
}
CHogaDepthSubGraph.prototype.SetPropertyInfoToDrawer = function(){

    switch (this.m_nSubGraphSubType) {

        case HOGADEPTH_SUBGRAPH_DEPTH_TYPE:
            this.m_Drawer.m_rPropertyInfo = this.m_HogaDepthTypeInfo;
            return true;
        default:            
            this.m_Drawer.m_rPropertyInfo = this.m_HogaDepthTypeInfo;
            return true;
    }
}
CHogaDepthSubGraph.prototype.GetPropertyInfo = function (SubGraphPropertyInfo) {

    if (SubGraphPropertyInfo === undefined)
        SubGraphPropertyInfo = new CHogaDepthSubGraphPropertyInfo();

    CSubGraph.prototype.GetPropertyInfo.call(this, SubGraphPropertyInfo);

    SubGraphPropertyInfo.m_HogaDepthTypeInfo = this.m_HogaDepthTypeInfo;    

    return SubGraphPropertyInfo;
}
CHogaDepthSubGraph.prototype.SetPropertyInfo = function (SubGraphPropertyInfo, bSetup) {

    if (SubGraphPropertyInfo === undefined)
        return false;

    var bChangeSubGraphSubType = this.m_nSubGraphSubType !== SubGraphPropertyInfo.m_nSubGraphSubType;

    if (CSubGraph.prototype.SetPropertyInfo.call(this, SubGraphPropertyInfo, bSetup) === false)
        return false;

    this.m_HogaDepthTypeInfo.SetPropertyInfo(SubGraphPropertyInfo.m_HogaDepthTypeInfo, bSetup);    

    if (bChangeSubGraphSubType)
        this.CreateDrawer();
    else
        this.SetPropertyInfoToDrawer();

    return true;
}

CHogaDepthSubGraph.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {

    this.m_Drawer.ExtractYScaleMinMax(rXScaleMng, SubGraphMinMaxInfo, bFullScan);    
}

CHogaDepthSubGraph.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {

    return this.m_Drawer.FindRQGraphDataPerXScaleMng(X, Y, rRQPackets, rXScaleMng, rectGraphRegion);    
}
CHogaDepthSubGraph.prototype.GetRQGraphFindDataPerXScaleMng = function (rRQPackets) {

    var rPacketItemData = rRQPackets.m_Packets[this.m_rPacketData.m_nPacketIndex];
    if (rPacketItemData === undefined) {
        return null;
    }
    
    var SubGraphFindData = this.m_SubGraphFindData4ToolTip;    

    //가격
    var rXPacketItemData = rRQPackets.m_rXScalePacketData;    
    SubGraphFindData.m_SubGraphFindSubDataArray[0].m_strSubGraphTitle = this.m_strPriceTitle;
    SubGraphFindData.m_SubGraphFindSubDataArray[0].m_strSubGraphFindData = ConvertNumToDigitText(rXPacketItemData.m_Data, rXPacketItemData.m_rPacketData.m_nDec, 1, rXPacketItemData.m_rPacketData.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

    //수량
    SubGraphFindData.m_SubGraphFindSubDataArray[1].m_strSubGraphTitle = this.m_strSubGraphTitle;
    SubGraphFindData.m_SubGraphFindSubDataArray[1].m_strSubGraphFindData = ConvertNumToDigitText(rPacketItemData.m_Data, rPacketItemData.m_rPacketData.m_nDec, 1, rPacketItemData.m_rPacketData.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

    //금액
    var rHogaAmountPacketItemData = rRQPackets.m_Packets[this.m_rHogaAmountPacketData.m_nPacketIndex];    
    SubGraphFindData.m_SubGraphFindSubDataArray[2].m_strSubGraphTitle = this.m_strSubGraphSubTitle;
    SubGraphFindData.m_SubGraphFindSubDataArray[2].m_strSubGraphFindData = ConvertNumToDigitText(rHogaAmountPacketItemData.m_Data, rHogaAmountPacketItemData.m_rPacketData.m_nDec, 1, rHogaAmountPacketItemData.m_rPacketData.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

    if (rRQPackets.m_rPrevRQPacketsItem !== null) {
        var rPrevPacketItemData = rRQPackets.m_rPrevRQPacketsItem.m_Packets[this.m_rPacketData.m_nPacketIndex];
        if (rPrevPacketItemData !== undefined) {
            ////test
            //SubGraphFindData.m_SubGraphFindSubDataArray[0].m_strSubGraphFindSubData = ConvertNumToDigitText(((rPacketItemData.m_Data - rPrevPacketItemData.m_Data) / rPrevPacketItemData.m_Data * 100), 10, 1, -2, -1, this.m_rGlobalProperty.m_bShowThousandComma);
        }
    }

    return SubGraphFindData;
}
CHogaDepthSubGraph.prototype.InitRendering = function () {

    this.m_ViewLatestData = null;
    this.m_ViewPrevData = null;
    this.m_clrViewLatestData = null;

    var bLog = this.GetLog();
    var bInvert = this.GetInvert();
    if (bLog === true) {

        this.m_yMin = Log(this.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit);
        this.m_yMax = Log(this.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit);
    }
    else {

	    this.m_yMin = this.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit;
    	this.m_yMax = this.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit;
    }
    this.m_yDiff = this.m_yMax - this.m_yMin;

    var rectGraphRegion = this.m_Graph.m_rBlock.m_rectGraphRegion;
    this.m_yZeroPos = rectGraphRegion.m_nBottom - (0 - this.m_yMin) / this.m_yDiff * rectGraphRegion.Height();
    if (bInvert === true)
        this.m_yZeroPos = rectGraphRegion.m_nBottom - this.m_yZeroPos + rectGraphRegion.m_nTop;

    this.m_bRenderingBreak = false;

    this.m_Drawer.InitRendering();    
}
CHogaDepthSubGraph.prototype.AddSelectPosInfo = function () {
    this.m_Drawer.AddSelectPosInfo();    
}
CHogaDepthSubGraph.prototype.RenderingInLoop = function (RenderingInfo) {

    this.m_Drawer.RenderingInLoop(RenderingInfo);    
}
CHogaDepthSubGraph.prototype.Draw = function (DrawingInfo) {

    this.m_Drawer.Draw(DrawingInfo);    
}
///////////////////////////////////////////////////////////////////////////////
//CHogaDepthDrawer
function CHogaDepthDrawer(rSubGraph) {

    if (rSubGraph === undefined)
        return;

    CBaseDrawer.call(this, rSubGraph);

    this.m_rPropertyInfo = this.m_rSubGraph.m_HogaDepthTypeInfo;

    this.m_BongTypeInfo = [];
}
CHogaDepthDrawer.prototype = new CBaseDrawer();
CHogaDepthDrawer.prototype.constructor = CHogaDepthDrawer;

CHogaDepthDrawer.prototype.InitRendering = function () {

    this.m_rPrevBongPosInfo = null;

    this.m_SignBongInfoArray.length = 0;

    this.m_BongTypeInfo.length = 0;    

    //매수호가 영역
    this.m_BongTypeInfo[0] = new CBarInfo();
    this.m_BongTypeInfo[0].m_clrBar = this.m_rPropertyInfo.m_clrBuyRange;
    this.m_BongTypeInfo[0].m_clrLine = this.m_rPropertyInfo.m_clrBuyLine;    
    
    //매도호가 영역
    this.m_BongTypeInfo[1] = new CBarInfo();
    this.m_BongTypeInfo[1].m_clrBar = this.m_rPropertyInfo.m_clrSellRange;
    this.m_BongTypeInfo[1].m_clrLine = this.m_rPropertyInfo.m_clrSellLine;    
}
CHogaDepthDrawer.prototype.RenderingInLoop = function (RenderingInfo) {

    var rRQPackets = this.m_rSubGraph.m_rRQInCol.m_rRQPackets;
    var rPrevRQPackets = this.m_rSubGraph.m_rRQInCol.m_rPrevRQPackets;

    var rectGraphRegion = this.m_rSubGraph.m_Graph.m_rBlock.m_rectGraphRegion;
    var nGraphRegionHeight = rectGraphRegion.Height();
    
    var BarTypeInfo = this.m_BongTypeInfo;
    
    var bLog = this.m_rSubGraph.GetLog();
    var bInvert = this.m_rSubGraph.GetInvert();
    var Data = null;

    var yMin = this.m_rSubGraph.m_yMin;
    var yMax = this.m_rSubGraph.m_yMax;
    var yDiff = this.m_rSubGraph.m_yDiff;
    var yZeroPos = this.m_rSubGraph.m_yZeroPos;

    var rPrevRQPacketItemData = null;    

    /////////////////////////////////////////////////////////////////////////////////////////////////////////
    var rPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rPacketData.m_nPacketIndex];
    if (!rPacketItemData)
        return;

    var rXPacketItemData = rRQPackets.m_rXScalePacketData;
    if(!rXPacketItemData || rXPacketItemData.m_Data == 0.0)
        return;

    Data = bLog ? Log(rPacketItemData.m_Data) : rPacketItemData.m_Data;

    var yPos = rectGraphRegion.m_nBottom - (Data - yMin) / yDiff * nGraphRegionHeight;

    if (bInvert === true)
        yPos = rectGraphRegion.m_nBottom - yPos + rectGraphRegion.m_nTop;

    var BarPosInfo = new CBarPosInfo();

    BarPosInfo.m_BongXPosInfo = this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray[this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray.length - 1];

    BarPosInfo.m_Top = yPos;
    BarPosInfo.m_Bottom = yZeroPos;    

    ////////////////////////////////////////////////////////////////////////
    //y축 보이는 봉중에서 최신 종가 및 등락율 보여주는 기능 처리를 위해 추가
    //if (this.m_rSubGraph.m_ViewLatestData)
    //    this.m_rSubGraph.m_ViewPrevData = this.m_rSubGraph.m_ViewLatestData;
    //this.m_rSubGraph.m_ViewLatestData = rPacketItemData.m_Data;
    ////////////////////////////////////////////////////////////////////////
    
    var rSellFlagPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rSellFlagPacketData.m_nPacketIndex];
    if (!rSellFlagPacketItemData)
        return;

    //0보다 큰 경우 상승
    if (rSellFlagPacketItemData.m_Data > 0) {//매도호가 영역
        BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;        
    }
    else {//매수호가 영역
        BarTypeInfo[0].m_BarPosInfoArray[BarTypeInfo[0].m_BarPosInfoArray.length] = BarPosInfo;        
    }
}

//가격 서브그래프 그리기 처리(봉차트)
CHogaDepthDrawer.prototype.Draw = function (DrawingInfo) {

    /////////////////////////////////////////
    //선택그래프 표시기능
    var SignBongInfoArray = this.m_SignBongInfoArray;
    var nStartSignXPos = this.m_rSubGraph.m_rRQInCol.m_nStartSignXPos;
    /////////////////////////////////////////

    var BarTypeInfo = this.m_BongTypeInfo;

    //최소 봉 두께
    var BongMinWidth = this.m_rSubGraph.m_rRQInCol.m_rChartBlockCol.m_BongMinWidth;

    {
        //////////////////////////////////////////////////////////////////
        //BarType은 다르지만 색상값이 같은 경우 하나로 묶는다( beginPath 호출횟수를 줄여 성능향상 목적)
        var i, j;
        var ColorArray = [];
        var ColorLineArray = [];
        var nLength = BarTypeInfo.length;
        if(nLength <= 0)
            return;
        
        ColorArray[ColorArray.length] = BarTypeInfo[0].m_clrBar;
        ColorLineArray[ColorLineArray.length] = BarTypeInfo[0].m_clrLine;
        for (i = 1; i < nLength; i++) {
            
            var ColorArrayLength = ColorArray.length;
            for (j = 0; j < ColorArrayLength; j++) {
                if (BarTypeInfo[i].m_clrBar === ColorArray[j])
                    break;
            }

            if (j === ColorArrayLength)
            {
                ColorArray[j] = BarTypeInfo[i].m_clrBar;            
                ColorLineArray[j] = BarTypeInfo[i].m_clrLine;
            }
        }
        //////////////////////////////////////////////////////////////////

        var BarPosInfo = null;
        var YPos, YZero, XPos;
        var XStartPos, YStartPos;

        var ColorArrayLength = ColorArray.length;

        DrawingInfo.m_Context.globalAlpha = 0.4;//내부색 채울 때 반투명처리
        for (i = 0; i < ColorArrayLength; i++) {

            DrawingInfo.m_Context.strokeStyle = ColorArray[i];
            DrawingInfo.m_Context.fillStyle = ColorArray[i];
            DrawingInfo.m_Context.lineWidth = 1;

            for (j = 0; j < nLength; j++) {

                if (ColorArray[i] === BarTypeInfo[j].m_clrBar) {

                    var BarItemIndex, BarItemLength = BarTypeInfo[j].m_BarPosInfoArray.length;
                    if(BarItemLength <= 0)
                        continue;

                    DrawingInfo.m_Context.beginPath();

                    BarPosInfo = BarTypeInfo[j].m_BarPosInfoArray[0];
                    XStartPos = BarPosInfo.m_BongXPosInfo.m_OpenXPos;
                    YStartPos = BarPosInfo.m_Top;
                    YZero = BarPosInfo.m_Bottom;
                    DrawingInfo.m_Context.moveTo(XStartPos, YStartPos);
                    
                    XPos = BarPosInfo.m_BongXPosInfo.m_CloseXPos;                        
                    DrawingInfo.m_Context.lineTo(XPos, YStartPos);

                    for (BarItemIndex = 1; BarItemIndex < BarItemLength; BarItemIndex++) {

                        BarPosInfo = BarTypeInfo[j].m_BarPosInfoArray[BarItemIndex];
                        XPos = BarPosInfo.m_BongXPosInfo.m_OpenXPos;
                        YPos = BarPosInfo.m_Top;
                        YZero = BarPosInfo.m_Bottom;                        
                        DrawingInfo.m_Context.lineTo(XPos, YPos);

                        XPos = BarPosInfo.m_BongXPosInfo.m_CloseXPos;
                        DrawingInfo.m_Context.lineTo(XPos, YPos);
                    }

                    DrawingInfo.m_Context.lineTo(XPos, YZero);
                    DrawingInfo.m_Context.lineTo(XStartPos, YZero);
                    DrawingInfo.m_Context.lineTo(XStartPos, YStartPos);
                    DrawingInfo.m_Context.fill();

                    DrawingInfo.m_Context.closePath();
                    
                    break;
                }
            }
        }
        DrawingInfo.m_Context.globalAlpha = 1.0;

        for (i = 0; i < ColorArrayLength; i++) {

            DrawingInfo.m_Context.beginPath();
            DrawingInfo.m_Context.strokeStyle = ColorLineArray[i];            
            DrawingInfo.m_Context.lineWidth = 2;

            for (j = 0; j < nLength; j++) {

                if (ColorArray[i] === BarTypeInfo[j].m_clrBar) {

                    var BarItemIndex, BarItemLength = BarTypeInfo[j].m_BarPosInfoArray.length;
                    if(BarItemLength <= 0)
                        continue;
                        
                    BarPosInfo = BarTypeInfo[j].m_BarPosInfoArray[0];
                    XStartPos = BarPosInfo.m_BongXPosInfo.m_OpenXPos;
                    YStartPos = BarPosInfo.m_Top;
                    DrawingInfo.m_Context.moveTo(XStartPos, YStartPos);

                    XPos = BarPosInfo.m_BongXPosInfo.m_CloseXPos;                        
                    DrawingInfo.m_Context.lineTo(XPos, YStartPos);
                    for (BarItemIndex = 1; BarItemIndex < BarItemLength; BarItemIndex++) {

                        BarPosInfo = BarTypeInfo[j].m_BarPosInfoArray[BarItemIndex];
                        XPos = BarPosInfo.m_BongXPosInfo.m_OpenXPos;
                        YPos = BarPosInfo.m_Top;
                        DrawingInfo.m_Context.lineTo(XPos, YPos);

                        XPos = BarPosInfo.m_BongXPosInfo.m_CloseXPos;
                        DrawingInfo.m_Context.lineTo(XPos, YPos);
                    }
                    DrawingInfo.m_Context.stroke();                    
                    
                    break;
                }
            }
            DrawingInfo.m_Context.closePath();
        }
    }
}

CHogaDepthDrawer.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {

    this.m_rSubGraph.m_MinMaxInfo.Init();

    var rPacketData = this.m_rSubGraph.m_rPacketData;

    gMinMaxInfo.Init();
    var MinMaxInfo = gMinMaxInfo;
    if (rXScaleMng.ExtractMinMaxValue(this.m_rSubGraph.m_rRQSet.m_strRQ, rPacketData.m_strPacketName, MinMaxInfo, bFullScan)) {
        //양수나 음수 한쪽방향으로만 존재하므로 강제로 0범위를 추가한다
        if (MinMaxInfo.m_Max * MinMaxInfo.m_Min > 0) {
            if (MinMaxInfo.m_Max < 0)
                MinMaxInfo.m_Max = 0;
            else
                MinMaxInfo.m_Min = 0;

            SubGraphMinMaxInfo.m_bZeroBaseLine = true;
        }
        //max > 0 and min < 0 인 경우이므로 중간에 0이 포함되어 있다.

        if (this.m_rSubGraph.m_MinMaxInfo.m_Max === null || this.m_rSubGraph.m_MinMaxInfo.m_Max < MinMaxInfo.m_Max)
            this.m_rSubGraph.m_MinMaxInfo.m_Max = MinMaxInfo.m_Max;

        if (this.m_rSubGraph.m_MinMaxInfo.m_Min === null || this.m_rSubGraph.m_MinMaxInfo.m_Min > MinMaxInfo.m_Min)
            this.m_rSubGraph.m_MinMaxInfo.m_Min = MinMaxInfo.m_Min;

        this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex = MinMaxInfo.m_nStartIndex;
        this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex = MinMaxInfo.m_nEndIndex;
    }

    if (SubGraphMinMaxInfo.m_Max === null)
        SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;
    else if (SubGraphMinMaxInfo.m_Max < this.m_rSubGraph.m_MinMaxInfo.m_Max)
        SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;

    if (SubGraphMinMaxInfo.m_Min === null)
        SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;
    else if (SubGraphMinMaxInfo.m_Min > this.m_rSubGraph.m_MinMaxInfo.m_Min)
        SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;

    SubGraphMinMaxInfo.m_nStartIndex = this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex;
    SubGraphMinMaxInfo.m_nEndIndex = this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex;
}

CHogaDepthDrawer.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {

    return true;//기본적으로 X데이터만 있으면 보여진다    
}

///////////////////////////////////////////////////////////////////////////////
//X축 위치 저장 클래스
function CBongXPosInfo() {

    this.m_OpenXPos = -1;
    this.m_CloseXPos = -1;
    this.m_HighXPos = -1;
    this.m_LowXPos = -1;

    this.m_Width = null;
    this.m_LeftXPos = null;
    this.m_CenterXPos = null;

}

CBongXPosInfo.prototype.Init = function () {

    this.m_OpenXPos = -1;
    this.m_CloseXPos = -1;
    this.m_HighXPos = -1;
    this.m_LowXPos = -1;

    this.m_Width = null;
    this.m_LeftXPos = null;
    this.m_CenterXPos = null;

}
///////////////////////////////////////////////////////////////////////////////
//봉차트 그리기 위한 좌표저장 클래스
function CBongPosInfo() {

    this.m_BongXPosInfo = null;
    this.m_OpenYPos = -1;
    this.m_CloseYPos = -1;
    this.m_HighYPos = -1;
    this.m_LowYPos = -1;

    this.m_Width = null;
    
    /////////////////////////////////////////////
    this.m_BuySignalYPos = null;
    this.m_SellSignalYPos = null;
    
    this.m_SignalWidth = null;
    this.m_SignalLeftXPos = null;
    this.m_SignalRightXPos = null;

    this.m_nSignalType = null;
}
function CBongInfo() {
    this.m_clrBong = "#CC0000";//"#F52D49";
    this.m_bFill = true;
    this.m_BongPosInfoArray = [];
}
CBongInfo.prototype.init = function () {
    this.m_BongPosInfoArray.length = 0;
}
///////////////////////////////////////////////////////////////////////////////
//캔들차트 설정

// 차트유형 가격차트의 바타입 설정
function CPriceBarTypeInfo()
{
    this.m_clrUpturnPlus = "#CC0000";    // 상승양봉색상
    this.m_clrUpturnMinus = "#1155CC";   // 상승음봉색상
    this.m_clrDropPlus = "#CC0000";      // 하락양봉색상
    this.m_clrDropMinus = "#1155CC";     // 하락음봉색상
    this.m_clrGapMinus = "#CC0000";      // 갭음봉색상
    this.m_clrSteadyTone = "#c5c8cb";    // 보합색상

    this.m_strKeyOfClrUpturnPlus = "clrUpturnPlus";
    this.m_strKeyOfClrUpturnMinus = "clrUpturnMinus";
    this.m_strKeyOfClrDropPlus = "clrDropPlus";
    this.m_strKeyOfClrDropMinus = "clrDropMinus";
    this.m_strKeyOfClrGapMinus = "clrGapMinus";
    this.m_strKeyOfClrSteadyTone = "clrSteadyTone";

    this.m_bUseHLCType = false;
    this.m_bUseThinType = true;
    this.m_bSteadyClrFollowToUpDropClr = true;
}
CPriceBarTypeInfo.prototype.ChangeLang = function(){

}
CPriceBarTypeInfo.prototype.SetClrUpturnPlus = function ( clrUpturnPlus )
{
    this.m_strKeyOfClrUpturnPlus = null;
    this.m_clrUpturnPlus = clrUpturnPlus;
}
CPriceBarTypeInfo.prototype.SetClrUpturnMinus = function ( clrUpturnMinus )
{
    this.m_strKeyOfClrUpturnMinus = null;
    this.m_clrUpturnMinus = clrUpturnMinus;
}
CPriceBarTypeInfo.prototype.SetClrDropPlus = function ( clrDropPlus )
{
    this.m_strKeyOfClrDropPlus = null;
    this.m_clrDropPlus = clrDropPlus;
}
CPriceBarTypeInfo.prototype.SetClrDropMinus = function ( clrDropMinus )
{
    this.m_strKeyOfClrDropMinus = null;
    this.m_clrDropMinus = clrDropMinus;
}
CPriceBarTypeInfo.prototype.SetClrGapMinus = function ( clrGapMinus )
{
    this.m_strKeyOfClrGapMinus = null;
    this.m_clrGapMinus = clrGapMinus;
}
CPriceBarTypeInfo.prototype.SetClrSteadyTone = function ( clrSteadyTone )
{
    this.m_strKeyOfClrSteadyTone = null;
    this.m_clrSteadyTone = clrSteadyTone;
}

CPriceBarTypeInfo.prototype.SetPropertyInfo = function (rSrcBarTypeInfo, bSetup) {

    if (rSrcBarTypeInfo === undefined)
        return false;

    this.m_clrUpturnPlus = rSrcBarTypeInfo.m_clrUpturnPlus;
    this.m_clrUpturnMinus = rSrcBarTypeInfo.m_clrUpturnMinus;
    this.m_clrDropPlus = rSrcBarTypeInfo.m_clrDropPlus;
    this.m_clrDropMinus = rSrcBarTypeInfo.m_clrDropMinus;
    this.m_clrGapMinus = rSrcBarTypeInfo.m_clrGapMinus;
    this.m_clrSteadyTone = rSrcBarTypeInfo.m_clrSteadyTone;

    this.m_bUseHLCType = rSrcBarTypeInfo.m_bUseHLCType;
    this.m_bUseThinType = rSrcBarTypeInfo.m_bUseThinType;
    this.m_bSteadyClrFollowToUpDropClr = rSrcBarTypeInfo.m_bSteadyClrFollowToUpDropClr;

    this.m_strKeyOfClrUpturnPlus = rSrcBarTypeInfo.m_strKeyOfClrUpturnPlus;
    this.m_strKeyOfClrUpturnMinus = rSrcBarTypeInfo.m_strKeyOfClrUpturnMinus;
    this.m_strKeyOfClrDropPlus = rSrcBarTypeInfo.m_strKeyOfClrDropPlus;
    this.m_strKeyOfClrDropMinus = rSrcBarTypeInfo.m_strKeyOfClrDropMinus;
    this.m_strKeyOfClrGapMinus = rSrcBarTypeInfo.m_strKeyOfClrGapMinus;
    this.m_strKeyOfClrSteadyTone = rSrcBarTypeInfo.m_strKeyOfClrSteadyTone;

    return true;
}

CPriceBarTypeInfo.prototype.Copy = function ( rCopyBarTypeInfo )
{
    if( rCopyBarTypeInfo === undefined )
        rCopyBarTypeInfo = new CPriceBarTypeInfo();

    rCopyBarTypeInfo.m_clrUpturnPlus = this.m_clrUpturnPlus;
    rCopyBarTypeInfo.m_clrUpturnMinus = this.m_clrUpturnMinus;
    rCopyBarTypeInfo.m_clrDropPlus = this.m_clrDropPlus;
    rCopyBarTypeInfo.m_clrDropMinus = this.m_clrDropMinus;
    rCopyBarTypeInfo.m_clrGapMinus = this.m_clrGapMinus;
    rCopyBarTypeInfo.m_clrSteadyTone = this.m_clrSteadyTone;

    rCopyBarTypeInfo.m_bUseHLCType = this.m_bUseHLCType;
    rCopyBarTypeInfo.m_bUseThinType = this.m_bUseThinType;
    rCopyBarTypeInfo.m_bSteadyClrFollowToUpDropClr = this.m_bSteadyClrFollowToUpDropClr;
    
    rCopyBarTypeInfo.m_strKeyOfClrUpturnPlus = this.m_strKeyOfClrUpturnPlus;
    rCopyBarTypeInfo.m_strKeyOfClrUpturnMinus = this.m_strKeyOfClrUpturnMinus;
    rCopyBarTypeInfo.m_strKeyOfClrDropPlus = this.m_strKeyOfClrDropPlus;
    rCopyBarTypeInfo.m_strKeyOfClrDropMinus = this.m_strKeyOfClrDropMinus;
    rCopyBarTypeInfo.m_strKeyOfClrGapMinus = this.m_strKeyOfClrGapMinus;
    rCopyBarTypeInfo.m_strKeyOfClrSteadyTone = this.m_strKeyOfClrSteadyTone;

    return rCopyBarTypeInfo;
}

/////////////////////////////////////////////////////////////////////////////////
//가격라인 차트
function CPriceLineTypeInfo()
{
    this.m_clrLine = "#CC0000";
    this.m_strKeyOfClrLine = "clrPriceLine";

    this.m_DType = PRICE_TYPE_CLOSE_INDEX;  // 라인기준 DataType
    this.m_nThickness = 1;
    this.m_nLineType = PS_SOLID;
}
CPriceLineTypeInfo.prototype.ChangeLang = function(){

}
CPriceLineTypeInfo.prototype.SetClrLine = function ( clrPriceLine )
{
    this.m_strKeyOfClrLine = null;
    this.m_clrLine = clrPriceLine;
}

CPriceLineTypeInfo.prototype.SetPropertyInfo = function (rSrcTypeInfo, bSetup) {

    if (rSrcTypeInfo === undefined)
        return false;

    this.m_clrLine = rSrcTypeInfo.m_clrLine;
    this.m_strKeyOfClrLine = rSrcTypeInfo.m_strKeyOfClrLine;

    this.m_DType = rSrcTypeInfo.m_DType;
    this.m_nThickness = rSrcTypeInfo.m_nThickness;
    this.m_nLineType = rSrcTypeInfo.m_nLineType;

    return true;
}

CPriceLineTypeInfo.prototype.Copy = function ( rCopyTypeInfo )
{
    if (rCopyTypeInfo === undefined )
        rCopyTypeInfo = new CPriceLineTypeInfo();

    rCopyTypeInfo.m_clrLine = this.m_clrLine;
    rCopyTypeInfo.m_strKeyOfClrLine = this.m_strKeyOfClrLine;

    rCopyTypeInfo.m_DType = this.m_DType;
    rCopyTypeInfo.m_nThickness = this.m_nThickness;
    rCopyTypeInfo.m_nLineType = this.m_nLineType;

    return rCopyTypeInfo;
}

/////////////////////////////////////////////////
//P&F 설정
function CPricePAndFTypeInfo()
{
    this.m_clrPAndFUp = "#CC0000";      // 상승색상
    this.m_clrPAndFDrop = "#0000CC";    // 하락색상

    this.m_strKeyOfClrPAndFUp = "clrPAndFUp";
    this.m_strKeyOfClrPAndFDrop = "clrPAndFDrop";

    this.m_DType = PRICE_TYPE_CLOSE_INDEX;
    this.m_nBoxSize = 3;
}
CPricePAndFTypeInfo.prototype.ChangeLang = function(){

}
CPricePAndFTypeInfo.prototype.SetClrPAndFUp = function ( clrPAndFUp )
{
    this.m_strKeyOfClrPAndFUp = null;
    this.m_clrPAndFUp = clrPAndFUp;
}
CPricePAndFTypeInfo.prototype.SetClrPAndFDrop = function ( clrPAndFDrop )
{
    this.m_strKeyOfClrPAndFDrop = null;
    this.m_clrPAndFDrop = clrPAndFDrop;
}

CPricePAndFTypeInfo.prototype.SetPropertyInfo = function (rSrcPAndFTypeInfo, bSetup) {

    if (rSrcPAndFTypeInfo === undefined)
        return false;

    this.m_clrPAndFUp = rSrcPAndFTypeInfo.m_clrPAndFUp;
    this.m_clrPAndFDrop = rSrcPAndFTypeInfo.m_clrPAndFDrop;

    this.m_DType = rSrcPAndFTypeInfo.m_DType;
    this.m_nBoxSize = rSrcPAndFTypeInfo.m_nBoxSize;

    this.m_strKeyOfClrPAndFUp = rSrcPAndFTypeInfo.m_strKeyOfClrPAndFUp;
    this.m_strKeyOfClrPAndFDrop = rSrcPAndFTypeInfo.m_strKeyOfClrPAndFDrop;

    return true;
}

CPricePAndFTypeInfo.prototype.Copy = function ( rCopyPAndFTypeInfo )
{
    if( rCopyPAndFTypeInfo === undefined )
        rCopyPAndFTypeInfo = new CPricePAndFTypeInfo();

    rCopyPAndFTypeInfo.m_clrPAndFUp = this.m_clrPAndFUp;
    rCopyPAndFTypeInfo.m_clrPAndFDrop = this.m_clrPAndFDrop;

    rCopyPAndFTypeInfo.m_DType = this.m_DType;
    rCopyPAndFTypeInfo.m_nBoxSize = this.m_nBoxSize;
    
    rCopyPAndFTypeInfo.m_strKeyOfClrPAndFUp = this.m_strKeyOfClrPAndFUp;
    rCopyPAndFTypeInfo.m_strKeyOfClrPAndFDrop = this.m_strKeyOfClrPAndFDrop;

    return rCopyPAndFTypeInfo;
}

/////////////////////////////////////////////////
//삼선전환도 설정
function CPriceThreeLineBreakTypeInfo()
{
    this.m_clrThreeLineBreakUp = "#CC0000";     // 상승색상
    this.m_clrThreeLineBreakDrop = "#0000CC";       // 하락색상
    this.m_strKeyOfClrThreeLineBreakUp = "clrThreeLineBreakUp";
    this.m_strKeyOfClrThreeLineBreakDrop = "clrThreeLineBreakDrop";

    this.m_DType = PRICE_TYPE_CLOSE_INDEX;
    this.m_nBoxSize = 3;
}
CPriceThreeLineBreakTypeInfo.prototype.ChangeLang = function(){

}
CPriceThreeLineBreakTypeInfo.prototype.SetClrThreeLineBreakUp = function ( clrThreeLineBreakUp )
{
    this.m_strKeyOfClrThreeLineBreakUp = null;
    this.m_clrThreeLineBreakUp = clrThreeLineBreakUp;
}
CPriceThreeLineBreakTypeInfo.prototype.SetClrThreeLineBreakDrop = function ( clrThreeLineBreakDrop )
{
    this.m_strKeyOfClrThreeLineBreakDrop = null;
    this.m_clrThreeLineBreakDrop = clrThreeLineBreakDrop;
}

CPriceThreeLineBreakTypeInfo.prototype.SetPropertyInfo = function (rSrcThreeLineBreakTypeInfo, bSetup) {

    if (rSrcThreeLineBreakTypeInfo === undefined)
        return false;

    this.m_clrThreeLineBreakUp = rSrcThreeLineBreakTypeInfo.m_clrThreeLineBreakUp;
    this.m_clrThreeLineBreakDrop = rSrcThreeLineBreakTypeInfo.m_clrThreeLineBreakDrop;

    this.m_strKeyOfClrThreeLineBreakUp = rSrcThreeLineBreakTypeInfo.m_strKeyOfClrThreeLineBreakUp;
    this.m_strKeyOfClrThreeLineBreakDrop = rSrcThreeLineBreakTypeInfo.m_strKeyOfClrThreeLineBreakDrop;

    this.m_DType = rSrcThreeLineBreakTypeInfo.m_DType;
    this.m_nBoxSize = rSrcThreeLineBreakTypeInfo.m_nBoxSize;

    return true;
}
CPriceThreeLineBreakTypeInfo.prototype.Copy = function ( rCopyThreeLineBreakTypeInfo )
{
    if( rCopyThreeLineBreakTypeInfo === undefined )
        rCopyThreeLineBreakTypeInfo = new CPriceThreeLineBreakTypeInfo();

    rCopyThreeLineBreakTypeInfo.m_clrThreeLineBreakUp = this.m_clrThreeLineBreakUp;
    rCopyThreeLineBreakTypeInfo.m_clrThreeLineBreakDrop = this.m_clrThreeLineBreakDrop;

    rCopyThreeLineBreakTypeInfo.m_strKeyOfClrThreeLineBreakUp = this.m_strKeyOfClrThreeLineBreakUp;
    rCopyThreeLineBreakTypeInfo.m_strKeyOfClrThreeLineBreakDrop = this.m_strKeyOfClrThreeLineBreakDrop;

    rCopyThreeLineBreakTypeInfo.m_DType = this.m_DType;
    rCopyThreeLineBreakTypeInfo.m_nBoxSize = this.m_nBoxSize;

    return rCopyThreeLineBreakTypeInfo;
}

//캔들차트 설정
export function CPriceCandleTypeInfo() {
    
    this.m_clrUpturnPlus = "#CC0000";//"#F52D49";//상승양봉색상
    this.m_clrUpturnMinus = "#1155CC"; //"#0B7EFF";//상승음봉색상
    this.m_clrDropPlus = "#CC0000";//하락양봉색상
    this.m_clrDropMinus = "#1155CC";//"#0B7EFF";//하락음봉색상
    this.m_clrGapMinus = "#CC0000";//갭음봉색상
    this.m_clrSteadyTone = "#c5c8cb";//"#00ff00";//보합색상

	this.m_strKeyOfClrUpturnPlus = "clrUpturnPlus";
    this.m_strKeyOfClrUpturnMinus = "clrUpturnMinus";
    this.m_strKeyOfClrDropPlus = "clrDropPlus";
    this.m_strKeyOfClrDropMinus = "clrDropMinus";
    this.m_strKeyOfClrGapMinus = "clrGapMinus";
    this.m_strKeyOfClrSteadyTone = "clrSteadyTone";

    this.m_bFillUpturnPlus = true;//상승양봉채움
    this.m_bFillUpturnMinus = true;//상승음봉채움
    this.m_bFillDropPlus = true;//하락양봉채움
    this.m_bFillDropMinus = true;//하락음봉채움
    this.m_bFillGapMinus = true;//갭음봉채움
    this.m_bSteadyClrFollowToUpDropClr = true;//보합색상 상승양봉/하락음봉 색상따라가기 여부
}
CPriceCandleTypeInfo.prototype.ChangeLang = function(){

}
CPriceCandleTypeInfo.prototype.SetClrUpturnPlus = function ( clrUpturnPlus )
{
    this.m_strKeyOfClrUpturnPlus = null;
    this.m_clrUpturnPlus = clrUpturnPlus;
}
CPriceCandleTypeInfo.prototype.SetClrUpturnMinus = function ( clrUpturnMinus )
{
    this.m_strKeyOfClrUpturnMinus = null;
    this.m_clrUpturnMinus = clrUpturnMinus;
}
CPriceCandleTypeInfo.prototype.SetClrDropPlus = function ( clrDropPlus )
{
    this.m_strKeyOfClrDropPlus = null;
    this.m_clrDropPlus = clrDropPlus;
}
CPriceCandleTypeInfo.prototype.SetClrDropMinus = function ( clrDropMinus )
{
    this.m_strKeyOfClrDropMinus = null;
    this.m_clrDropMinus = clrDropMinus;
}
CPriceCandleTypeInfo.prototype.SetClrGapMinus = function ( clrGapMinus )
{
    this.m_strKeyOfClrGapMinus = null;
    this.m_clrGapMinus = clrGapMinus;
}
CPriceCandleTypeInfo.prototype.SetClrSteadyTone = function ( clrSteadyTone )
{
    this.m_strKeyOfClrSteadyTone = null;
    this.m_clrSteadyTone = clrSteadyTone;
}

CPriceCandleTypeInfo.prototype.SetPropertyInfo = function (rSrcPriceCandleInfo, bSetup) {

    if (rSrcPriceCandleInfo === undefined)
        return false;

    this.m_clrUpturnPlus = rSrcPriceCandleInfo.m_clrUpturnPlus;
    this.m_clrUpturnMinus = rSrcPriceCandleInfo.m_clrUpturnMinus;
    this.m_clrDropPlus = rSrcPriceCandleInfo.m_clrDropPlus;
    this.m_clrDropMinus = rSrcPriceCandleInfo.m_clrDropMinus;
    this.m_clrGapMinus = rSrcPriceCandleInfo.m_clrGapMinus;
    this.m_clrSteadyTone = rSrcPriceCandleInfo.m_clrSteadyTone;

    this.m_bFillUpturnPlus = rSrcPriceCandleInfo.m_bFillUpturnPlus;
    this.m_bFillUpturnMinus = rSrcPriceCandleInfo.m_bFillUpturnMinus;
    this.m_bFillDropPlus = rSrcPriceCandleInfo.m_bFillDropPlus;
    this.m_bFillDropMinus = rSrcPriceCandleInfo.m_bFillDropMinus;
    this.m_bFillGapMinus = rSrcPriceCandleInfo.m_bFillGapMinus;

    this.m_bSteadyClrFollowToUpDropClr = rSrcPriceCandleInfo.m_bSteadyClrFollowToUpDropClr;

    this.m_strKeyOfClrUpturnPlus = rSrcPriceCandleInfo.m_strKeyOfClrUpturnPlus;
    this.m_strKeyOfClrUpturnMinus = rSrcPriceCandleInfo.m_strKeyOfClrUpturnMinus;
    this.m_strKeyOfClrDropPlus = rSrcPriceCandleInfo.m_strKeyOfClrDropPlus;
    this.m_strKeyOfClrDropMinus = rSrcPriceCandleInfo.m_strKeyOfClrDropMinus;
    this.m_strKeyOfClrGapMinus = rSrcPriceCandleInfo.m_strKeyOfClrGapMinus;
    this.m_strKeyOfClrSteadyTone = rSrcPriceCandleInfo.m_strKeyOfClrSteadyTone;

    return true;
}

CPriceCandleTypeInfo.prototype.Copy = function ( rCopyPriceCandleInfo )
{
    if( rCopyPriceCandleInfo === undefined )
        rCopyPriceCandleInfo = new CPriceCandleTypeInfo();
    
    rCopyPriceCandleInfo.m_clrUpturnPlus = this.m_clrUpturnPlus;
    rCopyPriceCandleInfo.m_clrUpturnMinus = this.m_clrUpturnMinus;
    rCopyPriceCandleInfo.m_clrDropPlus = this.m_clrDropPlus;
    rCopyPriceCandleInfo.m_clrDropMinus = this.m_clrDropMinus;
    rCopyPriceCandleInfo.m_clrGapMinus = this.m_clrGapMinus;
    rCopyPriceCandleInfo.m_clrSteadyTone = this.m_clrSteadyTone;

    rCopyPriceCandleInfo.m_bFillUpturnPlus = this.m_bFillUpturnPlus;
    rCopyPriceCandleInfo.m_bFillUpturnMinus = this.m_bFillUpturnMinus;
    rCopyPriceCandleInfo.m_bFillDropPlus = this.m_bFillDropPlus;
    rCopyPriceCandleInfo.m_bFillDropMinus = this.m_bFillDropMinus;
    rCopyPriceCandleInfo.m_bFillGapMinus = this.m_bFillGapMinus;
    rCopyPriceCandleInfo.m_bSteadyClrFollowToUpDropClr = this.m_bSteadyClrFollowToUpDropClr;

    rCopyPriceCandleInfo.m_strKeyOfClrUpturnPlus = this.m_strKeyOfClrUpturnPlus;
    rCopyPriceCandleInfo.m_strKeyOfClrUpturnMinus = this.m_strKeyOfClrUpturnMinus;
    rCopyPriceCandleInfo.m_strKeyOfClrDropPlus = this.m_strKeyOfClrDropPlus;
    rCopyPriceCandleInfo.m_strKeyOfClrDropMinus = this.m_strKeyOfClrDropMinus;
    rCopyPriceCandleInfo.m_strKeyOfClrGapMinus = this.m_strKeyOfClrGapMinus;
    rCopyPriceCandleInfo.m_strKeyOfClrSteadyTone = this.m_strKeyOfClrSteadyTone;

    return rCopyPriceCandleInfo;
}

/////////////////////////////////////////////////

export function CPriceSubGraphPropertyInfo() {

    CSubGraphPropertyInfo.call(this);

    this.m_nSubGraphType = PRICE_SUBGRAPH_TYPE;
    this.m_nSubGraphSubType = PRICE_SUBGRAPH_CANDLE_TYPE;//현재 선택되어 있는 타입 저장

    this.m_PriceCandleTypeInfo = new CPriceCandleTypeInfo();
    this.m_PriceBarTypeInfo = new CPriceBarTypeInfo();
    this.m_PriceLineTypeInfo = new CPriceLineTypeInfo();
    this.m_PricePAndFTypeInfo = new CPricePAndFTypeInfo();
    this.m_PriceThreeLineBreakTypeInfo = new CPriceThreeLineBreakTypeInfo();

}
CPriceSubGraphPropertyInfo.prototype = new CSubGraphPropertyInfo();
CPriceSubGraphPropertyInfo.prototype.constructor = CPriceSubGraphPropertyInfo;

CPriceSubGraphPropertyInfo.prototype.SetPropertyInfo = function (rSrcPriceSubGraphPropertyInfo, bSetup) {

    if (rSrcPriceSubGraphPropertyInfo === undefined)
        return false;

    CSubGraphPropertyInfo.prototype.SetPropertyInfo.call(this, rSrcPriceSubGraphPropertyInfo, bSetup);

    this.m_PriceCandleTypeInfo.SetPropertyInfo(rSrcPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo, bSetup);
    this.m_PriceBarTypeInfo.SetPropertyInfo(rSrcPriceSubGraphPropertyInfo.m_PriceBarTypeInfo, bSetup);
    this.m_PriceLineTypeInfo.SetPropertyInfo(rSrcPriceSubGraphPropertyInfo.m_PriceLineTypeInfo, bSetup)
    this.m_PricePAndFTypeInfo.SetPropertyInfo(rSrcPriceSubGraphPropertyInfo.m_PricePAndFTypeInfo, bSetup)
    this.m_PriceThreeLineBreakTypeInfo.SetPropertyInfo(rSrcPriceSubGraphPropertyInfo.m_PriceThreeLineBreakTypeInfo, bSetup)

    return true;
}
CPriceSubGraphPropertyInfo.prototype.Copy = function (rCopyPriceSubGraphPropertyInfo) {

    if (rCopyPriceSubGraphPropertyInfo === undefined)
        rCopyPriceSubGraphPropertyInfo = new CPriceSubGraphPropertyInfo();

    rCopyPriceSubGraphPropertyInfo = CSubGraphPropertyInfo.prototype.Copy.call(this, rCopyPriceSubGraphPropertyInfo);

    rCopyPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo = this.m_PriceCandleTypeInfo.Copy() ;
    rCopyPriceSubGraphPropertyInfo.m_PriceBarTypeInfo = this.m_PriceBarTypeInfo.Copy() ;
    rCopyPriceSubGraphPropertyInfo.m_PriceLineTypeInfo = this.m_PriceLineTypeInfo.Copy() ;
    rCopyPriceSubGraphPropertyInfo.m_PricePAndFTypeInfo = this.m_PricePAndFTypeInfo.Copy() ;
    rCopyPriceSubGraphPropertyInfo.m_PriceThreeLineBreakTypeInfo = this.m_PriceThreeLineBreakTypeInfo.Copy();

    return rCopyPriceSubGraphPropertyInfo;
}

////////////////////////////////////////////////////////////////////////////////
//CBaseDrawer
function CBaseDrawer(rSubGraph) {

    if (rSubGraph === undefined)
        return;

    this.m_rSubGraph = rSubGraph;
    this.m_rPrevBongPosInfo = null;
    this.m_SignBongInfoArray = [];
    this.m_BongMinWidth = null;
}
CBaseDrawer.prototype.ChangeLang = function(){

}
CBaseDrawer.prototype.InitRendering = function () {
}
CBaseDrawer.prototype.RenderingInLoop = function (RenderingInfo) {
}
CBaseDrawer.prototype.RenderingOnLast = function (RenderingInfo) {
    return true;
}
CBaseDrawer.prototype.Draw = function (DrawingInfo) {
}
CBaseDrawer.prototype.AddSelectPosInfo = function () {
    this.m_SignBongInfoArray[this.m_SignBongInfoArray.length] = this.m_rPrevBongPosInfo;
}
CBaseDrawer.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {
}
CBaseDrawer.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {
    return false;
}
////////////////////////////////////////////////////////////////////////////////
//CIndicatorLineDrawer
function CIndicatorLineDrawer(rSubGraph) {

    if (rSubGraph === undefined)
        return;

    CBaseDrawer.call(this, rSubGraph);

    this.m_rPropertyInfo = this.m_rSubGraph.m_LineTypeInfo;

    this.m_BongTypeInfo = [];
}
CIndicatorLineDrawer.prototype = new CBaseDrawer();
CIndicatorLineDrawer.prototype.constructor = CIndicatorLineDrawer;

CIndicatorLineDrawer.prototype.InitRendering = function () {

    this.m_rPrevBongPosInfo = null;

    this.m_SignBongInfoArray.length = 0;

    this.m_BongTypeInfo.length = 0;
    this.m_BongTypeInfo[0] = new CBongInfo();
    this.m_BongTypeInfo[0].m_clrBong = this.m_rPropertyInfo.m_clrLine;
    this.m_BongTypeInfo[0].m_bFill = false;
    this.m_BongMinWidth = this.m_rSubGraph.m_rRQInCol.m_rChartBlockCol.m_BongMinWidth;
}
CIndicatorLineDrawer.prototype.RenderingInLoop = function (RenderingInfo) {

    var rRQPackets = this.m_rSubGraph.m_rRQInCol.m_rRQPackets;
    var BongTypeInfo = this.m_BongTypeInfo;

    var Data, rPacketItemData;

    var rectGraphRegion = this.m_rSubGraph.m_Graph.m_rBlock.m_rectGraphRegion;
    var nGraphRegionHeight = rectGraphRegion.Height();

    rPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rPacketData.m_nPacketIndex];
    if (rPacketItemData === undefined)
        return;

    var bLog = this.m_rSubGraph.GetLog();
    var bInvert = this.m_rSubGraph.GetInvert();

    var yMin = this.m_rSubGraph.m_yMin, yMax = this.m_rSubGraph.m_yMax, yDiff = this.m_rSubGraph.m_yDiff;

    if (bLog === true)
        Data = Log(rPacketItemData.m_Data);
    else
        Data = rPacketItemData.m_Data;

    var yPos = rectGraphRegion.m_nBottom - (Data - yMin) / yDiff * nGraphRegionHeight;

    if (bInvert === true)
        yPos = rectGraphRegion.m_nBottom - yPos + rectGraphRegion.m_nTop;

    var BongPosInfo = new CBongPosInfo();

    BongPosInfo.m_BongXPosInfo = this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray[this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray.length - 1];

    BongPosInfo.m_CloseYPos = yPos;

    BongTypeInfo[0].m_BongPosInfoArray[BongTypeInfo[0].m_BongPosInfoArray.length] = BongPosInfo;

    /////////////////////////////////////////////////////////////////////
    if (this.m_rSubGraph.m_ViewLatestData)
        this.m_rSubGraph.m_ViewPrevData = this.m_rSubGraph.m_ViewLatestData;

    this.m_rSubGraph.m_ViewLatestData = rPacketItemData.m_Data;
    /////////////////////////////////////////////////////////////////////

    this.m_rSubGraph.m_clrViewLatestData = BongTypeInfo[0].m_clrBong;

    this.m_rPrevBongPosInfo = BongPosInfo;
}

CIndicatorLineDrawer.prototype.Draw = function (DrawingInfo) {

    var BongTypeInfo = this.m_BongTypeInfo;

    var BongPosInfo = null;

    DrawingInfo.m_Context.beginPath();

    //선그리기
    switch (this.m_rPropertyInfo.m_nLineType) {
        case PS_SOLID: DrawingInfo.m_Context.setLineDash([0, 0]); break;
        case PS_DASH: DrawingInfo.m_Context.setLineDash([8, 4]); break;
        case PS_DOT: DrawingInfo.m_Context.setLineDash([2, 3]); break;
        default: DrawingInfo.m_Context.setLineDash([0, 0]); break;
    }
    DrawingInfo.m_Context.strokeStyle = this.m_rPropertyInfo.m_clrLine;
    DrawingInfo.m_Context.lineWidth = this.m_rPropertyInfo.m_nThickness + (this.m_rSubGraph.IsDrawSelected(DrawingInfo) ? gSelectSignSize : 0);

    var bDrawStarted = false;
    var xPos, yPos;
    var xStartPos = null, yStartPos = null;
    var BongItemIndex, BongItemLength = BongTypeInfo[0].m_BongPosInfoArray.length;

    for (BongItemIndex = 0; BongItemIndex < BongItemLength; BongItemIndex++) {

        xPos = BongTypeInfo[0].m_BongPosInfoArray[BongItemIndex].m_BongXPosInfo.m_CenterXPos;

        if ((DrawingInfo.m_rectGraphRegion.m_nLeft < xPos && xPos < DrawingInfo.m_rectGraphRegion.m_nRight) && (BongItemIndex < BongItemLength - 1)) {
            xStartPos = xPos;
            yStartPos = BongTypeInfo[0].m_BongPosInfoArray[BongItemIndex].m_CloseYPos;

            bDrawStarted = true;

            BongItemIndex++;

            break;
        }
    }

    if (bDrawStarted) {

        xPos = BongTypeInfo[0].m_BongPosInfoArray[BongItemIndex].m_BongXPosInfo.m_CenterXPos;

        if (DrawingInfo.m_rectGraphRegion.m_nLeft < xPos && xPos < DrawingInfo.m_rectGraphRegion.m_nRight) {

            yPos = BongTypeInfo[0].m_BongPosInfoArray[BongItemIndex].m_CloseYPos;

            //DrawingInfo.m_Context.moveTo(xStartPos, yStartPos);
            //DrawingInfo.m_Context.lineTo(xPos, yPos);
            DrawingInfo.m_Context.moveTo(Math.floor(xStartPos) + 0.5, Math.floor(yStartPos) + 0.5);
            DrawingInfo.m_Context.lineTo(Math.floor(xPos) + 0.5, Math.floor(yPos) + 0.5);
        }

        BongItemIndex++;

        for (; BongItemIndex < BongItemLength; BongItemIndex++) {

            xPos = BongTypeInfo[0].m_BongPosInfoArray[BongItemIndex].m_BongXPosInfo.m_CenterXPos;

            if (DrawingInfo.m_rectGraphRegion.m_nLeft < xPos && xPos < DrawingInfo.m_rectGraphRegion.m_nRight) {

                yPos = BongTypeInfo[0].m_BongPosInfoArray[BongItemIndex].m_CloseYPos;

                //DrawingInfo.m_Context.lineTo(xPos,yPos);
                DrawingInfo.m_Context.lineTo(Math.floor(xPos) + 0.5, Math.floor(yPos) + 0.5);
            }
        }
    }

    DrawingInfo.m_Context.stroke();
    DrawingInfo.m_Context.closePath();
}

CIndicatorLineDrawer.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {

    this.m_rSubGraph.m_MinMaxInfo.Init();

    {
        var rPacketData = this.m_rSubGraph.m_rPacketData;

        gMinMaxInfo.Init();
        var MinMaxInfo = gMinMaxInfo;
        if (rXScaleMng.ExtractMinMaxValue(this.m_rSubGraph.m_rRQSet.m_strRQ, rPacketData.m_strPacketName, MinMaxInfo, bFullScan)) {
            if (this.m_rSubGraph.m_MinMaxInfo.m_Max === null)
                this.m_rSubGraph.m_MinMaxInfo.m_Max = MinMaxInfo.m_Max;
            else if (this.m_rSubGraph.m_MinMaxInfo.m_Max < MinMaxInfo.m_Max)
                this.m_rSubGraph.m_MinMaxInfo.m_Max = MinMaxInfo.m_Max;

            if (this.m_rSubGraph.m_MinMaxInfo.m_Min === null)
                this.m_rSubGraph.m_MinMaxInfo.m_Min = MinMaxInfo.m_Min;
            else if (this.m_rSubGraph.m_MinMaxInfo.m_Min > MinMaxInfo.m_Min)
                this.m_rSubGraph.m_MinMaxInfo.m_Min = MinMaxInfo.m_Min;

            this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex = MinMaxInfo.m_nStartIndex;
            this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex = MinMaxInfo.m_nEndIndex;
        }
        else {

            this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex = MinMaxInfo.m_nStartIndex;
            this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex = MinMaxInfo.m_nEndIndex;

        }
    }

    if (this.m_rSubGraph.m_MinMaxInfo.m_Max !== null) {
        if (SubGraphMinMaxInfo.m_Max === null)
            SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;
        else if (SubGraphMinMaxInfo.m_Max < this.m_rSubGraph.m_MinMaxInfo.m_Max)
            SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;
    }

    if (this.m_rSubGraph.m_MinMaxInfo.m_Min !== null) {
        if (SubGraphMinMaxInfo.m_Min === null)
            SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;
        else if (SubGraphMinMaxInfo.m_Min > this.m_rSubGraph.m_MinMaxInfo.m_Min)
            SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;
    }

    SubGraphMinMaxInfo.m_nStartIndex = this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex;
    SubGraphMinMaxInfo.m_nEndIndex = this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex;
}

CIndicatorLineDrawer.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {

    var rPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rPacketData.m_nPacketIndex];
    if (rPacketItemData === undefined)
        return false;

    var yPos = null;
    var yValue = null;

    var nViewStartIndex = rXScaleMng.m_nViewStartIndex;
    var nViewEndIndex = rXScaleMng.m_nViewEndIndex;

    var nGraphRegionWidth = rectGraphRegion.Width();
    var nGraphRegionHeight = rectGraphRegion.Height();
    var nViewDataCnt = nViewEndIndex - nViewStartIndex + 1;

    var i, j;
    var strRQ = this.m_rSubGraph.m_rRQSet.GetRQ();

    if (rRQPackets.m_rNextRQPacketsItem === null && rRQPackets.m_rPrevRQPacketsItem !== null)
        rRQPackets = rRQPackets.m_rPrevRQPacketsItem;
    else if (rRQPackets.m_rNextRQPacketsItem === null && rRQPackets.m_rPrevRQPacketsItem === null)
        return false;

    if (nViewEndIndex < (nViewStartIndex + rRQPackets.m_nRelativeStartIndex + rRQPackets.m_nRelativeNextStartIndex))
        return false;

    var rNextRQPackets = rRQPackets.m_rNextRQPacketsItem;
    var rNextPacketItemData = rNextRQPackets.m_Packets[this.m_rSubGraph.m_rPacketData.m_nPacketIndex];
    if (rNextPacketItemData === undefined)
        return false;

    var xPos1Left = rectGraphRegion.m_nLeft + nGraphRegionWidth / nViewDataCnt * rRQPackets.m_nRelativeStartIndex;
    var xPos1Right = rectGraphRegion.m_nLeft + nGraphRegionWidth / nViewDataCnt * (rRQPackets.m_nRelativeStartIndex + rRQPackets.m_nRelativeEndIndex);
    var xPos1 = xPos1Left + (xPos1Right - xPos1Left) / 2;

    var xPos2Left = rectGraphRegion.m_nLeft + nGraphRegionWidth / nViewDataCnt * rNextRQPackets.m_nRelativeStartIndex;
    var xPos2Right = rectGraphRegion.m_nLeft + nGraphRegionWidth / nViewDataCnt * (rNextRQPackets.m_nRelativeStartIndex + rNextRQPackets.m_nRelativeEndIndex);
    var xPos2 = xPos2Left + (xPos2Right - xPos2Left) / 2;


    var yMin, yMax, yDiff, yPos1, yPos2, yData, yNextData;

    var bLog = this.m_rSubGraph.GetLog();
    if (bLog === true) {

        yMin = Log(this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit);
        yMax = Log(this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit);

        yData = Log(rPacketItemData.m_Data);
        yNextData = Log(rNextPacketItemData.m_Data);
    }
    else {

        yMin = this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit;
        yMax = this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit;

        yData = rPacketItemData.m_Data;
        yNextData = rNextPacketItemData.m_Data;
    }

    yDiff = yMax - yMin;

    yPos1 = rectGraphRegion.m_nBottom - (yData - yMin) / yDiff * nGraphRegionHeight;
    yPos2 = rectGraphRegion.m_nBottom - (yNextData - yMin) / yDiff * nGraphRegionHeight;

    if (this.m_rSubGraph.GetInvert() === true) {

        yPos1 = rectGraphRegion.m_nBottom - yPos1 + rectGraphRegion.m_nTop;
        yPos2 = rectGraphRegion.m_nBottom - yPos2 + rectGraphRegion.m_nTop;
    }

    var DeltaX = xPos2 - xPos1;
    if (DeltaX !== 0) {
        var a = (yPos2 - yPos1) / DeltaX;//console.log("X:" + X + ", Y:" + Y + " " + "a(" + a + ")=(" + yPos2 + "-" + yPos1 + ")/(" + xPos2 + "-" + xPos1 + ")");
        var b = (yPos1 - a * xPos1);//console.log("b(" + b + ")=(" + yPos1 + "-" + a + " * " + xPos1 + ")");
        var CalcY = a * X + b;//console.log("CalcY(" + CalcY + ")=(" + a + "*" + X + " + " + b + "), Y=" + Y);
        if ((CalcY - (this.m_rPropertyInfo.m_nThickness + 5)) <= Y && Y <= (CalcY + (this.m_rPropertyInfo.m_nThickness + 5))) { //console.log((CalcY - (this.m_nThickness + 5)) + "<=" + Y + " && " + Y + "<=" + (CalcY + this.m_nThickness + 5));
            return true;
        }
    }
    else {
        if ((xPos1 - (this.m_rPropertyInfo.m_nThickness + 5)) <= X && X <= (xPos1 + (this.m_rPropertyInfo.m_nThickness + 5)))
            return true;
    }
    return false;
}
////////////////////////////////////////////////////////////////////////////////
//CIndicatorBarDrawer
function CIndicatorBarDrawer(rSubGraph) {

    if (rSubGraph === undefined)
        return;

    CBaseDrawer.call(this, rSubGraph);

    this.m_rPropertyInfo = this.m_rSubGraph.m_BarTypeInfo;

    this.m_BongTypeInfo = [];
}
CIndicatorBarDrawer.prototype = new CBaseDrawer();
CIndicatorBarDrawer.prototype.constructor = CIndicatorBarDrawer;

CIndicatorBarDrawer.prototype.InitRendering = function () {

    this.m_rPrevBongPosInfo = null;

    this.m_SignBongInfoArray.length = 0;

    this.m_BongTypeInfo.length = 0;

    if (this.m_rPropertyInfo.m_nCompareType !== 6) {
        //비교없음
        this.m_BongTypeInfo[0] = new CBarInfo();
        this.m_BongTypeInfo[0].m_clrBar = this.m_rPropertyInfo.m_clrBar;
        this.m_BongTypeInfo[0].m_bFill = this.m_rPropertyInfo.m_bFill;

        //상승
        this.m_BongTypeInfo[1] = new CBarInfo();
        this.m_BongTypeInfo[1].m_clrBar = this.m_rPropertyInfo.m_clrUp;
        this.m_BongTypeInfo[1].m_bFill = this.m_rPropertyInfo.m_bFill;

        //하락
        this.m_BongTypeInfo[2] = new CBarInfo();
        this.m_BongTypeInfo[2].m_clrBar = this.m_rPropertyInfo.m_clrDown;
        this.m_BongTypeInfo[2].m_bFill = this.m_rPropertyInfo.m_bFill;
    }
    else {

        this.m_BongTypeInfo[0] = new CBarInfo();
        this.m_BongTypeInfo[0].m_clrBar = this.m_rSubGraph.m_rPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrUpturnPlus;
        this.m_BongTypeInfo[0].m_bFill = this.m_rPropertyInfo.m_bFill;


        this.m_BongTypeInfo[1] = new CBarInfo();
        this.m_BongTypeInfo[1].m_clrBar = this.m_rSubGraph.m_rPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrUpturnMinus;
        this.m_BongTypeInfo[1].m_bFill = this.m_rPropertyInfo.m_bFill;

        this.m_BongTypeInfo[2] = new CBarInfo();
        this.m_BongTypeInfo[2].m_clrBar = this.m_rSubGraph.m_rPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrDropPlus;
        this.m_BongTypeInfo[2].m_bFill = this.m_rPropertyInfo.m_bFill;

        this.m_BongTypeInfo[3] = new CBarInfo();
        this.m_BongTypeInfo[3].m_clrBar = this.m_rSubGraph.m_rPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrDropMinus;
        this.m_BongTypeInfo[3].m_bFill = this.m_rPropertyInfo.m_bFill;

        this.m_BongTypeInfo[4] = new CBarInfo();
        this.m_BongTypeInfo[4].m_clrBar = this.m_rSubGraph.m_rPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrGapMinus;
        this.m_BongTypeInfo[4].m_bFill = this.m_rPropertyInfo.m_bFill;

        this.m_BongTypeInfo[5] = new CBarInfo();
        this.m_BongTypeInfo[5].m_clrBar = this.m_rSubGraph.m_rPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrSteadyTone;
        this.m_BongTypeInfo[5].m_bFill = this.m_rPropertyInfo.m_bFill;
    }
}
CIndicatorBarDrawer.prototype.RenderingInLoop = function (RenderingInfo) {

    var rRQPackets = this.m_rSubGraph.m_rRQInCol.m_rRQPackets;
    var rPrevRQPackets = this.m_rSubGraph.m_rRQInCol.m_rPrevRQPackets;

    var rectGraphRegion = this.m_rSubGraph.m_Graph.m_rBlock.m_rectGraphRegion;
    var nGraphRegionHeight = rectGraphRegion.Height();

    var PrevClose = this.m_rSubGraph.m_PrevClose;
    var BarTypeInfo = this.m_BongTypeInfo;

    var nOpenPacketIndex = this.m_rSubGraph.m_rRQSet.m_nOpenPacketIndex;
    var nHighPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHighPacketIndex;
    var nLowPacketIndex = this.m_rSubGraph.m_rRQSet.m_nLowPacketIndex;
    var nClosePacketIndex = this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex;

    var bLog = this.m_rSubGraph.GetLog();
    var bInvert = this.m_rSubGraph.GetInvert();
    var Data = null;

    var yMin = this.m_rSubGraph.m_yMin;
    var yMax = this.m_rSubGraph.m_yMax;
    var yDiff = this.m_rSubGraph.m_yDiff;
    var yZeroPos = this.m_rSubGraph.m_yZeroPos;

    var rPrevRQPacketItemData = null;
    var rRQOpenPacketItemData = null;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////
    var rPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rPacketData.m_nPacketIndex];
    if (!rPacketItemData)
        return;

    Data = bLog ? Log(rPacketItemData.m_Data) : rPacketItemData.m_Data;

    var yVolumePos = rectGraphRegion.m_nBottom - (Data - yMin) / yDiff * nGraphRegionHeight;

    if (bInvert === true)
        yVolumePos = rectGraphRegion.m_nBottom - yVolumePos + rectGraphRegion.m_nTop;

    var BarPosInfo = new CBarPosInfo();

    BarPosInfo.m_BongXPosInfo = this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray[this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray.length - 1];

    if (yVolumePos > yZeroPos) {
        BarPosInfo.m_Top = yZeroPos;
        BarPosInfo.m_Bottom = yVolumePos;
    }
    else {
        BarPosInfo.m_Top = yVolumePos;
        BarPosInfo.m_Bottom = yZeroPos;
    }

    ////////////////////////////////////////////////////////////////////////
    //y축 보이는 봉중에서 최신 종가 및 등락율 보여주는 기능 처리를 위해 추가
    if (this.m_rSubGraph.m_ViewLatestData)
        this.m_rSubGraph.m_ViewPrevData = this.m_rSubGraph.m_ViewLatestData;

    this.m_rSubGraph.m_ViewLatestData = rPacketItemData.m_Data;
    ////////////////////////////////////////////////////////////////////////

    switch (this.m_rPropertyInfo.m_nCompareType) {

        case COMPARE_TYPE_NO://비교없음
            {
                BarTypeInfo[0].m_BarPosInfoArray[BarTypeInfo[0].m_BarPosInfoArray.length] = BarPosInfo;
                this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[0].m_clrBar;
            }
            break;
        case COMPARE_TYPE_ZERO://0기준
            {
                //0보다 큰 경우 상승
                if (rPacketItemData.m_Data > 0) {
                    BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                    this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                }
                else {
                    BarTypeInfo[2].m_BarPosInfoArray[BarTypeInfo[2].m_BarPosInfoArray.length] = BarPosInfo;
                    this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[2].m_clrBar;
                }
            }
            break;
        case COMPARE_TYPE_PREV_VALUE://이전값
            {
                var bProcess = false;
                //var rPrevRQPackets = rRQPackets.m_rPrevRQPacketsItem;
                if (rPrevRQPackets !== null) {
                    rPrevRQPacketItemData = rPrevRQPackets.m_Packets[this.m_rSubGraph.m_rPacketData.m_nPacketIndex];
                    if (rPrevRQPacketItemData !== undefined) {
                        if (rPrevRQPacketItemData.m_Data < rPacketItemData.m_Data) {
                            bProcess = true;
                            BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                        }
                        else {
                            bProcess = true;
                            BarTypeInfo[2].m_BarPosInfoArray[BarTypeInfo[2].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[2].m_clrBar;
                        }
                    }
                }

                if (bProcess === false) {
                    BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                    this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                }
            }
            break;
        case COMPARE_TYPE_PREV_CLOSE://이전종가
            {
                var bProcess = false;
                var rRQClosePacketItemData = rRQPackets.m_Packets[nClosePacketIndex];
                if (rRQClosePacketItemData !== undefined) {

                    if (rPrevRQPackets !== null) {

                        rPrevRQPacketItemData = rPrevRQPackets.m_Packets[nClosePacketIndex];
                        if (rPrevRQPacketItemData !== undefined) {
                            if (rPrevRQPacketItemData.m_Data < rRQClosePacketItemData.m_Data) {
                                bProcess = true;
                                BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                                this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                            }
                            else {
                                bProcess = true;
                                BarTypeInfo[2].m_BarPosInfoArray[BarTypeInfo[2].m_BarPosInfoArray.length] = BarPosInfo;
                                this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[2].m_clrBar;
                            }
                        }
                    }
                }

                if (bProcess === false) {
                    BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                    this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                }
            }
            break;
        case COMPARE_TYPE_PREV_HIGH://이전고가
            {
                var bProcess = false;
                var rRQHighPacketItemData = rRQPackets.m_Packets[nHighPacketIndex];
                if (rRQHighPacketItemData !== undefined) {

                    if (rPrevRQPackets !== null) {

                        rPrevRQPacketItemData = rPrevRQPackets.m_Packets[nHighPacketIndex];
                        if (rPrevRQPacketItemData !== undefined) {
                            if (rPrevRQPacketItemData.m_Data < rRQHighPacketItemData.m_Data) {
                                bProcess = true;
                                BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                                this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                            }
                            else {
                                bProcess = true;
                                BarTypeInfo[2].m_BarPosInfoArray[BarTypeInfo[2].m_BarPosInfoArray.length] = BarPosInfo;
                                this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[2].m_clrBar;
                            }
                        }
                    }
                }

                if (bProcess === false) {
                    BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                    this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                }
            }
            break;
        case COMPARE_TYPE_CUR_OPEN://현재시가
            {
                var bProcess = false;
                var rRQClosePacketItemData = rRQPackets.m_Packets[nClosePacketIndex];
                if (rRQClosePacketItemData !== undefined) {

                    rRQOpenPacketItemData = rRQPackets.m_Packets[nOpenPacketIndex];
                    if (rRQOpenPacketItemData !== undefined) {
                        if (rRQOpenPacketItemData.m_Data < rRQClosePacketItemData.m_Data) {
                            bProcess = true;
                            BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                        }
                        else {
                            bProcess = true;
                            BarTypeInfo[2].m_BarPosInfoArray[BarTypeInfo[2].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[2].m_clrBar;
                        }
                    }

                }

                if (bProcess === false) {
                    BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                    this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                }
            }
            break;
        case COMPARE_TYPE_CANDLE://가격차트
            {
                var rClosePacketItemData = rRQPackets.m_Packets[nClosePacketIndex];
                var rOpenPacketItemData = rRQPackets.m_Packets[nOpenPacketIndex];
                var rHighPacketItemData = rRQPackets.m_Packets[nHighPacketIndex];
                var rLowPacketItemData = rRQPackets.m_Packets[nLowPacketIndex];

                var PrevClose = this.m_rSubGraph.m_PrevClose;

                if (PrevClose !== null) {
                    if (rOpenPacketItemData.m_Data > PrevClose)//상승
                    {
                        if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//양봉
                        {
                            BarTypeInfo[0].m_BarPosInfoArray[BarTypeInfo[0].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[0].m_clrBar;
                        }
                        else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//음봉
                        {
                            BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                        }
                        else//보합
                        {
                            BarTypeInfo[5].m_BarPosInfoArray[BarTypeInfo[5].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[5].m_clrBar;
                        }
                    }
                    else if (rOpenPacketItemData.m_Data < PrevClose)//하락
                    {
                        if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//양봉
                        {
                            BarTypeInfo[2].m_BarPosInfoArray[BarTypeInfo[2].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[2].m_clrBar;
                        }
                        else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//음봉
                        {
                            BarTypeInfo[3].m_BarPosInfoArray[BarTypeInfo[3].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[3].m_clrBar;
                        }
                        else//보합
                        {
                            BarTypeInfo[5].m_BarPosInfoArray[BarTypeInfo[5].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[5].m_clrBar;
                        }
                    }
                    else {
                        if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//상승양봉
                        {
                            BarTypeInfo[0].m_BarPosInfoArray[BarTypeInfo[0].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[0].m_clrBar;
                        }
                        else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//하락음봉
                        {
                            BarTypeInfo[3].m_BarPosInfoArray[BarTypeInfo[3].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[3].m_clrBar;
                        }
                        else//보합
                        {
                            BarTypeInfo[5].m_BarPosInfoArray[BarTypeInfo[5].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[5].m_clrBar;
                        }
                    }
                }
                else {
                    if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//상승양봉
                    {
                        BarTypeInfo[0].m_BarPosInfoArray[BarTypeInfo[0].m_BarPosInfoArray.length] = BarPosInfo;
                        this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[0].m_clrBar;
                    }
                    else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//하락음봉
                    {
                        BarTypeInfo[3].m_BarPosInfoArray[BarTypeInfo[3].m_BarPosInfoArray.length] = BarPosInfo;
                        this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[3].m_clrBar;
                    }
                    else//보합
                    {
                        BarTypeInfo[5].m_BarPosInfoArray[BarTypeInfo[5].m_BarPosInfoArray.length] = BarPosInfo;
                        this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[5].m_clrBar;
                    }
                }

                this.m_rSubGraph.m_PrevClose = rClosePacketItemData.m_Data;//전봉종가
            }
            break;
    }

    this.m_rPrevBongPosInfo = BarPosInfo;
}

CIndicatorBarDrawer.prototype.Draw = function (DrawingInfo) {

    /////////////////////////////////////////
    //선택그래프 표시기능
    var SignBongInfoArray = this.m_SignBongInfoArray;
    var nStartSignXPos = this.m_rSubGraph.m_rRQInCol.m_nStartSignXPos;
    /////////////////////////////////////////

    var BarTypeInfo = this.m_BongTypeInfo;

    //최소 봉 두께
    var BongMinWidth = this.m_rSubGraph.m_rRQInCol.m_rChartBlockCol.m_BongMinWidth;

    {
        //////////////////////////////////////////////////////////////////
        //BarType은 다르지만 색상값이 같은 경우 하나로 묶는다( beginPath 호출횟수를 줄여 성능향상 목적)
        var i, j;
        var ColorArray = [];

        var nLength = BarTypeInfo.length;
        for (i = 0; i < nLength; i++) {
            if (i === 0) {
                ColorArray[ColorArray.length] = BarTypeInfo[i].m_clrBar;
            }
            else {
                var ColorArrayLength = ColorArray.length;
                for (j = 0; j < ColorArrayLength; j++) {
                    if (BarTypeInfo[i].m_clrBar === ColorArray[j])
                        break;
                }
                if (j === ColorArrayLength)
                    ColorArray[j] = BarTypeInfo[i].m_clrBar;
            }
        }
        //////////////////////////////////////////////////////////////////

        var BarPosInfo = null;
        var YUpper, YLower;

        var ColorArrayLength = ColorArray.length;

        for (i = 0; i < ColorArrayLength; i++) {

            DrawingInfo.m_Context.beginPath();
            DrawingInfo.m_Context.strokeStyle = ColorArray[i];
            DrawingInfo.m_Context.fillStyle = ColorArray[i];
            DrawingInfo.m_Context.lineWidth = 1;

            for (j = 0; j < nLength; j++) {

                if (ColorArray[i] === BarTypeInfo[j].m_clrBar) {

                    var BarItemIndex, BarItemLength = BarTypeInfo[j].m_BarPosInfoArray.length;
                    for (BarItemIndex = 0; BarItemIndex < BarItemLength; BarItemIndex++) {
                        BarPosInfo = BarTypeInfo[j].m_BarPosInfoArray[BarItemIndex];

                        if (BarPosInfo.m_Bottom > BarPosInfo.m_Top) {
                            YUpper = BarPosInfo.m_Bottom;
                            YLower = BarPosInfo.m_Top;
                        }
                        else {
                            YUpper = BarPosInfo.m_Top;
                            YLower = BarPosInfo.m_Bottom;
                        }

                        if (BarTypeInfo[j].m_bFill)
                            DrawingInfo.m_Context.fillRect(BarPosInfo.m_BongXPosInfo.m_OpenXPos, YLower, BarPosInfo.m_BongXPosInfo.m_CloseXPos - BarPosInfo.m_BongXPosInfo.m_OpenXPos, YUpper - YLower);
                        else
                            DrawingInfo.m_Context.strokeRect(BarPosInfo.m_BongXPosInfo.m_OpenXPos, YLower, BarPosInfo.m_BongXPosInfo.m_CloseXPos - BarPosInfo.m_BongXPosInfo.m_OpenXPos, YUpper - YLower);
                    }
                }
            }

            DrawingInfo.m_Context.closePath();
            DrawingInfo.m_Context.stroke();
        }
    }

    // 그래프 선택 표시(반전색상)
    if (this.m_rSubGraph.IsDrawSelected(DrawingInfo)) {

        var nSize = gSelectSignSize;
        var nLength = SignBongInfoArray.length;

        for (i = 0; i < nLength; i++) {

            var rBarPosInfo = SignBongInfoArray[i];

            var XCenter = (rBarPosInfo.m_BongXPosInfo.m_OpenXPos + rBarPosInfo.m_BongXPosInfo.m_CloseXPos) / 2;
            var XLeft = XCenter - nSize;
            var XRight = XCenter + nSize;

            var YCenter = (rBarPosInfo.m_Top + rBarPosInfo.m_Bottom) / 2;
            var YTop = YCenter - nSize;
            var YBottom = YCenter + nSize;

            var imgData = DrawingInfo.m_Context.getImageData(XLeft, YTop, XRight - XLeft, YBottom - YTop);
            var nDataLength = imgData.data.length;
            for (var j = 0; j < nDataLength; j += 4) {

                imgData.data[j] = 255 - imgData.data[j];
                imgData.data[j + 1] = 255 - imgData.data[j + 1];
                imgData.data[j + 2] = 255 - imgData.data[j + 2];
                imgData.data[j + 3] = 255;
            }
            DrawingInfo.m_Context.putImageData(imgData, XLeft, YTop);
        }
    }
}

CIndicatorBarDrawer.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {

    this.m_rSubGraph.m_MinMaxInfo.Init();

    var rPacketData = this.m_rSubGraph.m_rPacketData;

    gMinMaxInfo.Init();
    var MinMaxInfo = gMinMaxInfo;
    if (rXScaleMng.ExtractMinMaxValue(this.m_rSubGraph.m_rRQSet.m_strRQ, rPacketData.m_strPacketName, MinMaxInfo, bFullScan)) {
        //양수나 음수 한쪽방향으로만 존재하므로 강제로 0범위를 추가한다
        if (MinMaxInfo.m_Max * MinMaxInfo.m_Min > 0) {
            if (MinMaxInfo.m_Max < 0)
                MinMaxInfo.m_Max = 0;
            else
                MinMaxInfo.m_Min = 0;

            SubGraphMinMaxInfo.m_bZeroBaseLine = true;
        }
        //max > 0 and min < 0 인 경우이므로 중간에 0이 포함되어 있다.

        if (this.m_rSubGraph.m_MinMaxInfo.m_Max === null || this.m_rSubGraph.m_MinMaxInfo.m_Max < MinMaxInfo.m_Max)
            this.m_rSubGraph.m_MinMaxInfo.m_Max = MinMaxInfo.m_Max;

        if (this.m_rSubGraph.m_MinMaxInfo.m_Min === null || this.m_rSubGraph.m_MinMaxInfo.m_Min > MinMaxInfo.m_Min)
            this.m_rSubGraph.m_MinMaxInfo.m_Min = MinMaxInfo.m_Min;

        this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex = MinMaxInfo.m_nStartIndex;
        this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex = MinMaxInfo.m_nEndIndex;
    }

    if (SubGraphMinMaxInfo.m_Max === null)
        SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;
    else if (SubGraphMinMaxInfo.m_Max < this.m_rSubGraph.m_MinMaxInfo.m_Max)
        SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;

    if (SubGraphMinMaxInfo.m_Min === null)
        SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;
    else if (SubGraphMinMaxInfo.m_Min > this.m_rSubGraph.m_MinMaxInfo.m_Min)
        SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;

    SubGraphMinMaxInfo.m_nStartIndex = this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex;
    SubGraphMinMaxInfo.m_nEndIndex = this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex;
}

CIndicatorBarDrawer.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {

    var rPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rPacketData.m_nPacketIndex];
    if (rPacketItemData === undefined)
        return false;

    var yPos = null;
    var yValue = null;

    var nViewStartIndex = rXScaleMng.m_nViewStartIndex;
    var nViewEndIndex = rXScaleMng.m_nViewEndIndex;

    var nGraphRegionWidth = rectGraphRegion.Width();
    var nGraphRegionHeight = rectGraphRegion.Height();
    var nViewDataCnt = nViewEndIndex - nViewStartIndex + 1;

    //최소 봉 두께
    var BarMinWidth = nGraphRegionWidth / nViewDataCnt;

    var i, j;
    var strRQ = this.m_rSubGraph.m_rRQSet.GetRQ();

    var xPosLeft = rectGraphRegion.m_nLeft + BarMinWidth * rRQPackets.m_nRelativeStartIndex;
    var xPosRight = rectGraphRegion.m_nLeft + BarMinWidth * (rRQPackets.m_nRelativeStartIndex + rRQPackets.m_nRelativeEndIndex);

    var yMin, yMax, yDiff, yZeroPos, yData;
    var bLog = this.m_rSubGraph.GetLog();
    if (bLog === true) {

        yMin = Log(this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit);
        yMax = Log(this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit);
        yData = Log(rPacketItemData.m_Data);
    }
    else {

        yMin = this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit;
        yMax = this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit;
        yData = rPacketItemData.m_Data;
    }

    yDiff = yMax - yMin;

    yZeroPos = rectGraphRegion.m_nBottom - (0 - yMin) / yDiff * nGraphRegionHeight;

    yPos = rectGraphRegion.m_nBottom - (yData - yMin) / yDiff * nGraphRegionHeight;

    if (this.m_rSubGraph.GetInvert() === true) {

        yZeroPos = rectGraphRegion.m_nBottom - yZeroPos + rectGraphRegion.m_nTop;
        yPos = rectGraphRegion.m_nBottom - yPos + rectGraphRegion.m_nTop;
    }

    if ((yPos <= Y && Y <= yZeroPos) && (xPosLeft <= X && X <= xPosRight))
        return true;

    return false;
}

////////////////////////////////////////////////////////////////////////////////
//CVolumeBarDrawer
function CVolumeBarDrawer(rSubGraph) {

    if (rSubGraph === undefined)
        return;

    CBaseDrawer.call(this, rSubGraph);

    this.m_rPropertyInfo = this.m_rSubGraph.m_VolumeBarTypeInfo;

    this.m_BongTypeInfo = [];
}
CVolumeBarDrawer.prototype = new CBaseDrawer();
CVolumeBarDrawer.prototype.constructor = CVolumeBarDrawer;

CVolumeBarDrawer.prototype.InitRendering = function () {

    this.m_rPrevBongPosInfo = null;

    this.m_SignBongInfoArray.length = 0;

    this.m_BongTypeInfo.length = 0;

    if (this.m_rPropertyInfo.m_nCompareType !== 6) {
        //비교없음
        this.m_BongTypeInfo[0] = new CBarInfo();
        this.m_BongTypeInfo[0].m_clrBar = this.m_rPropertyInfo.m_clrBar;
        this.m_BongTypeInfo[0].m_bFill = this.m_rPropertyInfo.m_bFill;

        //상승
        this.m_BongTypeInfo[1] = new CBarInfo();
        this.m_BongTypeInfo[1].m_clrBar = this.m_rPropertyInfo.m_clrUp;
        this.m_BongTypeInfo[1].m_bFill = this.m_rPropertyInfo.m_bFill;

        //하락
        this.m_BongTypeInfo[2] = new CBarInfo();
        this.m_BongTypeInfo[2].m_clrBar = this.m_rPropertyInfo.m_clrDown;
        this.m_BongTypeInfo[2].m_bFill = this.m_rPropertyInfo.m_bFill;
    }
    else {

        this.m_BongTypeInfo[0] = new CBarInfo();
        this.m_BongTypeInfo[0].m_clrBar = this.m_rSubGraph.m_rPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrUpturnPlus;
        this.m_BongTypeInfo[0].m_bFill = this.m_rPropertyInfo.m_bFill;


        this.m_BongTypeInfo[1] = new CBarInfo();
        this.m_BongTypeInfo[1].m_clrBar = this.m_rSubGraph.m_rPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrUpturnMinus;
        this.m_BongTypeInfo[1].m_bFill = this.m_rPropertyInfo.m_bFill;

        this.m_BongTypeInfo[2] = new CBarInfo();
        this.m_BongTypeInfo[2].m_clrBar = this.m_rSubGraph.m_rPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrDropPlus;
        this.m_BongTypeInfo[2].m_bFill = this.m_rPropertyInfo.m_bFill;

        this.m_BongTypeInfo[3] = new CBarInfo();
        this.m_BongTypeInfo[3].m_clrBar = this.m_rSubGraph.m_rPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrDropMinus;
        this.m_BongTypeInfo[3].m_bFill = this.m_rPropertyInfo.m_bFill;

        this.m_BongTypeInfo[4] = new CBarInfo();
        this.m_BongTypeInfo[4].m_clrBar = this.m_rSubGraph.m_rPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrGapMinus;
        this.m_BongTypeInfo[4].m_bFill = this.m_rPropertyInfo.m_bFill;

        this.m_BongTypeInfo[5] = new CBarInfo();
        this.m_BongTypeInfo[5].m_clrBar = this.m_rSubGraph.m_rPriceSubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrSteadyTone;
        this.m_BongTypeInfo[5].m_bFill = this.m_rPropertyInfo.m_bFill;
    }
}
CVolumeBarDrawer.prototype.RenderingInLoop = function (RenderingInfo) {

    var rRQPackets = this.m_rSubGraph.m_rRQInCol.m_rRQPackets;
    var rPrevRQPackets = this.m_rSubGraph.m_rRQInCol.m_rPrevRQPackets;

    var rectGraphRegion = this.m_rSubGraph.m_Graph.m_rBlock.m_rectGraphRegion;
    var nGraphRegionHeight = rectGraphRegion.Height();

    var PrevClose = this.m_rSubGraph.m_PrevClose;
    var BarTypeInfo = this.m_BongTypeInfo;

    var nOpenPacketIndex = this.m_rSubGraph.m_rRQSet.m_nOpenPacketIndex;
    var nHighPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHighPacketIndex;
    var nLowPacketIndex = this.m_rSubGraph.m_rRQSet.m_nLowPacketIndex;
    var nClosePacketIndex = this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex;

    var bLog = this.m_rSubGraph.GetLog();
    var bInvert = this.m_rSubGraph.GetInvert();
    var Data = null;

    var yMin = this.m_rSubGraph.m_yMin;
    var yMax = this.m_rSubGraph.m_yMax;
    var yDiff = this.m_rSubGraph.m_yDiff;
    var yZeroPos = this.m_rSubGraph.m_yZeroPos;

    var rPrevRQPacketItemData = null;
    var rRQOpenPacketItemData = null;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////
    var rPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rPacketData.m_nPacketIndex];
    if (!rPacketItemData)
        return;

    Data = bLog ? Log(rPacketItemData.m_Data) : rPacketItemData.m_Data;

    var yVolumePos = rectGraphRegion.m_nBottom - (Data - yMin) / yDiff * nGraphRegionHeight;

    if (bInvert === true)
        yVolumePos = rectGraphRegion.m_nBottom - yVolumePos + rectGraphRegion.m_nTop;

    var BarPosInfo = new CBarPosInfo();

    BarPosInfo.m_BongXPosInfo = this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray[this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray.length - 1];

    if (yVolumePos > yZeroPos) {
        BarPosInfo.m_Top = yZeroPos;
        BarPosInfo.m_Bottom = yVolumePos;
    }
    else {
        BarPosInfo.m_Top = yVolumePos;
        BarPosInfo.m_Bottom = yZeroPos;
    }

    ////////////////////////////////////////////////////////////////////////
    //y축 보이는 봉중에서 최신 종가 및 등락율 보여주는 기능 처리를 위해 추가
    if (this.m_rSubGraph.m_ViewLatestData)
        this.m_rSubGraph.m_ViewPrevData = this.m_rSubGraph.m_ViewLatestData;

    this.m_rSubGraph.m_ViewLatestData = rPacketItemData.m_Data;
    ////////////////////////////////////////////////////////////////////////

    switch (this.m_rPropertyInfo.m_nCompareType) {

        case COMPARE_TYPE_NO://비교없음
            {
                BarTypeInfo[0].m_BarPosInfoArray[BarTypeInfo[0].m_BarPosInfoArray.length] = BarPosInfo;
                this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[0].m_clrBar;
            }
            break;
        case COMPARE_TYPE_ZERO://0기준
            {
                //0보다 큰 경우 상승
                if (rPacketItemData.m_Data > 0) {
                    BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                    this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                }
                else {
                    BarTypeInfo[2].m_BarPosInfoArray[BarTypeInfo[2].m_BarPosInfoArray.length] = BarPosInfo;
                    this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[2].m_clrBar;
                }
            }
            break;
        case COMPARE_TYPE_PREV_VALUE://이전값
            {
                var bProcess = false;
                //var rPrevRQPackets = rRQPackets.m_rPrevRQPacketsItem;
                if (rPrevRQPackets !== null) {
                    rPrevRQPacketItemData = rPrevRQPackets.m_Packets[this.m_rSubGraph.m_rPacketData.m_nPacketIndex];
                    if (rPrevRQPacketItemData !== undefined) {
                        if (rPrevRQPacketItemData.m_Data < rPacketItemData.m_Data) {
                            bProcess = true;
                            BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                        }
                        else {
                            bProcess = true;
                            BarTypeInfo[2].m_BarPosInfoArray[BarTypeInfo[2].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[2].m_clrBar;
                        }
                    }
                }

                if (bProcess === false) {
                    BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                    this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                }
            }
            break;
        case COMPARE_TYPE_PREV_CLOSE://이전종가
            {
                var bProcess = false;
                var rRQClosePacketItemData = rRQPackets.m_Packets[nClosePacketIndex];
                if (rRQClosePacketItemData !== undefined) {

                    if (rPrevRQPackets !== null) {

                        rPrevRQPacketItemData = rPrevRQPackets.m_Packets[nClosePacketIndex];
                        if (rPrevRQPacketItemData !== undefined) {
                            if (rPrevRQPacketItemData.m_Data < rRQClosePacketItemData.m_Data) {
                                bProcess = true;
                                BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                                this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                            }
                            else {
                                bProcess = true;
                                BarTypeInfo[2].m_BarPosInfoArray[BarTypeInfo[2].m_BarPosInfoArray.length] = BarPosInfo;
                                this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[2].m_clrBar;
                            }
                        }
                    }
                }

                if (bProcess === false) {
                    BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                    this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                }
            }
            break;
        case COMPARE_TYPE_PREV_HIGH://이전고가
            {
                var bProcess = false;
                var rRQHighPacketItemData = rRQPackets.m_Packets[nHighPacketIndex];
                if (rRQHighPacketItemData !== undefined) {

                    if (rPrevRQPackets !== null) {

                        rPrevRQPacketItemData = rPrevRQPackets.m_Packets[nHighPacketIndex];
                        if (rPrevRQPacketItemData !== undefined) {
                            if (rPrevRQPacketItemData.m_Data < rRQHighPacketItemData.m_Data) {
                                bProcess = true;
                                BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                                this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                            }
                            else {
                                bProcess = true;
                                BarTypeInfo[2].m_BarPosInfoArray[BarTypeInfo[2].m_BarPosInfoArray.length] = BarPosInfo;
                                this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[2].m_clrBar;
                            }
                        }
                    }
                }

                if (bProcess === false) {
                    BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                    this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                }
            }
            break;
        case COMPARE_TYPE_CUR_OPEN://현재시가
            {
                var bProcess = false;
                var rRQClosePacketItemData = rRQPackets.m_Packets[nClosePacketIndex];
                if (rRQClosePacketItemData !== undefined) {

                    rRQOpenPacketItemData = rRQPackets.m_Packets[nOpenPacketIndex];
                    if (rRQOpenPacketItemData !== undefined) {
                        if (rRQOpenPacketItemData.m_Data < rRQClosePacketItemData.m_Data) {
                            bProcess = true;
                            BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                        }
                        else {
                            bProcess = true;
                            BarTypeInfo[2].m_BarPosInfoArray[BarTypeInfo[2].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[2].m_clrBar;
                        }
                    }

                }

                if (bProcess === false) {
                    BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                    this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                }
            }
            break;
        case COMPARE_TYPE_CANDLE://가격차트
            {
                var rClosePacketItemData = rRQPackets.m_Packets[nClosePacketIndex];
                var rOpenPacketItemData = rRQPackets.m_Packets[nOpenPacketIndex];
                var rHighPacketItemData = rRQPackets.m_Packets[nHighPacketIndex];
                var rLowPacketItemData = rRQPackets.m_Packets[nLowPacketIndex];

                var PrevClose = this.m_rSubGraph.m_PrevClose;

                if (PrevClose !== null) {
                    if (rOpenPacketItemData.m_Data > PrevClose)//상승
                    {
                        if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//양봉
                        {
                            BarTypeInfo[0].m_BarPosInfoArray[BarTypeInfo[0].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[0].m_clrBar;
                        }
                        else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//음봉
                        {
                            BarTypeInfo[1].m_BarPosInfoArray[BarTypeInfo[1].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[1].m_clrBar;
                        }
                        else//보합
                        {
                            BarTypeInfo[5].m_BarPosInfoArray[BarTypeInfo[5].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[5].m_clrBar;
                        }
                    }
                    else if (rOpenPacketItemData.m_Data < PrevClose)//하락
                    {
                        if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//양봉
                        {
                            BarTypeInfo[2].m_BarPosInfoArray[BarTypeInfo[2].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[2].m_clrBar;
                        }
                        else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//음봉
                        {
                            BarTypeInfo[3].m_BarPosInfoArray[BarTypeInfo[3].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[3].m_clrBar;
                        }
                        else//보합
                        {
                            BarTypeInfo[5].m_BarPosInfoArray[BarTypeInfo[5].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[5].m_clrBar;
                        }
                    }
                    else {
                        if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//상승양봉
                        {
                            BarTypeInfo[0].m_BarPosInfoArray[BarTypeInfo[0].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[0].m_clrBar;
                        }
                        else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//하락음봉
                        {
                            BarTypeInfo[3].m_BarPosInfoArray[BarTypeInfo[3].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[3].m_clrBar;
                        }
                        else//보합
                        {
                            BarTypeInfo[5].m_BarPosInfoArray[BarTypeInfo[5].m_BarPosInfoArray.length] = BarPosInfo;
                            this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[5].m_clrBar;
                        }
                    }
                }
                else {
                    if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//상승양봉
                    {
                        BarTypeInfo[0].m_BarPosInfoArray[BarTypeInfo[0].m_BarPosInfoArray.length] = BarPosInfo;
                        this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[0].m_clrBar;
                    }
                    else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//하락음봉
                    {
                        BarTypeInfo[3].m_BarPosInfoArray[BarTypeInfo[3].m_BarPosInfoArray.length] = BarPosInfo;
                        this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[3].m_clrBar;
                    }
                    else//보합
                    {
                        BarTypeInfo[5].m_BarPosInfoArray[BarTypeInfo[5].m_BarPosInfoArray.length] = BarPosInfo;
                        this.m_rSubGraph.m_clrViewLatestData = BarTypeInfo[5].m_clrBar;
                    }
                }

                this.m_rSubGraph.m_PrevClose = rClosePacketItemData.m_Data;//전봉종가
            }
            break;
    }

    this.m_rPrevBongPosInfo = BarPosInfo;
}

//가격 서브그래프 그리기 처리(봉차트)
CVolumeBarDrawer.prototype.Draw = function (DrawingInfo) {

    /////////////////////////////////////////
    //선택그래프 표시기능
    var SignBongInfoArray = this.m_SignBongInfoArray;
    var nStartSignXPos = this.m_rSubGraph.m_rRQInCol.m_nStartSignXPos;
    /////////////////////////////////////////

    var BarTypeInfo = this.m_BongTypeInfo;

    //최소 봉 두께
    var BongMinWidth = this.m_rSubGraph.m_rRQInCol.m_rChartBlockCol.m_BongMinWidth;

    {
        //////////////////////////////////////////////////////////////////
        //BarType은 다르지만 색상값이 같은 경우 하나로 묶는다( beginPath 호출횟수를 줄여 성능향상 목적)
        var i, j;
        var ColorArray = [];

        var nLength = BarTypeInfo.length;
        for (i = 0; i < nLength; i++) {
            if (i === 0) {
                ColorArray[ColorArray.length] = BarTypeInfo[i].m_clrBar;
            }
            else {
                var ColorArrayLength = ColorArray.length;
                for (j = 0; j < ColorArrayLength; j++) {
                    if (BarTypeInfo[i].m_clrBar === ColorArray[j])
                        break;
                }
                if (j === ColorArrayLength)
                    ColorArray[j] = BarTypeInfo[i].m_clrBar;
            }
        }
        //////////////////////////////////////////////////////////////////

        var BarPosInfo = null;
        var YUpper, YLower;

        var ColorArrayLength = ColorArray.length;

        for (i = 0; i < ColorArrayLength; i++) {

            DrawingInfo.m_Context.beginPath();
            DrawingInfo.m_Context.strokeStyle = ColorArray[i];
            DrawingInfo.m_Context.fillStyle = ColorArray[i];
            DrawingInfo.m_Context.lineWidth = 1;

            for (j = 0; j < nLength; j++) {

                if (ColorArray[i] === BarTypeInfo[j].m_clrBar) {

                    var BarItemIndex, BarItemLength = BarTypeInfo[j].m_BarPosInfoArray.length;
                    for (BarItemIndex = 0; BarItemIndex < BarItemLength; BarItemIndex++) {
                        BarPosInfo = BarTypeInfo[j].m_BarPosInfoArray[BarItemIndex];

                        if (BarPosInfo.m_Bottom > BarPosInfo.m_Top) {
                            YUpper = BarPosInfo.m_Bottom;
                            YLower = BarPosInfo.m_Top;
                        }
                        else {
                            YUpper = BarPosInfo.m_Top;
                            YLower = BarPosInfo.m_Bottom;
                        }

                        if (BarTypeInfo[j].m_bFill)
                            DrawingInfo.m_Context.fillRect(BarPosInfo.m_BongXPosInfo.m_OpenXPos, YLower, BarPosInfo.m_BongXPosInfo.m_CloseXPos - BarPosInfo.m_BongXPosInfo.m_OpenXPos, YUpper - YLower);
                        else
                            DrawingInfo.m_Context.strokeRect(BarPosInfo.m_BongXPosInfo.m_OpenXPos, YLower, BarPosInfo.m_BongXPosInfo.m_CloseXPos - BarPosInfo.m_BongXPosInfo.m_OpenXPos, YUpper - YLower);
                    }
                }
            }

            DrawingInfo.m_Context.closePath();
            DrawingInfo.m_Context.stroke();
        }
    }

    // 그래프 선택 표시(반전색상)
    if (this.m_rSubGraph.IsDrawSelected(DrawingInfo)) {

        var nSize = gSelectSignSize;
        var nLength = SignBongInfoArray.length;

        for (i = 0; i < nLength; i++) {

            var rBarPosInfo = SignBongInfoArray[i];

            var XCenter = (rBarPosInfo.m_BongXPosInfo.m_OpenXPos + rBarPosInfo.m_BongXPosInfo.m_CloseXPos) / 2;
            var XLeft = XCenter - nSize;
            var XRight = XCenter + nSize;

            var YCenter = (rBarPosInfo.m_Top + rBarPosInfo.m_Bottom) / 2;
            var YTop = YCenter - nSize;
            var YBottom = YCenter + nSize;

            var imgData = DrawingInfo.m_Context.getImageData(XLeft, YTop, XRight - XLeft, YBottom - YTop);
            var nDataLength = imgData.data.length;
            for (var j = 0; j < nDataLength; j += 4) {

                imgData.data[j] = 255 - imgData.data[j];
                imgData.data[j + 1] = 255 - imgData.data[j + 1];
                imgData.data[j + 2] = 255 - imgData.data[j + 2];
                imgData.data[j + 3] = 255;
            }
            DrawingInfo.m_Context.putImageData(imgData, XLeft, YTop);
        }
    }
}

CVolumeBarDrawer.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {

    this.m_rSubGraph.m_MinMaxInfo.Init();

    var rPacketData = this.m_rSubGraph.m_rPacketData;

    gMinMaxInfo.Init();
    var MinMaxInfo = gMinMaxInfo;
    if (rXScaleMng.ExtractMinMaxValue(this.m_rSubGraph.m_rRQSet.m_strRQ, rPacketData.m_strPacketName, MinMaxInfo, bFullScan)) {
        //양수나 음수 한쪽방향으로만 존재하므로 강제로 0범위를 추가한다
        if (MinMaxInfo.m_Max * MinMaxInfo.m_Min > 0) {
            if (MinMaxInfo.m_Max < 0)
                MinMaxInfo.m_Max = 0;
            else
                MinMaxInfo.m_Min = 0;

            SubGraphMinMaxInfo.m_bZeroBaseLine = true;
        }
        //max > 0 and min < 0 인 경우이므로 중간에 0이 포함되어 있다.

        if (this.m_rSubGraph.m_MinMaxInfo.m_Max === null || this.m_rSubGraph.m_MinMaxInfo.m_Max < MinMaxInfo.m_Max)
            this.m_rSubGraph.m_MinMaxInfo.m_Max = MinMaxInfo.m_Max;

        if (this.m_rSubGraph.m_MinMaxInfo.m_Min === null || this.m_rSubGraph.m_MinMaxInfo.m_Min > MinMaxInfo.m_Min)
            this.m_rSubGraph.m_MinMaxInfo.m_Min = MinMaxInfo.m_Min;

        this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex = MinMaxInfo.m_nStartIndex;
        this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex = MinMaxInfo.m_nEndIndex;
    }

    if (SubGraphMinMaxInfo.m_Max === null)
        SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;
    else if (SubGraphMinMaxInfo.m_Max < this.m_rSubGraph.m_MinMaxInfo.m_Max)
        SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;

    if (SubGraphMinMaxInfo.m_Min === null)
        SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;
    else if (SubGraphMinMaxInfo.m_Min > this.m_rSubGraph.m_MinMaxInfo.m_Min)
        SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;

    SubGraphMinMaxInfo.m_nStartIndex = this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex;
    SubGraphMinMaxInfo.m_nEndIndex = this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex;
}

CVolumeBarDrawer.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {

    var rPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rPacketData.m_nPacketIndex];
    if (rPacketItemData === undefined)
        return false;

    var yPos = null;
    var yValue = null;

    var nViewStartIndex = rXScaleMng.m_nViewStartIndex;
    var nViewEndIndex = rXScaleMng.m_nViewEndIndex;

    var nGraphRegionWidth = rectGraphRegion.Width();
    var nGraphRegionHeight = rectGraphRegion.Height();
    var nViewDataCnt = nViewEndIndex - nViewStartIndex + 1;

    //최소 봉 두께
    var BarMinWidth = nGraphRegionWidth / nViewDataCnt;

    var i, j;
    var strRQ = this.m_rSubGraph.m_rRQSet.GetRQ();

    var xPosLeft = rectGraphRegion.m_nLeft + BarMinWidth * rRQPackets.m_nRelativeStartIndex;
    var xPosRight = rectGraphRegion.m_nLeft + BarMinWidth * (rRQPackets.m_nRelativeStartIndex + rRQPackets.m_nRelativeEndIndex);

    var yMin, yMax, yDiff, yZeroPos, yData;
    var bLog = this.m_rSubGraph.GetLog();
    if (bLog === true) {

        yMin = Log(this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit);
        yMax = Log(this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit);
        yData = Log(rPacketItemData.m_Data);
    }
    else {

        yMin = this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit;
        yMax = this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit;
        yData = rPacketItemData.m_Data;
    }

    yDiff = yMax - yMin;

    yZeroPos = rectGraphRegion.m_nBottom - (0 - yMin) / yDiff * nGraphRegionHeight;

    yPos = rectGraphRegion.m_nBottom - (yData - yMin) / yDiff * nGraphRegionHeight;

    if (this.m_rSubGraph.GetInvert() === true) {

        yZeroPos = rectGraphRegion.m_nBottom - yZeroPos + rectGraphRegion.m_nTop;
        yPos = rectGraphRegion.m_nBottom - yPos + rectGraphRegion.m_nTop;
    }

    if ((yPos <= Y && Y <= yZeroPos) && (xPosLeft <= X && X <= xPosRight))
        return true;

    return false;
}
////////////////////////////////////////////////////////////////////////////////
//CPriceCandleDrawer
function CPriceCandleDrawer(rSubGraph) {

    if (rSubGraph === undefined)
        return;

    CBaseDrawer.call(this, rSubGraph);
    
    this.m_rPropertyInfo = this.m_rSubGraph.m_PriceCandleTypeInfo;

    this.m_BongTypeInfo = [];
    this.m_nPrevBongTypeIndex = null;
}
CPriceCandleDrawer.prototype = new CBaseDrawer();
CPriceCandleDrawer.prototype.constructor = CPriceCandleDrawer;

CPriceCandleDrawer.prototype.InitRendering = function () {

    this.m_rPrevBongPosInfo = null;

    this.m_nPrevBongTypeIndex = null;

    this.m_SignBongInfoArray.length = 0;
    
    this.m_BongTypeInfo.length = 0;
    //상승양봉
    this.m_BongTypeInfo[0] = new CBongInfo();
    this.m_BongTypeInfo[0].m_clrBong = this.m_rPropertyInfo.m_clrUpturnPlus;
    this.m_BongTypeInfo[0].m_bFill = this.m_rPropertyInfo.m_bFillUpturnPlus;

    //상승음봉
    this.m_BongTypeInfo[1] = new CBongInfo();
    this.m_BongTypeInfo[1].m_clrBong = this.m_rPropertyInfo.m_clrUpturnMinus;
    this.m_BongTypeInfo[1].m_bFill = this.m_rPropertyInfo.m_bFillUpturnMinus;

    //하락양봉
    this.m_BongTypeInfo[2] = new CBongInfo();
    this.m_BongTypeInfo[2].m_clrBong = this.m_rPropertyInfo.m_clrDropPlus;
    this.m_BongTypeInfo[2].m_bFill = this.m_rPropertyInfo.m_bFillDropPlus;

    //하락음봉
    this.m_BongTypeInfo[3] = new CBongInfo();
    this.m_BongTypeInfo[3].m_clrBong = this.m_rPropertyInfo.m_clrDropMinus;
    this.m_BongTypeInfo[3].m_bFill = this.m_rPropertyInfo.m_bFillDropMinus;

    //갭음봉
    this.m_BongTypeInfo[4] = new CBongInfo();
    this.m_BongTypeInfo[4].m_clrBong = this.m_rPropertyInfo.m_clrGapMinus;
    this.m_BongTypeInfo[4].m_bFill = this.m_rPropertyInfo.m_bFillGapMinus;

    //보합(시가=종가)
    this.m_BongTypeInfo[5] = new CBongInfo();
    this.m_BongTypeInfo[5].m_clrBong = this.m_rPropertyInfo.m_clrSteadyTone;
    this.m_BongTypeInfo[5].m_bFill = this.m_rPropertyInfo.m_bFillSteadyTone;
}
CPriceCandleDrawer.prototype.RenderingInLoop = function (RenderingInfo) {

    var rRQPackets = this.m_rSubGraph.m_rRQInCol.m_rRQPackets;
    var rPrevRQPackets = this.m_rSubGraph.m_rRQInCol.m_rPrevRQPackets;

    var PrevClose = this.m_rSubGraph.m_PrevClose;
    var BongTypeInfo = this.m_BongTypeInfo;

    var rectGraphRegion = this.m_rSubGraph.m_Graph.m_rBlock.m_rectGraphRegion;
    var nGraphRegionHeight = rectGraphRegion.Height();

    var yClosePos = null, yOpenPos = null, yHighPos = null, yLowPos = null;

    var nOpenPacketIndex = this.m_rSubGraph.m_rRQSet.m_nOpenPacketIndex;
    var nHighPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHighPacketIndex;
    var nLowPacketIndex = this.m_rSubGraph.m_rRQSet.m_nLowPacketIndex;
    var nClosePacketIndex = this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex;

    var bLog = this.m_rSubGraph.GetLog();
    var bInvert = this.m_rSubGraph.GetInvert();
    var CData, OData, HData, LData;
    var rClosePacketItemData, rOpenPacketItemData, rHighPacketItemData, rLowPacketItemData;
    var yMin = this.m_rSubGraph.m_yMin, yMax = this.m_rSubGraph.m_yMax, yDiff = this.m_rSubGraph.m_yDiff;

    if (bLog) {

        rClosePacketItemData = rRQPackets.m_Packets[nClosePacketIndex];
        if (!rClosePacketItemData)
            return;
        CData = Log(rClosePacketItemData.m_Data);

        rOpenPacketItemData = rRQPackets.m_Packets[nOpenPacketIndex];
        if (!rOpenPacketItemData)
            return;
        OData = Log(rOpenPacketItemData.m_Data);

        rHighPacketItemData = rRQPackets.m_Packets[nHighPacketIndex];
        if (!rHighPacketItemData)
            return;
        HData = Log(rHighPacketItemData.m_Data);

        rLowPacketItemData = rRQPackets.m_Packets[nLowPacketIndex];
        if (!rLowPacketItemData)
            return;
        LData = Log(rLowPacketItemData.m_Data);
    }
    else {

        rClosePacketItemData = rRQPackets.m_Packets[nClosePacketIndex];
        if (!rClosePacketItemData)
            return;
        CData = rClosePacketItemData.m_Data;

        rOpenPacketItemData = rRQPackets.m_Packets[nOpenPacketIndex];
        if (!rOpenPacketItemData)
            return;
        OData = rOpenPacketItemData.m_Data;

        rHighPacketItemData = rRQPackets.m_Packets[nHighPacketIndex];
        if (!rHighPacketItemData)
            return;
        HData = rHighPacketItemData.m_Data;

        rLowPacketItemData = rRQPackets.m_Packets[nLowPacketIndex];
        if (!rLowPacketItemData)
            return;
        LData = rLowPacketItemData.m_Data;
    }

    yClosePos = Math.round(rectGraphRegion.m_nBottom - (CData - yMin) / yDiff * nGraphRegionHeight);
    yOpenPos = Math.round(rectGraphRegion.m_nBottom - (OData - yMin) / yDiff * nGraphRegionHeight);
    yHighPos = Math.round(rectGraphRegion.m_nBottom - (HData - yMin) / yDiff * nGraphRegionHeight);
    yLowPos = Math.round(rectGraphRegion.m_nBottom - (LData - yMin) / yDiff * nGraphRegionHeight);

    if (bInvert === true) {

        yClosePos = Math.round(rectGraphRegion.m_nBottom - yClosePos + rectGraphRegion.m_nTop);
        yOpenPos = Math.round(rectGraphRegion.m_nBottom - yOpenPos + rectGraphRegion.m_nTop);
        yHighPos = Math.round(rectGraphRegion.m_nBottom - yHighPos + rectGraphRegion.m_nTop);
        yLowPos = Math.round(rectGraphRegion.m_nBottom - yLowPos + rectGraphRegion.m_nTop);
    }

    var BongPosInfo = new CBongPosInfo();

    BongPosInfo.m_BongXPosInfo = this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray[this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray.length - 1];

    BongPosInfo.m_OpenYPos = yOpenPos;
    BongPosInfo.m_HighYPos = yHighPos;
    BongPosInfo.m_LowYPos = yLowPos;
    BongPosInfo.m_CloseYPos = yClosePos;

    ////////////////////////////////////////////////////////////////////////
    //y축 보이는 봉중에서 최신 종가 및 등락율 보여주는 기능 처리를 위해 추가
    if (this.m_rSubGraph.m_ViewLatestData)
        this.m_rSubGraph.m_ViewPrevData = this.m_rSubGraph.m_ViewLatestData;

    this.m_rSubGraph.m_ViewLatestData = rClosePacketItemData.m_Data;
    //y축 보이는 봉중에서 최신 종가 및 등락율 보여주는 기능 처리를 위해 추가
    ////////////////////////////////////////////////////////////////////////
    var nBongTypeIndex = null;
    if (PrevClose) {

        if (rClosePacketItemData.m_Data > PrevClose)//상승
        {
            if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//양봉
                nBongTypeIndex = 0;
            else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//음봉
                nBongTypeIndex = 1;
            else//보합
                nBongTypeIndex = this.m_rPropertyInfo.m_bSteadyClrFollowToUpDropClr === true ? 0 : 5;
        }
        else if (rClosePacketItemData.m_Data < PrevClose)//하락
        {
            if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//양봉
                nBongTypeIndex = 2;
            else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//음봉
                nBongTypeIndex = (rOpenPacketItemData.m_Data < PrevClose) ? 4 : 3;//갭음봉
            else//보합
                nBongTypeIndex = this.m_rPropertyInfo.m_bSteadyClrFollowToUpDropClr === true ? 3 : 5;
        }
        else {//이전봉종가와 현재봉종가가 같은 경우 기본적으로 상승, 하지만 현재봉시가와 현재봉종가가 같으면 이전봉 색상을 따라감

            if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//상승양봉
                nBongTypeIndex = 0;
            else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//상승음봉
                nBongTypeIndex = 1;
            else
                nBongTypeIndex = (this.m_rPropertyInfo.m_bSteadyClrFollowToUpDropClr === true) ? (this.m_nPrevBongTypeIndex === null ? 5 : this.m_nPrevBongTypeIndex) : 5;//이전봉과 현재봉종가가 같고 현재봉시가와 종가가 같은 경우 이전봉 색상 따라감
        }
    }
    else {//이전종가가 없는 경우

        if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//상승양봉
            nBongTypeIndex = 0;
        else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//하락음봉
            nBongTypeIndex = 3;
        else//보합
            nBongTypeIndex = (this.m_bSteadyClrFollowToUpDropClr === true) ? 0 : 5;//이전봉과 현재봉종가가 같고 현재봉시가와 종가가 같은 경우 이전봉 색상 따라감
    }

    if (nBongTypeIndex !== null) {

        BongTypeInfo[nBongTypeIndex].m_BongPosInfoArray[BongTypeInfo[nBongTypeIndex].m_BongPosInfoArray.length] = BongPosInfo;
    }

    // 스마트 시그널 신호 히스토리 렌더링 그리기 작업 >>>>>
    if (rClosePacketItemData.m_SignalItemData !== null) {
    
        var nSignalType = rClosePacketItemData.m_SignalItemData.GetSignalType();
        BongPosInfo.m_nSignalType = nSignalType;

        // 스마트 시그널 Y 값 셋팅
        var nMargin = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_rSmartSignalProperty.m_nSignalArrowMargin;
        
        if (nSignalType & 0x01) { // 매수
            if (bInvert)
                BongPosInfo.m_BuySignalYPos = BongPosInfo.m_LowYPos - nMargin;
            else
                BongPosInfo.m_BuySignalYPos = BongPosInfo.m_LowYPos + nMargin;
        }
        if (nSignalType & 0x02) { // 매도
            if (bInvert)
                BongPosInfo.m_SellSignalYPos = BongPosInfo.m_HighYPos + nMargin;
            else
                BongPosInfo.m_SellSignalYPos = BongPosInfo.m_HighYPos - nMargin;
        }
    }
    // 스마트 시그널 신호 히스토리 렌더링 그리기 작업 <<<<<<

    this.m_rSubGraph.m_PrevClose = rClosePacketItemData.m_Data;//전봉종가
    this.m_nPrevBongTypeIndex = nBongTypeIndex;
    this.m_rPrevBongPosInfo = BongPosInfo;
}

//가격 서브그래프 그리기 처리(봉차트)
CPriceCandleDrawer.prototype.Draw = function (DrawingInfo) {

    /////////////////////////////////////////
    //선택그래프 표시기능
    var SignBongInfoArray = this.m_SignBongInfoArray;
    var nStartSignXPos = this.m_rSubGraph.m_rRQInCol.m_nStartSignXPos;
    /////////////////////////////////////////

    var BongTypeInfo = this.m_BongTypeInfo;

    //최소 봉 두께
    var BongMinWidth = this.m_rSubGraph.m_rRQInCol.m_rChartBlockCol.m_BongMinWidth;

    //////////////////////////////////////////////////////////////////
    //BongType은 다르지만 색상값이 같은 경우 하나로 묶는다( beginPath 호출횟수를 줄여 성능향상 목적)
    var i, j;
    var ColorArray = [];
    var ColorArrayLength = ColorArray.length;

    var nLength = BongTypeInfo.length;
    for (i = 0; i < nLength; i++) {
        if (i === 0) {
            ColorArray[ColorArray.length] = BongTypeInfo[i].m_clrBong;
        }
        else {
            ColorArrayLength = ColorArray.length;
            for (j = 0; j < ColorArrayLength; j++) {
                if (BongTypeInfo[i].m_clrBong === ColorArray[j])
                    break;
            }
            if (j === ColorArrayLength)
                ColorArray[j] = BongTypeInfo[i].m_clrBong;
        }
    }
    //////////////////////////////////////////////////////////////////

    var BongPosInfo = null;
    var YUpper, YLower;
    var nLeftX, nRightX, nCenterX;
    var Width;
    ColorArrayLength = ColorArray.length;

    var BuySignalBongPosArray = [];
    var SellSignalBongPosArray = [];

    for (i = 0; i < ColorArrayLength; i++) {

        DrawingInfo.m_Context.beginPath();
        DrawingInfo.m_Context.strokeStyle = ColorArray[i];
        DrawingInfo.m_Context.fillStyle = ColorArray[i];
        DrawingInfo.m_Context.lineWidth = 1;

        for (j = 0; j < nLength; j++) {
            if (ColorArray[i] === BongTypeInfo[j].m_clrBong) {

                var BongItemIndex, BongItemLength = BongTypeInfo[j].m_BongPosInfoArray.length;
                for (BongItemIndex = 0; BongItemIndex < BongItemLength; BongItemIndex++) {
                    BongPosInfo = BongTypeInfo[j].m_BongPosInfoArray[BongItemIndex];

                    if (BongPosInfo.m_OpenYPos > BongPosInfo.m_CloseYPos) {
                        YUpper = BongPosInfo.m_OpenYPos;
                        YLower = BongPosInfo.m_CloseYPos;
                    }
                    else {
                        YUpper = BongPosInfo.m_CloseYPos;
                        YLower = BongPosInfo.m_OpenYPos;
                    }

                    nLeftX = Math.floor(BongPosInfo.m_BongXPosInfo.m_OpenXPos) + 0.5;
                    nRightX = Math.floor(BongPosInfo.m_BongXPosInfo.m_CloseXPos) + 0.5;
                    nCenterX = Math.floor(BongPosInfo.m_BongXPosInfo.m_HighXPos) + 0.5;
                    Width = nRightX - nLeftX;
                    if (Width <= 0) Width = 1;
                    //var Width = Math.floor(BongPosInfo.m_BongXPosInfo.m_CloseXPos) - BongPosInfo.m_BongXPosInfo.m_OpenXPos;

                    if (2 <= Width) {

                        if (YUpper - YLower < 1) {

                            //DrawingInfo.m_Context.moveTo(BongPosInfo.m_BongXPosInfo.m_OpenXPos, YLower);
                            //DrawingInfo.m_Context.lineTo(BongPosInfo.m_BongXPosInfo.m_CloseXPos, YLower);
                            DrawingInfo.m_Context.moveTo(nLeftX, YLower + 0.5);
                            DrawingInfo.m_Context.lineTo(nRightX, YLower + 0.5);

                            if (BongPosInfo.m_HighYPos < YLower || YUpper < BongPosInfo.m_LowYPos) {

                                if (DrawingInfo.m_rectGraphRegion.m_nLeft < nCenterX && nCenterX < DrawingInfo.m_rectGraphRegion.m_nRight) {

                                    DrawingInfo.m_Context.moveTo(nCenterX, BongPosInfo.m_HighYPos + 0.5);
                                    DrawingInfo.m_Context.lineTo(nCenterX, BongPosInfo.m_LowYPos + 0.5);
                                }
                            }
                        }
                        else {
                            if (BongTypeInfo[j].m_bFill) {

                                DrawingInfo.m_Context.fillRect(nLeftX, YLower, Width, YUpper - YLower);

                                if (BongPosInfo.m_HighYPos < YLower || YUpper < BongPosInfo.m_LowYPos) {

                                    if (DrawingInfo.m_rectGraphRegion.m_nLeft < nCenterX && nCenterX < DrawingInfo.m_rectGraphRegion.m_nRight) {

                                        DrawingInfo.m_Context.moveTo(nCenterX, BongPosInfo.m_HighYPos + 0.5);
                                        DrawingInfo.m_Context.lineTo(nCenterX, BongPosInfo.m_LowYPos + 0.5);
                                    }
                                }
                            }
                            else {
                                
                                DrawingInfo.m_Context.strokeRect(nLeftX, YLower + 0.5, Width, YUpper - YLower);

                                if (DrawingInfo.m_rectGraphRegion.m_nLeft < nCenterX && nCenterX < DrawingInfo.m_rectGraphRegion.m_nRight) {

                                    if (BongPosInfo.m_HighYPos < YLower) {

                                        DrawingInfo.m_Context.moveTo(nCenterX, BongPosInfo.m_HighYPos + 0.5);
                                        DrawingInfo.m_Context.lineTo(nCenterX, YLower + 0.5);
                                    }

                                    if (YUpper < BongPosInfo.m_LowYPos) {

                                        DrawingInfo.m_Context.moveTo(nCenterX, BongPosInfo.m_LowYPos + 0.5);
                                        DrawingInfo.m_Context.lineTo(nCenterX, YUpper + 0.5);
                                    }
                                }
                            }
                        }
                    }
                    else {

                        //DrawingInfo.m_Context.fillRect(BongPosInfo.m_BongXPosInfo.m_OpenXPos, BongPosInfo.m_HighYPos, Width, BongPosInfo.m_LowYPos - BongPosInfo.m_HighYPos);
                        DrawingInfo.m_Context.fillRect(nLeftX, BongPosInfo.m_HighYPos + 0.5, Width, BongPosInfo.m_LowYPos - BongPosInfo.m_HighYPos);
                    }

                    if (this.m_rSubGraph.m_Graph.m_rSmartSignalMng !== null) {

                        if (BongPosInfo.m_nSignalType & 0x01) {
                            BuySignalBongPosArray[BuySignalBongPosArray.length] = BongPosInfo;
                        }

                        if (BongPosInfo.m_nSignalType & 0x02) {
                            SellSignalBongPosArray[SellSignalBongPosArray.length] = BongPosInfo;
                        }
                    }
                }
            }
        }

        DrawingInfo.m_Context.closePath();
        DrawingInfo.m_Context.stroke();
    }

    if (this.m_rSubGraph.m_Graph.m_rSmartSignalMng !== null) {

        var nArrowWidth = null;
        var nArrowMinWidth = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_rSmartSignalProperty.m_nSignalArrowMinWidth;
        var nArrowMaxWidth = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_rSmartSignalProperty.m_nSignalArrowMaxWidth;
        var nMargin = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_rSmartSignalProperty.m_nSignalArrowMargin;
        var nBongWidth = this.m_rSubGraph.m_rRQInCol.m_rChartBlockCol.m_BongMinWidth;

        if (nBongWidth >= nArrowMaxWidth) {
            nArrowWidth = nArrowMaxWidth;
        }
        else if (nBongWidth < nArrowMinWidth) {
            nArrowWidth = nArrowMinWidth;
        }
        else {
            nArrowWidth = nBongWidth;
        }

        var nArrowHight = nArrowWidth * this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_rSmartSignalProperty.m_SignalArrowHRatio;
        var nArrowHeadHight = nArrowWidth * 0.5;
        var nArrowSticWidth = nArrowWidth * 0.6;
        var nArrowSticHalfWidth = nArrowSticWidth / 2;

        /////////////////////매수 화살표 그리는 영역 //////////////////////////////
        var ArrowXPosArray = [];
        var ArrowYPosArray = [];
        var BuySignalBongPosCnt = BuySignalBongPosArray.length;

        DrawingInfo.m_Context.beginPath();
        DrawingInfo.m_Context.fillStyle = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_rSmartSignalProperty.m_clrSignalBuyArrow;
        DrawingInfo.m_Context.strokeStyle = DrawingInfo.m_Context.fillStyle;

        for (i = 0; i < BuySignalBongPosCnt; i++) {

            var nSignalBuyYPos = BuySignalBongPosArray[i].m_BuySignalYPos;
            if (nSignalBuyYPos <= DrawingInfo.m_rectGraphRegion.m_nTop)
                continue;

            // 스마트 시그널 X 값 셋팅
            var nCenterPos = BuySignalBongPosArray[i].m_BongXPosInfo.m_CenterXPos;

            var nSignalArrowLeftPos, nSignalArrowRightPos, nSignalArrowCenterPos;
            var nHalfWidth = nArrowWidth / 2;
            nSignalArrowLeftPos = nCenterPos - nHalfWidth;
            nSignalArrowRightPos = nCenterPos + nHalfWidth;

            // 화살표 삼각형 그리기 >>>
            ArrowXPosArray[0] = nCenterPos;
            ArrowYPosArray[0] = nSignalBuyYPos;
            ArrowXPosArray[1] = nSignalArrowRightPos;
            ArrowYPosArray[1] = nSignalBuyYPos + nArrowHeadHight;
            ArrowXPosArray[2] = nCenterPos + nArrowSticHalfWidth;
            ArrowYPosArray[2] = nSignalBuyYPos + nArrowHeadHight;
            ArrowXPosArray[3] = nCenterPos + nArrowSticHalfWidth;
            ArrowYPosArray[3] = nSignalBuyYPos + nArrowHight;
            ArrowXPosArray[4] = nCenterPos - nArrowSticHalfWidth;
            ArrowYPosArray[4] = nSignalBuyYPos + nArrowHight;
            ArrowXPosArray[5] = nCenterPos - nArrowSticHalfWidth;
            ArrowYPosArray[5] = nSignalBuyYPos + nArrowHeadHight;
            ArrowXPosArray[6] = nSignalArrowLeftPos;
            ArrowYPosArray[6] = nSignalBuyYPos + nArrowHeadHight;

            DrawingInfo.m_Context.moveTo(nCenterPos, nSignalBuyYPos);

            var ArrowPosCnt = ArrowXPosArray.length;
            for (j = 1; j < ArrowPosCnt; j++) {

                var y = ArrowYPosArray[j] > DrawingInfo.m_rectGraphRegion.m_nBottom ? DrawingInfo.m_rectGraphRegion.m_nBottom : ArrowYPosArray[j];
                DrawingInfo.m_Context.lineTo(ArrowXPosArray[j], y);
            }
        }
        DrawingInfo.m_Context.fill();
        DrawingInfo.m_Context.closePath();
        DrawingInfo.m_Context.stroke();

        /////////////////////매도 화살표 그리는 영역 //////////////////////////////
        var SellSignalBonPosCnt = SellSignalBongPosArray.length;

        DrawingInfo.m_Context.beginPath();
        DrawingInfo.m_Context.fillStyle = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_rSmartSignalProperty.m_clrSignalSellArrow;
        DrawingInfo.m_Context.strokeStyle = DrawingInfo.m_Context.fillStyle;

        for (i = 0; i < SellSignalBonPosCnt; i++) {

            var nSignalSellYPos = SellSignalBongPosArray[i].m_SellSignalYPos;
            if (nSignalSellYPos >= DrawingInfo.m_rectGraphRegion.m_nBottom)
                continue;

            // 스마트 시그널 X 값 셋팅
            var nCenterPos = SellSignalBongPosArray[i].m_BongXPosInfo.m_CenterXPos;

            var nSignalArrowLeftPos, nSignalArrowRightPos, nSignalArrowCenterPos;
            var nHalfWidth = nArrowWidth / 2;
            nSignalArrowLeftPos = nCenterPos - nHalfWidth;
            nSignalArrowRightPos = nCenterPos + nHalfWidth;

            ArrowXPosArray[0] = nCenterPos;
            ArrowYPosArray[0] = nSignalSellYPos;
            ArrowXPosArray[1] = nSignalArrowLeftPos;
            ArrowYPosArray[1] = nSignalSellYPos - nArrowHeadHight;
            ArrowXPosArray[2] = nCenterPos - nArrowSticHalfWidth;
            ArrowYPosArray[2] = nSignalSellYPos - nArrowHeadHight;
            ArrowXPosArray[3] = nCenterPos - nArrowSticHalfWidth;
            ArrowYPosArray[3] = nSignalSellYPos - nArrowHight;
            ArrowXPosArray[4] = nCenterPos + nArrowSticHalfWidth;
            ArrowYPosArray[4] = nSignalSellYPos - nArrowHight;
            ArrowXPosArray[5] = nCenterPos + nArrowSticHalfWidth;
            ArrowYPosArray[5] = nSignalSellYPos - nArrowHeadHight;
            ArrowXPosArray[6] = nSignalArrowRightPos;
            ArrowYPosArray[6] = nSignalSellYPos - nArrowHeadHight;
            
            DrawingInfo.m_Context.moveTo(nCenterPos, nSignalSellYPos);
            var ArrowPosCnt = ArrowXPosArray.length;
            for (j = 1; j < ArrowPosCnt; j++) {

                var y = ArrowYPosArray[j] < DrawingInfo.m_rectGraphRegion.m_nTop ? DrawingInfo.m_rectGraphRegion.m_nTop : ArrowYPosArray[j];
                DrawingInfo.m_Context.lineTo(ArrowXPosArray[j], y);
            }
        }

        DrawingInfo.m_Context.fill();
        DrawingInfo.m_Context.closePath();
        DrawingInfo.m_Context.stroke();
    }

    // 그래프 선택 표시
    if (this.m_rSubGraph.IsDrawSelected(DrawingInfo)) {

        var nSize = gSelectSignSize;
        nLength = SignBongInfoArray.length;
        for (i = 0; i < nLength; i++) {

            var rBongPosInfo = SignBongInfoArray[i];

            var XLeft = rBongPosInfo.m_BongXPosInfo.m_CenterXPos - nSize;
            var XRight = rBongPosInfo.m_BongXPosInfo.m_CenterXPos + nSize;

            var YCenter = (rBongPosInfo.m_HighYPos + rBongPosInfo.m_LowYPos) / 2;
            var YTop = YCenter - nSize;
            var YBottom = YCenter + nSize;

            var imgData = DrawingInfo.m_Context.getImageData(XLeft, YTop, XRight - XLeft, YBottom - YTop);
            var nDataLength = imgData.data.length;
            for (var j = 0; j < nDataLength; j += 4) {

                imgData.data[j] = 255 - imgData.data[j];
                imgData.data[j + 1] = 255 - imgData.data[j + 1];
                imgData.data[j + 2] = 255 - imgData.data[j + 2];
                imgData.data[j + 3] = 255;
            }
            DrawingInfo.m_Context.putImageData(imgData, XLeft, YTop);
        }
    }
}

CPriceCandleDrawer.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {

    this.m_rSubGraph.m_MinMaxInfo.Init();

    for (var strPacketName in this.m_rSubGraph.m_PacketObj) {
        var rPacketData = this.m_rSubGraph.m_PacketObj[strPacketName];

        gMinMaxInfo.Init();
        var MinMaxInfo = gMinMaxInfo;
        if (rXScaleMng.ExtractMinMaxValue(this.m_rSubGraph.m_rRQSet.m_strRQ, rPacketData.m_strPacketName, MinMaxInfo, bFullScan)) {
            if (this.m_rSubGraph.m_MinMaxInfo.m_Max === null)
                this.m_rSubGraph.m_MinMaxInfo.m_Max = MinMaxInfo.m_Max;
            else if (this.m_rSubGraph.m_MinMaxInfo.m_Max < MinMaxInfo.m_Max)
                this.m_rSubGraph.m_MinMaxInfo.m_Max = MinMaxInfo.m_Max;

            if (this.m_rSubGraph.m_MinMaxInfo.m_Min === null)
                this.m_rSubGraph.m_MinMaxInfo.m_Min = MinMaxInfo.m_Min;
            else if (this.m_rSubGraph.m_MinMaxInfo.m_Min > MinMaxInfo.m_Min)
                this.m_rSubGraph.m_MinMaxInfo.m_Min = MinMaxInfo.m_Min;

            this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex = MinMaxInfo.m_nStartIndex;
            this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex = MinMaxInfo.m_nEndIndex;
        }
    }

    if (SubGraphMinMaxInfo.m_Max === null)
        SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;
    else if (SubGraphMinMaxInfo.m_Max < this.m_rSubGraph.m_MinMaxInfo.m_Max)
        SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;

    if (SubGraphMinMaxInfo.m_Min === null)
        SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;
    else if (SubGraphMinMaxInfo.m_Min > this.m_rSubGraph.m_MinMaxInfo.m_Min)
        SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;

    SubGraphMinMaxInfo.m_nStartIndex = this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex;
    SubGraphMinMaxInfo.m_nEndIndex = this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex;
}

CPriceCandleDrawer.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {

    var rOpenPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rRQSet.m_nOpenPacketIndex];
    var rClosePacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex];
    var rHighPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rRQSet.m_nHighPacketIndex];
    var rLowPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rRQSet.m_nLowPacketIndex];

    if (rHighPacketItemData === undefined || rLowPacketItemData === undefined)
        return false;

    var nViewStartIndex = rXScaleMng.m_nViewStartIndex;
    var nViewEndIndex = rXScaleMng.m_nViewEndIndex;

    var nGraphRegionWidth = rectGraphRegion.Width();
    var nGraphRegionHeight = rectGraphRegion.Height();
    var nViewDataCnt = nViewEndIndex - nViewStartIndex + 1;

    //최소 봉 두께
    var BarMinWidth = nGraphRegionWidth / nViewDataCnt;

    var i, j;
    var strRQ = this.m_rSubGraph.m_rRQSet.GetRQ();

    var xPosLeft = rectGraphRegion.m_nLeft + BarMinWidth * rRQPackets.m_nRelativeStartIndex;
    var xPosRight = rectGraphRegion.m_nLeft + BarMinWidth * (rRQPackets.m_nRelativeStartIndex + rRQPackets.m_nRelativeEndIndex);

    var yMin, yMax, yDiff, yOpenData, yCloseData, yHighData, yLowData;
    var bLog = this.m_rSubGraph.GetLog();
    if (bLog === true) {

        yMin = Log(this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit);
        yMax = Log(this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit);

        yOpenData = Log(rOpenPacketItemData.m_Data);
        yCloseData = Log(rClosePacketItemData.m_Data);
        yHighData = Log(rHighPacketItemData.m_Data);
        yLowData = Log(rLowPacketItemData.m_Data);
    }
    else {

        yMin = this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit;
        yMax = this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit;

        yOpenData = rOpenPacketItemData.m_Data;
        yCloseData = rClosePacketItemData.m_Data;
        yHighData = rHighPacketItemData.m_Data;
        yLowData = rLowPacketItemData.m_Data;
    }

    yDiff = yMax - yMin;

    //////////////////////////////////////
    var yOpenPos = rectGraphRegion.m_nBottom - (yOpenData - yMin) / yDiff * nGraphRegionHeight;
    var yClosePos = rectGraphRegion.m_nBottom - (yCloseData - yMin) / yDiff * nGraphRegionHeight;
    var yHighPos = rectGraphRegion.m_nBottom - (yHighData - yMin) / yDiff * nGraphRegionHeight;
    var yLowPos = rectGraphRegion.m_nBottom - (yLowData - yMin) / yDiff * nGraphRegionHeight;

    if (this.m_rSubGraph.GetInvert() === true) {

        yOpenPos = rectGraphRegion.m_nBottom - yOpenPos + rectGraphRegion.m_nTop;
        yClosePos = rectGraphRegion.m_nBottom - yClosePos + rectGraphRegion.m_nTop;
        yHighPos = rectGraphRegion.m_nBottom - yHighPos + rectGraphRegion.m_nTop;
        yLowPos = rectGraphRegion.m_nBottom - yLowPos + rectGraphRegion.m_nTop;
    }

    //////////////////////////////////////
    if (yClosePos < yOpenPos) {
        if (((yClosePos - 2) <= Y && Y <= (yOpenPos + 2)) && (xPosLeft <= X && X <= xPosRight))
            return true;
    }
    else {
        if (((yOpenPos - 2) <= Y && Y <= (yClosePos + 2)) && (xPosLeft <= X && X <= xPosRight))
            return true;
    }

    var xPosCenter = (xPosLeft + xPosRight) / 2;
    if (((yHighPos - 5) <= Y && Y <= (yLowPos + 5)) && (xPosCenter - 2 <= X && X <= xPosCenter + 2))
        return true;

    return false;
}
////////////////////////////////////////////////////////////////////////////////
//CPriceLineDrawer
function CPriceLineDrawer(rSubGraph) {

    if (rSubGraph === undefined)
        return;

    CBaseDrawer.call(this, rSubGraph);

    this.m_rPropertyInfo = this.m_rSubGraph.m_PriceLineTypeInfo;

    this.m_BongTypeInfo = [];
}
CPriceLineDrawer.prototype = new CBaseDrawer();
CPriceLineDrawer.prototype.constructor = CPriceLineDrawer;

CPriceLineDrawer.prototype.InitRendering = function () {

    this.m_rPrevBongPosInfo = null;

    this.m_SignBongInfoArray.length = 0;

    this.m_BongTypeInfo.length = 0;
    this.m_BongTypeInfo[0] = new CBongInfo();
    this.m_BongTypeInfo[0].m_clrBong = this.m_rPropertyInfo.m_clrLine;
    this.m_BongTypeInfo[0].m_bFill = false;
}
CPriceLineDrawer.prototype.RenderingInLoop = function (RenderingInfo) {

    var rRQPackets = this.m_rSubGraph.m_rRQInCol.m_rRQPackets;
    var BongTypeInfo = this.m_BongTypeInfo;

    var Data, rPacketItemData;

    var rectGraphRegion = this.m_rSubGraph.m_Graph.m_rBlock.m_rectGraphRegion;
    var nGraphRegionHeight = rectGraphRegion.Height();

    var nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex;
    switch (this.m_rPropertyInfo.m_DType) {
        case PRICE_TYPE_OPEN_INDEX:
            nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nOpenPacketIndex;
            break;
        case PRICE_TYPE_HIGH_INDEX:
            nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHighPacketIndex;
            break;
        case PRICE_TYPE_LOW_INDEX:
            nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nLowPacketIndex;
            break;
        case PRICE_TYPE_CLOSE_INDEX:
            nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex;
            break;
        case PRICE_TYPE_HL2_INDEX:
            nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHL2PacketIndex;
            break;
        case PRICE_TYPE_HLC3_INDEX:
            nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHLC3PacketIndex;
            break;
    }
    rPacketItemData = rRQPackets.m_Packets[nPacketIndex];
    if (rPacketItemData === undefined)
        return;

    var yMin = this.m_rSubGraph.m_yMin, yMax = this.m_rSubGraph.m_yMax, yDiff = this.m_rSubGraph.m_yDiff;

    if (this.m_rSubGraph.GetLog() === true)
        Data = Log(rPacketItemData.m_Data);
    else
        Data = rPacketItemData.m_Data;

    var yPos = rectGraphRegion.m_nBottom - (Data - yMin) / yDiff * nGraphRegionHeight;

    if (this.m_rSubGraph.GetInvert() === true)
        yPos = rectGraphRegion.m_nBottom - yPos + rectGraphRegion.m_nTop;

    var BongPosInfo = new CBongPosInfo();

    BongPosInfo.m_BongXPosInfo = this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray[this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray.length - 1];

    BongPosInfo.m_CloseYPos = yPos;

    BongTypeInfo[0].m_BongPosInfoArray[BongTypeInfo[0].m_BongPosInfoArray.length] = BongPosInfo;

    /////////////////////////////////////////////////////////////////////
    if (this.m_rSubGraph.m_ViewLatestData)
        this.m_rSubGraph.m_ViewPrevData = this.m_rSubGraph.m_ViewLatestData;

    this.m_rSubGraph.m_ViewLatestData = rPacketItemData.m_Data;
    /////////////////////////////////////////////////////////////////////

    this.m_rSubGraph.m_clrViewLatestData = BongTypeInfo[0].m_clrBong;

    // 스마트 시그널 신호 히스토리 렌더링 그리기 작업 >>>>>
    var rClosePacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex];
    if (rClosePacketItemData.m_SignalItemData !== null) {

        var nSignalType = rClosePacketItemData.m_SignalItemData.GetSignalType();
        BongPosInfo.m_nSignalType = nSignalType;

        // 스마트 시그널 Y 값 셋팅
        var nMargin = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_SmartSignalProperty.m_nSignalArrowMargin + 4;

        if (nSignalType & 0x01) { // 매수
            if (bInvert)
                BongPosInfo.m_BuySignalYPos = BongPosInfo.m_CloseYPos + nMargin;
            else
                BongPosInfo.m_BuySignalYPos = BongPosInfo.m_CloseYPos - nMargin;
        }
        if (nSignalType & 0x02) { // 매도
            if (bInvert)
                BongPosInfo.m_SellSignalYPos = BongPosInfo.m_CloseYPos - nMargin;
            else
                BongPosInfo.m_SellSignalYPos = BongPosInfo.m_CloseYPos + nMargin;
        }
    }
    // 스마트 시그널 신호 히스토리 렌더링 그리기 작업 <<<<<<

    this.m_rPrevBongPosInfo = BongPosInfo;
}

CPriceLineDrawer.prototype.Draw = function (DrawingInfo) {

    var BongTypeInfo = this.m_BongTypeInfo;

    //최소 봉 두께
    var BongMinWidth = this.m_rSubGraph.m_rRQInCol.m_rChartBlockCol.m_BongMinWidth;

    var BongPosInfo = null;

    DrawingInfo.m_Context.beginPath();

    //선그리기
    switch (this.m_rPropertyInfo.m_nLineType) {
        case PS_SOLID: DrawingInfo.m_Context.setLineDash([0, 0]); break;
        case PS_DASH: DrawingInfo.m_Context.setLineDash([8, 4]); break;
        case PS_DOT: DrawingInfo.m_Context.setLineDash([2, 3]); break;
        default: DrawingInfo.m_Context.setLineDash([0, 0]); break;
    }

    DrawingInfo.m_Context.strokeStyle = this.m_rPropertyInfo.m_clrLine;
    DrawingInfo.m_Context.lineWidth = this.m_rPropertyInfo.m_nThickness + (this.m_rSubGraph.IsDrawSelected(DrawingInfo) ? gSelectSignSize : 0);

    var bDrawStarted = false;
    var xPos, yPos;
    var xStartPos = null, yStartPos = null;
    var BongItemIndex, BongItemLength = BongTypeInfo[0].m_BongPosInfoArray.length;

    //스마트 시그널
    var BuySignalBongPosArray = [];
    var SellSignalBongPosArray = [];

    for (BongItemIndex = 0; BongItemIndex < BongItemLength; BongItemIndex++) {

        BongPosInfo = BongTypeInfo[0].m_BongPosInfoArray[BongItemIndex];

        xPos = BongPosInfo.m_BongXPosInfo.m_CenterXPos;

        if ((DrawingInfo.m_rectGraphRegion.m_nLeft < xPos && xPos < DrawingInfo.m_rectGraphRegion.m_nRight) && (BongItemIndex < BongItemLength - 1)) {

            xStartPos = xPos;
            yStartPos = BongPosInfo.m_CloseYPos;

            bDrawStarted = true;

            BongItemIndex++;

            //스마트 시그널
            if (this.m_rSubGraph.m_Graph.m_rSmartSignalMng !== null) {

                if (BongPosInfo.m_nSignalType & 0x01) {
                    BuySignalBongPosArray[BuySignalBongPosArray.length] = BongPosInfo;
                }

                if (BongPosInfo.m_nSignalType & 0x02) {
                    SellSignalBongPosArray[SellSignalBongPosArray.length] = BongPosInfo;
                }
            }

            break;
        }
    }

    if (bDrawStarted) {

        BongPosInfo = BongTypeInfo[0].m_BongPosInfoArray[BongItemIndex];
        xPos = BongPosInfo.m_BongXPosInfo.m_CenterXPos;

        if (DrawingInfo.m_rectGraphRegion.m_nLeft < xPos && xPos < DrawingInfo.m_rectGraphRegion.m_nRight) {

            yPos = BongPosInfo.m_CloseYPos;

            DrawingInfo.m_Context.moveTo(xStartPos, yStartPos);
            DrawingInfo.m_Context.lineTo(xPos, yPos);

            //스마트 시그널
            if (this.m_rSubGraph.m_Graph.m_rSmartSignalMng !== null) {

                if (BongPosInfo.m_nSignalType & 0x01) {
                    BuySignalBongPosArray[BuySignalBongPosArray.length] = BongPosInfo;
                }

                if (BongPosInfo.m_nSignalType & 0x02) {
                    SellSignalBongPosArray[SellSignalBongPosArray.length] = BongPosInfo;
                }
            }
        }

        BongItemIndex++;

        for (; BongItemIndex < BongItemLength; BongItemIndex++) {

            BongPosInfo = BongTypeInfo[0].m_BongPosInfoArray[BongItemIndex];

            xPos = BongPosInfo.m_BongXPosInfo.m_CenterXPos;

            if (DrawingInfo.m_rectGraphRegion.m_nLeft < xPos && xPos < DrawingInfo.m_rectGraphRegion.m_nRight) {

                yPos = BongPosInfo.m_CloseYPos;

                DrawingInfo.m_Context.lineTo(xPos, yPos);

                //스마트 시그널
                if (this.m_rSubGraph.m_Graph.m_rSmartSignalMng !== null) {

                    if (BongPosInfo.m_nSignalType & 0x01) {
                        BuySignalBongPosArray[BuySignalBongPosArray.length] = BongPosInfo;
                    }

                    if (BongPosInfo.m_nSignalType & 0x02) {
                        SellSignalBongPosArray[SellSignalBongPosArray.length] = BongPosInfo;
                    }
                }
            }
        }
    }

    DrawingInfo.m_Context.stroke();
    DrawingInfo.m_Context.closePath();


    //스마트 시그널
    if (this.m_rSubGraph.m_Graph.m_rSmartSignalMng !== null) {

        var nArrowWidth = null;
        var nArrowMinWidth = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_SmartSignalProperty.m_nSignalArrowMinWidth;
        var nArrowMaxWidth = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_SmartSignalProperty.m_nSignalArrowMaxWidth;
        var nMargin = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_SmartSignalProperty.m_nSignalArrowMargin;
        var nBongWidth = this.m_rSubGraph.m_rRQInCol.m_rChartBlockCol.m_BongMinWidth;

        if (nBongWidth >= nArrowMaxWidth) {
            nArrowWidth = nArrowMaxWidth;
        }
        else if (nBongWidth < nArrowMinWidth) {
            nArrowWidth = nArrowMinWidth;
        }
        else {
            nArrowWidth = nBongWidth;
        }

        var nArrowHight = nArrowWidth * this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_SmartSignalProperty.m_SignalArrowHRatio;
        var nArrowHeadHight = nArrowWidth * 0.5;
        var nArrowSticWidth = nArrowWidth * 0.6;
        var nArrowSticHalfWidth = nArrowSticWidth / 2;

        /////////////////////매수 화살표 그리는 영역 //////////////////////////////
        var ArrowXPosArray = [];
        var ArrowYPosArray = [];
        var BuySignalBongPosCnt = BuySignalBongPosArray.length;

        DrawingInfo.m_Context.beginPath();
        DrawingInfo.m_Context.fillStyle = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_rSmartSignalProperty.m_clrSignalBuyArrow;
        DrawingInfo.m_Context.strokeStyle = DrawingInfo.m_Context.fillStyle;

        for (i = 0; i < BuySignalBongPosCnt; i++) {

            var nSignalBuyYPos = BuySignalBongPosArray[i].m_BuySignalYPos;
            if (nSignalBuyYPos <= DrawingInfo.m_rectGraphRegion.m_nTop)
                continue;

            // 스마트 시그널 X 값 셋팅
            var nCenterPos = BuySignalBongPosArray[i].m_BongXPosInfo.m_CenterXPos;

            var nSignalArrowLeftPos, nSignalArrowRightPos, nSignalArrowCenterPos;
            var nHalfWidth = nArrowWidth / 2;
            nSignalArrowLeftPos = nCenterPos - nHalfWidth;
            nSignalArrowRightPos = nCenterPos + nHalfWidth;

            // 화살표 삼각형 그리기 >>>
            ArrowXPosArray[0] = nCenterPos;
            ArrowYPosArray[0] = nSignalBuyYPos;
            ArrowXPosArray[1] = nSignalArrowRightPos;
            ArrowYPosArray[1] = nSignalBuyYPos + nArrowHeadHight;
            ArrowXPosArray[2] = nCenterPos + nArrowSticHalfWidth;
            ArrowYPosArray[2] = nSignalBuyYPos + nArrowHeadHight;
            ArrowXPosArray[3] = nCenterPos + nArrowSticHalfWidth;
            ArrowYPosArray[3] = nSignalBuyYPos + nArrowHight;
            ArrowXPosArray[4] = nCenterPos - nArrowSticHalfWidth;
            ArrowYPosArray[4] = nSignalBuyYPos + nArrowHight;
            ArrowXPosArray[5] = nCenterPos - nArrowSticHalfWidth;
            ArrowYPosArray[5] = nSignalBuyYPos + nArrowHeadHight;
            ArrowXPosArray[6] = nSignalArrowLeftPos;
            ArrowYPosArray[6] = nSignalBuyYPos + nArrowHeadHight;

            DrawingInfo.m_Context.moveTo(nCenterPos, nSignalBuyYPos);

            var ArrowPosCnt = ArrowXPosArray.length;
            for (j = 1; j < ArrowPosCnt; j++) {

                var y = ArrowYPosArray[j] > DrawingInfo.m_rectGraphRegion.m_nBottom ? DrawingInfo.m_rectGraphRegion.m_nBottom : ArrowYPosArray[j];
                DrawingInfo.m_Context.lineTo(ArrowXPosArray[j], y);
            }
        }
        DrawingInfo.m_Context.fill();
        DrawingInfo.m_Context.closePath();
        DrawingInfo.m_Context.stroke();

        /////////////////////매도 화살표 그리는 영역 //////////////////////////////
        var SellSignalBonPosCnt = SellSignalBongPosArray.length;

        DrawingInfo.m_Context.beginPath();
        DrawingInfo.m_Context.fillStyle = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_rSmartSignalProperty.m_clrSignalSellArrow;
        DrawingInfo.m_Context.strokeStyle = DrawingInfo.m_Context.fillStyle;

        for (i = 0; i < SellSignalBonPosCnt; i++) {

            var nSignalSellYPos = SellSignalBongPosArray[i].m_SellSignalYPos;
            if (nSignalSellYPos >= DrawingInfo.m_rectGraphRegion.m_nBottom)
                continue;

            // 스마트 시그널 X 값 셋팅
            var nCenterPos = SellSignalBongPosArray[i].m_BongXPosInfo.m_CenterXPos;

            var nSignalArrowLeftPos, nSignalArrowRightPos, nSignalArrowCenterPos;
            var nHalfWidth = nArrowWidth / 2;
            nSignalArrowLeftPos = nCenterPos - nHalfWidth;
            nSignalArrowRightPos = nCenterPos + nHalfWidth;

            ArrowXPosArray[0] = nCenterPos;
            ArrowYPosArray[0] = nSignalSellYPos;
            ArrowXPosArray[1] = nSignalArrowLeftPos;
            ArrowYPosArray[1] = nSignalSellYPos - nArrowHeadHight;
            ArrowXPosArray[2] = nCenterPos - nArrowSticHalfWidth;
            ArrowYPosArray[2] = nSignalSellYPos - nArrowHeadHight;
            ArrowXPosArray[3] = nCenterPos - nArrowSticHalfWidth;
            ArrowYPosArray[3] = nSignalSellYPos - nArrowHight;
            ArrowXPosArray[4] = nCenterPos + nArrowSticHalfWidth;
            ArrowYPosArray[4] = nSignalSellYPos - nArrowHight;
            ArrowXPosArray[5] = nCenterPos + nArrowSticHalfWidth;
            ArrowYPosArray[5] = nSignalSellYPos - nArrowHeadHight;
            ArrowXPosArray[6] = nSignalArrowRightPos;
            ArrowYPosArray[6] = nSignalSellYPos - nArrowHeadHight;
            
            DrawingInfo.m_Context.moveTo(nCenterPos, nSignalSellYPos);
            var ArrowPosCnt = ArrowXPosArray.length;
            for (j = 1; j < ArrowPosCnt; j++) {

                var y = ArrowYPosArray[j] < DrawingInfo.m_rectGraphRegion.m_nTop ? DrawingInfo.m_rectGraphRegion.m_nTop : ArrowYPosArray[j];
                DrawingInfo.m_Context.lineTo(ArrowXPosArray[j], y);
            }
        }

        DrawingInfo.m_Context.fill();
        DrawingInfo.m_Context.closePath();
        DrawingInfo.m_Context.stroke();
    }


}

CPriceLineDrawer.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {

    this.m_rSubGraph.m_MinMaxInfo.Init();

    {
        var nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex;
        switch (this.m_rPropertyInfo.m_DType) {
            case PRICE_TYPE_OPEN_INDEX:
                nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nOpenPacketIndex;
                break;
            case PRICE_TYPE_HIGH_INDEX:
                nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHighPacketIndex;
                break;
            case PRICE_TYPE_LOW_INDEX:
                nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nLowPacketIndex;
                break;
            case PRICE_TYPE_CLOSE_INDEX:
                nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex;
                break;
            case PRICE_TYPE_HL2_INDEX:
                nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHL2PacketIndex;
                break;
            case PRICE_TYPE_HLC3_INDEX:
                nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHLC3PacketIndex;
                break;
        }
        var rPacketData = this.m_rSubGraph.m_rRQSet.m_PacketDataArray[nPacketIndex];
        if (rPacketData === undefined)
            return;

        gMinMaxInfo.Init();
        var MinMaxInfo = gMinMaxInfo;
        if (rXScaleMng.ExtractMinMaxValue(this.m_rSubGraph.m_rRQSet.m_strRQ, rPacketData.m_strPacketName, MinMaxInfo, bFullScan)) {
            if (this.m_rSubGraph.m_MinMaxInfo.m_Max === null)
                this.m_rSubGraph.m_MinMaxInfo.m_Max = MinMaxInfo.m_Max;
            else if (this.m_rSubGraph.m_MinMaxInfo.m_Max < MinMaxInfo.m_Max)
                this.m_rSubGraph.m_MinMaxInfo.m_Max = MinMaxInfo.m_Max;

            if (this.m_rSubGraph.m_MinMaxInfo.m_Min === null)
                this.m_rSubGraph.m_MinMaxInfo.m_Min = MinMaxInfo.m_Min;
            else if (this.m_rSubGraph.m_MinMaxInfo.m_Min > MinMaxInfo.m_Min)
                this.m_rSubGraph.m_MinMaxInfo.m_Min = MinMaxInfo.m_Min;

            this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex = MinMaxInfo.m_nStartIndex;
            this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex = MinMaxInfo.m_nEndIndex;
        }
        else {

            this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex = MinMaxInfo.m_nStartIndex;
            this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex = MinMaxInfo.m_nEndIndex;

        }
    }

    if (this.m_rSubGraph.m_MinMaxInfo.m_Max !== null) {
        if (SubGraphMinMaxInfo.m_Max === null)
            SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;
        else if (SubGraphMinMaxInfo.m_Max < this.m_rSubGraph.m_MinMaxInfo.m_Max)
            SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;
    }

    if (this.m_rSubGraph.m_MinMaxInfo.m_Min !== null) {
        if (SubGraphMinMaxInfo.m_Min === null)
            SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;
        else if (SubGraphMinMaxInfo.m_Min > this.m_rSubGraph.m_MinMaxInfo.m_Min)
            SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;
    }

    SubGraphMinMaxInfo.m_nStartIndex = this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex;
    SubGraphMinMaxInfo.m_nEndIndex = this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex;
}

CPriceLineDrawer.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {

    var nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex;
    switch (this.m_rPropertyInfo.m_DType) {
        case PRICE_TYPE_OPEN_INDEX:
            nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nOpenPacketIndex;
            break;
        case PRICE_TYPE_HIGH_INDEX:
            nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHighPacketIndex;
            break;
        case PRICE_TYPE_LOW_INDEX:
            nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nLowPacketIndex;
            break;
        case PRICE_TYPE_CLOSE_INDEX:
            nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex;
            break;
        case PRICE_TYPE_HL2_INDEX:
            nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHL2PacketIndex;
            break;
        case PRICE_TYPE_HLC3_INDEX:
            nPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHLC3PacketIndex;
            break;
    }
    var rPacketItemData = rRQPackets.m_Packets[nPacketIndex];
    if (rPacketItemData === undefined)
        return false;

    var yPos = null;
    var yValue = null;

    var nViewStartIndex = rXScaleMng.m_nViewStartIndex;
    var nViewEndIndex = rXScaleMng.m_nViewEndIndex;

    var nGraphRegionWidth = rectGraphRegion.Width();
    var nGraphRegionHeight = rectGraphRegion.Height();
    var nViewDataCnt = nViewEndIndex - nViewStartIndex + 1;

    var i, j;
    var strRQ = this.m_rSubGraph.m_rRQSet.GetRQ();

    if (rRQPackets.m_rNextRQPacketsItem === null && rRQPackets.m_rPrevRQPacketsItem !== null)
        rRQPackets = rRQPackets.m_rPrevRQPacketsItem;
    else if (rRQPackets.m_rNextRQPacketsItem === null && rRQPackets.m_rPrevRQPacketsItem === null)
        return false;

    if (nViewEndIndex < (nViewStartIndex + rRQPackets.m_nRelativeStartIndex + rRQPackets.m_nRelativeNextStartIndex))
        return false;

    var rNextRQPackets = rRQPackets.m_rNextRQPacketsItem;
    var rNextPacketItemData = rNextRQPackets.m_Packets[this.m_rSubGraph.m_rPacketData.m_nPacketIndex];
    if (rNextPacketItemData === undefined)
        return false;

    var xPos1Left = rectGraphRegion.m_nLeft + nGraphRegionWidth / nViewDataCnt * rRQPackets.m_nRelativeStartIndex;
    var xPos1Right = rectGraphRegion.m_nLeft + nGraphRegionWidth / nViewDataCnt * (rRQPackets.m_nRelativeStartIndex + rRQPackets.m_nRelativeEndIndex);
    var xPos1 = xPos1Left + (xPos1Right - xPos1Left) / 2;

    var xPos2Left = rectGraphRegion.m_nLeft + nGraphRegionWidth / nViewDataCnt * rNextRQPackets.m_nRelativeStartIndex;
    var xPos2Right = rectGraphRegion.m_nLeft + nGraphRegionWidth / nViewDataCnt * (rNextRQPackets.m_nRelativeStartIndex + rNextRQPackets.m_nRelativeEndIndex);
    var xPos2 = xPos2Left + (xPos2Right - xPos2Left) / 2;


    var yMin, yMax, yDiff, yPos1, yPos2, yData, yNextData;

    var bLog = this.m_rSubGraph.GetLog();
    if (bLog === true) {

        yMin = Log(this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit);
        yMax = Log(this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit);

        yData = Log(rPacketItemData.m_Data);
        yNextData = Log(rNextPacketItemData.m_Data);
    }
    else {

        yMin = this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit;
        yMax = this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit;

        yData = rPacketItemData.m_Data;
        yNextData = rNextPacketItemData.m_Data;
    }

    yDiff = yMax - yMin;

    yPos1 = rectGraphRegion.m_nBottom - (yData - yMin) / yDiff * nGraphRegionHeight;
    yPos2 = rectGraphRegion.m_nBottom - (yNextData - yMin) / yDiff * nGraphRegionHeight;

    if (this.m_rSubGraph.GetInvert() === true) {

        yPos1 = rectGraphRegion.m_nBottom - yPos1 + rectGraphRegion.m_nTop;
        yPos2 = rectGraphRegion.m_nBottom - yPos2 + rectGraphRegion.m_nTop;
    }

    var DeltaX = xPos2 - xPos1;
    if (DeltaX !== 0) {
        var a = (yPos2 - yPos1) / DeltaX;//console.log("X:" + X + ", Y:" + Y + " " + "a(" + a + ")=(" + yPos2 + "-" + yPos1 + ")/(" + xPos2 + "-" + xPos1 + ")");
        var b = (yPos1 - a * xPos1);//console.log("b(" + b + ")=(" + yPos1 + "-" + a + " * " + xPos1 + ")");
        var CalcY = a * X + b;//console.log("CalcY(" + CalcY + ")=(" + a + "*" + X + " + " + b + "), Y=" + Y);
        if ((CalcY - (this.m_rPropertyInfo.m_nThickness + 5)) <= Y && Y <= (CalcY + (this.m_rPropertyInfo.m_nThickness + 5))) { //console.log((CalcY - (this.m_nThickness + 5)) + "<=" + Y + " && " + Y + "<=" + (CalcY + this.m_nThickness + 5));
            return true;
        }
    }
    else {
        if ((xPos1 - (this.m_rPropertyInfo.m_nThickness + 5)) <= X && X <= (xPos1 + (this.m_rPropertyInfo.m_nThickness + 5)))
            return true;
    }
    return false;
}

////////////////////////////////////////////////////////////////////////////////
//CPriceBarDrawer
function CPriceBarDrawer(rSubGraph) {

    if (rSubGraph === undefined)
        return;

    CBaseDrawer.call(this, rSubGraph);
    
    this.m_rPropertyInfo = this.m_rSubGraph.m_PriceBarTypeInfo;

    this.m_BongTypeInfo = [];
    this.m_nPrevBongTypeIndex = null;
}
CPriceBarDrawer.prototype = new CBaseDrawer();
CPriceBarDrawer.prototype.constructor = CPriceBarDrawer;

CPriceBarDrawer.prototype.InitRendering = function () {

    this.m_rPrevBongPosInfo = null;

    this.m_nPrevBongTypeIndex = null;

    this.m_SignBongInfoArray.length = 0;
    
    this.m_BongTypeInfo.length = 0;
    //상승양봉
    this.m_BongTypeInfo[0] = new CBongInfo();
    this.m_BongTypeInfo[0].m_clrBong = this.m_rPropertyInfo.m_clrUpturnPlus;

    //상승음봉
    this.m_BongTypeInfo[1] = new CBongInfo();
    this.m_BongTypeInfo[1].m_clrBong = this.m_rPropertyInfo.m_clrUpturnMinus;

    //하락양봉
    this.m_BongTypeInfo[2] = new CBongInfo();
    this.m_BongTypeInfo[2].m_clrBong = this.m_rPropertyInfo.m_clrDropPlus;

    //하락음봉
    this.m_BongTypeInfo[3] = new CBongInfo();
    this.m_BongTypeInfo[3].m_clrBong = this.m_rPropertyInfo.m_clrDropMinus;

    //갭음봉
    this.m_BongTypeInfo[4] = new CBongInfo();
    this.m_BongTypeInfo[4].m_clrBong = this.m_rPropertyInfo.m_clrGapMinus;

    //보합(시가=종가)
    this.m_BongTypeInfo[5] = new CBongInfo();
    this.m_BongTypeInfo[5].m_clrBong = this.m_rPropertyInfo.m_clrSteadyTone;
}
CPriceBarDrawer.prototype.RenderingInLoop = function (RenderingInfo) {

    var rRQPackets = this.m_rSubGraph.m_rRQInCol.m_rRQPackets;
    var rPrevRQPackets = this.m_rSubGraph.m_rRQInCol.m_rPrevRQPackets;

    var PrevClose = this.m_rSubGraph.m_PrevClose;
    var BongTypeInfo = this.m_BongTypeInfo;

    var rectGraphRegion = this.m_rSubGraph.m_Graph.m_rBlock.m_rectGraphRegion;
    var nGraphRegionHeight = rectGraphRegion.Height();

    var yClosePos = null, yOpenPos = null, yHighPos = null, yLowPos = null;

    var nOpenPacketIndex = this.m_rSubGraph.m_rRQSet.m_nOpenPacketIndex;
    var nHighPacketIndex = this.m_rSubGraph.m_rRQSet.m_nHighPacketIndex;
    var nLowPacketIndex = this.m_rSubGraph.m_rRQSet.m_nLowPacketIndex;
    var nClosePacketIndex = this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex;

    var bLog = this.m_rSubGraph.GetLog();
    var bInvert = this.m_rSubGraph.GetInvert();
    var CData, OData, HData, LData;
    var rClosePacketItemData, rOpenPacketItemData, rHighPacketItemData, rLowPacketItemData;
    var yMin = this.m_rSubGraph.m_yMin, yMax = this.m_rSubGraph.m_yMax, yDiff = this.m_rSubGraph.m_yDiff;

    if (bLog) {

        rClosePacketItemData = rRQPackets.m_Packets[nClosePacketIndex];
        if (!rClosePacketItemData)
            return;
        CData = Log(rClosePacketItemData.m_Data);

        rOpenPacketItemData = rRQPackets.m_Packets[nOpenPacketIndex];
        if (!rOpenPacketItemData)
            return;
        OData = Log(rOpenPacketItemData.m_Data);

        rHighPacketItemData = rRQPackets.m_Packets[nHighPacketIndex];
        if (!rHighPacketItemData)
            return;
        HData = Log(rHighPacketItemData.m_Data);

        rLowPacketItemData = rRQPackets.m_Packets[nLowPacketIndex];
        if (!rLowPacketItemData)
            return;
        LData = Log(rLowPacketItemData.m_Data);
    }
    else {

        rClosePacketItemData = rRQPackets.m_Packets[nClosePacketIndex];
        if (!rClosePacketItemData)
            return;
        CData = rClosePacketItemData.m_Data;

        rOpenPacketItemData = rRQPackets.m_Packets[nOpenPacketIndex];
        if (!rOpenPacketItemData)
            return;
        OData = rOpenPacketItemData.m_Data;

        rHighPacketItemData = rRQPackets.m_Packets[nHighPacketIndex];
        if (!rHighPacketItemData)
            return;
        HData = rHighPacketItemData.m_Data;

        rLowPacketItemData = rRQPackets.m_Packets[nLowPacketIndex];
        if (!rLowPacketItemData)
            return;
        LData = rLowPacketItemData.m_Data;
    }

    yClosePos = Math.round(rectGraphRegion.m_nBottom - (CData - yMin) / yDiff * nGraphRegionHeight);
    yOpenPos = Math.round(rectGraphRegion.m_nBottom - (OData - yMin) / yDiff * nGraphRegionHeight);
    yHighPos = Math.round(rectGraphRegion.m_nBottom - (HData - yMin) / yDiff * nGraphRegionHeight);
    yLowPos = Math.round(rectGraphRegion.m_nBottom - (LData - yMin) / yDiff * nGraphRegionHeight);

    if (bInvert === true) {

        yClosePos = Math.round(rectGraphRegion.m_nBottom - yClosePos + rectGraphRegion.m_nTop);
        yOpenPos = Math.round(rectGraphRegion.m_nBottom - yOpenPos + rectGraphRegion.m_nTop);
        yHighPos = Math.round(rectGraphRegion.m_nBottom - yHighPos + rectGraphRegion.m_nTop);
        yLowPos = Math.round(rectGraphRegion.m_nBottom - yLowPos + rectGraphRegion.m_nTop);
    }

    var BongPosInfo = new CBongPosInfo();

    BongPosInfo.m_BongXPosInfo = this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray[this.m_rSubGraph.m_rRQInCol.m_BongXPosInfoArray.length - 1];

    BongPosInfo.m_OpenYPos = yOpenPos;
    BongPosInfo.m_HighYPos = yHighPos;
    BongPosInfo.m_LowYPos = yLowPos;
    BongPosInfo.m_CloseYPos = yClosePos;

    ////////////////////////////////////////////////////////////////////////
    //y축 보이는 봉중에서 최신 종가 및 등락율 보여주는 기능 처리를 위해 추가
    if (this.m_rSubGraph.m_ViewLatestData)
        this.m_rSubGraph.m_ViewPrevData = this.m_rSubGraph.m_ViewLatestData;

    this.m_rSubGraph.m_ViewLatestData = rClosePacketItemData.m_Data;
    //y축 보이는 봉중에서 최신 종가 및 등락율 보여주는 기능 처리를 위해 추가
    ////////////////////////////////////////////////////////////////////////
    var nBongTypeIndex = null;
    if (PrevClose) {

        if (rClosePacketItemData.m_Data > PrevClose)//상승
        {
            if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//양봉
                nBongTypeIndex = 0;
            else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//음봉
                nBongTypeIndex = 1;
            else//보합
                nBongTypeIndex = this.m_rPropertyInfo.m_bSteadyClrFollowToUpDropClr === true ? 0 : 5;
        }
        else if (rClosePacketItemData.m_Data < PrevClose)//하락
        {
            if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//양봉
                nBongTypeIndex = 2;
            else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//음봉
                nBongTypeIndex = (rOpenPacketItemData.m_Data < PrevClose) ? 4 : 3;//갭음봉
            else//보합
                nBongTypeIndex = this.m_rPropertyInfo.m_bSteadyClrFollowToUpDropClr === true ? 3 : 5;
        }
        else {//이전봉종가와 현재봉종가가 같은 경우 기본적으로 상승, 하지만 현재봉시가와 현재봉종가가 같으면 이전봉 색상을 따라감

            if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//상승양봉
                nBongTypeIndex = 0;
            else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//상승음봉
                nBongTypeIndex = 1;
            else
                nBongTypeIndex = (this.m_rPropertyInfo.m_bSteadyClrFollowToUpDropClr === true) ? (this.m_nPrevBongTypeIndex === null ? 5 : this.m_nPrevBongTypeIndex) : 5;//이전봉과 현재봉종가가 같고 현재봉시가와 종가가 같은 경우 이전봉 색상 따라감
        }
    }
    else {//이전종가가 없는 경우

        if (rOpenPacketItemData.m_Data < rClosePacketItemData.m_Data)//상승양봉
            nBongTypeIndex = 0;
        else if (rOpenPacketItemData.m_Data > rClosePacketItemData.m_Data)//하락음봉
            nBongTypeIndex = 3;
        else//보합
            nBongTypeIndex = (this.m_bSteadyClrFollowToUpDropClr === true) ? 0 : 5;//이전봉과 현재봉종가가 같고 현재봉시가와 종가가 같은 경우 이전봉 색상 따라감
    }

    if (nBongTypeIndex !== null) {

        BongTypeInfo[nBongTypeIndex].m_BongPosInfoArray[BongTypeInfo[nBongTypeIndex].m_BongPosInfoArray.length] = BongPosInfo;
    }

    // 스마트 시그널 신호 히스토리 렌더링 그리기 작업 >>>>>
    if (rClosePacketItemData.m_SignalItemData !== null) {
    
        var nSignalType = rClosePacketItemData.m_SignalItemData.GetSignalType();
        BongPosInfo.m_nSignalType = nSignalType;

        // 스마트 시그널 Y 값 셋팅
        var nMargin = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_SmartSignalProperty.m_nSignalArrowMargin;

        if (nSignalType & 0x01) { // 매수
            if (bInvert)
                BongPosInfo.m_BuySignalYPos = BongPosInfo.m_LowYPos - nMargin;
            else
                BongPosInfo.m_BuySignalYPos = BongPosInfo.m_LowYPos + nMargin;
        }
        if (nSignalType & 0x02) { // 매도
            if (bInvert)
                BongPosInfo.m_SellSignalYPos = BongPosInfo.m_HighYPos + nMargin;
            else
                BongPosInfo.m_SellSignalYPos = BongPosInfo.m_HighYPos - nMargin;
        }
    }
    // 스마트 시그널 신호 히스토리 렌더링 그리기 작업 <<<<<<

    this.m_rSubGraph.m_PrevClose = rClosePacketItemData.m_Data;//전봉종가
    this.m_nPrevBongTypeIndex = nBongTypeIndex;
    this.m_rPrevBongPosInfo = BongPosInfo;
}

// 가격차트 바유형 그리기 처리
CPriceBarDrawer.prototype.Draw = function (DrawingInfo) {

    /////////////////////////////////////////
    //선택그래프 표시기능
    var SignBongInfoArray = this.m_SignBongInfoArray;
    var nStartSignXPos = this.m_rSubGraph.m_rRQInCol.m_nStartSignXPos;

    //최소 봉 두께
    var bUseHLCType = this.m_rPropertyInfo.m_bUseHLCType;
    var bUseThinType = this.m_rPropertyInfo.m_bUseThinType;
    var BongMinWidth = this.m_rSubGraph.m_rRQInCol.m_rChartBlockCol.m_BongMinWidth;
    var nBarWidth = bUseThinType === true ? 1 : BongMinWidth /3;
    var nHalfWidth = nBarWidth / 2;

    //////////////////////////////////////////////////////////////////
    //BongType은 다르지만 색상값이 같은 경우 하나로 묶는다( beginPath 호출횟수를 줄여 성능향상 목적)
    var i, j;
    var ColorArray = [];
    var ColorArrayLength = ColorArray.length;
    var BongTypeInfo = this.m_BongTypeInfo;

    var nLength = BongTypeInfo.length;
    for (i = 0; i < nLength; i++) {
        if (i === 0) {
            ColorArray[ColorArray.length] = BongTypeInfo[i].m_clrBong;
        }
        else {
            ColorArrayLength = ColorArray.length;
            for (j = 0; j < ColorArrayLength; j++) {
                if (BongTypeInfo[i].m_clrBong === ColorArray[j])
                    break;
            }
            if (j === ColorArrayLength)
                ColorArray[j] = BongTypeInfo[i].m_clrBong;
        }
    }
    //////////////////////////////////////////////////////////////////
   
    var BongPosInfo = null;
    var YOpen, YClose, Width;
    ColorArrayLength = ColorArray.length;

    var BuySignalBongPosArray = [];
    var SellSignalBongPosArray = [];

    for (i = 0; i < ColorArrayLength; i++) {

        DrawingInfo.m_Context.beginPath();
        DrawingInfo.m_Context.strokeStyle = ColorArray[i];
        DrawingInfo.m_Context.fillStyle = ColorArray[i];
        DrawingInfo.m_Context.lineWidth = nBarWidth;

        for (j = 0; j < nLength; j++)
        {
            if (ColorArray[i] === BongTypeInfo[j].m_clrBong)
            {
                var BongItemIndex, BongItemLength = BongTypeInfo[j].m_BongPosInfoArray.length;
                for (BongItemIndex = 0; BongItemIndex < BongItemLength; BongItemIndex++)
                {
                    BongPosInfo = BongTypeInfo[j].m_BongPosInfoArray[BongItemIndex];

                    YOpen = BongPosInfo.m_OpenYPos;
                    YClose = BongPosInfo.m_CloseYPos;

                    if( bUseThinType === false )
                    {
                        if (BongPosInfo.m_OpenYPos + nHalfWidth > BongPosInfo.m_LowYPos )
                            YOpen = BongPosInfo.m_LowYPos - nHalfWidth;
                        else if( BongPosInfo.m_OpenYPos - nHalfWidth < BongPosInfo.m_HighYPos )
                            YOpen = BongPosInfo.m_HighYPos + nHalfWidth;

                        if( BongPosInfo.m_CloseYPos + nHalfWidth > BongPosInfo.m_LowYPos )
                            YClose = BongPosInfo.m_LowYPos - nHalfWidth;
                        else if( BongPosInfo.m_CloseYPos - nHalfWidth < BongPosInfo.m_HighYPos )
                            YClose = BongPosInfo.m_HighYPos + nHalfWidth;
                    }

                    Width = BongPosInfo.m_BongXPosInfo.m_CloseXPos - BongPosInfo.m_BongXPosInfo.m_OpenXPos;

                    if (2 <= Width)
                    {
                        if( bUseHLCType == false )
                        {
                            // 시가
                            DrawingInfo.m_Context.moveTo(BongPosInfo.m_BongXPosInfo.m_OpenXPos, YOpen);
                            DrawingInfo.m_Context.lineTo(BongPosInfo.m_BongXPosInfo.m_CenterXPos, YOpen);
                        }

                        // 고가, 저가
                        DrawingInfo.m_Context.moveTo(BongPosInfo.m_BongXPosInfo.m_CenterXPos, BongPosInfo.m_HighYPos);
                        DrawingInfo.m_Context.lineTo(BongPosInfo.m_BongXPosInfo.m_CenterXPos, BongPosInfo.m_LowYPos);

                        // 종가
                        DrawingInfo.m_Context.moveTo(BongPosInfo.m_BongXPosInfo.m_CenterXPos, YClose);
                        DrawingInfo.m_Context.lineTo(BongPosInfo.m_BongXPosInfo.m_CloseXPos, YClose);
                    }
                    else
                    {
                        // 고가, 저가
                        DrawingInfo.m_Context.moveTo(BongPosInfo.m_BongXPosInfo.m_CenterXPos, BongPosInfo.m_HighYPos);
                        DrawingInfo.m_Context.lineTo(BongPosInfo.m_BongXPosInfo.m_CenterXPos, BongPosInfo.m_LowYPos);
                    }

                    if (this.m_rSubGraph.m_Graph.m_rSmartSignalMng !== null) {

                        if (BongPosInfo.m_nSignalType & 0x01) {
                            BuySignalBongPosArray[BuySignalBongPosArray.length] = BongPosInfo;
                        }

                        if (BongPosInfo.m_nSignalType & 0x02) {
                            SellSignalBongPosArray[SellSignalBongPosArray.length] = BongPosInfo;
                        }
                    }
                }
            }
        }

        DrawingInfo.m_Context.closePath();
        DrawingInfo.m_Context.stroke();
    }

    if (this.m_rSubGraph.m_Graph.m_rSmartSignalMng !== null) {

        var nArrowWidth = null;
        var nArrowMinWidth = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_SmartSignalProperty.m_nSignalArrowMinWidth;
        var nArrowMaxWidth = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_SmartSignalProperty.m_nSignalArrowMaxWidth;
        var nMargin = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_SmartSignalProperty.m_nSignalArrowMargin;
        var nBongWidth = this.m_rSubGraph.m_rRQInCol.m_rChartBlockCol.m_BongMinWidth;

        if (nBongWidth >= nArrowMaxWidth) {
            nArrowWidth = nArrowMaxWidth;
        }
        else if (nBongWidth < nArrowMinWidth) {
            nArrowWidth = nArrowMinWidth;
        }
        else {
            nArrowWidth = nBongWidth;
        }

        var nArrowHight = nArrowWidth * this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_SmartSignalProperty.m_SignalArrowHRatio;
        var nArrowHeadHight = nArrowWidth * 0.5;
        var nArrowSticWidth = nArrowWidth * 0.6;
        var nArrowSticHalfWidth = nArrowSticWidth / 2;

        /////////////////////매수 화살표 그리는 영역 //////////////////////////////
        var ArrowXPosArray = [];
        var ArrowYPosArray = [];
        var BuySignalBongPosCnt = BuySignalBongPosArray.length;

        DrawingInfo.m_Context.beginPath();
        DrawingInfo.m_Context.fillStyle = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_rSmartSignalProperty.m_clrSignalBuyArrow;
        DrawingInfo.m_Context.strokeStyle = DrawingInfo.m_Context.fillStyle;

        for (i = 0; i < BuySignalBongPosCnt; i++) {

            var nSignalBuyYPos = BuySignalBongPosArray[i].m_BuySignalYPos;
            if (nSignalBuyYPos <= DrawingInfo.m_rectGraphRegion.m_nTop)
                continue;

            // 스마트 시그널 X 값 셋팅
            var nCenterPos = BuySignalBongPosArray[i].m_BongXPosInfo.m_CenterXPos;

            var nSignalArrowLeftPos, nSignalArrowRightPos, nSignalArrowCenterPos;
            var nHalfWidth = nArrowWidth / 2;
            nSignalArrowLeftPos = nCenterPos - nHalfWidth;
            nSignalArrowRightPos = nCenterPos + nHalfWidth;

            // 화살표 삼각형 그리기 >>>
            ArrowXPosArray[0] = nCenterPos;
            ArrowYPosArray[0] = nSignalBuyYPos;
            ArrowXPosArray[1] = nSignalArrowRightPos;
            ArrowYPosArray[1] = nSignalBuyYPos + nArrowHeadHight;
            ArrowXPosArray[2] = nCenterPos + nArrowSticHalfWidth;
            ArrowYPosArray[2] = nSignalBuyYPos + nArrowHeadHight;
            ArrowXPosArray[3] = nCenterPos + nArrowSticHalfWidth;
            ArrowYPosArray[3] = nSignalBuyYPos + nArrowHight;
            ArrowXPosArray[4] = nCenterPos - nArrowSticHalfWidth;
            ArrowYPosArray[4] = nSignalBuyYPos + nArrowHight;
            ArrowXPosArray[5] = nCenterPos - nArrowSticHalfWidth;
            ArrowYPosArray[5] = nSignalBuyYPos + nArrowHeadHight;
            ArrowXPosArray[6] = nSignalArrowLeftPos;
            ArrowYPosArray[6] = nSignalBuyYPos + nArrowHeadHight;

            DrawingInfo.m_Context.moveTo(nCenterPos, nSignalBuyYPos);

            var ArrowPosCnt = ArrowXPosArray.length;
            for (j = 1; j < ArrowPosCnt; j++) {

                var y = ArrowYPosArray[j] > DrawingInfo.m_rectGraphRegion.m_nBottom ? DrawingInfo.m_rectGraphRegion.m_nBottom : ArrowYPosArray[j];
                DrawingInfo.m_Context.lineTo(ArrowXPosArray[j], y);
            }
        }
        DrawingInfo.m_Context.fill();
        DrawingInfo.m_Context.closePath();
        DrawingInfo.m_Context.stroke();

        /////////////////////매도 화살표 그리는 영역 //////////////////////////////
        var SellSignalBonPosCnt = SellSignalBongPosArray.length;

        DrawingInfo.m_Context.beginPath();
        DrawingInfo.m_Context.fillStyle = this.m_rSubGraph.m_Graph.m_rSmartSignalMng.m_rSmartSignalProperty.m_clrSignalSellArrow;
        DrawingInfo.m_Context.strokeStyle = DrawingInfo.m_Context.fillStyle;

        for (i = 0; i < SellSignalBonPosCnt; i++) {

            var nSignalSellYPos = SellSignalBongPosArray[i].m_SellSignalYPos;
            if (nSignalSellYPos >= DrawingInfo.m_rectGraphRegion.m_nBottom)
                continue;

            // 스마트 시그널 X 값 셋팅
            var nCenterPos = SellSignalBongPosArray[i].m_BongXPosInfo.m_CenterXPos;

            var nSignalArrowLeftPos, nSignalArrowRightPos, nSignalArrowCenterPos;
            var nHalfWidth = nArrowWidth / 2;
            nSignalArrowLeftPos = nCenterPos - nHalfWidth;
            nSignalArrowRightPos = nCenterPos + nHalfWidth;

            ArrowXPosArray[0] = nCenterPos;
            ArrowYPosArray[0] = nSignalSellYPos;
            ArrowXPosArray[1] = nSignalArrowLeftPos;
            ArrowYPosArray[1] = nSignalSellYPos - nArrowHeadHight;
            ArrowXPosArray[2] = nCenterPos - nArrowSticHalfWidth;
            ArrowYPosArray[2] = nSignalSellYPos - nArrowHeadHight;
            ArrowXPosArray[3] = nCenterPos - nArrowSticHalfWidth;
            ArrowYPosArray[3] = nSignalSellYPos - nArrowHight;
            ArrowXPosArray[4] = nCenterPos + nArrowSticHalfWidth;
            ArrowYPosArray[4] = nSignalSellYPos - nArrowHight;
            ArrowXPosArray[5] = nCenterPos + nArrowSticHalfWidth;
            ArrowYPosArray[5] = nSignalSellYPos - nArrowHeadHight;
            ArrowXPosArray[6] = nSignalArrowRightPos;
            ArrowYPosArray[6] = nSignalSellYPos - nArrowHeadHight;
            
            DrawingInfo.m_Context.moveTo(nCenterPos, nSignalSellYPos);
            var ArrowPosCnt = ArrowXPosArray.length;
            for (j = 1; j < ArrowPosCnt; j++) {

                var y = ArrowYPosArray[j] < DrawingInfo.m_rectGraphRegion.m_nTop ? DrawingInfo.m_rectGraphRegion.m_nTop : ArrowYPosArray[j];
                DrawingInfo.m_Context.lineTo(ArrowXPosArray[j], y);
            }
        }

        DrawingInfo.m_Context.fill();
        DrawingInfo.m_Context.closePath();
        DrawingInfo.m_Context.stroke();
    }

    // 그래프 선택 표시
    if (this.m_rSubGraph.IsDrawSelected(DrawingInfo)) {

        var nSize = gSelectSignSize;
        nLength = SignBongInfoArray.length;
        for (i = 0; i < nLength; i++) {

            var rBongPosInfo = SignBongInfoArray[i];

            var XLeft = rBongPosInfo.m_BongXPosInfo.m_CenterXPos - nSize;
            var XRight = rBongPosInfo.m_BongXPosInfo.m_CenterXPos + nSize;

            var YCenter = (rBongPosInfo.m_HighYPos + rBongPosInfo.m_LowYPos) / 2;
            var YTop = YCenter - nSize;
            var YBottom = YCenter + nSize;

            var imgData = DrawingInfo.m_Context.getImageData(XLeft, YTop, XRight - XLeft, YBottom - YTop);
            var nDataLength = imgData.data.length;
            for (var j = 0; j < nDataLength; j += 4) {

                imgData.data[j] = 255 - imgData.data[j];
                imgData.data[j + 1] = 255 - imgData.data[j + 1];
                imgData.data[j + 2] = 255 - imgData.data[j + 2];
                imgData.data[j + 3] = 255;
            }
            DrawingInfo.m_Context.putImageData(imgData, XLeft, YTop);
        }
    }
}

CPriceBarDrawer.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {

    this.m_rSubGraph.m_MinMaxInfo.Init();

    for (var strPacketName in this.m_rSubGraph.m_PacketObj) {
        var rPacketData = this.m_rSubGraph.m_PacketObj[strPacketName];

        gMinMaxInfo.Init();
        var MinMaxInfo = gMinMaxInfo;
        if (rXScaleMng.ExtractMinMaxValue(this.m_rSubGraph.m_rRQSet.m_strRQ, rPacketData.m_strPacketName, MinMaxInfo, bFullScan)) {
            if (this.m_rSubGraph.m_MinMaxInfo.m_Max === null)
                this.m_rSubGraph.m_MinMaxInfo.m_Max = MinMaxInfo.m_Max;
            else if (this.m_rSubGraph.m_MinMaxInfo.m_Max < MinMaxInfo.m_Max)
                this.m_rSubGraph.m_MinMaxInfo.m_Max = MinMaxInfo.m_Max;

            if (this.m_rSubGraph.m_MinMaxInfo.m_Min === null)
                this.m_rSubGraph.m_MinMaxInfo.m_Min = MinMaxInfo.m_Min;
            else if (this.m_rSubGraph.m_MinMaxInfo.m_Min > MinMaxInfo.m_Min)
                this.m_rSubGraph.m_MinMaxInfo.m_Min = MinMaxInfo.m_Min;

            this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex = MinMaxInfo.m_nStartIndex;
            this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex = MinMaxInfo.m_nEndIndex;
        }
    }

    if (SubGraphMinMaxInfo.m_Max === null)
        SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;
    else if (SubGraphMinMaxInfo.m_Max < this.m_rSubGraph.m_MinMaxInfo.m_Max)
        SubGraphMinMaxInfo.m_Max = this.m_rSubGraph.m_MinMaxInfo.m_Max;

    if (SubGraphMinMaxInfo.m_Min === null)
        SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;
    else if (SubGraphMinMaxInfo.m_Min > this.m_rSubGraph.m_MinMaxInfo.m_Min)
        SubGraphMinMaxInfo.m_Min = this.m_rSubGraph.m_MinMaxInfo.m_Min;

    SubGraphMinMaxInfo.m_nStartIndex = this.m_rSubGraph.m_MinMaxInfo.m_nStartIndex;
    SubGraphMinMaxInfo.m_nEndIndex = this.m_rSubGraph.m_MinMaxInfo.m_nEndIndex;
}

CPriceBarDrawer.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {

    var rOpenPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rRQSet.m_nOpenPacketIndex];
    var rClosePacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rRQSet.m_nClosePacketIndex];
    var rHighPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rRQSet.m_nHighPacketIndex];
    var rLowPacketItemData = rRQPackets.m_Packets[this.m_rSubGraph.m_rRQSet.m_nLowPacketIndex];

    if (rHighPacketItemData === undefined || rLowPacketItemData === undefined)
        return false;

    var nViewStartIndex = rXScaleMng.m_nViewStartIndex;
    var nViewEndIndex = rXScaleMng.m_nViewEndIndex;

    var nGraphRegionWidth = rectGraphRegion.Width();
    var nGraphRegionHeight = rectGraphRegion.Height();
    var nViewDataCnt = nViewEndIndex - nViewStartIndex + 1;

    //최소 봉 두께
    var BarMinWidth = nGraphRegionWidth / nViewDataCnt;

    var i, j;
    var strRQ = this.m_rSubGraph.m_rRQSet.GetRQ();

    var xPosLeft = rectGraphRegion.m_nLeft + BarMinWidth * rRQPackets.m_nRelativeStartIndex;
    var xPosRight = rectGraphRegion.m_nLeft + BarMinWidth * (rRQPackets.m_nRelativeStartIndex + rRQPackets.m_nRelativeEndIndex);

    var yMin, yMax, yDiff, yOpenData, yCloseData, yHighData, yLowData;
    var bLog = this.m_rSubGraph.GetLog();
    if (bLog === true) {

        yMin = Log(this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit);
        yMax = Log(this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit);

        yOpenData = Log(rOpenPacketItemData.m_Data);
        yCloseData = Log(rClosePacketItemData.m_Data);
        yHighData = Log(rHighPacketItemData.m_Data);
        yLowData = Log(rLowPacketItemData.m_Data);
    }
    else {

        yMin = this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit;
        yMax = this.m_rSubGraph.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit;

        yOpenData = rOpenPacketItemData.m_Data;
        yCloseData = rClosePacketItemData.m_Data;
        yHighData = rHighPacketItemData.m_Data;
        yLowData = rLowPacketItemData.m_Data;
    }

    yDiff = yMax - yMin;

    //////////////////////////////////////
    var yOpenPos = rectGraphRegion.m_nBottom - (yOpenData - yMin) / yDiff * nGraphRegionHeight;
    var yClosePos = rectGraphRegion.m_nBottom - (yCloseData - yMin) / yDiff * nGraphRegionHeight;
    var yHighPos = rectGraphRegion.m_nBottom - (yHighData - yMin) / yDiff * nGraphRegionHeight;
    var yLowPos = rectGraphRegion.m_nBottom - (yLowData - yMin) / yDiff * nGraphRegionHeight;

    if (this.m_rSubGraph.GetInvert() === true) {

        yOpenPos = rectGraphRegion.m_nBottom - yOpenPos + rectGraphRegion.m_nTop;
        yClosePos = rectGraphRegion.m_nBottom - yClosePos + rectGraphRegion.m_nTop;
        yHighPos = rectGraphRegion.m_nBottom - yHighPos + rectGraphRegion.m_nTop;
        yLowPos = rectGraphRegion.m_nBottom - yLowPos + rectGraphRegion.m_nTop;
    }

    //////////////////////////////////////
    if (yClosePos < yOpenPos) {
        if (((yClosePos - 2) <= Y && Y <= (yOpenPos + 2)) && (xPosLeft <= X && X <= xPosRight))
            return true;
    }
    else {
        if (((yOpenPos - 2) <= Y && Y <= (yClosePos + 2)) && (xPosLeft <= X && X <= xPosRight))
            return true;
    }

    var xPosCenter = (xPosLeft + xPosRight) / 2;
    if (((yHighPos - 5) <= Y && Y <= (yLowPos + 5)) && (xPosCenter - 2 <= X && X <= xPosCenter + 2))
        return true;

    return false;
}


///////////////////////////////////////////////////////////////////////////////
//가격차트만의 속성과 그리기 처리가 일반지표와 다른 경우라서 별도 처리를 위해 클래스 추가
export function CPriceSubGraph(Graph, nSubGraphSubType) {
    CSubGraph.call(this, Graph);

    this.m_nSubGraphType = PRICE_SUBGRAPH_TYPE;
    this.m_nSubGraphSubType = nSubGraphSubType ? nSubGraphSubType : PRICE_SUBGRAPH_CANDLE_TYPE;//현재 선택되어 있는 타입 저장

    this.m_strSubGraphTitleLangKeyArray = ["chart.open", "chart.high", "chart.low", "chart.close", "chart.volume"];
    this.m_strSubGraphTitleArray = ["시가", "고가", "저가", "종가", "거래량"];
    this.m_strPacketNameArray = ["_OPEN_", "_HIGH_", "_LOW_", "_CLOSE_", "_VOLUME_"];
    this.m_nPacketIndexArray = [];
    this.m_PacketObj = {};

    this.m_PriceCandleTypeInfo = new CPriceCandleTypeInfo();
    this.m_PriceBarTypeInfo = new CPriceBarTypeInfo();
    this.m_PriceLineTypeInfo = new CPriceLineTypeInfo();
    this.m_PricePAndFTypeInfo = new CPricePAndFTypeInfo();
    this.m_PriceThreeLineBreakTypeInfo = new CPriceThreeLineBreakTypeInfo();

    this.m_Drawer = null;
    this.CreateDrawer();

}
CPriceSubGraph.prototype = new CSubGraph();//CSubGraph 상속
CPriceSubGraph.prototype.constructor = CPriceSubGraph;

CPriceSubGraph.prototype.ChangeLang = function(){

    CSubGraph.prototype.ChangeLang.call(this);

    this.m_strSubGraphTitleArray = [];
    var i, nLen = this.m_strSubGraphTitleLangKeyArray.length;
    for(i = 0 ; i < nLen; i++ )
    {
        this.m_strSubGraphTitleArray[i] = t(this.m_strSubGraphTitleLangKeyArray[i]);
    }

    this.m_PriceCandleTypeInfo.ChangeLang();
    this.m_PriceBarTypeInfo.ChangeLang();
    this.m_PriceLineTypeInfo.ChangeLang();
    this.m_PricePAndFTypeInfo.ChangeLang();
    this.m_PriceThreeLineBreakTypeInfo.ChangeLang();

    if(this.m_Drawer) this.m_Drawer.ChangeLang();
}
CPriceSubGraph.prototype.CreateDrawer = function () {
    
    switch (this.m_nSubGraphSubType) {

        case PRICE_SUBGRAPH_CANDLE_TYPE:
            this.m_Drawer = new CPriceCandleDrawer(this);
            return true;
        case PRICE_SUBGRAPH_LINE_TYPE:
            this.m_Drawer = new CPriceLineDrawer(this);
            return true;
        case PRICE_SUBGRAPH_BAR_TYPE:
            this.m_Drawer = new CPriceBarDrawer(this);
            return true;
        default:
            this.m_Drawer = null;
            return false;
    }
    return false;
}

/*
CPriceSubGraph.prototype.GetTitle = function () {

    var rRQInfo = this.m_Graph.m_rRQSet.m_RQInfo;
    
    var strTitle = "";
    if (this.m_rGlobalProperty.m_bShowIndicatorName === true)
        strTitle = rRQInfo.m_strItemName;
    if (this.m_rGlobalProperty.m_bShowIndicatorValue === true) {
        
        var rClosePacket = this.m_Graph.m_rRQSet.GetPacketDataByIndex(this.m_Graph.m_rRQSet.m_nClosePacketIndex);
        var rLastestClosePacketItemData = rClosePacket.GetLastestPacketItemData();
        if (rLastestClosePacketItemData !== null) {

            //var rOpenPacket = this.m_Graph.m_rRQSet.GetPacketDataByIndex(this.m_Graph.m_rRQSet.m_nOpenPacketIndex);
            //var rHighPacket = this.m_Graph.m_rRQSet.GetPacketDataByIndex(this.m_Graph.m_rRQSet.m_nHighPacketIndex);
            //var rLowPacket = this.m_Graph.m_rRQSet.GetPacketDataByIndex(this.m_Graph.m_rRQSet.m_nLowPacketIndex);
            //var rLastestOpenPacketItemData = rOpenPacket.GetLastestPacketItemData();
            //var rLastestHighPacketItemData = rHighPacket.GetLastestPacketItemData();
            //var rLastestLowPacketItemData = rLowPacket.GetLastestPacketItemData();
            //var strLastestOpenData = ConvertNumToDigitText(rLastestOpenPacketItemData.m_Data, rOpenPacket.m_nDec, 1, rOpenPacket.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);
            //var strLastestHighData = ConvertNumToDigitText(rLastestHighPacketItemData.m_Data, rHighPacket.m_nDec, 1, rHighPacket.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);
            //var strLastestLowData = ConvertNumToDigitText(rLastestLowPacketItemData.m_Data, rLowPacket.m_nDec, 1, rLowPacket.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);
            var strLastestCloseData = ConvertNumToDigitText(rLastestClosePacketItemData.m_Data, rClosePacket.m_nDec, 1, rClosePacket.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

            //strTitle += "(시:" + strLastestOpenData + ", 고:" + strLastestHighData + ", 저:" + strLastestLowData + ", 종:" + strLastestCloseData + ")";
            strTitle += "(" + strLastestCloseData + ")";
        }
    }
    return strTitle;
}
*/
CPriceSubGraph.prototype.SetPropertyInfoToDrawer = function () {

    switch (this.m_nSubGraphSubType) {

        case PRICE_SUBGRAPH_CANDLE_TYPE:
            this.m_Drawer.m_rPropertyInfo = this.m_PriceCandleTypeInfo;
            return true;
        default:
            return false;
    }
}
CPriceSubGraph.prototype.GetPropertyInfo = function (SubGraphPropertyInfo) {

    if (SubGraphPropertyInfo === undefined)
        SubGraphPropertyInfo = new CPriceSubGraphPropertyInfo();

    CSubGraph.prototype.GetPropertyInfo.call(this, SubGraphPropertyInfo);

    SubGraphPropertyInfo.m_PriceCandleTypeInfo = this.m_PriceCandleTypeInfo;
    SubGraphPropertyInfo.m_PriceBarTypeInfo = this.m_PriceBarTypeInfo;
    SubGraphPropertyInfo.m_PriceLineTypeInfo = this.m_PriceLineTypeInfo;
    SubGraphPropertyInfo.m_PricePAndFTypeInfo = this.m_PricePAndFTypeInfo;
    SubGraphPropertyInfo.m_PriceThreeLineBreakTypeInfo = this.m_PriceThreeLineBreakTypeInfo;
    
    return SubGraphPropertyInfo;
}

CPriceSubGraph.prototype.SetPropertyInfo = function (SubGraphPropertyInfo, bSetup) {

    if (SubGraphPropertyInfo === undefined)
        return false;

    var bChangeSubGraphSubType = this.m_nSubGraphSubType !== SubGraphPropertyInfo.m_nSubGraphSubType;

    if (CSubGraph.prototype.SetPropertyInfo.call(this, SubGraphPropertyInfo, bSetup) === false)
        return false;

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////
    //설정ui에서 갭하락 색상 지정이 없어서 하락음봉과 동일하게 강제 셋팅처리
    SubGraphPropertyInfo.m_PriceCandleTypeInfo.m_bFillGapMinus = SubGraphPropertyInfo.m_PriceCandleTypeInfo.m_bFillDropMinus;
    SubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrGapMinus = SubGraphPropertyInfo.m_PriceCandleTypeInfo.m_clrDropMinus;
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////
    //바타입 설정ui에서 상승음봉, 하락양봉, 갭하락 색상 지정이 없어서 상승양봉, 하락음봉과 동일하게 세팅
    SubGraphPropertyInfo.m_PriceBarTypeInfo.m_clrUpturnMinus = SubGraphPropertyInfo.m_PriceBarTypeInfo.m_clrUpturnPlus;
    SubGraphPropertyInfo.m_PriceBarTypeInfo.m_clrDropPlus = SubGraphPropertyInfo.m_PriceBarTypeInfo.m_clrDropMinus;
    SubGraphPropertyInfo.m_PriceBarTypeInfo.m_clrGapMinus = SubGraphPropertyInfo.m_PriceBarTypeInfo.m_clrDropMinus;
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////

    this.m_PriceCandleTypeInfo.SetPropertyInfo(SubGraphPropertyInfo.m_PriceCandleTypeInfo, bSetup);
    this.m_PriceBarTypeInfo.SetPropertyInfo(SubGraphPropertyInfo.m_PriceBarTypeInfo, bSetup);
    this.m_PriceLineTypeInfo.SetPropertyInfo(SubGraphPropertyInfo.m_PriceLineTypeInfo, bSetup);
    this.m_PricePAndFTypeInfo.SetPropertyInfo(SubGraphPropertyInfo.m_PricePAndFTypeInfo, bSetup);
    this.m_PriceThreeLineBreakTypeInfo.SetPropertyInfo(SubGraphPropertyInfo.m_PriceThreeLineBreakTypeInfo, bSetup);

    if (bChangeSubGraphSubType)
        this.CreateDrawer();
    else
        this.SetPropertyInfoToDrawer();

    return true;
}

CPriceSubGraph.prototype.GetTitleAndPacketName = function (strTitleArray, strPacketNameArray) {

    var length = this.m_strSubGraphTitleArray.length;
    for (var i = 0; i < length; i++)
        strTitleArray[i] = this.m_strSubGraphTitleArray[i];

    for (var strPacketName in this.m_PacketObj) {
        strPacketNameArray[strPacketNameArray.length] = strPacketName;
    }
}

CPriceSubGraph.prototype.SetPacketData = function (strPacketDataNameArray) {

    this.m_PacketObj = {};
    var nCount = 0;

    //툴팁 또는 수치조회 기능 메모리 절약을 위해 미리 메모리 풀방식 사용
    this.m_SubGraphFindData4ToolTip.m_SubGraphFindSubDataArray.length = 0;

    var length = strPacketDataNameArray.length;
    for (var i = 0; i < length; i++) {
        var strPacketName = strPacketDataNameArray[i];
        var rPacketData = this.m_rRQSet.GetPacketData(strPacketName);
        if (rPacketData !== null) {
            rPacketData.AddSubGraph(this);
            this.m_PacketObj[strPacketName] = rPacketData;
            this.m_nPacketIndexArray[nCount] = rPacketData.m_nPacketIndex;

            if (strPacketName === "_CLOSE_") {
                this.m_rPacketData = rPacketData;
                this.m_strPacketName = strPacketName;
            }

            //툴팁 또는 수치조회 기능 메모리 절약을 위해 미리 메모리 풀방식 사용
            this.m_SubGraphFindData4ToolTip.m_SubGraphFindSubDataArray[nCount] = new CSubGraphFindSubData();

            nCount++;
        }
    }
    return nCount;
}
CPriceSubGraph.prototype.DeleteSubGraphInPacketData = function () {

    var i, nLen = this.m_nPacketIndexArray.length;
    for (i = 0; i < nLen; i++) {
        var rPacketData = this.m_rRQSet.m_PacketDataArray[this.m_nPacketIndexArray[i]];
        rPacketData.DeleteSubGraph(this);
    }
    return true;
}
CPriceSubGraph.prototype.ExtractYScaleMinMax = function (rXScaleMng, SubGraphMinMaxInfo, bFullScan) {

    this.m_Drawer.ExtractYScaleMinMax(rXScaleMng, SubGraphMinMaxInfo, bFullScan);
}

CPriceSubGraph.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rRQPackets, rXScaleMng, rectGraphRegion) {

    return this.m_Drawer.FindRQGraphDataPerXScaleMng(X, Y, rRQPackets, rXScaleMng, rectGraphRegion);
}
CPriceSubGraph.prototype.GetRQGraphFindDataPerXScaleMng = function (rRQPackets) {

    var i, length = this.m_nPacketIndexArray.length;
    var SubGraphFindData = this.m_SubGraphFindData4ToolTip;
    for (i = 0; i < length; i++) {

        var rPacketItemData = rRQPackets.m_Packets[this.m_nPacketIndexArray[i]];
        if (rPacketItemData !== undefined) {
            
            SubGraphFindData.m_SubGraphFindSubDataArray[i].m_strSubGraphTitle = this.m_strSubGraphTitleArray[i];
            SubGraphFindData.m_SubGraphFindSubDataArray[i].m_strSubGraphFindData = ConvertNumToDigitText(rPacketItemData.m_Data, rPacketItemData.m_rPacketData.m_nDec, 1, rPacketItemData.m_rPacketData.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

            if (rRQPackets.m_rPrevRQPacketsItem !== null) {
                var rPrevPacketItemData = rRQPackets.m_rPrevRQPacketsItem.m_Packets[this.m_nPacketIndexArray[i]];
                if (rPrevPacketItemData !== undefined) {

                    ////test
                    //SubGraphFindData.m_SubGraphFindSubDataArray[i].m_strSubGraphFindSubData = ConvertNumToDigitText(((rPacketItemData.m_Data - rPrevPacketItemData.m_Data) / rPrevPacketItemData.m_Data * 100), 10, 1, -2, -1);
                }
            }
        }
    }

    return SubGraphFindData;
}

//속도개선처리
CPriceSubGraph.prototype.InitRendering = function () {

    this.m_ViewLatestData = null;
    this.m_ViewPrevData = null;

    if (this.GetLog() === true) {

        this.m_yMin = Log(this.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit);
        this.m_yMax = Log(this.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit);
    }
    else {

	    this.m_yMin = this.m_Graph.m_rYScale.m_MinMaxInfo.m_LowerLimit;
    	this.m_yMax = this.m_Graph.m_rYScale.m_MinMaxInfo.m_UpperLimit;
    }

    this.m_yDiff = this.m_yMax - this.m_yMin;

    this.m_PrevClose = null;
    
    this.m_bRenderingBreak = false;

    this.m_Drawer.InitRendering();
}
CPriceSubGraph.prototype.AddSelectPosInfo = function () {

    this.m_Drawer.AddSelectPosInfo();
}
CPriceSubGraph.prototype.RenderingInLoop = function (RenderingInfo) {

    this.m_Drawer.RenderingInLoop(RenderingInfo);
}

//가격 서브그래프 그리기 처리(봉차트)
CPriceSubGraph.prototype.Draw = function (DrawingInfo) {

    this.m_Drawer.Draw(DrawingInfo);
}

///////////////////////////////////////////////////////////
//지표 기준선 (BaseLine)
export function CBaseLine() {
 
	this.m_dBaseValue = null;//기준값
	this.m_strKeyOfClrLine = "baseLine";
    this.m_clrLine = "#ff0000";//선색
    this.m_nLineType = PS_SOLID;//선타입(PS_SOLID, PS_DASH, PS_DOT)
    this.m_nThickness = 1;//선두께
}

CBaseLine.prototype.SetClrLine = function (clrLine) {

    this.m_strKeyOfClrLine = null;
    this.m_clrLine = clrLine;
}

CBaseLine.prototype.SetPropertyInfo = function (rSrcBaseLine, bSetup) {
    if (rSrcBaseLine === undefined)
        return false;

    this.m_dBaseValue = rSrcBaseLine.m_dBaseValue;//기준값
    this.m_strKeyOfClrLine = rSrcBaseLine.m_strKeyOfClrLine;
    this.m_clrLine = rSrcBaseLine.m_clrLine;//선색
    this.m_nLineType = rSrcBaseLine.m_nLineType;//선타입(PS_SOLID, PS_DASH, PS_DOT)
    this.m_nThickness = rSrcBaseLine.m_nThickness;//선두께

    return true;
}
CBaseLine.prototype.Copy = function ( rCopyBaseLine )
{
    if( rCopyBaseLine === undefined )
        rCopyBaseLine = new CBaseLine();

    rCopyBaseLine.m_dBaseValue = this.m_dBaseValue;//기준값
	rCopyBaseLine.m_strKeyOfClrLine = this.m_strKeyOfClrLine;
    rCopyBaseLine.m_clrLine = this.m_clrLine;//선색
    rCopyBaseLine.m_nLineType = this.m_nLineType;//선타입(PS_SOLID, PS_DASH, PS_DOT)
    rCopyBaseLine.m_nThickness = this.m_nThickness;//선두께

    return rCopyBaseLine;
}
///////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////
//CGraphPropertyInfo
export function CGraphPropertyInfo() {
    this.m_strKey = "";
    this.m_strGroup = null;
    this.m_strName = "";
    this.m_strTitle = "";
    this.m_strTitleLangKey = "";
    this.m_nBasePriceTextAlign = TEXT_RIGHT_ALIGN;
    this.m_bShowBasePrice = true;//기준선위에 기준가표시여부(우측표시)

    this.m_nShowLatestDataType = 0;//마지막값 표시 (0:보이지 않음, 1: 보이는 영역에서 최근봉 데이터 보기, 2: 현재시세 또는 현재값 보기)
    this.m_bShowLatestDataOfAllSubGraph = false;//모든 라인 표시
    this.m_nDataChangeRatioType = 0; //등락률 표시

    this.m_nAddType = APPEND_TYPE;

    this.m_BaseLineArray = [];
    this.m_SubGraphPropertyInfoArray = [];
}
CGraphPropertyInfo.prototype.ChangeLang = function(){

    if(this.m_strTitleLangKey && this.m_strTitleLangKey.length > 0)
        this.m_strTitle = t(this.m_strTitleLangKey);
}
CGraphPropertyInfo.prototype.AddSubGraphPropertyInfo = function (SubGraphPropertyInfo) {
    this.m_SubGraphPropertyInfoArray[this.m_SubGraphPropertyInfoArray.length] = SubGraphPropertyInfo;
}
CGraphPropertyInfo.prototype.AddBaseLine = function (BaseLine) {
    this.m_BaseLineArray[this.m_BaseLineArray.length] = BaseLine;
}
CGraphPropertyInfo.prototype.GetPriceTypeNameByIndex = function ( nPriceTypeIndex )
{
    var i, nLen = PRICE_TYPE_GROUPS.length;
 	for(i = 0; i < nLen ; i++){

		if(PRICE_TYPE_GROUPS[i].nValue === nPriceTypeIndex)
			return PRICE_TYPE_GROUPS[i].strValue;
	}
	return null;
}
CGraphPropertyInfo.prototype.SetPropertyInfo = function (PropertyInfo) {

    this.m_strGroup = PropertyInfo.m_strGroup;
    this.m_strName = PropertyInfo.m_strName;

    if(PropertyInfo.m_strTitleLangKey && PropertyInfo.m_strTitleLangKey.length > 0)
        this.m_strTitle = t(PropertyInfo.m_strTitleLangKey);
    else
        this.m_strTitle = PropertyInfo.m_strTitle;

    this.m_strTitleLangKey = PropertyInfo.m_strTitleLangKey;

    this.m_nBasePriceTextAlign = PropertyInfo.m_nBasePriceTextAlign;
    this.m_bShowBasePrice = PropertyInfo.m_bShowBasePrice;

    this.m_nShowLatestDataType = PropertyInfo.m_nShowLatestDataType;//마지막값 표시 (0:보이지 않음, 1: 보이는 영역에서 최근봉 데이터 보기, 2: 현재시세 또는 현재값 보기)
    this.m_bShowLatestDataOfAllSubGraph = PropertyInfo.m_bShowLatestDataOfAllSubGraph;//모든 라인 표시
    this.m_nDataChangeRatioType = PropertyInfo.m_nDataChangeRatioType; //등락률 표시

    this.m_nAddType = PropertyInfo.m_nAddType;

    var i, j;

    //////////////////////////////////////////////////////////////
    //SubGraph
    var rSubGraph;
    var rSubGraphPropertyInfo;
    var nPropLength = PropertyInfo.m_SubGraphPropertyInfoArray.length;
    this.m_SubGraphPropertyInfoArray.length = 0;
    var NewSubGraphPropertyInfo = null;

    for (i = 0; i < nPropLength; i++) {
        
        rSubGraphPropertyInfo = PropertyInfo.m_SubGraphPropertyInfoArray[i];

        if (rSubGraphPropertyInfo.m_strSubGraphName === "_CLOSE_")
            NewSubGraphPropertyInfo = new CPriceSubGraphPropertyInfo();
        else if (rSubGraphPropertyInfo.m_strSubGraphName === "_VOLUME_")
            NewSubGraphPropertyInfo = new CVolumeSubGraphPropertyInfo();
        else
            NewSubGraphPropertyInfo = new CIndicatorSubGraphPropertyInfo();

        NewSubGraphPropertyInfo.SetPropertyInfo(rSubGraphPropertyInfo);

        this.m_SubGraphPropertyInfoArray[i] = NewSubGraphPropertyInfo;
    }

    /////////////////////////////////////////////////////////
    //BaseLine
    var rBaseLine, rPropBaseLine;
    nPropLength = PropertyInfo.m_BaseLineArray.length;
    var nBaseLineLen = this.m_BaseLineArray.length;
    var nDiffLen = nPropLength - nBaseLineLen;
    var nMinLen = nPropLength > nBaseLineLen ? nBaseLineLen : nPropLength;

    for (i = 0; i < nMinLen; i++)
        this.m_BaseLineArray[i].SetPropertyInfo(PropertyInfo.m_BaseLineArray[i]);

    if (nDiffLen < 0)
        this.m_BaseLineArray.splice(nBaseLineLen + nDiffLen, -nDiffLen);
    else {

        for (j = 0; j < nDiffLen; j++) {

            rPropBaseLine = PropertyInfo.m_BaseLineArray[i + j];
            rBaseLine = new CBaseLine();
            rBaseLine.SetPropertyInfo(rPropBaseLine);
            this.m_BaseLineArray[this.m_BaseLineArray.length] = rBaseLine;
        }
    }

    return true;
}
CGraphPropertyInfo.prototype.Copy = function ( rCopyGraphPropertyInfo )
{
    if( rCopyGraphPropertyInfo === undefined )
        rCopyGraphPropertyInfo = new CGraphPropertyInfo();

    rCopyGraphPropertyInfo.m_strKey = this.m_strKey;
    rCopyGraphPropertyInfo.m_strGroup = this.m_strGroup;
    rCopyGraphPropertyInfo.m_strName = this.m_strName;
    rCopyGraphPropertyInfo.m_strTitle = this.m_strTitle;
    rCopyGraphPropertyInfo.m_strTitleLangKey = this.m_strTitleLangKey;

	rCopyGraphPropertyInfo.m_nBasePriceTextAlign = this.m_nBasePriceTextAlign ;
    rCopyGraphPropertyInfo.m_bShowBasePrice = this.m_bShowBasePrice ;//기준선위에 기준가표시여부(우측표시)

    rCopyGraphPropertyInfo.m_nShowLatestDataType = this.m_nShowLatestDataType;
    rCopyGraphPropertyInfo.m_bShowLatestDataOfAllSubGraph = this.m_bShowLatestDataOfAllSubGraph;
    rCopyGraphPropertyInfo.m_nDataChangeRatioType = this.m_nDataChangeRatioType;

    rCopyGraphPropertyInfo.m_nAddType = this.m_nAddType;

    var i, rBaseLine;
    var nLength = this.m_BaseLineArray.length;
    for( i = 0; i < nLength; i++ )
    {
        rBaseLine = this.m_BaseLineArray[i];
        var NewBaseLine = rBaseLine.Copy();
        rCopyGraphPropertyInfo.m_BaseLineArray[rCopyGraphPropertyInfo.m_BaseLineArray.length] = NewBaseLine;
    }

    var rSrcSubGraphProperty;
    nLength = this.m_SubGraphPropertyInfoArray.length;
    for( i = 0; i < nLength; i++ )
    {
        rSrcSubGraphProperty = this.m_SubGraphPropertyInfoArray[i];

        var NewSubGraphPropertyInfo = rSrcSubGraphProperty.Copy();
        rCopyGraphPropertyInfo.m_SubGraphPropertyInfoArray[rCopyGraphPropertyInfo.m_SubGraphPropertyInfoArray.length] = NewSubGraphPropertyInfo;
    }

    return rCopyGraphPropertyInfo;
}
/////////////////////////////////////////////////////////////////
//계산과정이 없는 일반 그래프
export function CGraph(rRQSet, strName) {

    //this.m_strKey = strName + "-" + Date.now() + "-" + (Math.floor(Math.random() * (10000 - 1 + 1)) + 1);
    this.m_strKey = "" + (Math.floor(Math.random() * (10000 - 1 + 1)) + 1);
    this.m_strGroup = null;
    this.m_strName = strName;
    this.m_strTitle = "";//설정창 같은 곳에 셋팅 또는 지표리스트 보이는 경우 사용되는 타이틀명칭
    this.m_strTitleLangKey = "";

    this.m_nBasePriceTextAlign = TEXT_RIGHT_ALIGN;
    this.m_bShowBasePrice = true;//기준선위에 기준가표시여부(우측표시)
    this.m_BaseLineArray = [];//기준선 배열

    this.m_rXAxisPacket = null;
    this.m_rRQSet = rRQSet;
    this.m_rChart = rRQSet ? rRQSet.m_rChart : null;
    this.m_rGlobalProperty = (this.m_rChart !== null ? this.m_rChart.GetGlobalProperty() : null);

    this.m_rBlock = null;
    this.m_rYScale = null;
    this.m_rXScale = null;

    this.m_strFontName = "돋움";//"굴림";
    this.m_nFontSize = 11;//9;

    this.m_SubGraphArray = [];

    this.m_GraphMinMaxInfo = new CMinMaxInfo();

    this.m_bSelected = false;

    this.m_bRenderingBreak = false;

    this.m_rRQInCol = null;
    
    this.m_nShowLatestDataType = 0;
    this.m_bShowLatestDataOfAllSubGraph = false;
    this.m_nDataChangeRatioType = 0;

    //수치조회 및 툴팁 메모리 풀방식 처리
    this.m_GraphFindData = new CGraphFindData(this);

    ////////////////////////////////////////////////////
    //그래프가 차트에 추가될 때 지정해주어야 하는 설정값
    this.m_nAddType = APPEND_TYPE;//APPEND_TYPE(0), OVERLAY_TYPE(1)
    this.m_strOverlayGraphName = null;//OVERLAY_TYPE인 경우 OVERLAY 하기 위해 찾아야 하는 그래프명(해당 그래프를 찾아서 추가되지 않았으면 APPEND 된다)
    ////////////////////////////////////////////////////
}

CGraph.prototype.ChangeLang = function(){

    if(this.m_strTitleLangKey && this.m_strTitleLangKey.length > 0)
        this.m_strTitle = t(this.m_strTitleLangKey);

    var i, rSubGraph , nSubGraphLen = this.m_SubGraphArray.length;
    for( i = 0 ; i < nSubGraphLen; i++ )
    {
        rSubGraph = this.m_SubGraphArray[i];
        rSubGraph.ChangeLang();
    }
}

CGraph.prototype.GetChartFullProperty = function () {

    var GraphProperty = new CGraphProperty();
    GraphProperty.m_strRQ = this.m_rRQSet.m_strRQ;
    GraphProperty.m_strGraphName = this.m_strName;
    GraphProperty.m_strGraphKey = this.m_strKey;
    var BlockPosInfo = this.GetBlockPosInfo();
    GraphProperty.m_nColIndex = BlockPosInfo.m_X;
    GraphProperty.m_nRowIndex = BlockPosInfo.m_Y;
    GraphProperty.m_nVertScaleIndex = BlockPosInfo.m_nVertScaleIndex;
    GraphProperty.m_nBlockRatio = this.m_rBlock.GetBlockRatio();
    GraphProperty.m_PropertyInfo = this.GetPropertyInfo();
    return GraphProperty;
}

CGraph.prototype.GetBlockPosInfo = function () {

    var rBlock = this.m_rBlock;

    gResultBlockPos.m_X = rBlock.m_nColIndex;
    gResultBlockPos.m_Y = rBlock.m_nRowIndex;
    gResultBlockPos.m_nVertScaleIndex = null;

    var i, nLen = rBlock.m_YScaleArray.length;
    for (i = 0; i < nLen; i++) {
        if (this.m_rYScale === rBlock.m_YScaleArray[i]) {
            gResultBlockPos.m_nVertScaleIndex = i;
            break;
        }
    }
    return gResultBlockPos;
}

CGraph.prototype.GetTotalIndicatorProp = function (mapTotalIndicatorProp) {

    var Property = this.GetPropertyInfo();
    var CopyProperty = Property.Copy();
    //var strKey = this.m_strName + "_" + this.m_strKey;
    mapTotalIndicatorProp[this.m_strName] = CopyProperty;
}

CGraph.prototype.SetGlobalPropertyToChart = function () {

    let i, j, rSubGraph = null, nSubGraphArrayLen = this.m_SubGraphArray.length;
    for (i = 0; i < nSubGraphArrayLen; i++) {

        rSubGraph = this.m_SubGraphArray[i];
        rSubGraph.SetGlobalPropertyToChart();
    }
}

CGraph.prototype.ChangeSubGraphSubType = function (strSubGraphName, nSubGraphSubType) {

    let i, j, rSubGraph = null, nSubGraphArrayLen = this.m_SubGraphArray.length;
    for (i = 0; i < nSubGraphArrayLen; i++) {

        rSubGraph = this.m_SubGraphArray[i];
        if (rSubGraph.m_strSubGraphName === strSubGraphName) {
            rSubGraph.ChangeSubGraphSubType(nSubGraphSubType);
            return true;
        }
    }
    return false;
}

CGraph.prototype.GetLog = function () {
    return this.m_rYScale.GetLog();
}

CGraph.prototype.GetInvert = function () {
    return this.m_rYScale.GetInvert();
}

CGraph.prototype.SetShowLatestDataType = function (nShowLatestDataType) {
    this.m_nShowLatestDataType = nShowLatestDataType;
}
CGraph.prototype.GetShowLatestDataType = function () {
    return this.m_nShowLatestDataType;
}
CGraph.prototype.SetShowLatestDataOfAllSubGraph = function (bShowLatestDataOfAllSubGraph) {
    this.m_bShowLatestDataOfAllSubGraph = bShowLatestDataOfAllSubGraph;
}
CGraph.prototype.GetShowLatestDataOfAllSubGraph = function () {
    return this.m_bShowLatestDataOfAllSubGraph;
}
CGraph.prototype.SetDataChangeRatioType = function (nDataChangeRatioType) {
    this.m_nDataChangeRatioType = nDataChangeRatioType;
}
CGraph.prototype.GetDataChangeRatioType = function () {
    return this.m_nDataChangeRatioType;
}

CGraph.prototype.SetRQInCol = function (RQInCol) {

    this.m_rRQInCol = RQInCol;
    var i, length = this.m_SubGraphArray.length;
    for (i = 0; i < length; i++) {

        var rSubGraph = this.m_SubGraphArray[i];
        rSubGraph.m_rRQInCol = RQInCol;
    }
}
CGraph.prototype.AddSelectPosInfo = function () {
    var i, length = this.m_SubGraphArray.length;
    for (i = 0; i < length; i++) {
        var rSubGraph = this.m_SubGraphArray[i];
        rSubGraph.AddSelectPosInfo();
    }
}
CGraph.prototype.InitRendering = function () {

    var i, length = this.m_SubGraphArray.length;
    for (i = 0; i < length; i++) {

        var rSubGraph = this.m_SubGraphArray[i];
        rSubGraph.InitRendering();
    }
}
CGraph.prototype.ReadyRendering = function (DrawingInfo) {

    this.m_bRenderingBreak = false;

    var i, length = this.m_SubGraphArray.length;
    for (i = 0; i < length; i++) {
        var rSubGraph = this.m_SubGraphArray[i];
        rSubGraph.ReadyRendering(DrawingInfo);
    }
}
CGraph.prototype.RenderingInLoop = function (RenderingInfo) {

    var i, length = this.m_SubGraphArray.length;
    for (i = 0; i < length; i++) {
        var rSubGraph = this.m_SubGraphArray[i];
        rSubGraph.RenderingInLoop(RenderingInfo);
    }
}
CGraph.prototype.RenderingOnLast = function (RenderingInfo) {

    //if (this.m_bRenderingBreak)
    //    return true;

    var bBreak = true;
    var i, length = this.m_SubGraphArray.length;
    for (i = 0; i < length; i++) {
        var rSubGraph = this.m_SubGraphArray[i];
        if (!rSubGraph.RenderingOnLast(RenderingInfo))
            bBreak = false;
    }

    this.m_bRenderingBreak = bBreak;
    return bBreak;
}

CGraph.prototype.SetUpdateMinMax = function (bUpdateMinMax) {
    this.m_rYScale.SetUpdateMinMax(bUpdateMinMax);
}
CGraph.prototype.GetGraphKey = function () {
    return this.m_strKey;
}
CGraph.prototype.GetGraphName = function () {
    return this.m_strName;
}
CGraph.prototype.SendEvent = function (strEventName, EventInfoData) {
    this.m_rBlock.SendEvent(strEventName, EventInfoData);
}
CGraph.prototype.GetTitleDiv = function (TitleDiv) {

    var nLength = this.m_SubGraphArray.length;
    for (var i = 0; i < nLength; i++) {
        var rSubGraph = this.m_SubGraphArray[i];
        var rTitleDiv = rSubGraph.GetTitleDiv();
        if (rTitleDiv) {
            TitleDiv[TitleDiv.length] = rTitleDiv;
        }
    }
}
CGraph.prototype.SetTitle = function (strTitle) {
    this.m_strTitle = strTitle;
}
CGraph.prototype.ShowTitle = function (StartPt, LayoutInfo, TitleDivArray) {

    var bShowIndicatorName = this.m_rGlobalProperty.m_bShowIndicatorName;
    var bShowIndicatorParameter = this.m_rGlobalProperty.m_bShowIndicatorParameter;
    var bShowIndicatorValue = this.m_rGlobalProperty.m_bShowIndicatorValue;

    //지표명과 지표값 보지 않는 설정은 타이틀 자체를 생성하지 않는다
    if (bShowIndicatorName === false && bShowIndicatorValue === false) {
        this.DestroyTitle();
        return;
    }

    var nLength = this.m_SubGraphArray.length;
    var strTitle, strLastestData, rLastestPacketItemData = null;
    for (var i = 0; i < nLength; i++) {
        var rSubGraph = this.m_SubGraphArray[i];

        if (bShowIndicatorName === true)
            strTitle = rSubGraph.m_strSubGraphTitle;
        else
            strTitle = "";

        if (bShowIndicatorValue === true) {

            rLastestPacketItemData = rSubGraph.m_rPacketData.GetLastestPacketItemData();
            if (rLastestPacketItemData !== null) {

                if (rLastestPacketItemData.GetPacketType() === NUMERIC_TYPE) {
                    strLastestData = ConvertNumToDigitText(rLastestPacketItemData.m_Data, rLastestPacketItemData.m_rPacketData.m_nDec, 1, rLastestPacketItemData.m_rPacketData.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);
                    strTitle += "(" + strLastestData + ")";
                }
                else
                    strTitle += "(" + rLastestPacketItemData.m_Data + ")";
            }
        }
        rSubGraph.SetTitle(strTitle);
        
        var rTitleDiv = rSubGraph.ShowTitle(StartPt, LayoutInfo);
        if (rTitleDiv)
            TitleDivArray[TitleDivArray.length] = rTitleDiv;
    }
}
CGraph.prototype.DestroyTitle = function () {

    var nLength = this.m_SubGraphArray.length;
    for (var i = 0; i < nLength; i++) {
        var rSubGraph = this.m_SubGraphArray[i];
        rSubGraph.DestroyTitle();
    }
}

CGraph.prototype.SetPropertyInfo = function (strKey, PropertyInfo, bSetup) {

    if (this.m_strKey !== strKey)
        return false;

    this.m_strGroup = PropertyInfo.m_strGroup;
    this.m_strName = PropertyInfo.m_strName;
    
    if(PropertyInfo.m_strTitleLangKey && PropertyInfo.m_strTitleLangKey.length > 0)
        this.m_strTitle = t(PropertyInfo.m_strTitleLangKey);
    else
        this.m_strTitle = PropertyInfo.m_strTitle;
    
    this.m_strTitleLangKey = PropertyInfo.m_strTitleLangKey;

	this.m_nBasePriceTextAlign = PropertyInfo.m_nBasePriceTextAlign;
	this.m_bShowBasePrice = PropertyInfo.m_bShowBasePrice;

    this.m_nShowLatestDataType = PropertyInfo.m_nShowLatestDataType ;//마지막값 표시 (0:보이지 않음, 1: 보이는 영역에서 최근봉 데이터 보기, 2: 현재시세 또는 현재값 보기)
    this.m_bShowLatestDataOfAllSubGraph = PropertyInfo.m_bShowLatestDataOfAllSubGraph ;//모든 라인 표시
    this.m_nDataChangeRatioType = PropertyInfo.m_nDataChangeRatioType ; //등락률 표시

    this.m_nAddType = PropertyInfo.m_nAddType;

    var i, j;

    //////////////////////////////////////////////////////////////
    //SubGraph
    var rSubGraph;
    var rSubGraphPropertyInfo;
    var nPropLength = PropertyInfo.m_SubGraphPropertyInfoArray.length;
    var nSubGraphLength = this.m_SubGraphArray.length;
    var nMinLen = nPropLength > nSubGraphLength ? nSubGraphLength : nPropLength;

    for (i = 0; i < nMinLen; i++)
        this.m_SubGraphArray[i].SetPropertyInfo(PropertyInfo.m_SubGraphPropertyInfoArray[i], bSetup);
        
    /////////////////////////////////////////////////////////
    //BaseLine
    var rBaseLine, rPropBaseLine;
    nPropLength = PropertyInfo.m_BaseLineArray.length;
    var nBaseLineLen = this.m_BaseLineArray.length;
    var nDiffLen = nPropLength - nBaseLineLen;
    nMinLen = nPropLength > nBaseLineLen ? nBaseLineLen : nPropLength;

    for (i = 0; i < nMinLen; i++)
        this.m_BaseLineArray[i].SetPropertyInfo(PropertyInfo.m_BaseLineArray[i], bSetup);

    if (nDiffLen < 0)
        this.m_BaseLineArray.splice(nBaseLineLen + nDiffLen, -nDiffLen);
    else {

        for (j = 0; j < nDiffLen; j++) {

            rPropBaseLine = PropertyInfo.m_BaseLineArray[i + j];
            rBaseLine = new CBaseLine();
            rBaseLine.SetPropertyInfo(rPropBaseLine, bSetup);
            this.m_BaseLineArray[this.m_BaseLineArray.length] = rBaseLine;
        }
    }

    return true;
}
CGraph.prototype.GetPropertyInfo = function (strKey, PropertyInfo) {

    var i, j;

    if (strKey !== undefined && this.m_strKey !== strKey)
        return null;

    if (PropertyInfo === undefined)
        PropertyInfo = new CGraphPropertyInfo();

    PropertyInfo.m_strKey = this.m_strKey;
    PropertyInfo.m_strGroup = this.m_strGroup;
    PropertyInfo.m_strName = this.m_strName;
	PropertyInfo.m_strTitle = this.m_strTitle;
    PropertyInfo.m_strTitleLangKey = this.m_strTitleLangKey;

	PropertyInfo.m_nBasePriceTextAlign = this.m_nBasePriceTextAlign;
	PropertyInfo.m_bShowBasePrice = this.m_bShowBasePrice;

    PropertyInfo.m_nShowLatestDataType = this.m_nShowLatestDataType;//마지막값 표시 (0:보이지 않음, 1: 보이는 영역에서 최근봉 데이터 보기, 2: 현재시세 또는 현재값 보기)
    PropertyInfo.m_bShowLatestDataOfAllSubGraph = this.m_bShowLatestDataOfAllSubGraph;//모든 라인 표시
    PropertyInfo.m_nDataChangeRatioType = this.m_nDataChangeRatioType; //등락률 표시

    PropertyInfo.m_nAddType = this.m_nAddType;

    var nLength = this.m_BaseLineArray.length;
    for (i = 0; i < nLength; i++) {
        PropertyInfo.m_BaseLineArray[i] = this.m_BaseLineArray[i];
    }

    nLength = this.m_SubGraphArray.length;
    for (i = 0; i < nLength; i++) {
        PropertyInfo.m_SubGraphPropertyInfoArray[i] = this.m_SubGraphArray[i].GetPropertyInfo();
    }
    return PropertyInfo;
}
CGraph.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, nFindXIndex, rXScaleMng, rFindInfo) {

    var rGraphXScaleMng = this.GetXScaleMng();
    if (rGraphXScaleMng !== undefined && rXScaleMng === rGraphXScaleMng) {

        if (rXScaleMng.GetType() === DATETIME_TYPE) {

            var strRQ = this.m_rRQSet.GetRQ();

            
            //var rDateTimeXScaleItem = new CDateTimeXScaleItem(rXScaleMng);
            //var nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(nFindXIndex, 0, rXScaleMng.m_XScaleItemArray.length, rDateTimeXScaleItem);
            //if (nXScaleItemArrayIndex < 0 || rDateTimeXScaleItem === null)
            //    return null;
            //var tDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(nFindXIndex);
            var tDateTime = null;
            var rXScaleMergeIndex = rXScaleMng.m_XScaleMergeArray[nFindXIndex];
            if (rXScaleMergeIndex !== undefined)
            {
                rXScaleMng.m_tFindDateTime = rXScaleMergeIndex.m_tStart;

                var rRQPackets = rXScaleMergeIndex.m_mapRQPacketsItem[strRQ];

                if (rRQPackets === undefined) {

                    var strKey = strRQ + "_TIME";
                    var tPrevStartDateTime = rXScaleMng.m_tTimeArray[rXScaleMergeIndex.m_tStart][strKey];
                    if (tPrevStartDateTime !== undefined) {

                        if (rXScaleMng.m_tTimeArray[tPrevStartDateTime] !== undefined) {
                            rRQPackets = rXScaleMng.m_tTimeArray[tPrevStartDateTime][strRQ];
                        }
                    }
                }

                if (rRQPackets !== undefined) {

                    if (!rFindInfo) {

                        rFindInfo = new CFindInfo();
                        rFindInfo.m_strRQ = strRQ;
                        rFindInfo.m_XDataInfo = rRQPackets;
                        rFindInfo.m_strXTitle = rXScaleMng.GetTitle();

                        var DateTimeItem = rRQPackets.m_Packets[this.m_rXAxisPacket.m_nPacketIndex];

                        //LKY 세계시간 적용 >>
                        var ChangeDateTime = ChangeGlobalTime(this.m_rGlobalProperty.m_ChartUniversalTime, DateTimeItem.m_tDateTime);
                        
                        var nYear = ChangeDateTime.getFullYear();
                        var nMon = ChangeDateTime.getMonth();
                        var nDay = ChangeDateTime.getDate();
                        var nHour = ChangeDateTime.getHours();
                        var nMin = ChangeDateTime.getMinutes();
                        var nSecond = ChangeDateTime.getSeconds();

                        switch (rRQPackets.m_nCycle) {
                            case 1://일
                            case 2://주
                                //rFindInfo.m_strXData = DateTimeItem.m_nYear + "/" + sprintf(2, (DateTimeItem.m_nMonth + 1)) + "/" + sprintf(2, DateTimeItem.m_nDay); break;
                                rFindInfo.m_strXData = nYear + "/" + sprintf(2, (nMon + 1)) + "/" + sprintf(2, nDay); break;
                            case 3://월
                                //rFindInfo.m_strXData = DateTimeItem.m_nYear + "/" + sprintf(2, (DateTimeItem.m_nMonth + 1)); break;
                                rFindInfo.m_strXData = nYear + "/" + sprintf(2, (nMon + 1)); break;
                            case 4://년
                                //rFindInfo.m_strXData = DateTimeItem.m_nYear; break;
                                rFindInfo.m_strXData = nYear; break;
                            case 5://분
                                //rFindInfo.m_strXData = DateTimeItem.m_nYear + "/" + sprintf(2, (DateTimeItem.m_nMonth + 1)) + "/" + sprintf(2, DateTimeItem.m_nDay) + " " + sprintf(2, DateTimeItem.m_nHour) + ":" + sprintf(2, DateTimeItem.m_nMin); break;
                                rFindInfo.m_strXData = nYear + "/" + sprintf(2, (nMon + 1)) + "/" + sprintf(2, nDay) + " " + sprintf(2, nHour) + ":" +
                                sprintf(2, nMin); break;
                            case 6://초
                                //rFindInfo.m_strXData = DateTimeItem.m_nYear + "/" + sprintf(2, (DateTimeItem.m_nMonth + 1)) + "/" + sprintf(2, DateTimeItem.m_nDay) + " " + sprintf(2, DateTimeItem.m_nHour) + ":" + //sprintf(2, DateTimeItem.m_nMin) + ":" + sprintf(2, DateTimeItem.m_nSecond); break;
                                rFindInfo.m_strXData = nYear + "/" + sprintf(2, (nMon + 1)) + "/" + sprintf(2, nDay) + " " + sprintf(2, nHour) + ":" + sprintf(2, nMin) + ":" + sprintf(2, nSecond); break;
                            default://기본주기 => 일주기
                                //rFindInfo.m_strXData = DateTimeItem.m_nYear + "/" + sprintf(2, (DateTimeItem.m_nMonth + 1)) + "/" + sprintf(2, DateTimeItem.m_nDay); break;
                                rFindInfo.m_strXData = nYear + "/" + sprintf(2, (nMon + 1)) + "/" + sprintf(2, nDay); break;
                        }
                        //LKY 세계시간 적용 <<
                    }

                    var GraphFindData = null;
                    var i, length = this.m_SubGraphArray.length;
                    for (i = length - 1; i >= 0; i--) {

                        var rSubGraph = this.m_SubGraphArray[i];
                        if (rSubGraph.m_bShow === false)
                            continue;

                        if (rSubGraph.FindRQGraphDataPerXScaleMng(X, Y, rRQPackets, rXScaleMng, this.m_rBlock.m_rectGraphRegion)) {
                           
                            rFindInfo.m_rFindSubGraph = rSubGraph;//마우스 위치에 서브그래프가 존재하는 경우 찾은 서브그래프를 변수에 저장한다

                            break;
                        }
                    }

                    return rFindInfo;
                }
            }
        }
        else if (rXScaleMng.GetXScalePacketName() === "_HOGA_")
        {
            var strRQ = this.m_rRQSet.GetRQ();

            
            //var rDateTimeXScaleItem = new CDateTimeXScaleItem(rXScaleMng);
            //var nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(nFindXIndex, 0, rXScaleMng.m_XScaleItemArray.length, rDateTimeXScaleItem);
            //if (nXScaleItemArrayIndex < 0 || rDateTimeXScaleItem === null)
            //    return null;
            //var tDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(nFindXIndex);
            var tDateTime = null;
            var rXScaleItem = rXScaleMng.m_XScaleItemArray[nFindXIndex];
            if (rXScaleMergeIndex !== undefined)
            {
                var rRQPackets = rXScaleItem.m_mapRQPacketsItem[strRQ];
                if (rRQPackets !== undefined) {

                    if (!rFindInfo) {

                        rFindInfo = new CFindInfo();
                        rFindInfo.m_strRQ = strRQ;
                        rFindInfo.m_XDataInfo = rRQPackets;
                        rFindInfo.m_strXTitle = rXScaleMng.GetTitle();

                        var rHogaPacketItemData = rRQPackets.m_Packets[this.m_rXAxisPacket.m_nPacketIndex];
                        rFindInfo.m_strXData = ConvertNumToDigitText(rHogaPacketItemData.m_Data, rHogaPacketItemData.m_rPacketData.m_nDec, 1, rHogaPacketItemData.m_rPacketData.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);                        
                    }

                    var GraphFindData = null;
                    var i, length = this.m_SubGraphArray.length;
                    for (i = length - 1; i >= 0; i--) {

                        var rSubGraph = this.m_SubGraphArray[i];
                        if (rSubGraph.m_bShow === false)
                            continue;

                        if (rSubGraph.FindRQGraphDataPerXScaleMng(X, Y, rRQPackets, rXScaleMng, this.m_rBlock.m_rectGraphRegion)) {
                           
                            rFindInfo.m_rFindSubGraph = rSubGraph;//마우스 위치에 서브그래프가 존재하는 경우 찾은 서브그래프를 변수에 저장한다

                            break;
                        }
                    }

                    return rFindInfo;
                }
            }
        }
    }

    return null;
}

CGraph.prototype.GetRQGraphFindDataPerXScaleMng = function (rFindInfo, rXScaleMng) {

    var GraphFindData = null;
    var rGraphXScaleMng = this.GetXScaleMng();
    if (rGraphXScaleMng !== undefined && rXScaleMng === rGraphXScaleMng) {

        if (rXScaleMng.GetType() === DATETIME_TYPE) {

            var rRQPackets = rFindInfo;
            if (rRQPackets !== undefined) {

                var i, length = this.m_SubGraphArray.length;
                for (i = 0; i < length; i++) {

                    var rSubGraph = this.m_SubGraphArray[i];
                    var SubGraphFindData = rSubGraph.GetRQGraphFindDataPerXScaleMng(rRQPackets);
                    if (SubGraphFindData !== null) {

                        if (GraphFindData === null) {
                            GraphFindData = this.m_GraphFindData;
                            GraphFindData.m_strGraphName = this.m_strTitle;
                        }

                        var rSubGraphFindData = GraphFindData.GetSubGraphFindData(SubGraphFindData.m_strSubGraphName);
                        if(rSubGraphFindData === null)
                            GraphFindData.m_arrSubGraphFindData[GraphFindData.m_arrSubGraphFindData.length] = SubGraphFindData;
                    }
                }
            }
        }
    }
    return GraphFindData;
}
CGraph.prototype.GetGraphTitleInfo = function () {

    var GraphTitleInfo = new CGraphTitleInfo();
    GraphTitleInfo.m_strGraphTitle = this.m_strName;
    var i, length = this.m_SubGraphArray.length;
    for (i = 0; i < length; i++) {
        var SubGraph = this.m_SubGraphArray[i];
        var SubGraphTitleInfo = SubGraph.GetSubGraphTitleInfo();
        GraphTitleInfo.m_SubGraphTitleInfoArray[GraphTitleInfo.m_SubGraphTitleInfoArray.length] = SubGraphTitleInfo;
    }
    return GraphTitleInfo;
}

CGraph.prototype.GetXScaleMng = function () {
    var strXPacketName = this.m_rXAxisPacket.GetPacketName();
    return this.m_rRQSet.GetXScaleMng(strXPacketName);
}
CGraph.prototype.GetYScale = function () {
    return this.m_rYScale;
}
CGraph.prototype.GetXScale = function () {
    return this.m_rXScale;
}
CGraph.prototype.IsSelected = function () {
    return this.m_bSelected;
}
CGraph.prototype.Select = function (bSelected) {
    this.m_bSelected = bSelected;
    if (bSelected == true) {
        var i, nLength = this.m_rBlock.m_YScaleArray.length;
        for (i = 0; i < nLength; i++)
            this.m_rBlock.m_YScaleArray[i].Select(false);
        this.m_rYScale.Select(true);
    }
}
CGraph.prototype.GetXScaleMng = function () {
    var rXScaleMng = this.m_rRQSet.GetXScaleMng(this.m_rXAxisPacket.m_strPacketName);
    return rXScaleMng;
}
CGraph.prototype.ExtractYScaleMinMax = function (MinMaxInfo, bFullScan) {

    var bZeroBaseLine = false;
    this.m_GraphMinMaxInfo.Init();
    var rXScaleMng = this.m_rRQSet.GetXScaleMng(this.m_rXAxisPacket.m_strPacketName);
    for (var i = 0; i < this.m_SubGraphArray.length; i++) {
        var SubGraph = this.m_SubGraphArray[i];

        if (SubGraph.m_bShow != true)
            continue;

        //var SubGraphMinMaxInfo = new CMinMaxInfo();
        gMinMaxInfo.Init();
        var SubGraphMinMaxInfo = gMinMaxInfo;
        SubGraph.ExtractYScaleMinMax(rXScaleMng, SubGraphMinMaxInfo, bFullScan);

        //console.log("CSubGraph.ExtractYScaleMinMax [" + SubGraph.m_strSubGraphName + "]  =>> Min:" + SubGraphMinMaxInfo.m_Min + ", Max:" + SubGraphMinMaxInfo.m_Max);

        if (SubGraphMinMaxInfo.m_Max != null) {
            if (this.m_GraphMinMaxInfo.m_Max == null || SubGraphMinMaxInfo.m_Max > this.m_GraphMinMaxInfo.m_Max)
                this.m_GraphMinMaxInfo.m_Max = SubGraphMinMaxInfo.m_Max;
        }

        if (SubGraphMinMaxInfo.m_Min != null) {
            if (this.m_GraphMinMaxInfo.m_Min == null || SubGraphMinMaxInfo.m_Min < this.m_GraphMinMaxInfo.m_Min)
                this.m_GraphMinMaxInfo.m_Min = SubGraphMinMaxInfo.m_Min;
        }

        if (SubGraphMinMaxInfo.m_bZeroBaseLine)
            bZeroBaseLine = SubGraphMinMaxInfo.m_bZeroBaseLine;

        this.m_GraphMinMaxInfo.m_nStartIndex = SubGraphMinMaxInfo.m_nStartIndex;
        this.m_GraphMinMaxInfo.m_nEndIndex = SubGraphMinMaxInfo.m_nEndIndex;
    }

    MinMaxInfo.m_Max = this.m_GraphMinMaxInfo.m_Max;
    MinMaxInfo.m_Min = this.m_GraphMinMaxInfo.m_Min;
    MinMaxInfo.m_nStartIndex = this.m_GraphMinMaxInfo.m_nStartIndex;
    MinMaxInfo.m_nEndIndex = this.m_GraphMinMaxInfo.m_nEndIndex;

    //console.log("CGraph.ExtractYScaleMinMax [" + this.m_strName + "]  =>> Min:" + this.m_GraphMinMaxInfo.m_Min + ", Max:" + this.m_GraphMinMaxInfo.m_Max);

    if (bZeroBaseLine && (MinMaxInfo.m_Max == 0 || MinMaxInfo.m_Min == 0))
        MinMaxInfo.m_bZeroBaseLine = true;
}

CGraph.prototype.SetRQSet = function (rRQSet) {
    this.m_rRQSet = rRQSet;
}
CGraph.prototype.GetRQSet = function () {
    return this.m_rRQSet;
}
CGraph.prototype.Draw = function (DrawingInfo) {

    var i;
    for (i = 0; i < this.m_SubGraphArray.length; i++)
        this.m_SubGraphArray[i].Draw(DrawingInfo);

    this.DrawBaseLine(DrawingInfo);
}

CGraph.prototype.DrawBaseLine = function (DrawingInfo) {

    let BaseValue = null;
    let rBaseLine = null;
    let rYScale = this.m_rYScale;
    let bLog = rYScale.m_bLog;
    let bInvert = rYScale.m_bInvert;
    let yMin, yMax, yDiff, yPos, xPos;
    let rectGraphRegion = DrawingInfo.m_rectGraphRegion;
    let nGraphRegionHeight = rectGraphRegion.Height();
    let nLeft = DrawingInfo.m_rectGraphBackground.m_nLeft;
    let nRight = DrawingInfo.m_rectGraphBackground.m_nRight;
    let bShowBasePrice = this.m_bShowBasePrice;
    let nBasePriceTextAlign = this.m_nBasePriceTextAlign;
    let strBasePrice = null;

    if (bLog === true) {

        yMin = Log(rYScale.m_MinMaxInfo.m_LowerLimit);
        yMax = Log(rYScale.m_MinMaxInfo.m_UpperLimit);
    }
    else {

        yMin = rYScale.m_MinMaxInfo.m_LowerLimit;
        yMax = rYScale.m_MinMaxInfo.m_UpperLimit;
    }
    yDiff = yMax - yMin;

    let i, nBaseLineLen = this.m_BaseLineArray.length;
    for (i = 0; i < nBaseLineLen; i++) {

        rBaseLine = this.m_BaseLineArray[i];

        BaseValue = (bLog === true ? Log(rBaseLine.m_dBaseValue) : rBaseLine.m_dBaseValue);

        yPos = rectGraphRegion.m_nBottom - (BaseValue - yMin) / yDiff * nGraphRegionHeight;

        if (bInvert === true)
            yPos = rectGraphRegion.m_nBottom - yPos + rectGraphRegion.m_nTop;

        if (rectGraphRegion.m_nTop < yPos && yPos < rectGraphRegion.m_nBottom) {

            DrawingInfo.m_Context.fillStyle = rBaseLine.m_clrLine;

            //선그리기
            switch (rBaseLine.m_nLineType) {
                case PS_SOLID: DrawingInfo.m_Context.setLineDash([0, 0]); break;
                case PS_DASH: DrawingInfo.m_Context.setLineDash([8, 4]); break;
                case PS_DOT: DrawingInfo.m_Context.setLineDash([2, 3]); break;
                default: DrawingInfo.m_Context.setLineDash([0, 0]); break;
            }

            DrawingInfo.m_Context.strokeStyle = rBaseLine.m_clrLine;
            DrawingInfo.m_Context.lineWidth = rBaseLine.m_nThickness;

            DrawingInfo.m_Context.beginPath();

            yPos = Math.floor(yPos) + 0.5;

            DrawingInfo.m_Context.moveTo(nLeft, yPos);
            DrawingInfo.m_Context.lineTo(nRight, yPos);

            if (bShowBasePrice === true) {

                strBasePrice = ConvertNumToDigitText(BaseValue, rYScale.m_nDec, 1, rYScale.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

                if (yPos - DrawingInfo.m_nFontHeight < rectGraphRegion.m_nTop) {
                    DrawingInfo.m_Context.textBaseline = "top";
                    yPos += 2;
                }
                else {
                    DrawingInfo.m_Context.textBaseline = "bottom";
                    yPos -= 1;
                }

                if (nBasePriceTextAlign & TEXT_LEFT_ALIGN) {
                    xPos = nLeft + 1;
                    DrawingInfo.m_Context.textAlign = "left";
                    DrawingInfo.m_Context.fillText(strBasePrice, xPos, yPos);
                }
                if (nBasePriceTextAlign & TEXT_RIGHT_ALIGN) {
                    xPos = nRight - 1;
                    DrawingInfo.m_Context.textAlign = "right";
                    DrawingInfo.m_Context.fillText(strBasePrice, xPos, yPos);
                }
            }

            DrawingInfo.m_Context.stroke();
            DrawingInfo.m_Context.closePath();
        }
    }
}

CGraph.prototype.Calc = function () {
    if (!this.m_rRQSet)
        return false;
    return true;
}

//bAddData : true(봉이 추가되는 상황), false(마지막 봉이 업데이트 되는 상황)
CGraph.prototype.RealCalc = function (bAddData) {
    if (!this.m_rRQSet)
        return false;
    return true;
}
/////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////
//CIndiProperty
export function CIndiPropertyInfo() {
    CGraphPropertyInfo.call(this);

    this.m_VariableArray = [];
}
CIndiPropertyInfo.prototype = new CGraphPropertyInfo();
CIndiPropertyInfo.prototype.constructor = CIndiPropertyInfo;

CIndiPropertyInfo.prototype.AddVariableInfo = function (Variable) {
    this.m_VariableArray[this.m_VariableArray.length] = Variable;
}
CIndiPropertyInfo.prototype.SetPropertyInfo = function (PropertyInfo) {

    if (!CGraphPropertyInfo.prototype.SetPropertyInfo.call(this, PropertyInfo))
        return false;

    var i, j;
    var rPropVariable;
    this.m_VariableArray.length = 0;
    var nPropLength = PropertyInfo.m_VariableArray.length;

    for (i = 0; i < nPropLength; i++) {

        var NewVariable = new CVariable();
        NewVariable.SetPropertyInfo(PropertyInfo.m_VariableArray[i]);
        this.m_VariableArray[this.m_VariableArray.length] = NewVariable;
    }

    return true;
}
CIndiPropertyInfo.prototype.Copy = function ( rCopyIndiPropertyInfo )
{
    if( rCopyIndiPropertyInfo === undefined )
        rCopyIndiPropertyInfo = new CIndiPropertyInfo();

    rCopyIndiPropertyInfo = CGraphPropertyInfo.prototype.Copy.call( this, rCopyIndiPropertyInfo );

    var nLength = this.m_VariableArray.length;
    for( var i = 0; i < nLength; i++ )
    {
        var NewVariable = this.m_VariableArray[i].Copy();
        rCopyIndiPropertyInfo.m_VariableArray[rCopyIndiPropertyInfo.m_VariableArray.length] = NewVariable;
    }
    
    return rCopyIndiPropertyInfo;
}

////////////////////////////////////////////////////////////////
function CXAxis(rXScale) {

    this.m_rXScale = rXScale;
    this.m_rChart = rXScale ? rXScale.m_rChart : null;
    this.m_rGlobalProperty = (this.m_rChart !== null ? this.m_rChart.GetGlobalProperty() : null);

    this.m_bTop = false;
    
    this.m_bShowOption = false;

    this.m_clrBack = !this.m_rChart ? null : this.m_rChart.GetColorByKey("background");
    if (this.m_clrBack === null)
        this.m_clrBack = "rgb( 255, 255, 255)"; //하단스케일색상

    this.m_clrText = !this.m_rChart ? null : this.m_rChart.GetColorByKey("XAxisText");
    if (this.m_clrText === null)
        this.m_clrText = "#757575";

    this.m_clrVertLine = !this.m_rChart ? null : this.m_rChart.GetColorByKey("vertLine");
    if (this.m_clrVertLine === null)
        this.m_clrVertLine = "#dedede";

    this.m_clrXAxis = !this.m_rChart ? null : this.m_rChart.GetColorByKey("XAxis");
    if (this.m_clrXAxis === null)
        this.m_clrXAxis = "#dedede";

    this.m_nVertLineType = PS_SOLID;
    this.m_nVertLineThickness = 1;

    this.m_rectAxis = new CRect();
    this.m_rectGraphRegion = new CRect();
    this.m_rectGraphBackground = new CRect();
}

CXAxis.prototype.SetGlobalPropertyToChart = function () {

    this.m_clrBack = this.m_rGlobalProperty.m_clrBack;
    this.m_clrText = this.m_rGlobalProperty.m_clrText;
    this.m_clrVertLine = this.m_rGlobalProperty.m_clrVertLine;
    this.m_nVertLineType = this.m_rGlobalProperty.m_nVertLineType;
    this.m_nVertLineThickness = this.m_rGlobalProperty.m_nVertLineThickness;
    this.m_clrXAxis = this.m_rGlobalProperty.m_clrXAxis;
}

CXAxis.prototype.SetTextColor= function (clrText) {
    this.m_clrText = clrText;
}
CXAxis.prototype.GetTextColor = function () {
    return this.m_clrText;
}
CXAxis.prototype.SetVertLineColor = function (clrVertLine) {
    this.m_clrVertLine = clrVertLine;
}
CXAxis.prototype.GetVertLineColor = function () {
    return this.m_clrVertLine;
}
CXAxis.prototype.SetVertLineThickness = function (nVertLineThickness) {
    this.m_nVertLineThickness = nVertLineThickness;
}
CXAxis.prototype.GetVertLineThickness = function () {
    return this.m_nVertLineThickness;
}
CXAxis.prototype.SetVertLineType = function (nVertLineType) {
    this.m_nVertLineType = nVertLineType;
}
CXAxis.prototype.GetVertLineType = function () {
    return this.m_nVertLineType;
}
CXAxis.prototype.SetBackColor = function (clrBack) {
    this.m_clrBack = clrBack;
}
CXAxis.prototype.GetBackColor = function () {
    return this.m_clrBack;
}
CXAxis.prototype.SetShow = function (bShow) {
    this.m_bShowOption = bShow;
}
CXAxis.prototype.GetShow = function () {
    return this.m_bShowOption;
}
CXAxis.prototype.SetTopXAxis = function (bTop) {
    this.m_bTop = bTop;
}
CXAxis.prototype.SetXScale = function (rXScale) {
    this.m_rXScale = rXScale;
}
CXAxis.prototype.GetXScale = function () {
    return this.m_rXScale;
}
CXAxis.prototype.Draw = function (DrawingInfo) {

    var nDataCnt = this.m_rXScale.m_rChartBlockCol.m_nDataCnt;
    var rXScaleMng = this.m_rXScale.m_rXScaleMng;

    //그래프영역에 격자선 그리기
    DrawingInfo.m_Context.beginPath();
    DrawingInfo.m_Context.strokeStyle = this.m_clrVertLine;
    DrawingInfo.m_Context.lineWidth = this.m_nVertLineThickness;

    var rectGraphRegion = this.m_rectGraphRegion;
    var rectGraphBackground = this.m_rectGraphBackground;
    var GraphRegionWidthPerDataCnt = rectGraphRegion.Width() / nDataCnt;

    switch (this.m_nVertLineType) {
        case PS_SOLID: DrawingInfo.m_Context.setLineDash([0, 0]); break;
        case PS_DASH: DrawingInfo.m_Context.setLineDash([8, 4]); break;
        case PS_DOT: DrawingInfo.m_Context.setLineDash([2, 3]); break;
    }

    var ScaleLineXPosArray = [];
    var nLength = this.m_rXScale.m_rChartBlockCol.m_XScaleTextPosArray.length;
    var nLineTop = rectGraphBackground.m_nTop + 0.5;
    var nLineBottom = rectGraphBackground.m_nBottom - 0.5;
    for (var i = 0; i < nLength; i++) {

        var XScalePosInfo = this.m_rXScale.m_rChartBlockCol.m_XScaleTextPosArray[i];

        var XPos = rectGraphRegion.m_nLeft + Math.floor(GraphRegionWidthPerDataCnt * (XScalePosInfo.m_nPosIndex - rXScaleMng.m_nViewStartIndex)) + 0.5;
        XScalePosInfo.m_XPos = XPos;
        if (XPos <= rectGraphRegion.m_nLeft + 1)
            continue;

        DrawingInfo.m_Context.moveTo(XPos, nLineTop);
        DrawingInfo.m_Context.lineTo(XPos, nLineBottom);

        ScaleLineXPosArray[ScaleLineXPosArray.length] = XPos;
    }
    DrawingInfo.m_Context.stroke();
    DrawingInfo.m_Context.closePath();

    DrawingInfo.m_Context.setLineDash([0, 0]);

    //눈금 & 글자 출력
    if (!this.m_bShowOption) {
        if (this.m_rectAxis.Height() > 0) {
            DrawingInfo.m_Context.fillStyle = this.m_clrBack;
            DrawingInfo.m_Context.fillRect(this.m_rectAxis.m_nLeft, this.m_rectAxis.m_nTop, this.m_rectAxis.Width(), this.m_rectAxis.Height());
        }
    }
    else {

        DrawingInfo.m_Context.fillStyle = this.m_clrBack;
        DrawingInfo.m_Context.fillRect(this.m_rectAxis.m_nLeft, this.m_rectAxis.m_nTop, this.m_rectAxis.Width(), this.m_rectAxis.Height());

        DrawingInfo.m_Context.beginPath();

        DrawingInfo.m_Context.strokeStyle = this.m_clrXAxis;
        DrawingInfo.m_Context.lineWidth = 1;

        //X축 그리기
        var nXAxisY = this.m_bTop ? rectGraphBackground.m_nTop + 0.5 : rectGraphBackground.m_nBottom - 0.5;
        DrawingInfo.m_Context.moveTo(rectGraphBackground.m_nLeft + 0.5, nXAxisY);
        DrawingInfo.m_Context.lineTo(rectGraphBackground.m_nRight + 0.5, nXAxisY);
        //DrawingInfo.m_Context.strokeStyle = this.m_clrVertLine;
        //DrawingInfo.m_Context.lineWidth = this.m_nVertLineThickness;
        DrawingInfo.m_Context.textBaseline = this.m_bTop ? "bottom" : "top";
        DrawingInfo.m_Context.textAlign = "left";
        DrawingInfo.m_Context.fillStyle = this.m_clrText;

        var rectGraphBackground = this.m_rectGraphBackground;
        var nPrevScaleTextRightPos = null;
        var nPrevXPos = null;
        var rPrevXScalePosInfo = null;
        var nScaleLineTop = this.m_bTop ? rectGraphBackground.m_nTop + 0.5 : rectGraphBackground.m_nBottom - 0.5;
        var nScaleLineBottom = this.m_bTop ? rectGraphBackground.m_nTop - 3.5 : rectGraphBackground.m_nBottom + 3.5;
        var nScaleTextY = this.m_bTop ? rectGraphBackground.m_nTop - 7.5 : rectGraphBackground.m_nBottom + 7.5;

        for (var i = 0; i < nLength; i++) {

            var XScalePosInfo = this.m_rXScale.m_rChartBlockCol.m_XScaleTextPosArray[i];

            var XPos = XScalePosInfo.m_XPos;//rectGraphRegion.m_nLeft + GraphRegionWidthPerDataCnt * (XScalePosInfo.m_nPosIndex - rXScaleMng.m_nViewStartIndex);
            if (XPos <= nPrevScaleTextRightPos) {

                if (rPrevXScalePosInfo.m_bKeyPosition === false && XScalePosInfo.m_bKeyPosition === true) {
                    nPrevXPos = XPos;
                    rPrevXScalePosInfo = XScalePosInfo;
                    nPrevScaleTextRightPos = XPos + XScalePosInfo.m_nScaleTextLen;
                }
                continue;
            }

            if (nPrevXPos) {
                
                DrawingInfo.m_Context.moveTo(nPrevXPos, nScaleLineTop);
                DrawingInfo.m_Context.lineTo(nPrevXPos, nScaleLineBottom);
                DrawingInfo.m_Context.fillText(rPrevXScalePosInfo.m_strScaleText, nPrevXPos, nScaleTextY);
            }

            nPrevXPos = XPos;
            rPrevXScalePosInfo = XScalePosInfo;
            nPrevScaleTextRightPos = XPos + XScalePosInfo.m_nScaleTextLen;
        }

        if (nPrevXPos) {

            DrawingInfo.m_Context.moveTo(nPrevXPos, nScaleLineTop);
            DrawingInfo.m_Context.lineTo(nPrevXPos, nScaleLineBottom);
            DrawingInfo.m_Context.fillText(rPrevXScalePosInfo.m_strScaleText, nPrevXPos, nScaleTextY);
        }

        DrawingInfo.m_Context.stroke();
        DrawingInfo.m_Context.closePath();
    }
}

CXAxis.prototype.CalcLayout = function (nXHeight, rectGraphRegion, rectGraphBackground, rectChartBlock, DrawingInfo) {

    if (this.m_bTop)
        this.m_rectAxis.SetRect(rectChartBlock.m_nLeft, rectChartBlock.m_nTop, rectChartBlock.m_nRight, rectChartBlock.m_nTop + nXHeight);
    else
        this.m_rectAxis.SetRect(rectChartBlock.m_nLeft, rectChartBlock.m_nBottom - nXHeight, rectChartBlock.m_nRight, rectChartBlock.m_nBottom);

    this.m_rectGraphRegion.SetRect(rectGraphRegion.m_nLeft, rectGraphRegion.m_nTop, rectGraphRegion.m_nRight, rectGraphRegion.m_nBottom);
    this.m_rectGraphBackground.SetRect(rectGraphBackground.m_nLeft, rectGraphBackground.m_nTop, rectGraphBackground.m_nRight, rectGraphBackground.m_nBottom);
}
//////////////////////////////////
//CHogaXAxis
function CHogaXAxis(rXScale)
{
    CXAxis.call(this, rXScale);
}
CHogaXAxis.prototype = new CXAxis();
CHogaXAxis.prototype.constructor = CHogaXAxis;
CHogaXAxis.prototype.Draw = function (DrawingInfo) {

    var nDataCnt = this.m_rXScale.m_rChartBlockCol.m_nDataCnt;
    var rXScaleMng = this.m_rXScale.m_rXScaleMng;

    //그래프영역에 격자선 그리기
    DrawingInfo.m_Context.beginPath();
    DrawingInfo.m_Context.strokeStyle = this.m_clrVertLine;
    DrawingInfo.m_Context.lineWidth = this.m_nVertLineThickness;

    var rectGraphRegion = this.m_rectGraphRegion;
    var rectGraphBackground = this.m_rectGraphBackground;
    var GraphRegionWidthPerDataCnt = rectGraphRegion.Width() / nDataCnt;

    switch (this.m_nVertLineType) {
        case PS_SOLID: DrawingInfo.m_Context.setLineDash([0, 0]); break;
        case PS_DASH: DrawingInfo.m_Context.setLineDash([8, 4]); break;
        case PS_DOT: DrawingInfo.m_Context.setLineDash([2, 3]); break;
    }

    var ScaleLineXPosArray = [];
    var nLength = this.m_rXScale.m_rChartBlockCol.m_XScaleTextPosArray.length;
    var nLineTop = rectGraphBackground.m_nTop + 0.5;
    var nLineBottom = rectGraphBackground.m_nBottom - 0.5;
    for (var i = 0; i < nLength; i++) {

        var XScalePosInfo = this.m_rXScale.m_rChartBlockCol.m_XScaleTextPosArray[i];

        var XPos = rectGraphRegion.m_nLeft + Math.floor(GraphRegionWidthPerDataCnt * (XScalePosInfo.m_nPosIndex - rXScaleMng.m_nViewStartIndex)) + 0.5;
        XScalePosInfo.m_XPos = XPos;
        if (XPos <= rectGraphBackground.m_nLeft + 1)
            continue;

        DrawingInfo.m_Context.moveTo(XPos, nLineTop);
        DrawingInfo.m_Context.lineTo(XPos, nLineBottom);

        ScaleLineXPosArray[ScaleLineXPosArray.length] = XPos;
    }
    DrawingInfo.m_Context.stroke();
    DrawingInfo.m_Context.closePath();

    DrawingInfo.m_Context.setLineDash([0, 0]);

    //눈금 & 글자 출력
    if (!this.m_bShowOption) {
        if (this.m_rectAxis.Height() > 0) {
            DrawingInfo.m_Context.fillStyle = this.m_clrBack;
            DrawingInfo.m_Context.fillRect(this.m_rectAxis.m_nLeft, this.m_rectAxis.m_nTop, this.m_rectAxis.Width(), this.m_rectAxis.Height());
        }
    }
    else {

        DrawingInfo.m_Context.fillStyle = this.m_clrBack;
        DrawingInfo.m_Context.fillRect(this.m_rectAxis.m_nLeft, this.m_rectAxis.m_nTop, this.m_rectAxis.Width(), this.m_rectAxis.Height());

        DrawingInfo.m_Context.beginPath();

        DrawingInfo.m_Context.strokeStyle = this.m_clrXAxis;
        DrawingInfo.m_Context.lineWidth = 1;

        //X축 그리기
        var nXAxisY = this.m_bTop ? rectGraphBackground.m_nTop + 0.5 : rectGraphBackground.m_nBottom - 0.5;
        DrawingInfo.m_Context.moveTo(rectGraphBackground.m_nLeft + 0.5, nXAxisY);
        DrawingInfo.m_Context.lineTo(rectGraphBackground.m_nRight + 0.5, nXAxisY);
        //DrawingInfo.m_Context.strokeStyle = this.m_clrVertLine;
        //DrawingInfo.m_Context.lineWidth = this.m_nVertLineThickness;
        DrawingInfo.m_Context.textBaseline = this.m_bTop ? "bottom" : "top";
        DrawingInfo.m_Context.textAlign = "left";
        DrawingInfo.m_Context.fillStyle = this.m_clrText;

        var rectGraphBackground = this.m_rectGraphBackground;
        var nPrevScaleTextRightPos = null;
        var nPrevXPos = null;
        var rPrevXScalePosInfo = null;
        var nScaleLineTop = this.m_bTop ? rectGraphBackground.m_nTop + 0.5 : rectGraphBackground.m_nBottom - 0.5;
        var nScaleLineBottom = this.m_bTop ? rectGraphBackground.m_nTop - 3.5 : rectGraphBackground.m_nBottom + 3.5;
        var nScaleTextY = this.m_bTop ? rectGraphBackground.m_nTop - 7.5 : rectGraphBackground.m_nBottom + 7.5;

        for (var i = 0; i < nLength; i++) {

            var XScalePosInfo = this.m_rXScale.m_rChartBlockCol.m_XScaleTextPosArray[i];

            var XPos = XScalePosInfo.m_XPos;//rectGraphRegion.m_nLeft + GraphRegionWidthPerDataCnt * (XScalePosInfo.m_nPosIndex - rXScaleMng.m_nViewStartIndex);
            if (XPos <= nPrevScaleTextRightPos) {

                if (rPrevXScalePosInfo.m_bKeyPosition === false && XScalePosInfo.m_bKeyPosition === true) {
                    nPrevXPos = XPos;
                    rPrevXScalePosInfo = XScalePosInfo;
                    nPrevScaleTextRightPos = XPos + XScalePosInfo.m_nScaleTextLen;
                }
                continue;
            }

            if (nPrevXPos && rPrevXScalePosInfo.m_strScaleText && rPrevXScalePosInfo.m_strScaleText.length > 0) {
                
                DrawingInfo.m_Context.moveTo(nPrevXPos, nScaleLineTop);
                DrawingInfo.m_Context.lineTo(nPrevXPos, nScaleLineBottom);
                DrawingInfo.m_Context.fillText(rPrevXScalePosInfo.m_strScaleText, nPrevXPos, nScaleTextY);
            }

            nPrevXPos = XPos;
            rPrevXScalePosInfo = XScalePosInfo;
            nPrevScaleTextRightPos = XPos + XScalePosInfo.m_nScaleTextLen;
        }

        if (nPrevXPos && rPrevXScalePosInfo.m_strScaleText && rPrevXScalePosInfo.m_strScaleText.length > 0) {

            DrawingInfo.m_Context.moveTo(nPrevXPos, nScaleLineTop);
            DrawingInfo.m_Context.lineTo(nPrevXPos, nScaleLineBottom);
            DrawingInfo.m_Context.fillText(rPrevXScalePosInfo.m_strScaleText, nPrevXPos, nScaleTextY);
        }

        DrawingInfo.m_Context.stroke();
        DrawingInfo.m_Context.closePath();
    }
}

/////////////////////////////////
function CXScale(rChartBlock) {

    this.m_rChartBlock = rChartBlock;
    this.m_rChart = rChartBlock ? rChartBlock.m_rChart : null;
    this.m_rGlobalProperty = (this.m_rChart !== null ? this.m_rChart.GetGlobalProperty() : null);

    this.m_TopXAxis = new CXAxis(this);
    this.m_BottomXAxis = new CXAxis(this);

    this.m_TopXAxis.SetXScale(this);
    this.m_TopXAxis.SetTopXAxis(true);

    this.m_BottomXAxis.SetXScale(this);

    this.m_rXScaleMng = null;
    this.m_strXScalePacketName = "";
    this.m_GraphArray = [];
    this.m_nShowOption = 0;//0x00:top, bottom 모두 숨김, 0x01:bottom 보임, 0x02:top 보임

    this.m_rChartBlockCol = null;
}
CXScale.prototype.SetGlobalPropertyToChart = function () {

    this.m_TopXAxis.SetGlobalPropertyToChart();
    this.m_BottomXAxis.SetGlobalPropertyToChart();
}

CXScale.prototype.SetChartBlockCol = function (rChartBlockCol) {
    this.m_rChartBlockCol = rChartBlockCol;
}

CXScale.prototype.SetShowOption = function (nShowOption) {
    this.m_nShowOption = nShowOption;

    if (this.m_nShowOption & 0x01)
        this.m_BottomXAxis.SetShow(true);
    else
        this.m_BottomXAxis.SetShow(false);

    if (this.m_nShowOption & 0x02)
        this.m_TopXAxis.SetShow(true);
    else
        this.m_TopXAxis.SetShow(false);
}
CXScale.prototype.GetShowOption = function () {
    return this.m_nShowOption;
}

CXScale.prototype.GetXScalePacketName = function () {
    return this.m_strXScalePacketName;
}
CXScale.prototype.GetXScalePacketNameArray = function (rXScalePacketNameArray) {
    var i;
    for (i = 0; i < rXScalePacketNameArray.length; i++) {
        var strXScalePacketName = rXScalePacketNameArray[i];
        if (this.m_strXScalePacketName == strXScalePacketName)
            return false;
    }
    if (i >= rXScalePacketNameArray.length)
        rXScalePacketNameArray[rXScalePacketNameArray.length] = this.m_strXScalePacketName;

    return true;
}
CXScale.prototype.SetXScaleMng = function (rXScaleMng) {
    this.m_rXScaleMng = rXScaleMng;
}
CXScale.prototype.Draw = function (DrawingInfo) {

    this.m_TopXAxis.Draw(DrawingInfo);
    this.m_BottomXAxis.Draw(DrawingInfo);

}
CXScale.prototype.CalcLayout = function (nTopXHeight, nBottomXHeight, rectGraphRegion, rectChartBlock, DrawingInfo) {
    this.m_TopXAxis.CalcLayout(nTopXHeight, rectGraphRegion, rectChartBlock, DrawingInfo);
    this.m_BottomXAxis.CalcLayout(nBottomXHeight, rectGraphRegion, rectChartBlock, DrawingInfo);
}
//////////////////////////////////////////////////////////
//CHogaXScale
function CHogaXScale(rChartBlock) {

    this.m_rChartBlock = rChartBlock;
    this.m_rChart = rChartBlock ? rChartBlock.m_rChart : null;
    this.m_rGlobalProperty = (this.m_rChart !== null ? this.m_rChart.GetGlobalProperty() : null);

    this.m_TopXAxis = new CHogaXAxis(this);
    this.m_BottomXAxis = new CHogaXAxis(this);

    this.m_TopXAxis.SetXScale(this);
    this.m_TopXAxis.SetTopXAxis(true);

    this.m_BottomXAxis.SetXScale(this);

    this.m_rXScaleMng = null;
    this.m_strXScalePacketName = "";
    this.m_GraphArray = [];
    this.m_nShowOption = 0;//0x00:top, bottom 모두 숨김, 0x01:bottom 보임, 0x02:top 보임

    this.m_rChartBlockCol = null;
}
CHogaXScale.prototype = new CXScale();
CHogaXScale.prototype.constructor = CHogaXScale;

/////////////////////////////////
function CYAxis(rYScale) {

    this.m_rYScale = rYScale;
    this.m_rChart = rYScale ? rYScale.m_rChart : null;
    this.m_rGlobalProperty = (this.m_rChart !== null ? this.m_rChart.GetGlobalProperty() : null);

    this.m_bLeft = false;
    this.m_rYScale = null;
    this.m_bShowOption = false;

    if (this.m_rChart !== null) {
        this.m_clrBack = this.m_rChart.GetColorByKey("background");
        if (this.m_clrBack === null)
            this.m_clrBack = "rgb( 255, 255, 255)"; //스케일색상

        this.m_clrText = this.m_rChart.GetColorByKey("YAxisText");
        if (this.m_clrText === null)
            this.m_clrText = "#000000";

        this.m_clrLastestDataText = this.m_rChart.GetColorByKey("lastestDataText");
        if (this.m_clrLastestDataText === null)
            this.m_clrLastestDataText = "#ffffff";

        this.m_clrHorzLine = this.m_rChart.GetColorByKey("horzLine");
        if (this.m_clrHorzLine === null)
            this.m_clrHorzLine = "#dedede";//this.m_clrHorzLine = "#E6E6E6";

        this.m_clrYAxis = this.m_rChart.GetColorByKey("YAxis");
        if (this.m_clrYAxis === null)
            this.m_clrYAxis = "#dedede";
    }
    else {

        this.m_clrBack = "rgb( 255, 255, 255)"; //스케일색상
        this.m_clrText = "#000000";
        this.m_clrLastestDataText = "#ffffff";
        this.m_clrHorzLine = "#dedede";
        this.m_clrYAxis = "#dedede";
    }

    this.m_nHorzLineType = PS_SOLID;
    this.m_nHorzLineThickness = 1;

    this.m_rectAxis = new CRect();
    this.m_rectGraphRegion = new CRect();
    this.m_rectGraphBackground = new CRect();
}

CYAxis.prototype.SetGlobalPropertyToChart = function () {

    this.m_clrBack = this.m_rGlobalProperty.m_clrBack;
    this.m_clrText = this.m_rGlobalProperty.m_clrText;
    this.m_clrLastestDataText = this.m_rGlobalProperty.m_clrLastestDataText;

    this.m_clrHorzLine = this.m_rGlobalProperty.m_clrHorzLine;
    this.m_nHorzLineType = this.m_rGlobalProperty.m_nHorzLineType;
    this.m_nHorzLineThickness = this.m_rGlobalProperty.m_nHorzLineThickness;
    this.m_clrYAxis = this.m_rGlobalProperty.m_clrYAxis;
}
CYAxis.prototype.SetTextColor = function (clrText) {
    this.m_clrText = clrText;
}
CYAxis.prototype.GetTextColor = function () {
    return this.m_clrText;
}
CYAxis.prototype.SetLastestDataTextColor = function (clrLastestDataText) {
    this.m_clrLastestDataText = clrLastestDataText;
}
CYAxis.prototype.GetLastestDataTextColor = function () {
    return this.m_clrLastestDataText;
}
CYAxis.prototype.SetHorzLineColor = function (clrHorzLine) {
    this.m_clrHorzLine = clrHorzLine;
}
CYAxis.prototype.GetHorzLineColor = function () {
    return this.m_clrHorzLine;
}
CYAxis.prototype.SetHorzLineType = function (nHorzLineType) {
    this.m_nHorzLineType = nHorzLineType;
}
CYAxis.prototype.GetHorzLineType = function () {
    return this.m_nHorzLineType;
}
CYAxis.prototype.SetHorzLineThickness = function (nHorzLineThickness) {
    this.m_nHorzLineThickness = nHorzLineThickness;
}
CYAxis.prototype.GetHorzLineThickness = function () {
    return this.m_nHorzLineThickness;
}
CYAxis.prototype.SetBackColor = function (clrBack) {
    this.m_clrBack = clrBack;
}
CYAxis.prototype.GetBackColor = function () {
    return this.m_clrBack;
}
CYAxis.prototype.SetShow = function (bShow) {
    this.m_bShowOption = bShow;
}
CYAxis.prototype.GetShow = function () {
    return this.m_bShowOption;
}
CYAxis.prototype.SetLeftYAxis = function (bLeft) {
    this.m_bLeft = bLeft;
}
CYAxis.prototype.SetYScale = function (rYScale) {
    this.m_rYScale = rYScale;
}
CYAxis.prototype.GetYScale = function () {
    return this.m_rYScale;
}

CYAxis.prototype.Draw = function (DrawingInfo) { //

    if (this.m_rectAxis.Width() > 0) {
        DrawingInfo.m_Context.fillStyle = this.m_clrBack;
        DrawingInfo.m_Context.fillRect(this.m_rectAxis.m_nLeft, this.m_rectAxis.m_nTop, this.m_rectAxis.Width(), this.m_rectAxis.Height());
    }
    else
        return;

    //다른 차트블록의 Y축 영역때문에 영역은 있지만 보이지 않도록 처리할 경우
    if (!this.m_bShowOption)
        return;

    var i, j;
    var strMarkValue = "";
    var value = 0;
    var yPos;

    var rectGraphBkgLeft = Math.floor(this.m_rectGraphBackground.m_nLeft);
    var rectGraphBkgRight = Math.floor(this.m_rectGraphBackground.m_nRight);
    var rectGraphBkgTop = Math.floor(this.m_rectGraphBackground.m_nTop);
    var rectGraphBkgBottom = Math.floor(this.m_rectGraphBackground.m_nBottom);

    var xPos = this.m_bLeft ? rectGraphBkgLeft + 0.5 : rectGraphBkgRight + 0.5;
    var xPos1 = this.m_bLeft ? rectGraphBkgRight + 0.5 : rectGraphBkgLeft + 0.5;
    
    //var xTextPos = this.m_bLeft ? this.m_rectAxis.m_nLeft + 5 : this.m_rectAxis.m_nRight - 5;
    var xTextPos = this.m_bLeft ? rectGraphBkgLeft - 4.5 : rectGraphBkgRight + 5.5;

    //Y Scale이 숫자타입인 경우
    if (this.m_rYScale.m_nPacketType == NUMERIC_TYPE) {
        //눈금선 그리기

        DrawingInfo.m_Context.beginPath();

        DrawingInfo.m_Context.strokeStyle = this.m_clrHorzLine;
        DrawingInfo.m_Context.lineWidth = this.m_nHorzLineThickness;
        DrawingInfo.m_Context.textBaseline = "middle";
        DrawingInfo.m_Context.textAlign = this.m_bLeft ? "right" : "left";
        DrawingInfo.m_Context.fillStyle = this.m_clrText;

        //DrawingInfo.m_Context.setLineDash([1, 2]);
        switch (this.m_nHorzLineType) {
            case PS_SOLID: DrawingInfo.m_Context.setLineDash([0, 0]); break;
            case PS_DASH: DrawingInfo.m_Context.setLineDash([8, 4]); break;
            case PS_DOT: DrawingInfo.m_Context.setLineDash([2, 3]); break;
        }

        var nLen = this.m_rYScale.m_PlusRangeMarkPosArray.length;
        for (i = 0; i < nLen ; i++) {
            
            yPos = this.m_rYScale.m_PlusRangeMarkPosArray[i];

            DrawingInfo.m_Context.moveTo(xPos, yPos);
            DrawingInfo.m_Context.lineTo(xPos1, yPos);
        }
        nLen = this.m_rYScale.m_MinusRangeMarkPosArray.length;
        for (i = 0; i < nLen ; i++) {

            yPos = this.m_rYScale.m_MinusRangeMarkPosArray[i];

            DrawingInfo.m_Context.moveTo(xPos, yPos);
            DrawingInfo.m_Context.lineTo(xPos1, yPos);
        }

        DrawingInfo.m_Context.stroke();
        DrawingInfo.m_Context.closePath();

        DrawingInfo.m_Context.beginPath();

        //Y축 수직선 그리기
        DrawingInfo.m_Context.strokeStyle = this.m_clrYAxis;
        DrawingInfo.m_Context.lineWidth = 1;
        DrawingInfo.m_Context.moveTo(xPos, rectGraphBkgTop + 0.5);
        DrawingInfo.m_Context.lineTo(xPos, rectGraphBkgBottom + 0.5);

        DrawingInfo.m_Context.setLineDash([0, 0]);

        var nHalfFontHeight = DrawingInfo.m_nFontHeight / 2;
        //y축 눈금과 숫자 출력
        nLen = this.m_rYScale.m_PlusRangeMarkPosArray.length;
        for (i = 0; i <  nLen; i++) {

            value = this.m_rYScale.m_PlusRangeMarkArray[i];

            yPos = this.m_rYScale.m_PlusRangeMarkPosArray[i];
            
            DrawingInfo.m_Context.moveTo(xPos, yPos);
            DrawingInfo.m_Context.lineTo(this.m_bLeft ? xPos - 3 : xPos + 3 , yPos);
            
            //눈금값 그리기
            if (yPos - nHalfFontHeight <= this.m_rectGraphBackground.m_nTop || this.m_rectGraphBackground.m_nBottom <= yPos + nHalfFontHeight)
                continue;

            strMarkValue = null;
            if ((this.m_rYScale.m_nDec == 10 && this.m_rYScale.m_bShowKUnit)) {

                if (1000000000000 <= value || value <= -1000000000000) {

                    strMarkValue = ConvertNumToDigitText(value, this.m_rYScale.m_nDec, 1000000000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "G";
                }
                else if (1000000000 <= value || value <= -1000000000) {

                    strMarkValue = ConvertNumToDigitText(value, this.m_rYScale.m_nDec, 1000000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "M";
                }
                else if (1000000 <= value || value <= -1000000) {

                    strMarkValue = ConvertNumToDigitText(value, this.m_rYScale.m_nDec, 1000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "K";
                }
            }

            if (!strMarkValue)
                strMarkValue = ConvertNumToDigitText(value, this.m_rYScale.m_nDec, 1, this.m_rYScale.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

            DrawingInfo.m_Context.fillText(strMarkValue, xTextPos, yPos);
        }

        nLen = this.m_rYScale.m_MinusRangeMarkPosArray.length;
        for (i = 0; i < nLen ; i++) {

            value = this.m_rYScale.m_MinusRangeMarkArray[i];

            yPos = this.m_rYScale.m_MinusRangeMarkPosArray[i];

            DrawingInfo.m_Context.moveTo(xPos, yPos);
            DrawingInfo.m_Context.lineTo(this.m_bLeft ? xPos - 3 : xPos + 3, yPos);

            //눈금값 그리기
            strMarkValue = null;
            if ((this.m_rYScale.m_nDec == 10 && this.m_rYScale.m_bShowKUnit)) {

                if (1000000000000 <= value || value <= -1000000000000) {

                    strMarkValue = ConvertNumToDigitText(value, this.m_rYScale.m_nDec, 1000000000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "G";
                }
                else if (1000000000 <= value || value <= -1000000000) {

                    strMarkValue = ConvertNumToDigitText(value, this.m_rYScale.m_nDec, 1000000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "M";
                }
                else if (1000000 <= value || value <= -1000000) {

                    strMarkValue = ConvertNumToDigitText(value, this.m_rYScale.m_nDec, 1000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "K";
                }
            }

            if (!strMarkValue)
                strMarkValue = ConvertNumToDigitText(value, this.m_rYScale.m_nDec, 1, this.m_rYScale.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

            DrawingInfo.m_Context.fillText(strMarkValue, xTextPos, yPos);
        }

        DrawingInfo.m_Context.stroke();
        DrawingInfo.m_Context.closePath();
    }
}

CYAxis.prototype.DrawLastestData = function (DrawingInfo) {  //Y축 데이터 영역 (지표 데이터 표기)

    ////////////////////////////////////////////////////////////////////////////
    //폭이 0이거나 다른 차트블록의 Y축 영역때문에 영역은 있지만 보이지 않도록 처리할 경우
    if (this.m_rectAxis.Width() <= 0 || !this.m_bShowOption)
        return;

    //Y축에 현재가 보여주는 옵션 선택시만 동작
    var nShowValueOption = this.m_rYScale.m_nShowValueOption;
    if (nShowValueOption & SHOW_VALUE_YOPTION) {

        var bLog = this.m_rYScale.GetLog();
        var bInvert = this.m_rYScale.GetInvert();

        var nDistBetweenYAxisAndText = 5;
        var nMarginBetweenBoxLeftAndText = 2;
        var nBoxLeft, nBoxTop, nBoxRight, nBoxBottom;
        var nMaxBoxWidth = this.m_rectAxis.Width() - nDistBetweenYAxisAndText - nMarginBetweenBoxLeftAndText;

        var xTextPos = this.m_bLeft ? this.m_rectAxis.m_nRight - nDistBetweenYAxisAndText : this.m_rectAxis.m_nLeft + nDistBetweenYAxisAndText;

        var nBottom = this.m_rectGraphRegion.m_nBottom;
        var Upper = this.m_rYScale.m_MinMaxInfo.m_UpperLimit;
        var Lower = this.m_rYScale.m_MinMaxInfo.m_LowerLimit;
        var logUpper = 0, logLower = 0;
        var DiffYValue = 0;
        if (bLog) {

            logUpper = Log(Upper);
            logLower = Log(Lower);
            DiffYValue = logUpper - logLower;
        }
        else
            DiffYValue = Upper - Lower;

        var DiffY = this.m_rectGraphRegion.Height();
        var DiffRatio = DiffY / DiffYValue;

        var nFontHeight = DrawingInfo.m_nFontHeight - 2;

        var nDoubleFontHeight = nFontHeight + nFontHeight;

        var nTripleFontHeight = nDoubleFontHeight + nFontHeight;

        var nFontHalfHeight = nFontHeight / 2;

        var oldFillStyle = DrawingInfo.m_Context.fillStyle;

        var rGlobalProperty = this.m_rGlobalProperty;
        
        var nShowLatestPriceType = rGlobalProperty.GetShowLatestPriceType();
        var nPriceChangeRatioType = rGlobalProperty.GetPriceChangeRatioType();
        var nShowLatestVolumeType = rGlobalProperty.GetShowLatestVolumeType();
        var nVolumeChangeRatioType = rGlobalProperty.GetVolumeChangeRatioType();

        var clrUp, clrDown, clrSteady;

        DrawingInfo.m_Context.beginPath();
        DrawingInfo.m_Context.textAlign = this.m_bLeft ? "right" : "left";
        DrawingInfo.m_Context.textBaseline = "middle";

        var yPos = 0;
        var iIndex, nGraphLength = this.m_rYScale.m_GraphArray.length;
        for (iIndex = 0; iIndex < nGraphLength; iIndex++) {

            var bDraw = false;
            var rGraph = this.m_rYScale.m_GraphArray[iIndex];
            var nDataChangeRatioType;
            if (rGraph.GetGraphName() === "_PRICE_") {

                if (nShowLatestPriceType === 0)
                    continue;

                else if (nShowLatestPriceType === 1 || nShowLatestPriceType === 2) {

                    var rRQSet = rGraph.GetRQSet();
                    var rPriceSubGraph = rGraph.m_SubGraphArray[0];
                    var rPriceCandleTypeInfo = rPriceSubGraph.m_PriceCandleTypeInfo;
                    
                    var dCurPrice = nShowLatestPriceType === 1 ? rPriceSubGraph.m_ViewLatestData : rRQSet.m_RQInfo.m_CurPrice;//현재가(숫자데이터)
                    var dPrevPrice = nShowLatestPriceType === 1 ? rPriceSubGraph.m_ViewPrevData :rRQSet.m_RQInfo.m_PrevPrice;//전일종가(숫자데이터)
                    var dChangeRatio = nShowLatestPriceType === 1 ? (dCurPrice - dPrevPrice ) / dPrevPrice * 100 : rRQSet.m_RQInfo.m_ChangeRatio;//등락율(숫자데이터)
                    var dLogCurPrice = bLog ? Log(dCurPrice) : 0;
                    
                    if (Lower < dCurPrice && dCurPrice < Upper) {
                        
                        if (bInvert)
                            yPos = bLog ? this.m_rectGraphRegion.m_nBottom - DiffRatio * (logUpper - dLogCurPrice) : this.m_rectGraphRegion.m_nBottom - DiffRatio * (Upper - dCurPrice);
                        else
                            yPos = bLog ? DiffRatio * (logUpper - dLogCurPrice) + this.m_rectGraphRegion.m_nTop : DiffRatio * (Upper - dCurPrice) + this.m_rectGraphRegion.m_nTop;

                        strLatestData = null;

                        if (this.m_rYScale.m_nDec === 10 && this.m_rYScale.m_bShowKUnit) {

                            if (1000000000000 <= this.m_rYScale.m_MinMaxInfo.m_UpperLimit || this.m_rYScale.m_MinMaxInfo.m_LowerLimit <= -1000000000000) {

                                strLatestData = ConvertNumToDigitText(dCurPrice, this.m_rYScale.m_nDec, 1000000000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "G";
                            }
                            else if (1000000000 <= this.m_rYScale.m_MinMaxInfo.m_UpperLimit || this.m_rYScale.m_MinMaxInfo.m_LowerLimit <= -1000000000) {

                                strLatestData = ConvertNumToDigitText(dCurPrice, this.m_rYScale.m_nDec, 1000000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "M";
                            }
                            else if (1000000 <= this.m_rYScale.m_MinMaxInfo.m_UpperLimit || this.m_rYScale.m_MinMaxInfo.m_LowerLimit <= -1000000) {

                                strLatestData = ConvertNumToDigitText(dCurPrice, this.m_rYScale.m_nDec, 1000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "K";
                            }
                        }

                        if (!strLatestData)
                            strLatestData = ConvertNumToDigitText(dCurPrice, this.m_rYScale.m_nDec, 1, this.m_rYScale.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);
                        
                        var strChangeRatio = null;
                        var nRatioWidth = 0;
                        if (nPriceChangeRatioType === 1 || nPriceChangeRatioType === 2) {
                            strChangeRatio = "(" + ConvertNumToDigitText(dChangeRatio, this.m_rYScale.m_nDec, 1, -2, 0, this.m_rGlobalProperty.m_bShowThousandComma) + "%)";
                            nRatioWidth = DrawingInfo.m_Context.measureText(strChangeRatio).width + 6;
                        }

                        var nBoxWidth = DrawingInfo.m_Context.measureText(strLatestData).width + 6;
                        nBoxWidth = (nBoxWidth < nRatioWidth ? nRatioWidth : nBoxWidth);
                        nBoxWidth = (nMaxBoxWidth < nBoxWidth) ? nMaxBoxWidth : nBoxWidth;

                        nBoxTop = yPos - nFontHeight;
                        if (nBoxTop < this.m_rectAxis.m_nTop) nBoxTop = this.m_rectAxis.m_nTop;

                        nBoxLeft = this.m_bLeft ? xTextPos - nBoxWidth + nMarginBetweenBoxLeftAndText : xTextPos - nMarginBetweenBoxLeftAndText;

                        DrawingInfo.m_Context.fillStyle = (dCurPrice > dPrevPrice ? rPriceCandleTypeInfo.m_clrUpturnPlus : (dPrevPrice > dCurPrice ? rPriceCandleTypeInfo.m_clrDropMinus : (rPriceCandleTypeInfo.m_bSteadyClrFollowToUpDropClr ? rPriceCandleTypeInfo.m_clrUpturnPlus : rPriceCandleTypeInfo.m_clrSteadyTone) ));
                        DrawingInfo.m_Context.fillRect(nBoxLeft, nBoxTop, nBoxWidth, nPriceChangeRatioType === 1 || nPriceChangeRatioType === 2 ? nDoubleFontHeight : nFontHeight);

                        DrawingInfo.m_Context.fillStyle = this.m_clrLastestDataText;
                        DrawingInfo.m_Context.fillText(strLatestData, xTextPos, nBoxTop + nFontHalfHeight);

                        if (strChangeRatio !== null)
                            DrawingInfo.m_Context.fillText(strChangeRatio, xTextPos, nBoxTop + nFontHalfHeight + nFontHeight);

                        DrawingInfo.m_Context.fillStyle = oldFillStyle;
                    }

                    bDraw = true;
                }
            }
            else if (rGraph.GetGraphName() === "_VOLUME_") {

                if (nShowLatestVolumeType === 0)
                    continue;

                nDataChangeRatioType = nVolumeChangeRatioType;
            }
            else {//일반지표인 경우

                var nShowLatestDataType = rGraph.GetShowLatestDataType();
                nDataChangeRatioType = rGraph.GetDataChangeRatioType();
                if (nShowLatestDataType === 0)
                    continue;
            }

            if(!bDraw){

                var nSubGraphIndex;
                var strLatestData;
                var nSubGraphLength = rGraph.m_SubGraphArray.length;

                //첫번째 서브그래프의 y값만 출력하는 경우
                if (rGraph.m_bShowLatestDataOfAllSubGraph === false)
                    nSubGraphLength = 1;

                for (nSubGraphIndex = 0; nSubGraphIndex < nSubGraphLength; nSubGraphIndex++) {

                    var rSubGraph = rGraph.m_SubGraphArray[nSubGraphIndex];

                    if (Lower < rSubGraph.m_ViewLatestData && rSubGraph.m_ViewLatestData < Upper) {
                        
                        if (bInvert)
                            yPos = bLog ? this.m_rectGraphRegion.m_nBottom - DiffRatio * (logUpper - Log(rSubGraph.m_ViewLatestData)) : this.m_rectGraphRegion.m_nBottom - DiffRatio * (Upper - rSubGraph.m_ViewLatestData);
                        else
                            yPos = bLog ? DiffRatio * (logUpper - Log(rSubGraph.m_ViewLatestData)) + this.m_rectGraphRegion.m_nTop : DiffRatio * (Upper - rSubGraph.m_ViewLatestData) + this.m_rectGraphRegion.m_nTop;

                        strLatestData = null;

                        if (this.m_rYScale.m_nDec === 10 && this.m_rYScale.m_bShowKUnit) {

                            if (1000000000000 <= this.m_rYScale.m_MinMaxInfo.m_UpperLimit || this.m_rYScale.m_MinMaxInfo.m_LowerLimit <= -1000000000000) {

                                strLatestData = ConvertNumToDigitText(rSubGraph.m_ViewLatestData, this.m_rYScale.m_nDec, 1000000000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "G";
                            }
                            else if (1000000000 <= this.m_rYScale.m_MinMaxInfo.m_UpperLimit || this.m_rYScale.m_MinMaxInfo.m_LowerLimit <= -1000000000) {

                                strLatestData = ConvertNumToDigitText(rSubGraph.m_ViewLatestData, this.m_rYScale.m_nDec, 1000000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "M";
                            }
                            else if (1000000 <= this.m_rYScale.m_MinMaxInfo.m_UpperLimit || this.m_rYScale.m_MinMaxInfo.m_LowerLimit <= -1000000) {

                                strLatestData = ConvertNumToDigitText(rSubGraph.m_ViewLatestData, this.m_rYScale.m_nDec, 1000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "K";
                            }
                        }

                        if (!strLatestData)
                            strLatestData = ConvertNumToDigitText(rSubGraph.m_ViewLatestData, this.m_rYScale.m_nDec, 1, this.m_rYScale.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

                        strChangeRatio = null;
                        nRatioWidth = 0;
                        if (nDataChangeRatioType === 1) {
                            dChangeRatio = (rSubGraph.m_ViewLatestData - rSubGraph.m_ViewPrevData) / rSubGraph.m_ViewPrevData * 100;
                            strChangeRatio = "(" + ConvertNumToDigitText(dChangeRatio, 10, 1, -2, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "%)";
                            nRatioWidth = DrawingInfo.m_Context.measureText(strChangeRatio).width + 6;//strChangeRatio.length * this.m_rChart.m_nTextLen + 4;
                        }

                        nBoxWidth = DrawingInfo.m_Context.measureText(strLatestData).width + 6;//strLatestData.length * this.m_rChart.m_nTextLen + 4;
                        nBoxWidth = nBoxWidth < nRatioWidth ? nRatioWidth : nBoxWidth;
                        nBoxWidth = nBoxWidth < nMaxBoxWidth ? nBoxWidth : nMaxBoxWidth;

                        nBoxTop = yPos - nFontHalfHeight;
                        if (nBoxTop < this.m_rectAxis.m_nTop) nBoxTop = this.m_rectAxis.m_nTop;

                        nBoxLeft = this.m_bLeft ? xTextPos - nBoxWidth + nMarginBetweenBoxLeftAndText : xTextPos - nMarginBetweenBoxLeftAndText;

                        DrawingInfo.m_Context.fillStyle = rSubGraph.m_clrViewLatestData;
                        DrawingInfo.m_Context.fillRect(nBoxLeft, nBoxTop, nBoxWidth, nDataChangeRatioType === 1 ? nDoubleFontHeight : nFontHeight);

                        DrawingInfo.m_Context.fillStyle = this.m_clrLastestDataText;
                        DrawingInfo.m_Context.fillText(strLatestData, xTextPos, nBoxTop + nFontHalfHeight);

                        if (nDataChangeRatioType === 1)
                            DrawingInfo.m_Context.fillText(strChangeRatio, xTextPos, nBoxTop + nFontHalfHeight + nFontHeight);
                    }
                }
            }
        }

        DrawingInfo.m_Context.stroke();
        DrawingInfo.m_Context.closePath();
        DrawingInfo.m_Context.fillStyle = oldFillStyle;
    }
}
CYAxis.prototype.CalcLayout = function (nYWidth, rectGraphRegion, rectGraphBackground, rectChartBlock, DrawingInfo) {

    if (this.m_bLeft)
        this.m_rectAxis.SetRect(rectChartBlock.m_nLeft, rectChartBlock.m_nTop, rectChartBlock.m_nLeft + nYWidth, rectChartBlock.m_nBottom);
    else
        this.m_rectAxis.SetRect(rectChartBlock.m_nRight - nYWidth, rectChartBlock.m_nTop, rectChartBlock.m_nRight, rectChartBlock.m_nBottom);

    this.m_rectGraphRegion.SetRect(rectGraphRegion.m_nLeft, rectGraphRegion.m_nTop, rectGraphRegion.m_nRight, rectGraphRegion.m_nBottom);
    this.m_rectGraphBackground.SetRect(rectGraphBackground.m_nLeft, rectGraphBackground.m_nTop, rectGraphBackground.m_nRight, rectGraphBackground.m_nBottom);
}
/////////////////////////////////
function CYScale(rChartBlock) {

    this.m_rChartBlock = rChartBlock;
    this.m_rChart = rChartBlock ? rChartBlock.m_rChart : null;
    this.m_rGlobalProperty = (this.m_rChart !== null ? this.m_rChart.GetGlobalProperty() : null);

    this.m_GraphArray = [];

    this.m_LeftYAxis = new CYAxis(this);
    this.m_LeftYAxis.SetLeftYAxis(true);

    this.m_RightYAxis = new CYAxis(this);

    this.m_LeftYAxis.SetYScale(this);
    this.m_RightYAxis.SetYScale(this);

    this.m_nShowOption = 2;//0x00:left, right 모두 숨김, 0x01:left 보임, 0x02:right 보임

    this.m_MinMaxInfo = new CMinMaxInfo();

    this.m_MarginRatio = 0;//0.01;//최대, 최소값 대비 1% 여백 추가

    this.m_nPacketType = null;//NUMERIC_TYPE, DATETIME_TYPE, STRING_TYPE

    this.m_bSelect = false;

    this.m_bShowKUnit = true;//y축이 1000 단위가 넘어가면 1000단위로 보여주고 K뒤에 붙이기 옵션

    this.m_nMarkHeight = 0;

    this.m_nMaxMarkCnt = 0;

    //0x1000:숨김(HIDE_VALUE_YOPTION), 0x2000:보이기(SHOW_VALUE_YOPTION),
    this.m_nShowValueOption = SHOW_VALUE_YOPTION ;

    this.m_nDec = null;//진법
    this.m_Unit = null;//최소단위(데이터의 최소 간격의미(예:호가))
    this.m_nDigit = null;//최소자리수

    this.m_nShowUnit = 1;//Y축 숫자 표기단위(길면 1000단위 기준으로 표현, 기본은 1(서버에서 온 값 그대로), 1000(값을 1000으로 나눈 몫), 1000000(값을 1000000으로 나눈 몫) ....
    this.m_strShowUnit = "";//this.m_nShowUnit = 1인 경우는 "", 1000 인 경우는 "K", 1000000 "M", 1000000000 "G" 등

    this.m_bUpdateMinMax = false;//실시간 데이터 업데이트시 y스케일의 최대,최소값 범위가 넘어가는 경우 true로 셋팅하여 해당 y스케일 최대,최소 업데이트 처리

    this.m_PlusRangeMarkPosArray = [];
    this.m_PlusRangeMarkArray = [];

    this.m_MinusRangeMarkPosArray = [];
    this.m_MinusRangeMarkArray = [];

    //20190121 이문수 로그,반전 기능 추가 >>
    this.m_bLog = false;//데이터 로그변환여부
    this.m_bInvert = false;//데이터 반전여부
    //20190121 이문수 로그,반전 기능 추가 <<
}

CYScale.prototype.SetGlobalPropertyToChart = function () {

    this.m_LeftYAxis.SetGlobalPropertyToChart();
    this.m_RightYAxis.SetGlobalPropertyToChart();
    
    this.m_bShowKUnit = this.m_rGlobalProperty.m_bShowKUnit;

    //로그,반전 옵션 셋팅
    let i, nGraphArrayLen = this.m_GraphArray.length;
    for (i = 0; i < nGraphArrayLen; i++) {

        var rGraph = this.m_GraphArray[i];
        if (rGraph.m_strName === "_PRICE_")
            break;
    }
    //가격차트가 포함된 Y스케일인 경우
    if (i < nGraphArrayLen) {

        if (this.m_rGlobalProperty.m_bChangeLogOption === true)
            this.m_bLog = this.m_rGlobalProperty.m_bLogPriceYAxis;

        if (this.m_rGlobalProperty.m_bChangeInvertOption === true)
            this.m_bInvert = this.m_rGlobalProperty.m_bInvertPriceYAxis;

        //상하여백%
        this.m_MarginRatio = this.m_rGlobalProperty.m_nTopBottomMargin / 100;
    }
    else{

        //상하여백%
        this.m_MarginRatio = 5 / 100;
    }
}

//20190121 이문수 로그,반전 기능 추가 >>
CYScale.prototype.GetLog = function () {
    return this.m_bLog;
}

CYScale.prototype.SetLog = function (bLog) {
    this.m_bLog = bLog;
}

CYScale.prototype.GetInvert = function () {
    return this.m_bInvert;
}

CYScale.prototype.SetInvert = function (bInvert) {
    this.m_bInvert = bInvert;
}
//20190121 이문수 로그,반전 기능 추가 <<

CYScale.prototype.IsUpdateMinMax = function () {
    return this.m_bUpdateMinMax;
}
CYScale.prototype.SetUpdateMinMax = function (bUpdateMinMax) {
    this.m_bUpdateMinMax = bUpdateMinMax;
}
CYScale.prototype.DrawLastestData = function (DrawingInfo) {
    this.m_LeftYAxis.DrawLastestData(DrawingInfo);
    this.m_RightYAxis.DrawLastestData(DrawingInfo);
}
CYScale.prototype.SetShowValueOption = function (nShowValueOption) {
    this.m_nShowValueOption = nShowValueOption;
}
CYScale.prototype.GetShowValueOption = function () {
    return this.m_nShowValueOption;
}
CYScale.prototype.SetShowKUnit = function (bShowKUnit) {
    this.m_bShowKUnit = bShowKUnit;
}
CYScale.prototype.GetShowKUnit = function () {
    return this.m_bShowKUnit;
}
CYScale.prototype.Select = function (bSelect) {
    this.m_bSelect = bSelect;
}
CYScale.prototype.IsSelected = function () {
    return this.m_bSelect;
}
CYScale.prototype.SetPacketType = function (nPacketType, strSubPacketType, nDec, Unit, nDigit) {

    if (this.m_nPacketType == null) {

        this.m_nPacketType = nPacketType;
        this.m_strSubPacketType = strSubPacketType;
        this.m_nDec = nDec;
        //this.m_Unit = Unit;
        this.m_nDigit = nDigit;
        return true;
    }
    else {

        if (this.m_nPacketType != nPacketType)//기존의 타입과 다른 타입데이터를 같은 y축에 연결하려 하면 실패
            return false;

        if (this.m_nPacketType == DATETIME_TYPE) {

            if (this.m_strSubPacketType == "YYYYMM") {
                if (strSubPacketType == "YYYY" || strSubPacketType == "YYYYMM")
                    this.m_strSubPacketType = strSubPacketType;
            }
            else if (this.m_strSubPacketType == "YYYYMMDD") {
                if (strSubPacketType == "YYYY" || strSubPacketType == "YYYYMM" || strSubPacketType == "YYYYMMDD")
                    this.m_strSubPacketType = strSubPacketType;
            }
            else if (this.m_strSubPacketType == "YYYYMMDDHHMM") {
                if (strSubPacketType == "YYYY" || strSubPacketType == "YYYYMM" || strSubPacketType == "YYYYMMDD" || strSubPacketType == "YYYYMMDDHHMM")
                    this.m_strSubPacketType = strSubPacketType;
            }
            else if (this.m_strSubPacketType == "YYYYMMDDHHMMSS") {
                this.m_strSubPacketType = strSubPacketType;
            }
        }
        else if (this.m_nPacketType == NUMERIC_TYPE) {

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //(nDec) 진법이 다르면 기존 진법으로 표현(어차피 내부 데이터는 10진수이므로 계산방식은 모두 동일하고 숫자 출력하는 과정에서만 진법표현이 사용됨) 따라서 진법은 추가된 진법것을 셋팅할 필요없다
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //기존 y스케일에 그래프가 추가되더라도 nDigit,nDec, Unit 세가지 값의 변경은 없도록 정하여 주석처리 함
            //if (this.m_nDigit < nDigit)
            //    this.m_nDigit = nDigit;
        }
        else {

            this.m_strSubPacketType = strSubPacketType;
        }

        return true;
    }
}
CYScale.prototype.AddGrpah = function (Graph) {

    var i, j, nLength = Graph.m_SubGraphArray.length;
    for (i = 0; i < nLength; i++) {
        var rSubGraph = Graph.m_SubGraphArray[i];
        var rPacketData = rSubGraph.m_rPacketData;
        if (rPacketData != undefined) {
            this.SetPacketType(rPacketData.m_nPacketType, rPacketData.m_strPacketSubType, rPacketData.m_nDec, rPacketData.m_Unit, rPacketData.m_nDigit);
        }
    }

    this.m_GraphArray.push(Graph);
}

CYScale.prototype.SetShowOption = function (nShowOption) {

    this.m_nShowOption = nShowOption;
    if (this.m_nShowOption & 0x01)
        this.m_LeftYAxis.SetShow(true);
    else
        this.m_LeftYAxis.SetShow(false);

    if (this.m_nShowOption & 0x02)
        this.m_RightYAxis.SetShow(true);
    else
        this.m_RightYAxis.SetShow(false);
}
CYScale.prototype.GetShowOption = function () {
    return this.m_nShowOption;
}

CYScale.prototype.CalcYScaleWidth = function (DrawingInfo) {
    var strMax = "" + this.m_MinMaxInfo.m_UpperLimit;
    var strMin = "" + this.m_MinMaxInfo.m_LowerLimit;
    var i, strSubPacketType;
    var nFindPos = -1;
    var nDigit = 0;
    var nIntLen = 0;
    var nMaxLength = 0;
    var nMinLength = 0;
    var bProcess = false;

    if ((this.m_nDec == 10 && this.m_bShowKUnit)) {

        if (1000000000000 <= this.m_MinMaxInfo.m_UpperLimit || this.m_MinMaxInfo.m_LowerLimit <= -1000000000000) {

            strMax = ConvertNumToDigitText(this.m_MinMaxInfo.m_UpperLimit, this.m_nDec, 1000000000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "G";
            strMin = ConvertNumToDigitText(this.m_MinMaxInfo.m_LowerLimit, this.m_nDec, 1000000000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "G";

            var bProcess = true;
        }
        else if (1000000000 <= this.m_MinMaxInfo.m_UpperLimit || this.m_MinMaxInfo.m_LowerLimit <= -1000000000) {

            strMax = ConvertNumToDigitText(this.m_MinMaxInfo.m_UpperLimit, this.m_nDec, 1000000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "M";
            strMin = ConvertNumToDigitText(this.m_MinMaxInfo.m_LowerLimit, this.m_nDec, 1000000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "M";

            var bProcess = true;
        }
        else if (1000000 <= this.m_MinMaxInfo.m_UpperLimit || this.m_MinMaxInfo.m_LowerLimit <= -1000000) {

            strMax = ConvertNumToDigitText(this.m_MinMaxInfo.m_UpperLimit, this.m_nDec, 1000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "K";
            strMin = ConvertNumToDigitText(this.m_MinMaxInfo.m_LowerLimit, this.m_nDec, 1000, 0, -1, this.m_rGlobalProperty.m_bShowThousandComma) + "K";

            var bProcess = true;
        }
    }

    if (!bProcess) {

        strMax = ConvertNumToDigitText(this.m_MinMaxInfo.m_UpperLimit, this.m_nDec, 1, this.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);
        strMin = ConvertNumToDigitText(this.m_MinMaxInfo.m_LowerLimit, this.m_nDec, 1, this.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);
    }

    var nMaxWidth = DrawingInfo.m_Context.measureText(strMax).width + 5;//var nMaxWidth = strMax.length * this.m_rChart.m_nTextLen + 5;
    var nMinWidth = DrawingInfo.m_Context.measureText(strMin).width + 5;//var nMinWidth = strMin.length * this.m_rChart.m_nTextLen + 5;

    return (nMinWidth < nMaxWidth ? nMaxWidth : nMinWidth);
}

CYScale.prototype.ExtractYScaleMinMax = function (bFullScan) {

    var bZeroBaseLine = false;
    this.m_MinMaxInfo.Init();
    for (var i = 0; i < this.m_GraphArray.length; i++) {
        var Graph = this.m_GraphArray[i];

        //var MinMaxInfo = new CMinMaxInfo();
        gMinMaxInfo.Init();
        var MinMaxInfo = gMinMaxInfo;
        Graph.ExtractYScaleMinMax(MinMaxInfo, bFullScan);

        if (MinMaxInfo.m_Max != null) {
            if (this.m_MinMaxInfo.m_Max == null || this.m_MinMaxInfo.m_Max < MinMaxInfo.m_Max)
                this.m_MinMaxInfo.m_Max = MinMaxInfo.m_Max;
        }

        if (MinMaxInfo.m_Min != null) {
            if (this.m_MinMaxInfo.m_Min == null || this.m_MinMaxInfo.m_Min > MinMaxInfo.m_Min)
                this.m_MinMaxInfo.m_Min = MinMaxInfo.m_Min;
        }

        this.m_MinMaxInfo.m_nStartIndex = MinMaxInfo.m_nStartIndex;
        this.m_MinMaxInfo.m_nEndIndex = MinMaxInfo.m_nEndIndex;

        if (MinMaxInfo.m_bZeroBaseLine)
            bZeroBaseLine = true;
    }

    //console.log("[CYScale.prototype.ExtractYScaleMinMax] ==>> Min:" + this.m_MinMaxInfo.m_Min + " Max:" + this.m_MinMaxInfo.m_Max);

    if (bZeroBaseLine && (this.m_MinMaxInfo.m_Max == 0 || this.m_MinMaxInfo.m_Min == 0)) {

        if (this.m_MinMaxInfo.m_Max > 0) {

            this.m_MinMaxInfo.m_UpperLimit = this.m_MinMaxInfo.m_Max + this.m_MinMaxInfo.m_Max * this.m_MarginRatio;
            this.m_MinMaxInfo.m_LowerLimit = this.m_MinMaxInfo.m_Min;
        }
        else if (this.m_MinMaxInfo.m_Min < 0) {

            this.m_MinMaxInfo.m_UpperLimit = this.m_MinMaxInfo.m_Max;
            this.m_MinMaxInfo.m_LowerLimit = this.m_MinMaxInfo.m_Min - this.m_MinMaxInfo.m_Min * this.m_MarginRatio;
        }
        else {

            this.m_MinMaxInfo.m_UpperLimit = this.m_MinMaxInfo.m_Max + 10;
            this.m_MinMaxInfo.m_LowerLimit = this.m_MinMaxInfo.m_Min;
        }
    }
    else {

        var Diff = this.m_MinMaxInfo.m_Max - this.m_MinMaxInfo.m_Min;
        if (Diff == 0) {

            if(this.m_MinMaxInfo.m_Max === 0){
                var MarginValue = Math.pow(10, this.m_nDigit);
                this.m_MinMaxInfo.m_UpperLimit = this.m_MinMaxInfo.m_Max + MarginValue;
                this.m_MinMaxInfo.m_LowerLimit = this.m_MinMaxInfo.m_Min - MarginValue;
            }
            else{
                this.m_MinMaxInfo.m_UpperLimit = this.m_MinMaxInfo.m_Max + this.m_MinMaxInfo.m_Max * 0.01;
                this.m_MinMaxInfo.m_LowerLimit = this.m_MinMaxInfo.m_Min - this.m_MinMaxInfo.m_Min * 0.01;
            }
        }
        else {

                this.m_MinMaxInfo.m_UpperLimit = this.m_MinMaxInfo.m_Max + Diff * this.m_MarginRatio;
                this.m_MinMaxInfo.m_LowerLimit = this.m_MinMaxInfo.m_Min - Diff * this.m_MarginRatio;
        }
    }
}

CYScale.prototype.Draw = function (DrawingInfo) {

    var i, j;
    var nMarkCnt = this.m_nMaxMarkCnt;

    var UpperLimit = this.m_MinMaxInfo.m_UpperLimit;
    var LowerLimit = this.m_MinMaxInfo.m_LowerLimit;
    var yMax = UpperLimit;
    var yMin = LowerLimit;

    var nTop = DrawingInfo.m_rectGraphRegion.m_nTop;
    var nBottom = DrawingInfo.m_rectGraphRegion.m_nBottom;

    var DiffY = DrawingInfo.m_rectGraphRegion.Height();
    var strMarkValue = "";

    var value = 0;
    var yPos;

    //////////////////////////////////////////////////////////////////////////////////
    //출력해야 할 눈금값과 y좌표 추출 로직
    //////////////////////////////////////////////////////////////////////////////////
    var Unit = this.m_Unit;//최소단위(데이터의 최소 간격의미(예:호가단위))
    var nDigit = this.m_nDigit;//최소자리수
    if (!Unit)
        Unit = Math.pow(10, nDigit);

    var DiffYValue;
    if (yMax > 0 && yMin < 0) {

        var yMinPositive = Math.abs(yMin);

        if (yMax > yMinPositive)
            DiffYValue = yMax;
        else
            DiffYValue = yMinPositive;
    }
    else
        DiffYValue = UpperLimit - LowerLimit;

    //최대,최소값 간격(최대값-최소값)을 현재 공간에서 최대 출력 가능한 글자수로 나누면 글자 간격 계산됨(nMultipleNum)
    var nMultipleNum = ceil(DiffYValue / nMarkCnt, nDigit);

    //계산된 글자간격이 최소단위의 몇배인지 계산하여 글자간격값을 글자간격배수로 환산함
    nMultipleNum = fDivide(nMultipleNum, Unit);

    var n1 = null, Num = null;
    var sMultipleNum = "" + nMultipleNum;
    var nLength = sMultipleNum.length;
    var nPointPos = sMultipleNum.indexOf(".");
    if (nLength === 1) {

        if (2 < nMultipleNum && nMultipleNum <= 4)
            nMultipleNum = 5;
        else if (5 < nMultipleNum)
            nMultipleNum = 10;

        var Unit1 = fMultiply(Unit, nMultipleNum);

        //눈금이 없는 경우 눈금단위간격 Unit을 좁힌다
        if (DiffYValue <= Unit1) {

            if (nMultipleNum === 2)
                nMultipleNum = 1;
            else if (nMultipleNum === 5)
                nMultipleNum = 2;
            else if (nMultipleNum === 10)
                nMultipleNum = 5;

            Unit1 = fMultiply(Unit, nMultipleNum);
        }

        Unit = Unit1;
    }
    else if (nLength > 1 && nPointPos === -1) {

        n1 = Number(sMultipleNum.substring(0, 2));
        //Num = Number(n1 + "0".repeat(nLength - 2));
        Num = Number(n1 + Array(nLength - 2 + 1).join("0"));
        if ((n1 === 10 || n1 === 20 || n1 === 25 || n1 === 50) && nMultipleNum === Num) {

            Unit1 = fMultiply(Unit, nMultipleNum);
            if (DiffYValue <= Unit1) {
                if (n1 === 10)
                    n1 = 5;
                else if (n1 === 20)
                    n1 = 10;
                else if (n1 === 25)
                    n1 = 20;
                else//(n1 == 50)
                    n1 = 25;

                //sMultipleNum = n1 + "0".repeat(nLength - 2);
                sMultipleNum = n1 + Array(nLength - 2 + 1).join("0");
                Unit1 = fMultiply(Unit, Number(sMultipleNum));
            }
        }
        else {

            if (10 <= n1 && n1 < 20)
                n1 = 20;
            else if (20 <= n1 && n1 < 25)
                n1 = 25;
            else if (25 <= n1 && n1 <50)
                n1 = 50;
            else if(50 <= n1)
                n1 = 100;

            //sMultipleNum = n1 + "0".repeat(nLength - 2);
            sMultipleNum = n1 + Array(nLength - 2 + 1).join("0");
            Unit1 = fMultiply(Unit, Number(sMultipleNum));

            if (DiffYValue <= Unit1) {
                if (n1 === 20)
                    n1 = 10;
                else if (n1 === 25)
                    n1 = 20;
                else if (n1 === 50)
                    n1 = 25;
                else if (n1 === 100)
                    n1 = 50;

                //sMultipleNum = n1 + "0".repeat(nLength - 2);
                sMultipleNum = n1 + Array(nLength - 2 + 1).join("0");
                Unit1 = fMultiply(Unit, Number(sMultipleNum));
            }
        }

        Unit = Unit1;
    }
    else //(nLength > 1 && nPointPos >= 0)
    {
        if (nPointPos > 1) {

            n1 = Number(sMultipleNum.substring(0, 2));
            
            if (10 <= n1 && n1 < 20)
                n1 = 20;
            else if (20 <= n1 && n1 < 25)
                n1 = 25;
            else if (25 <= n1 && n1 < 50)
                n1 = 50;
            else if (50 <= n1)
                n1 = 100;

            //sMultipleNum = n1 + "0".repeat(nPointPos - 2);
            sMultipleNum = n1 + Array(nPointPos - 2 + 1).join("0");
            Unit1 = fMultiply(Unit, Number(sMultipleNum));

            if (DiffYValue <= Unit1) {
                if (n1 === 20)
                    n1 = 10;
                else if (n1 === 25)
                    n1 = 20;
                else if (n1 === 50)
                    n1 = 25;
                else if (n1 === 100)
                    n1 = 50;

                //sMultipleNum = n1 + "0".repeat(nPointPos - 2);
                sMultipleNum = n1 + Array(nPointPos - 2 + 1).join("0");
                Unit1 = fMultiply(Unit, Number(sMultipleNum));
            }

            Unit = Unit1;
        }
        else {

            n1 = Number(sMultipleNum.substring(0, 3));

            if (0 <= n1 && n1 < 1)
                n1 = 1;
            else if (1 <= n1 && n1 < 2)
                n1 = 2;
            else if (2 <= n1 && n1 < 2.5)
                n1 = 2.5;
            else if (2.5 <= n1 && n1 < 5)
                n1 = 5;
            else if (5 <= n1)
                n1 = 10;
            
            Unit1 = fMultiply(Unit, n1);

            if (DiffYValue <= Unit1) {
                if (n1 === 2)
                    n1 = 1;
                else if (n1 === 2.5)
                    n1 = 2;
                else if (n1 === 5)
                    n1 = 2.5;
                else if (n1 === 10)
                    n1 = 5;

                Unit1 = fMultiply(Unit, n1);
            }

            Unit = Unit1;
        }
    }

    this.m_PlusRangeMarkArray.length = 0;
    this.m_PlusRangeMarkPosArray.length = 0;
    this.m_MinusRangeMarkArray.length = 0;
    this.m_MinusRangeMarkPosArray.length = 0;

    if (this.GetLog() === true) {

        yMax = Log(yMax);
        yMin = Log(yMin);
        var DiffMaxMin = yMax - yMin;

        var nMultiple;
        var nYPos1 = null, nYPos2 = null;
        var nRatio , MData, LogData, nDiff, iIndex, MarkData, MarkValue;

        if (LowerLimit >= 0) {//현재 보이는 모든 데이터 영역이 양수 영역에 존재하는 경우

            nMultiple = Math.ceil((UpperLimit - Unit) / Unit);
            UpperLimit = fMultiply(nMultiple, Unit);

            //실제폰트높이를 가지고 간격을 조정한다
            //로그인 경우는 큰값 영역이 좁게 그려지므로 큰값기준으로 간격 측정을 한다
            MarkValue = UpperLimit;
            MarkData = Log(MarkValue);
            nYPos1 = nBottom - (MarkData - yMin) / DiffMaxMin * DiffY;
            this.m_PlusRangeMarkPosArray[this.m_PlusRangeMarkPosArray.length] = Math.floor(nYPos1) + 0.5;
            this.m_PlusRangeMarkArray[this.m_PlusRangeMarkArray.length] = MarkValue;
            MarkValue = fPlus(MarkValue, -Unit);

            iIndex = 1;
            while (MarkValue >= LowerLimit) {

                MarkData = Log(MarkValue);
                nYPos2 = nBottom - (MarkData - yMin) / DiffMaxMin * DiffY;
                if (nYPos2 - nYPos1 >= DrawingInfo.m_nFontHeight) {

                    Unit = fMultiply(Unit, iIndex);
                    break;
                }
                iIndex++;
                MarkValue = fPlus(MarkValue, -Unit);
            }

            while (MarkValue >= LowerLimit) {

                MarkData = Log(MarkValue);
                this.m_PlusRangeMarkPosArray[this.m_PlusRangeMarkPosArray.length] = Math.floor(nBottom - (MarkData - yMin) / DiffMaxMin * DiffY) + 0.5;
                this.m_PlusRangeMarkArray[this.m_PlusRangeMarkArray.length] = MarkValue;
                MarkValue = fPlus(MarkValue, -Unit);
            }
        }
        else if (UpperLimit <= 0) {//현재 보이는 모든 데이터 영역이 음수 영역에 존재하는 경우
            
            var nMultiple = Math.ceil(LowerLimit / Unit);
            LowerLimit = fMultiply(nMultiple, Unit);

            MarkValue = LowerLimit;
            MarkData = Log(MarkValue);
            nYPos1 = nBottom - (MarkData - yMin) / DiffMaxMin * DiffY;
            this.m_MinusRangeMarkPosArray[this.m_MinusRangeMarkPosArray.length] = Math.floor(nYPos1) + 0.5;
            this.m_MinusRangeMarkArray[this.m_MinusRangeMarkArray.length] = MarkValue;
            MarkValue = fPlus(MarkValue, Unit);

            iIndex = 1;
            while (MarkValue <= UpperLimit) {

                MarkData = Log(MarkValue);
                nYPos2 = nBottom - (MarkData - yMin) / DiffMaxMin * DiffY;
                if (nYPos1 - nYPos2 >= DrawingInfo.m_nFontHeight) {

                    Unit = fMultiply(Unit, iIndex);
                    break;
                }
                iIndex++;
                MarkValue = fPlus(MarkValue, Unit);
            }

            while (MarkValue <= UpperLimit) {

                MarkData = Log(MarkValue);
                this.m_MinusRangeMarkPosArray[this.m_MinusRangeMarkPosArray.length] = Math.floor(nBottom - (MarkData - yMin) / DiffMaxMin * DiffY) + 0.5;
                this.m_MinusRangeMarkArray[this.m_MinusRangeMarkArray.length] = MarkValue;
                MarkValue = fPlus(MarkValue, Unit);
            }
        }
        else {//현재 보이는 모든 데이터 영역이 양수에서 음수 영역에 걸쳐 존재하는 경우

            nMultiple = Math.ceil((UpperLimit - Unit) / Unit);
            UpperLimit = fMultiply(nMultiple, Unit);
            LowerLimit = 0;

            //실제폰트높이를 가지고 간격을 조정한다
            //로그인 경우는 큰값 영역이 좁게 그려지므로 큰값기준으로 간격 측정을 한다
            MarkValue = UpperLimit;
            MarkData = Log(MarkValue);
            nYPos1 = nBottom - (MarkData - yMin) / DiffMaxMin * DiffY;
            this.m_PlusRangeMarkPosArray[this.m_PlusRangeMarkPosArray.length] = Math.floor(nYPos1) + 0.5;
            this.m_PlusRangeMarkArray[this.m_PlusRangeMarkArray.length] = MarkValue;
            MarkValue = fPlus(MarkValue, -Unit);

            iIndex = 1;
            while (MarkValue > LowerLimit) {

                MarkData = Log(MarkValue);
                nYPos2 = nBottom - (MarkData - yMin) / DiffMaxMin * DiffY;
                if (nYPos2 - nYPos1 >= DrawingInfo.m_nFontHeight) {

                    Unit = fMultiply(Unit, iIndex);
                    break;
                }
                iIndex++;
                MarkValue = fPlus(MarkValue, -Unit);
            }

            while (MarkValue > LowerLimit) {

                MarkData = Log(MarkValue);
                this.m_PlusRangeMarkPosArray[this.m_PlusRangeMarkPosArray.length] = Math.floor(nBottom - (MarkData - yMin) / DiffMaxMin * DiffY) + 0.5;
                this.m_PlusRangeMarkArray[this.m_PlusRangeMarkArray.length] = MarkValue;
                MarkValue = fPlus(MarkValue, -Unit);
            }

            MarkValue = 0;
            MarkData = MarkValue;
            this.m_PlusRangeMarkPosArray[this.m_PlusRangeMarkPosArray.length] = Math.floor(nBottom - (MarkData - yMin) / DiffMaxMin * DiffY) + 0.5;
            this.m_PlusRangeMarkArray[this.m_PlusRangeMarkArray.length] = MarkValue;

            //////
            LowerLimit = this.m_MinMaxInfo.m_LowerLimit;

            nMultiple = Math.ceil(LowerLimit / Unit);
            LowerLimit = fMultiply(nMultiple, Unit);
            UpperLimit = 0;

            MarkValue = LowerLimit;
            MarkData = Log(MarkValue);
            nYPos1 = nBottom - (MarkData - yMin) / DiffMaxMin * DiffY;
            this.m_MinusRangeMarkPosArray[this.m_MinusRangeMarkPosArray.length] = Math.floor(nYPos1) + 0.5;
            this.m_MinusRangeMarkArray[this.m_MinusRangeMarkArray.length] = MarkValue;
            MarkValue = fPlus(MarkValue, Unit);

            iIndex = 1;
            while (MarkValue < UpperLimit) {

                MarkData = Log(MarkValue);
                nYPos2 = nBottom - (MarkData - yMin) / DiffMaxMin * DiffY;
                if (nYPos1 - nYPos2 >= DrawingInfo.m_nFontHeight) {

                    Unit = fMultiply(Unit, iIndex);
                    break;
                }
                iIndex++;
                MarkValue = fPlus(MarkValue, Unit);
            }

            while (MarkValue < UpperLimit) {

                MarkData = Log(MarkValue);
                this.m_MinusRangeMarkPosArray[this.m_MinusRangeMarkPosArray.length] = Math.floor(nBottom - (MarkData - yMin) / DiffMaxMin * DiffY) + 0.5;
                this.m_MinusRangeMarkArray[this.m_MinusRangeMarkArray.length] = MarkValue;
                MarkValue = fPlus(MarkValue, Unit);
            }
        }
    }
    else {

	    DiffMaxMin = yMax - yMin;
	
	    if (LowerLimit > 0) {//현재 보이는 모든 데이터 영역이 양수 영역에 존재하는 경우
	
	        nMultiple = Math.ceil(LowerLimit / Unit);
	        LowerLimit = fMultiply(nMultiple, Unit);
	        MarkValue = LowerLimit;
	        while (MarkValue < UpperLimit) {
	            this.m_PlusRangeMarkPosArray[this.m_PlusRangeMarkPosArray.length] = Math.floor(nBottom - (MarkValue - yMin) / DiffMaxMin * DiffY) + 0.5;
	            this.m_PlusRangeMarkArray[this.m_PlusRangeMarkArray.length] = MarkValue;
	            MarkValue = fPlus(MarkValue, Unit);
	        }
	    }
	    else if (UpperLimit < 0) {//현재 보이는 모든 데이터 영역이 음수 영역에 존재하는 경우
	
	        nMultiple = Math.ceil((UpperLimit - Unit) / Unit);
	        UpperLimit = fMultiply(nMultiple, Unit);
	        LowerLimit = this.m_MinMaxInfo.m_LowerLimit;
	        MarkValue = UpperLimit;
	        while (MarkValue > LowerLimit) {
	            this.m_MinusRangeMarkPosArray[this.m_MinusRangeMarkPosArray.length] = Math.floor(nBottom - (MarkValue - yMin) / DiffMaxMin * DiffY) + 0.5;
	            this.m_MinusRangeMarkArray[this.m_MinusRangeMarkArray.length] = MarkValue;
	            MarkValue = fPlus(MarkValue, -Unit);
	        }
	    }
	    else if (LowerLimit === 0) {//현재 보이는 모든 데이터 영역이 0부터 양수 영역에 존재하는 경우
	
	        MarkValue = LowerLimit;
	        while (MarkValue < UpperLimit) {
	            this.m_PlusRangeMarkPosArray[this.m_PlusRangeMarkPosArray.length] = Math.floor(nBottom - (MarkValue - yMin) / DiffMaxMin * DiffY) + 0.5;
	            this.m_PlusRangeMarkArray[this.m_PlusRangeMarkArray.length] = MarkValue;
	            MarkValue = fPlus(MarkValue, Unit);
	        }
	
	    }
	    else if (UpperLimit === 0) {//현재 보이는 모든 데이터 영역이 0부터 음수 영역에 존재하는 경우
	
	        LowerLimit = this.m_MinMaxInfo.m_LowerLimit;
	        MarkValue = UpperLimit;
	        while (MarkValue > LowerLimit) {
	            this.m_MinusRangeMarkPosArray[this.m_MinusRangeMarkPosArray.length] = Math.floor(nBottom - (MarkValue - yMin) / DiffMaxMin * DiffY) + 0.5;
	            this.m_MinusRangeMarkArray[this.m_MinusRangeMarkArray.length] = MarkValue;
	            MarkValue = fPlus(MarkValue, -Unit);
	        }
	    }
	    else {//현재 보이는 모든 데이터 영역이 양수에서 음수 영역에 걸쳐 존재하는 경우
	
	        MarkValue = 0;
	        yMin = this.m_MinMaxInfo.m_LowerLimit;
	        while (MarkValue < UpperLimit) {
	            this.m_PlusRangeMarkPosArray[this.m_PlusRangeMarkPosArray.length] = Math.floor(nBottom - (MarkValue - yMin) / DiffMaxMin * DiffY) + 0.5;
	            this.m_PlusRangeMarkArray[this.m_PlusRangeMarkArray.length] = MarkValue;
	            MarkValue = fPlus(MarkValue, Unit);
	        }
	
	        LowerLimit = this.m_MinMaxInfo.m_LowerLimit;
	        MarkValue = 0;
	        MarkValue = fPlus(MarkValue, -Unit);
	        while (MarkValue > LowerLimit) {
	            this.m_MinusRangeMarkPosArray[this.m_MinusRangeMarkPosArray.length] = Math.floor(nBottom - (MarkValue - yMin) / DiffMaxMin * DiffY) + 0.5;
	            this.m_MinusRangeMarkArray[this.m_MinusRangeMarkArray.length] = MarkValue;
	            MarkValue = fPlus(MarkValue, -Unit);
	        }
	    }
    }
    //////////////////////////////////////////////////////////////////////////////////
    if (this.GetInvert() === true) {

        nLength = this.m_PlusRangeMarkPosArray.length;
        for (i = 0; i < nLength; i++)
            this.m_PlusRangeMarkPosArray[i] = nBottom - this.m_PlusRangeMarkPosArray[i] + nTop;

        nLength = this.m_MinusRangeMarkPosArray.length;
        for (i = 0; i < nLength; i++)
            this.m_MinusRangeMarkPosArray[i] = nBottom - this.m_MinusRangeMarkPosArray[i] + nTop;
    }
    //////////////////////////////////////////////////////////////////////////////////
    this.m_LeftYAxis.Draw(DrawingInfo);
    this.m_RightYAxis.Draw(DrawingInfo);

}
CYScale.prototype.CalcLayout = function (nLeftYWidth, nRightYWidth, rectGraphRegion, rectGraphBackground, rectChartBlock, DrawingInfo) {

    this.m_nMarkHeight = DrawingInfo.m_nFontSize * 2;
    this.m_nMaxMarkCnt = Math.floor(rectGraphRegion.Height() / this.m_nMarkHeight);
    if (this.m_nMaxMarkCnt < 1)
        this.m_nMaxMarkCnt = 1;

    this.m_LeftYAxis.CalcLayout(nLeftYWidth, rectGraphRegion, rectGraphBackground, rectChartBlock, DrawingInfo);
    this.m_RightYAxis.CalcLayout(nRightYWidth, rectGraphRegion, rectGraphBackground, rectChartBlock, DrawingInfo);
}

///////////////////////////////
function CPacketSearchInfo(strTitle, strPacketName) {
    this.m_strTitle = strTitle;
    this.m_strPacketName = strPacketName;
    this.m_PacketData = null;
}

//////////////////////////////
function CChartBlockCol() {

    this.m_rXScaleMng = null;
    this.m_RQInColArray = [];//CRQInCol 개체를 저장하는 배열
    this.m_nLeft = null;
    this.m_nRight = null;
    this.m_nGraphRegionLeft = null;//CalcLayout에서 셋팅
    this.m_nGraphRegionRight = null;
    this.m_nGraphRegionWidth = null;

    this.m_nDataCnt = null;
    this.m_BongMinWidth = null;
    this.m_nViewStartIndex = null;
    this.m_nViewEndIndex = null;
    this.m_nViewEndIndexIncludeRightMargin = null;//추세선이 그려지도록 우측여백 포함된 보이는 영역 마지막 인덱스

    this.m_strXCycleType = null;
    this.m_nXTextInterval = null;
    this.m_strPrevXTextCompare = null;
    this.m_XScaleTextPosArray = [];

    this.m_bRenderingBreak = false;
}

CChartBlockCol.prototype.InitRendering = function (rXScaleMng) {

    var rGlobalProperty = rXScaleMng.m_rChart.GetGlobalProperty();
    var nRightMargin = rGlobalProperty.GetRightMargin();

    this.m_nViewStartIndex = rXScaleMng.m_nViewStartIndex;
    this.m_nViewEndIndex = rXScaleMng.m_nViewEndIndex;

    this.m_bRenderingBreak = false;

    this.m_nDataCnt = this.m_nViewEndIndex - this.m_nViewStartIndex + 1;
    this.m_nGraphRegionWidth = this.m_nGraphRegionRight - this.m_nGraphRegionLeft;
    //this.m_BongMinWidth = Math.floor(this.m_nGraphRegionWidth / this.m_nDataCnt);//절삭
    this.m_BongMinWidth = this.m_nGraphRegionWidth / this.m_nDataCnt;

    var nBongCntInMargin = Math.ceil(nRightMargin / this.m_BongMinWidth);
    this.m_nViewEndIndexIncludeRightMargin = this.m_nViewEndIndex + nBongCntInMargin;

    this.m_strXCycleType = null;
    this.m_nXTextInterval = null;
    this.m_strPrevXTextCompare = null;
    this.m_XScaleTextPosArray.length = 0;

    var i, length = this.m_RQInColArray.length;
    for (i = 0; i < length; i++) {
        var rRQInCol = this.m_RQInColArray[i];
        rRQInCol.InitRendering();
    }
}
CChartBlockCol.prototype.ReadyRendering = function (DrawingInfo) {


}

CChartBlockCol.prototype.RenderingInLoop = function(RenderingInfo){

    var i, nLength = this.m_RQInColArray.length;
    for (i = 0; i < nLength; i++) {

        var rRQInCol = this.m_RQInColArray[i];
        rRQInCol.RenderingInLoop(RenderingInfo);
    }
}

CChartBlockCol.prototype.RenderingOnLast = function (RenderingInfo) {

    //if (this.m_bRenderingBreak)
    //    return false;

    var bBreak = true;
    var i, nLength = this.m_RQInColArray.length;
    for (i = 0; i < nLength; i++) {

        var rRQInCol = this.m_RQInColArray[i];
        if (rRQInCol.RenderingOnLast(RenderingInfo))
            bBreak = false;
    }
    this.m_bRenderingBreak = bBreak;

    return !bBreak;
}
///////////////////////////////
export function CChartBlock(rMainBlock) {

    this.m_rMainBlock = rMainBlock;
    this.m_rChart = (rMainBlock !== undefined ? rMainBlock.m_rChart : null);
    this.m_rGlobalProperty = (this.m_rChart !== null ? this.m_rChart.GetGlobalProperty() : null);

    this.m_nColIndex = 0;
    this.m_nRowIndex = 0;

    //LKY 블락의 최대화 관련 부분>>
    this.m_bShow = true;
    //LKY 블락의 최대화 관련 부분<<

    this.m_clrBack = this.m_rChart.GetColorByKey("background");
    if (this.m_clrBack === null)
        this.m_clrBack = "#ffffff";

    //left, top, width, height
    this.m_rectBlock = new CRect();
    this.m_rectBlock.SetRect(0, 0, 0, 0);

    this.m_GraphArray = [];
    this.m_XScaleArray = [];
    this.m_YScaleArray = [];

    this.m_nYScaleShowOption = 0x03;//0x00:모두 보이지 않기, 0x01:좌측보이기, 0x02:우측보이기
    this.m_nXScaleShowOption = 0;//0x00:모두 보이지 않기, 0x01:하단보이기, 0x02:상단보이기

    this.m_nLeftYScaleWidth = 0;
    this.m_nRightYScaleWidth = 0;
    this.m_nTopXScaleHeight = 0;
    this.m_nBottomXScaleHeight = 0;

    this.m_rectGraphRegion = new CRect();
    this.m_rectGraphBackground = new CRect();

    this.m_rToolMng = rMainBlock.m_ToolMng;
    //this.m_rToolMng = (rMainBlock.m_ToolMng !== undefined ? rMainBlock.m_ToolMng : null);
    this.m_ToolArray = [];
    this.m_ShowToolArray = [];//현재 보여지고 있는 분석툴

    this.m_strChartBlockKey = "CB_" + Date.now() + "_" + (Math.floor(Math.random() * (10000 - 1 + 1)) + 1);

    this.m_nBlockRatio = 1;//블록크기 비율로 제어하는 변수(세로타입인 경우 높이, 가로타입인 경우 폭)

    //LKY 블락버튼 생성 관련 부분>>
    this.m_bButtonDivShow = true;
    this.m_ButtonDiv = null;
    this.m_ButtonId = null;
    //LKY 블락버튼 생성 관련 부분<<
}

CChartBlock.prototype.ChangeLang = function(){

    var i, rGraph, nGraphLen = this.m_GraphArray.length;
    for( i = 0 ; i < nGraphLen; i++ )
    {
        rGraph = this.m_GraphArray[i];
        rGraph.ChangeLang();
    }
}

CChartBlock.prototype.RemoveAllIndicatorExceptIndicator = function(strRemoveExceptIndicatorNameArray){

    var i, j, rGraph, nLen = this.m_GraphArray.length, nIndiNameArrayLen = strRemoveExceptIndicatorNameArray;
    for(i = 0 ; i < nLen; i++)
    {
        rGraph = this.m_GraphArray[i];
        for(j = 0 ; j < nIndiNameArrayLen; j++ )
        {
            var strRemoveExceptIndiName = strRemoveExceptIndicatorNameArray[j];
            if(rGraph.m_strName === strRemoveExceptIndiName)
                break;
        }

        //제거에서 제외해야 할 지표들이 실제 없는 경우
        if(j >= nIndiNameArrayLen)
            this.m_rChart.DeleteIndicator( rGraph.m_strKey );
    }
}

CChartBlock.prototype.GetChartFullProperty = function () {

    var i, nLen, ChartBlockProperty = new CChartBlockProperty();
    ChartBlockProperty.m_nColIndex = this.m_nColIndex;
    ChartBlockProperty.m_nRowIndex = this.m_nRowIndex;
    ChartBlockProperty.m_nBlockRatio = this.GetBlockRatio();
    ChartBlockProperty.m_bBlockMaximize = this.m_rMainBlock.m_rMaximumBlock === this;

    nLen = this.m_GraphArray.length;
    for (i = 0; i < nLen; i++)
        ChartBlockProperty.m_GraphPropertyArray[i] = this.m_GraphArray[i].GetChartFullProperty();

    return ChartBlockProperty;
}

CChartBlock.prototype.GetTotalIndicatorProp = function (mapTotalIndicatorProp) {

    var i, nLen = this.m_GraphArray.length;
    for (i = 0; i < nLen; i++) {

        var rGraph = this.m_GraphArray[i];
        rGraph.GetTotalIndicatorProp(mapTotalIndicatorProp);
    }
}

CChartBlock.prototype.ChangeSubGraphSubType = function (strGraphKey, strSubGraphName, nSubGraphSubType) {

    var i, nLen = this.m_GraphArray.length;
    for (i = 0; i < nLen; i++) {

        var rGraph = this.m_GraphArray[i];
        if (rGraph.m_strKey === strGraphKey) {
            rGraph.ChangeSubGraphSubType(strSubGraphName, nSubGraphSubType);
            return true;
        }
    }
    return false;
}

CChartBlock.prototype.SetGlobalPropertyToChart = function () {

    let i, j;
    let nYScaleShowOption = 0;
    let nGraphArrayLen = this.m_GraphArray.length;
    let nXScaleArrayLen = this.m_XScaleArray.length;
    let nYScaleArrayLen = this.m_YScaleArray.length;
    let rGraph, rXScale, rYScale;

    /////////////////////////////////////////////////////////
    //차트블록 배경색 설정
    /////////////////////////////////////////////////////////
    this.m_clrBack = this.m_rGlobalProperty.m_clrBack;

    /////////////////////////////////////////////////////////
    //Y축 좌우측 SHOW 여부 설정
    /////////////////////////////////////////////////////////
    //0x00:모두 보이지 않기, 0x01:좌측보이기, 0x02:우측보이기
    if (this.m_rGlobalProperty.m_bShowLeftYAxis === true)
        nYScaleShowOption |= 0x01;
    if (this.m_rGlobalProperty.m_bShowRightYAxis === true)
        nYScaleShowOption |= 0x02;
    this.SetYScaleShowOption(nYScaleShowOption);

    //그래프별 설정 셋팅
    for (i = 0; i < nGraphArrayLen; i++) {

        rGraph = this.m_GraphArray[i];
        rGraph.SetGlobalPropertyToChart();
    }

    //X축별 설정 셋팅
    for (i = 0; i < nXScaleArrayLen; i++) {

        rXScale = this.m_XScaleArray[i];
        rXScale.SetGlobalPropertyToChart();
    }

    //Y축별 설정 셋팅
    for (i = 0; i < nYScaleArrayLen; i++) {

        rYScale = this.m_YScaleArray[i];
        rYScale.SetGlobalPropertyToChart();
    }
    
}

CChartBlock.prototype.IsInBlock = function (X, Y) {

    //보이지 않는 블록은 무조건 false
    if (this.m_bShow !== true)
        return false;

    if ((this.m_rectBlock.m_nLeft <= X && X <= this.m_rectBlock.m_nRight) &&
        (this.m_rectBlock.m_nTop <= Y && Y <= this.m_rectBlock.m_nBottom)) {
        return true;
    }
    return false;
}

CChartBlock.prototype.SetInvertYScale = function (bInvert) {

    var i, rYScale, nYScaleArrayLen = this.m_YScaleArray.length;
    for (i = 0; i < nYScaleArrayLen; i++) {

        rYScale = this.m_YScaleArray[i];
        if (rYScale.IsSelected()) {
            rYScale.SetInvert(bInvert);
            return rYScale;
        }
    }
    return null;
}

CChartBlock.prototype.GetInvertYScale = function () {

    var i, rYScale, nYScaleArrayLen = this.m_YScaleArray.length;
    for (i = 0; i < nYScaleArrayLen; i++) {

        rYScale = this.m_YScaleArray[i];
        if (rYScale.IsSelected()) {

            if (rYScale.GetInvert())
                return rYScale;

            return null;
        }
    }
    return null;
}

CChartBlock.prototype.SetLogYScale = function (bLog) {

    var i, rYScale, nYScaleArrayLen = this.m_YScaleArray.length;
    for (i = 0; i < nYScaleArrayLen; i++) {

        rYScale = this.m_YScaleArray[i];
        if (rYScale.IsSelected()) {
            rYScale.SetLog(bLog);
            return rYScale;
        }
    }
    return null;
}

CChartBlock.prototype.GetLogYScale = function () {

    var i, rYScale, nYScaleArrayLen = this.m_YScaleArray.length;
    for (i = 0; i < nYScaleArrayLen; i++) {

        rYScale = this.m_YScaleArray[i];
        if (rYScale.IsSelected()) {

            if(rYScale.GetLog())
                return rYScale;

            return null;
        }
    }
    return null;
}

//LKY Block 버튼 이벤트 구현 처리 >>
CChartBlock.prototype.CreateButton = function (StartPt, LayoutInfo) {
    
    if (!this.m_bButtonDivShow)
        return null;

    this.m_ButtonId = this.m_nRowIndex;
    this.m_ButtonDiv = document.createElement('DIV');
    this.m_ButtonDiv.id = this.m_ButtonId;
    this.m_ButtonDiv.style.position = 'absolute';
    this.m_ButtonDiv.style.display = 'none'; //생성시점에는 보이지 않도록 처리(chartblock에서 위치조정 후 show(='inline'셋팅)
    this.m_ButtonDiv.style.left = StartPt.m_X + 'px';
    this.m_ButtonDiv.style.top = StartPt.m_Y + 'px';
    this.m_ButtonDiv.style.zIndex = 5;
    this.m_ButtonDiv.className = "chart_btn_grp " + this.m_rChart.m_strThemeName;
    this.m_ButtonDiv.ChartBlock = this;

    var innerHtml = '';
    innerHtml += '<button id="' + this.m_nRowIndex + "_0" + '" class="chart_btn_data up"></button>';
    innerHtml += '<button id="' + this.m_nRowIndex + "_1" + '" class="chart_btn_data down"></button>';
    innerHtml += '<button id="' + this.m_nRowIndex + "_2" + '" class="chart_btn_data big"></button>';
    innerHtml += '<button id="' + this.m_nRowIndex + "_3" + '" class="chart_btn_data close_btn"></button>';
 
    this.m_ButtonDiv.innerHTML = innerHtml;

    LayoutInfo.m_rChartParentDIV.appendChild(this.m_ButtonDiv);

    var self = this;

    this.m_ButtonDiv.addEventListener('mousemove', function (e) {

        self.OnMouseMove(e);
    });

    $(this.m_ButtonDiv).on("click", "button", function () {
        var DivBtnid = ($(this).attr("id"));
        console.log($(this).attr("id"));

        var BtnIdArray = DivBtnid.split('_');
        
        if( BtnIdArray[1] === "0" )
            self.OnDivUpBtnClick();
        else if(BtnIdArray[1] === "1")
            self.OnDivDownBtnClick();
        else if(BtnIdArray[1] === "2")
            self.OnDivMaxBtnClick();
        else if(BtnIdArray[1] === "3")
            self.OnDivDelBtnClick();
    });

    StartPt.m_X += (this.m_ButtonDiv.offsetWidth + 5);

    return this.m_ButtonDiv;
}

CChartBlock.prototype.OnDivUpBtnClick = function() {

    this.m_rMainBlock.SetChangeBlock(this.m_nRowIndex, true);

    this.m_rMainBlock.ResizeBlocks();
    this.m_rChart.Draw(DRAW_CASE_RESIZE);
}

CChartBlock.prototype.OnDivDownBtnClick = function() {

    this.m_rMainBlock.SetChangeBlock(this.m_nRowIndex, false);

    this.m_rMainBlock.ResizeBlocks();
    this.m_rChart.Draw(DRAW_CASE_RESIZE);
}

CChartBlock.prototype.OnDivMaxBtnClick = function () {
    
    if(this.m_rMainBlock.m_rMaximumBlock === null){
        this.m_rMainBlock.m_rMaximumBlock = this;

        var nCnt = this.m_rMainBlock.m_ChartBlockArray.length;
        for(var i = 0; i < nCnt; i++){
            var SelectChartBlock = this.m_rMainBlock.m_ChartBlockArray[i];

            SelectChartBlock.SetShow(false);
        }

        this.SetShow(true);
    }
    else{

        var nTotalCnt = this.m_rMainBlock.m_ChartBlockArray.length;
        for(var i = 0; i < nTotalCnt; i++){
            var SelectChartBlock = this.m_rMainBlock.m_ChartBlockArray[i];

            SelectChartBlock.SetShow(true);
        }

        this.m_rMainBlock.m_rMaximumBlock = null;
    }

    this.m_rMainBlock.ResizeBlocks();
    this.m_rChart.Draw(DRAW_CASE_RESIZE);
}

CChartBlock.prototype.OnDivDelBtnClick = function() {

    var i, rGraph;
    var nGraphTotalCnt = this.m_GraphArray.length;
    for (i = nGraphTotalCnt - 1; i >= 0; i--) {

        rGraph = this.m_GraphArray[i];
        if (rGraph.m_rRQSet.m_strRQ === this.m_rChart.m_strDefaultRQ && rGraph.m_strName === "_PRICE_" ){
            console.log(rGraph.m_rRQSet.m_strRQ);
            return;
        }
    }

    if (this.m_rMainBlock.m_rMaximumBlock !== null)
        this.m_rMainBlock.RestoreChartBlock(false);

    for (i = nGraphTotalCnt - 1; i >= 0; i--) {
        rGraph = this.m_GraphArray[i];
        this.m_rMainBlock.DeleteIndicator(rGraph.m_strKey, this.m_nRowIndex);
    }

    this.m_rChart.Draw(DRAW_CASE_DEL_CHARTBLOCK);
}

CChartBlock.prototype.DestroyButton = function () {

    if (this.m_ButtonDiv && this.m_ButtonDiv.parentNode) {
        this.m_ButtonDiv.parentNode.removeChild(this.m_ButtonDiv);

        var strID = ($(this).attr("id"));
        $(strID).remove();

        this.m_ButtonDiv = null;
    }
}

CChartBlock.prototype.ShowButton = function (LayoutInfo) {

    var StartPt = new CPoint(LayoutInfo.m_ScreenCanvas.offsetLeft + this.m_rectBlock.m_nLeft + 5, LayoutInfo.m_ScreenCanvas.offsetTop + this.m_rectBlock.m_nTop + 3);
    var StartOrgPt = new CPoint(StartPt.m_X, StartPt.m_Y);

    LayoutInfo.m_rectGraphRegion.SetRect(this.m_rectGraphRegion.m_nLeft, this.m_rectGraphRegion.m_nTop, this.m_rectGraphRegion.m_nRight, this.m_rectGraphRegion.m_nBottom);
    LayoutInfo.m_rectGraphBackground.SetRect(this.m_rectGraphBackground.m_nLeft, this.m_rectGraphBackground.m_nTop, this.m_rectGraphBackground.m_nRight, this.m_rectGraphBackground.m_nBottom);

    var ButtonDivArray = [];
    if (this.m_ButtonDiv)
        this.DestroyButton();

    var rButtonDiv =  null;
    rButtonDiv = this.CreateButton(StartPt, LayoutInfo);
    if (rButtonDiv)
        ButtonDivArray[ButtonDivArray.length] = rButtonDiv;

    StartPt.m_X = StartOrgPt.m_X;
    StartPt.m_Y = StartOrgPt.m_Y;

    this.RepositionButton(StartPt, LayoutInfo, ButtonDivArray);
    rButtonDiv.style.display = 'none';
}

CChartBlock.prototype.RepositionButton = function (StartPt, LayoutInfo, ButtonDivArray) {

    var StartX = StartPt.m_X;
    var StartY = StartPt.m_Y;
    var rectBlock = this.m_rectBlock;
    var nLeft = LayoutInfo.m_ScreenCanvas.offsetLeft + rectBlock.m_nLeft;
    var nRight = LayoutInfo.m_ScreenCanvas.offsetLeft + this.m_rectGraphBackground.m_nRight;
    var nLength = ButtonDivArray.length;
    for (var i = 0; i < nLength; i++) {

        var rButtonDiv = ButtonDivArray[i];

        rButtonDiv.style.display = 'inline';
        
        var Width = rButtonDiv.offsetWidth;
        var Height = rButtonDiv.offsetHeight;

        if(this.m_rMainBlock.m_rMaximumBlock !== null)
            StartX = nRight - Width + 36;
        else{
            if(this.m_nRowIndex === 0 || this.m_nRowIndex === this.m_rMainBlock.m_ChartBlockArray.length - 1)
                StartX = nRight - Width + 18;
            else
                StartX = nRight - Width;
        }

        rButtonDiv.style.left = StartX + "px";
        rButtonDiv.style.top = StartY + "px";

    }

}

CChartBlock.prototype.SetShow = function(bShow){
    
    this.m_bShow = bShow;

    if (this.m_bShow === false ){

        //this.DestroyButton();
        if(this.m_ButtonDiv !== null)
            this.m_ButtonDiv.style.display = 'none';

        var nGraphTotalCnt = this.m_GraphArray.length;
        for(var i = 0; i < nGraphTotalCnt; i++){
            var rGraph = this.m_GraphArray[i];
            rGraph.DestroyTitle();
        }
    }
}

CChartBlock.prototype.SetShowDivButton = function(nRowIndex) {

    var e, x, y, z;
    for(var i = 0; i < this.m_rMainBlock.m_ChartBlockArray.length; i++){

        var rChartBlock = this.m_rMainBlock.m_ChartBlockArray[i];

        if (rChartBlock.m_ButtonDiv === null)
            continue;

        rChartBlock.m_ButtonDiv.style.display = 'inline';

        if (this.m_rMainBlock.m_rMaximumBlock !== null) {
            if(i === this.m_rMainBlock.m_rMaximumBlock.m_nRowIndex) {
                e = document.getElementById(this.m_ButtonDiv.id);
                x = e.children[0].style.display = 'none';
                y = e.children[1].style.display = 'none';
                // S 확대/축소 버튼 토글
                z = e.children[2];
                z.classList.remove("big");
                z.classList.add("small");
                // E 확대/축소 버튼 토글
            }
            else
                rChartBlock.m_ButtonDiv.style.display = 'none';
        }
        else {
            if(nRowIndex === i){
                if(nRowIndex === 0){
                    e = document.getElementById(this.m_ButtonDiv.id);
                    x = e.children[0].style.display = 'none';
                }
                else if(nRowIndex === this.m_rMainBlock.m_ChartBlockArray.length - 1){
                    e = document.getElementById(this.m_ButtonDiv.id);
                    x = e.children[1].style.display = 'none';
                }
            }
            else{
                rChartBlock.m_ButtonDiv.style.display = 'none';
            }
        }
    }
}
//LKY Block 버튼 이벤트 구현 처리 <<

CChartBlock.prototype.SetBlockRatio = function (nBlockRatio) {
    this.m_nBlockRatio = nBlockRatio;
}
CChartBlock.prototype.GetBlockRatio = function () {
    return this.m_nBlockRatio;
}
CChartBlock.prototype.IsInGraphRegionRect = function (X, Y) {
}

CChartBlock.prototype.IsInGraphRegionRect = function (X, Y) {

    if ((this.m_rectGraphRegion.m_nLeft <= X && X <= this.m_rectGraphRegion.m_nRight) &&
        (this.m_rectGraphRegion.m_nTop <= Y && Y <= this.m_rectGraphRegion.m_nBottom)) {
        return true;
    }
    return false;
}

CChartBlock.prototype.IsInGraphBackgroundRect = function (X, Y) {

    if ((this.m_rectGraphBackground.m_nLeft <= X && X <= this.m_rectGraphBackground.m_nRight) &&
        (this.m_rectGraphBackground.m_nTop <= Y && Y <= this.m_rectGraphBackground.m_nBottom)) {
        return true;
    }
    return false;
}

CChartBlock.prototype.SelectGraphByXY = function (X, Y) {

    var rFindSubGraph = null;
    var rOldDrawSelectedSubGraph = this.m_rMainBlock.m_DrawSelectedSubGraph;
    this.m_rMainBlock.m_DrawSelectedSubGraph = null;

    for (var strXScaleKey in this.m_rMainBlock.m_mapXScaleMng) {
        var rXScaleMng = this.m_rMainBlock.m_mapXScaleMng[strXScaleKey];
        if (rXScaleMng != undefined) {

            rFindSubGraph = this.FindSubGraph(X, Y, rXScaleMng);
            if (rFindSubGraph != null) {//해당 차트블록안에 마우스포인터가 위치한 경우

                this.m_rMainBlock.m_DrawSelectedSubGraph = rFindSubGraph;
                this.SendEvent("Event_SelectGraph", rFindSubGraph.m_Graph);
            }
        }
    }

    if (rFindSubGraph != rOldDrawSelectedSubGraph) {

        this.m_rMainBlock.m_rChart.Draw(DRAW_CASE_SELECT_SUBGRAPH);
    }
    return rFindSubGraph;
}

CChartBlock.prototype.SendEvent = function (strEventName, EventInfoData) {

    this.m_rMainBlock.SendEvent(strEventName, EventInfoData);
}

CChartBlock.prototype.Remove = function () {
    this.DestroyButton();
}

CChartBlock.prototype.GetSelectedYScale = function () {
    var i, nLength = this.m_YScaleArray.length;
    for (i = 0; i < nLength; i++) {
        var rYScale = this.m_YScaleArray[i];
        if (rYScale.IsSelected() == true)
            return rYScale;
    }
    return null;
}
CChartBlock.prototype.GetSelectedXScale = function () {

    var rSelectedGraph = this.GetSelectedGraph();
    var rXScale = rSelectedGraph.GetXScale();
    return rXScale;
}
CChartBlock.prototype.FindSubGraph = function (X, Y, rXScaleMng) {

    if ((this.m_rectGraphRegion.m_nLeft <= X && X <= this.m_rectGraphRegion.m_nRight) &&
        (this.m_rectGraphRegion.m_nTop <= Y && Y <= this.m_rectGraphRegion.m_nBottom)) {

        var i, length = this.m_GraphArray.length;

        var nViewDataCnt = rXScaleMng.m_nViewEndIndex - rXScaleMng.m_nViewStartIndex + 1;
        var nGraphRegionWidth = this.m_rectGraphRegion.Width();
        if (nGraphRegionWidth <= 0)
            return null;

        var nFindXIndex = Math.floor((X - this.m_rectGraphRegion.m_nLeft) * (nViewDataCnt / this.m_rectGraphRegion.Width()) + rXScaleMng.m_nViewStartIndex);

        var nFindGraphIndex = null;
        var rRQGraphFindData = null;
        var rFindInfo = null;
        for (i = length - 1; i >= 0; i--) {

            var rGraph = this.m_GraphArray[i];

            rFindInfo = rGraph.FindRQGraphDataPerXScaleMng(X, Y, nFindXIndex, rXScaleMng);
            if (rFindInfo != null) {
                return rFindInfo.m_rFindSubGraph;
            }
        }
    }
    return null;
}
CChartBlock.prototype.FindRQGraphDataPerXScaleMng = function (X, Y, rXScaleMng, RQGraphFindDataPerXScaleMng, bShowDataList/*수치조회여부*/) {

    if (this.m_bShow === false)
        return null;

    if ((this.m_rectGraphRegion.m_nLeft <= X && X <= this.m_rectGraphRegion.m_nRight) &&
        (this.m_rectGraphRegion.m_nTop <= Y && Y <= this.m_rectGraphRegion.m_nBottom)) {

        var i, length = this.m_GraphArray.length;

        var nViewDataCnt = rXScaleMng.m_nViewEndIndex - rXScaleMng.m_nViewStartIndex + 1;
        var nGraphRegionWidth = this.m_rectGraphRegion.Width();
        if (nGraphRegionWidth <= 0)
            return null;

        var nFindXIndex = Math.floor((X - this.m_rectGraphRegion.m_nLeft) * (nViewDataCnt / this.m_rectGraphRegion.Width()) + rXScaleMng.m_nViewStartIndex);

        var nFindGraphIndex = null;
        var rRQGraphFindData = null;
        var mapRQFindInfo = {};
        var nMapCnt = 0;
        var rFindInfo = null;

        //수치조회 및 툴팁 기능을 위한 처리
        if (bShowDataList) {

            for (i = length - 1; i >= 0; i--) {

                var rGraph = this.m_GraphArray[i];
                //그물차트는 툴팁리스트에서 제외한다
                if (rGraph.m_strName === "_RAINBOW_")
                    continue;

                rFindInfo = mapRQFindInfo[rGraph.m_rRQSet.m_strRQ];
                if (!rFindInfo || !rFindInfo.m_rFindSubGraph) {

                    var rResultFindInfo = rGraph.FindRQGraphDataPerXScaleMng(X, Y, nFindXIndex, rXScaleMng, rFindInfo);

                    //해당rq의 Graph에 대한 FindInfo정보를 이미 얻은 경우는 맵에 저장되어 있으므로 또 저장하지 않는다
                    if (rResultFindInfo) {
                        if (!rFindInfo) {

                            mapRQFindInfo[rResultFindInfo.m_strRQ] = rResultFindInfo;
                            nMapCnt++;//맵개수 얻어오는 방법은 속도가 느리므로 미리 개수 카운트 할 수 있는 것은 카운트 해둔다

                        }
                    }

                }
            }

            if (nMapCnt > 0) {

                for (i = 0; i < length; i++) {

                    var rGraph = this.m_GraphArray[i];

                    //그물차트는 툴팁리스트에서 제외한다
                    if (rGraph.m_strName === "_RAINBOW_")
                        continue;

                    var strRQ = rGraph.m_rRQSet.m_strRQ;
                    var rFInfo = mapRQFindInfo[strRQ];
                    if (!rFInfo) continue;

                    var GraphFindData = rGraph.GetRQGraphFindDataPerXScaleMng(rFInfo.m_XDataInfo, rXScaleMng);
                    if (GraphFindData !== null) {

                        if (rFInfo.m_rFindSubGraph)//마우스 위치에 존재하는 서브그래프 있음(툴팁가능)
                            RQGraphFindDataPerXScaleMng.m_strFindToolTipRQ = strRQ;//툴팁되는 그래프의 rq 저장

                        rRQGraphFindData = RQGraphFindDataPerXScaleMng.GetRQGraphFindData(strRQ);
                        if (rRQGraphFindData === null) {
                            rRQGraphFindData = new CRQGraphFindData(rGraph.m_rRQSet);
                            rRQGraphFindData.m_strXTitle = rFInfo.m_strXTitle;
                            rRQGraphFindData.m_strXData = rFInfo.m_strXData;
                            RQGraphFindDataPerXScaleMng.m_arrRQGraphFindData[RQGraphFindDataPerXScaleMng.m_arrRQGraphFindData.length] = rRQGraphFindData;
                        }
                        rRQGraphFindData.m_arrGraphFindData[rRQGraphFindData.m_arrGraphFindData.length] = GraphFindData;
                    }
                }

                RQGraphFindDataPerXScaleMng.m_nFindXIndex = nFindXIndex;
                return mapRQFindInfo;
            }
        }
        //툴팁 기능 만을 위한 처리
        else {

            for (i = length - 1; i >= 0; i--) {

                var rGraph = this.m_GraphArray[i];

                //그물차트는 툴팁리스트에서 제외한다
                if (rGraph.m_strName === "_RAINBOW_")
                    continue;

                var rResultFindInfo = rGraph.FindRQGraphDataPerXScaleMng(X, Y, nFindXIndex, rXScaleMng, rFindInfo);

                //해당rq의 Graph에 대한 FindInfo정보를 이미 얻은 경우는 맵에 저장되어 있으므로 또 저장하지 않는다
                if (rResultFindInfo && rResultFindInfo.m_rFindSubGraph) {
                    
                    mapRQFindInfo[rResultFindInfo.m_strRQ] = rResultFindInfo;

                    var GraphFindData = rGraph.GetRQGraphFindDataPerXScaleMng(rResultFindInfo.m_XDataInfo, rXScaleMng);
                    if (GraphFindData != null) {

                        var strRQ = rGraph.m_rRQSet.m_strRQ;

                        RQGraphFindDataPerXScaleMng.m_strFindToolTipRQ = strRQ;//툴팁되는 그래프의 rq 저장

                        rRQGraphFindData = RQGraphFindDataPerXScaleMng.GetRQGraphFindData(strRQ);
                        if (rRQGraphFindData === null) {
                            rRQGraphFindData = new CRQGraphFindData(rGraph.m_rRQSet);
                            rRQGraphFindData.m_strXTitle = rResultFindInfo.m_strXTitle;
                            rRQGraphFindData.m_strXData = rResultFindInfo.m_strXData;
                            RQGraphFindDataPerXScaleMng.m_arrRQGraphFindData[RQGraphFindDataPerXScaleMng.m_arrRQGraphFindData.length] = rRQGraphFindData;
                        }
                        rRQGraphFindData.m_arrGraphFindData[rRQGraphFindData.m_arrGraphFindData.length] = GraphFindData;
                    }

                    return mapRQFindInfo;
                }
            }
        }
    }
    return null;
}

CChartBlock.prototype.GetRQGraphFindDataPerXScaleMng = function (rXScaleMng, RQGraphFindDataPerXScaleMng, rRQGraphFindDataPerXScaleMngToolTip) {

    if (this.m_bShow === false)
        return false;

    var bResult = false;

    var tFindDateTime = rXScaleMng.m_tFindDateTime;
    if (tFindDateTime && rXScaleMng.m_tTimeArray[tFindDateTime] != undefined)
    {
        var i, length = this.m_GraphArray.length;
        for (i = 0; i < length; i++) {

            var rGraph = this.m_GraphArray[i];

            var strRQ = rGraph.m_rRQSet.m_strRQ;
            var rRQPackets = rXScaleMng.m_tTimeArray[tFindDateTime][strRQ]
            if (rRQPackets === undefined) {

                var strKey = strRQ + "_TIME";
                var tPrevStartDateTime = rXScaleMng.m_tTimeArray[tFindDateTime][strKey];
                if (tPrevStartDateTime !== undefined) {

                    if (rXScaleMng.m_tTimeArray[tPrevStartDateTime] !== undefined) {
                        rRQPackets = rXScaleMng.m_tTimeArray[tPrevStartDateTime][strRQ];
                    }
                }
            }

            if (rRQPackets !== undefined) {

                var GraphFindData = null;
                if (rRQGraphFindDataPerXScaleMngToolTip !== undefined) {

                    var rRQGraphFindData = rRQGraphFindDataPerXScaleMngToolTip.GetRQGraphFindData(strRQ);
                    if (rRQGraphFindData !== null) {
                        GraphFindData = rRQGraphFindData.GetGraphFindData(rGraph.m_strKey);
                    }
                    if (GraphFindData === null)
                        GraphFindData = rGraph.GetRQGraphFindDataPerXScaleMng(rRQPackets, rXScaleMng);
                }
                else
                    GraphFindData = rGraph.GetRQGraphFindDataPerXScaleMng(rRQPackets, rXScaleMng);
                
                if (GraphFindData !== null) {

                    rRQGraphFindData = RQGraphFindDataPerXScaleMng.GetRQGraphFindData(strRQ);
                    if (rRQGraphFindData === null) {
                        rRQGraphFindData = new CRQGraphFindData(rGraph.m_rRQSet);
                        RQGraphFindDataPerXScaleMng.m_arrRQGraphFindData[RQGraphFindDataPerXScaleMng.m_arrRQGraphFindData.length] = rRQGraphFindData;

                        rRQGraphFindData.m_strXTitle = rXScaleMng.GetTitle();
                        var DateTimeItem = rRQPackets.m_Packets[rGraph.m_rXAxisPacket.m_nPacketIndex];
                        switch (rRQPackets.m_nCycle) {
                            case 1://일
                            case 2://주
                                rRQGraphFindData.m_strXData = DateTimeItem.m_nYear + "/" + sprintf(2, (DateTimeItem.m_nMonth + 1)) + "/" + sprintf(2, DateTimeItem.m_nDay); break;
                            case 3://월
                                rRQGraphFindData.m_strXData = DateTimeItem.m_nYear + "/" + sprintf(2, (DateTimeItem.m_nMonth + 1)); break;
                            case 4://년
                                rRQGraphFindData.m_strXData = DateTimeItem.m_nYear; break;
                            case 5://분
                                rRQGraphFindData.m_strXData = DateTimeItem.m_nYear + "/" + sprintf(2, (DateTimeItem.m_nMonth + 1)) + "/" + sprintf(2, DateTimeItem.m_nDay) + " " + sprintf(2, DateTimeItem.m_nHour) + ":" + sprintf(2, DateTimeItem.m_nMin); break;
                            case 6://초
                                rRQGraphFindData.m_strXData = DateTimeItem.m_nYear + "/" + sprintf(2, (DateTimeItem.m_nMonth + 1)) + "/" + sprintf(2, DateTimeItem.m_nDay) + " " + sprintf(2, DateTimeItem.m_nHour) + ":" + sprintf(2, DateTimeItem.m_nMin) + ":" + sprintf(2, DateTimeItem.m_nSecond); break;
                            default://기본주기 => 일주기
                                rRQGraphFindData.m_strXData = DateTimeItem.m_nYear + "/" + sprintf(2, (DateTimeItem.m_nMonth + 1)) + "/" + sprintf(2, DateTimeItem.m_nDay); break;
                        }
                    }
                    rRQGraphFindData.m_arrGraphFindData[rRQGraphFindData.m_arrGraphFindData.length] = GraphFindData;

                    bResult = true;
                }
            }
        }
    }

    return bResult;
}

export var CB_NO_SELECT = 0, CB_SELECT = 1, CB_SELECT_TOOL = 2, CB_SELECT_GRAPH = 3, CB_SELECT_TRADINGLING = 4;

CChartBlock.prototype.OnMouseDown = function (e) {

    if (this.m_bShow === false)
        return CB_NO_SELECT;

    var X = e.ChartXPos;
    var Y = e.ChartYPos;
    if (X < this.m_rectBlock.m_nLeft || this.m_rectBlock.m_nRight < X) {
        return CB_NO_SELECT;
    }
    if (Y < this.m_rectBlock.m_nTop || this.m_rectBlock.m_nBottom < Y) {
        return CB_NO_SELECT;
    }

    if (this.m_rectGraphBackground.m_nLeft <= X && X <= this.m_rectGraphBackground.m_nRight &&
        this.m_rectGraphBackground.m_nTop <= Y && Y <= this.m_rectGraphBackground.m_nBottom) {

        if (this.m_rToolMng.OnMouseDown(e, this))
            return CB_SELECT_TOOL;//추세선 동작이 되어야 하는 경우는 다른 동작못하도록 여기서 리턴

        // 20190115 전중현 : 알림선 삭제 이벤트처리
        if (this.m_rChart.m_TradingLineMng.OnMouseDown(e, this) )
            return CB_SELECT_TRADINGLING;

        if (this.m_rectGraphRegion.m_nLeft <= X && X <= this.m_rectGraphRegion.m_nRight &&
            this.m_rectGraphRegion.m_nTop <= Y && Y <= this.m_rectGraphRegion.m_nBottom) {
     
            if (this.SelectGraphByXY(X, Y))
                return CB_SELECT_GRAPH;
        }
    }

    return CB_SELECT;
}
CChartBlock.prototype.OnMouseUp = function (e) {

    if (this.m_bShow === false)
        return false;

    var X = e.ChartXPos;
    var Y = e.ChartYPos;

    if (!this.m_rToolMng.IsDrawingTool()) {
        if (X < this.m_rectBlock.m_nLeft || this.m_rectBlock.m_nRight < X) {
            return false;
        }
        if (Y < this.m_rectBlock.m_nTop || this.m_rectBlock.m_nBottom < Y) {
            return false;
        }
    }

    if (this.m_rToolMng.IsDrawingTool()) {
        this.m_rToolMng.OnMouseUp(e);
    }

    return true;
}
CChartBlock.prototype.OnMouseMove = function (e) {

    if (this.m_bShow === false)
        return false;

    var X = e.ChartXPos;
    var Y = e.ChartYPos;

    if (!this.m_rToolMng.IsDrawingTool()) {
        if (X < this.m_rectBlock.m_nLeft || this.m_rectBlock.m_nRight < X) {
            return false;
        }
        if (Y < this.m_rectBlock.m_nTop || this.m_rectBlock.m_nBottom < Y) {
            return false;
        }
    }

    if (this.m_rToolMng.IsDrawingTool()) {
        this.m_rToolMng.OnMouseMove(e, this);
    }

    if ((this.m_rectGraphRegion.m_nLeft <= X && X <= this.m_rectGraphRegion.m_nRight) &&
        (this.m_rectGraphRegion.m_nTop <= Y && Y <= this.m_rectGraphRegion.m_nBottom)) {

    }
    else {

    }
    //LKY ChartBlock 영역을 벗어났을 때 Div버튼 Hide 이벤트 >>>
    this.SetShowDivButton(this.m_nRowIndex);
    if ((X < this.m_rectGraphBackground.m_nLeft  || this.m_rectGraphBackground.m_nRight < X) ||
        (Y < this.m_rectGraphBackground.m_nTop || this.m_rectGraphBackground.m_nBottom < Y)) {
        if (this.m_ButtonDiv !== null)
            this.m_ButtonDiv.style.display = 'none';
    }
    //LKY ChartBlock 영역을 벗어났을 때 Div버튼 Hide 이벤트 <<<

    /********* Jang 2017-12-04  start ***************************************************************************************/
    return true;

}
CChartBlock.prototype.OnMouseOut = function () {

    if (this.m_ButtonDiv !== null)
        this.m_ButtonDiv.style.display = 'none';
}

CChartBlock.prototype.SetYScaleShowOption = function (ShowOption) {

    this.m_nYScaleShowOption = ShowOption;
    var length = this.m_YScaleArray.length;
    for (var i = 0; i < length; i++) {
        var YScale = this.m_YScaleArray[i];
        YScale.SetShowOption(ShowOption);
    }
}
CChartBlock.prototype.GetYScaleShowOption = function () {
    return this.m_nYScaleShowOption;
}
CChartBlock.prototype.SetXScaleShowOption = function (ShowOption) {
    this.m_nXScaleShowOption = ShowOption;
    var length = this.m_XScaleArray.length;
    for (var i = 0; i < length; i++) {
        var XScale = this.m_XScaleArray[i];
        XScale.SetShowOption(ShowOption);
    }
}
CChartBlock.prototype.GetXScaleShowOption = function () {
    return this.m_nXScaleShowOption;
}
CChartBlock.prototype.GetSelectedGraph = function () {
    for (var i = 0; i < this.m_GraphArray.length; i++) {
        var Graph = this.m_GraphArray[i];
        if (Graph.IsSelected())
            return Graph;
    }

    if (this.m_GraphArray[0] == undefined)
        return null;

    return this.m_GraphArray[0];
}
CChartBlock.prototype.ExtractYScaleMinMax = function (bFullScan) {
    for (var i = 0; i < this.m_YScaleArray.length; i++) {
        var YScale = this.m_YScaleArray[i];
        YScale.ExtractYScaleMinMax(bFullScan);
    }
}
CChartBlock.prototype.ExtractYScaleMinMaxOnRealData = function (bFullScan) {
    for (var i = 0; i < this.m_YScaleArray.length; i++) {
        var YScale = this.m_YScaleArray[i];
        if (YScale.IsUpdateMinMax()) {
            YScale.ExtractYScaleMinMax(bFullScan);
            YScale.SetUpdateMinMax(false);
        }
    }
}
CChartBlock.prototype.AddIndicator = function (rRQSet, strIndicatorName, nVertScaleIndex, IndicatorPropertyInfo) {
    var i = 0;
    var rYScale = null;
    var rXScale = null;
    var nYScaleIndex = -1;

    var Indicator = this.m_rChart.CreateIndicator(rRQSet, strIndicatorName);
    if (Indicator) {
        Indicator.SetRQSet(rRQSet);

        /////////////////////////////////////////////////////////////
        //y축 셋팅
        if (0 <= nVertScaleIndex && nVertScaleIndex < this.m_YScaleArray.length) {
            for (i = 0; i < this.m_YScaleArray.length; i++) {
                var YScale = this.m_YScaleArray[i];
                if (i == nVertScaleIndex) {
                    rYScale = YScale;
                    rYScale.AddGrpah(Indicator);
                    break;
                }
            }
        }
        if (!rYScale) {
            rYScale = new CYScale(this);
            rYScale.SetShowOption(this.m_nYScaleShowOption);
            rYScale.AddGrpah(Indicator);
            if (this.m_YScaleArray.length <= 0)
                rYScale.Select(true);

            this.m_YScaleArray.push(rYScale);
        }

        Indicator.m_rYScale = rYScale;

        //////////////////////////////////////////////////////////////////
        //x축 셋팅
        var rSelectXScale = null;
        for (i = 0; i < this.m_XScaleArray.length; i++) {
            var XScale = this.m_XScaleArray[i];
            if (XScale.m_strXScalePacketName == Indicator.m_rXAxisPacket.m_strPacketName) {
                rSelectXScale = XScale;
                break;
            }
        }
        if (!rSelectXScale) {

            if(Indicator.m_rXAxisPacket.m_strPacketName !== "_HOGA_")
                rSelectXScale = new CXScale(this);
            else
                rSelectXScale = new CHogaXScale(this);

            rSelectXScale.SetShowOption(this.m_nXScaleShowOption);
            rSelectXScale.m_strXScalePacketName = Indicator.m_rXAxisPacket.m_strPacketName;
            this.m_XScaleArray.push(rSelectXScale);
        }
        rSelectXScale.m_GraphArray[rSelectXScale.m_GraphArray.length] = Indicator;
        Indicator.m_rXScale = rSelectXScale;

        var rXScaleMng = Indicator.m_rRQSet.GetXScaleMng(rSelectXScale.m_strXScalePacketName);
        if (rXScaleMng != null)
            Indicator.m_rXScale.SetXScaleMng(rXScaleMng);

        /////////////////////////////////////////////////////////////////
        //Property 셋팅
        if (IndicatorPropertyInfo != undefined && IndicatorPropertyInfo != null)
            Indicator.SetPropertyInfo(Indicator.m_strKey, IndicatorPropertyInfo);

        /////////////////////////////////////////////////////////////////
        //chartblock 등록
        Indicator.m_rBlock = this;
        this.m_GraphArray[this.m_GraphArray.length] = Indicator;

        /////////////////////////////////////////////////////////////////
        //RQSet등록
        rRQSet.AddGraph(Indicator);

        ////////////////////////////////////////////////////////////////
        //Select Graph
        rRQSet.SelectGraph(Indicator);

        ////////////////////////////////////////////////////////////////
        //서브그래프 선택표시는 그래프에 변화가 생기면 풀어버린다
        this.m_rMainBlock.m_DrawSelectedSubGraph = null;

        return Indicator.m_strKey;
    }
    else
        return "";
}
CChartBlock.prototype.DeleteIndicator = function (strIndicatorKey) {

    var i, nGraphLength = this.m_GraphArray.length;
    for (i = 0; i < nGraphLength; i++) {
        var rGraph = this.m_GraphArray[i];

        if (rGraph.m_strKey === strIndicatorKey) {

            //패킷정리(패킷본체는 rqset초기화 되기 전에는 삭제처리 하지 않는다.패킷index변화 없도록 하며 timeArray에 rq삭제도 시간이 걸리므로 rqset 삭제,초기화 될때만 패킷도 같이 처리)
            var nSubGraphLength = rGraph.m_SubGraphArray.length;
            for (var nSubIndex = 0; nSubIndex < nSubGraphLength; nSubIndex++) {

                var rSubGraph = rGraph.m_SubGraphArray[nSubIndex];
                rSubGraph.DeleteSubGraphInPacketData();
            }

            //Y Scale 정리
            var j, nLength = rGraph.m_rYScale.m_GraphArray.length;
            for (j = 0; j < nLength; j++) {
                var rG = rGraph.m_rYScale.m_GraphArray[j];
                if (rG == rGraph) {
                    rGraph.m_rYScale.m_GraphArray.splice(j, 1);
                    if (rGraph.m_rYScale.m_GraphArray.length == 0) {

                        var k, nYScaleLength = this.m_YScaleArray.length;
                        for (k = 0; k < nYScaleLength; k++) {
                            var rY = this.m_YScaleArray[k];
                            if (rY == rGraph.m_rYScale) {
                                this.m_YScaleArray.splice(k, 1);
                                break;
                            }
                        }
                    }
                    break;
                }
            }

            //X Scale 정리
            nLength = rGraph.m_rXScale.m_GraphArray.length;
            for (j = 0; j < nLength; j++) {
                var rG = rGraph.m_rXScale.m_GraphArray[j];
                if (rG == rGraph) {
                    rGraph.m_rXScale.m_GraphArray.splice(j, 1);
                    if (rGraph.m_rXScale.m_GraphArray.length == 0) {

                        var k, nXScaleLength = this.m_XScaleArray.length;
                        for (k = 0; k < nXScaleLength; k++) {
                            var rX = this.m_XScaleArray[k];
                            if (rX == rGraph.m_rXScale) {
                                this.m_XScaleArray.splice(k, 1);
                                break;
                            }
                        }
                    }
                    break;
                }
            }

            //RQSet 정리
            var rRQSet = rGraph.m_rRQSet;
            nLength = rRQSet.m_GraphArray.length;
            for (j = 0; j < nLength; j++) {
                var rG = rRQSet.m_GraphArray[j];
                if (rG == rGraph) {

                    rRQSet.m_GraphArray.splice(j, 1);

                    if (rRQSet.m_rSelectGraph && rRQSet.m_rSelectGraph == rGraph) {


                        if (rRQSet.m_GraphArray.length > 0) {
                            rRQSet.m_rSelectGraph = rRQSet.m_Graph
                        }
                        else {
                            rRQSet.m_rSelectGraph = null;
                        }

                    }

                    break;
                }
            }

            //최대,최소 정리
            this.m_GraphArray.splice(i, 1);
            if (this.m_GraphArray.length > 0)
                this.ExtractYScaleMinMax(false);

            //그래프 소속의 타이틀 삭제
            rGraph.DestroyTitle();

            //서브그래프 선택표시는 그래프에 변화가 생기면 풀어버린다
            this.m_rMainBlock.m_DrawSelectedSubGraph = null;

            return true;
        }
    }
    return false;
}
CChartBlock.prototype.SetPropertyInfo = function (strIndicatorKey, IndicatorPropertyInfo, bSetup) {
    var i, nLength = this.m_GraphArray.length;
    for (i = 0; i < nLength; i++) {
        if (this.m_GraphArray[i].SetPropertyInfo(strIndicatorKey, IndicatorPropertyInfo, bSetup))
            return true;
    }
    return false;
}
CChartBlock.prototype.GetPropertyInfo = function (strIndicatorKey) {
    var IndicatorPropertyInfo = null;
    var i, nLength = this.m_GraphArray.length;
    for (i = 0; i < nLength; i++) {
        IndicatorPropertyInfo = this.m_GraphArray[i].GetPropertyInfo(strIndicatorKey);
        if (IndicatorPropertyInfo != null)
            return IndicatorPropertyInfo;
    }
    return null;
}
CChartBlock.prototype.CalcLayoutHorz = function (bTopXShow, bBottomXShow, nXScaleHeight, LayoutInfo) {

    var nMargin = 0;
    nXScaleHeight += 15;

    var rGlobalProperty = this.m_rGlobalProperty;

    if (bTopXShow === true)
        this.m_nTopXScaleHeight = nXScaleHeight;
    else
        this.m_nTopXScaleHeight = nMargin;

    if (bBottomXShow === true)
        this.m_nBottomXScaleHeight = nXScaleHeight;
    else
        this.m_nBottomXScaleHeight = nMargin;


    var nYWidth = 0;
    if (this.m_nYScaleShowOption !== 0)
        nYWidth = this.CalcYScaleWidth(LayoutInfo) + 15;

    if (this.m_nYScaleShowOption & 0x01)
        this.m_nLeftYScaleWidth = nYWidth;
    else
        this.m_nLeftYScaleWidth = nMargin;

    if (this.m_nYScaleShowOption & 0x02)
        this.m_nRightYScaleWidth = nYWidth;
    else
        this.m_nRightYScaleWidth = nMargin;

    this.m_rectGraphBackground.m_nLeft = this.m_rectBlock.m_nLeft + this.m_nLeftYScaleWidth;
    this.m_rectGraphBackground.m_nRight = this.m_rectBlock.m_nRight - this.m_nRightYScaleWidth;
    this.m_rectGraphBackground.m_nTop = this.m_rectBlock.m_nTop + this.m_nTopXScaleHeight;
    this.m_rectGraphBackground.m_nBottom = this.m_rectBlock.m_nBottom - this.m_nBottomXScaleHeight;

    this.m_rectGraphRegion.m_nLeft = this.m_rectBlock.m_nLeft + this.m_nLeftYScaleWidth + 3;
    this.m_rectGraphRegion.m_nRight = this.m_rectBlock.m_nRight - this.m_nRightYScaleWidth - 3 - rGlobalProperty.GetRightMargin();
    this.m_rectGraphRegion.m_nTop = this.m_rectBlock.m_nTop + this.m_nTopXScaleHeight + LayoutInfo.m_nFontSize;
    this.m_rectGraphRegion.m_nBottom = this.m_rectBlock.m_nBottom - this.m_nBottomXScaleHeight - 3;

    var SelectedGraph = this.GetSelectedGraph();
    if (SelectedGraph === null && this.m_GraphArray.length > 0)
        SelectedGraph = this.m_GraphArray[0];

    if (SelectedGraph !== null && SelectedGraph !== undefined) {

        SelectedGraph.m_rYScale.CalcLayout(this.m_nLeftYScaleWidth, this.m_nRightYScaleWidth, this.m_rectGraphRegion, this.m_rectGraphBackground, this.m_rectBlock, LayoutInfo);
        SelectedGraph.m_rXScale.CalcLayout(this.m_nTopXScaleHeight, this.m_nBottomXScaleHeight, this.m_rectGraphRegion, this.m_rectGraphBackground, this.m_rectBlock, LayoutInfo);

        this.ShowGraphTitle(LayoutInfo);
        this.ShowButton(LayoutInfo);
        this.SetShow(this.m_bShow);

    }
}
CChartBlock.prototype.CalcLayoutVert = function (bLeftYShow, bRightYShow, nYScaleWidth, LayoutInfo) {

    if(this.m_bShow === false)
        return;

    var nMargin = 0;
    nYScaleWidth += 15;

    var rGlobalProperty = this.m_rGlobalProperty;

    var nXScaleHeight = LayoutInfo.m_nFontSize + 15;

    if (bLeftYShow === true)
        this.m_nLeftYScaleWidth = nYScaleWidth;
    else
        this.m_nLeftYScaleWidth = nMargin;

    if (bRightYShow === true)
        this.m_nRightYScaleWidth = nYScaleWidth;
    else
        this.m_nRightYScaleWidth = nMargin;


    if (this.m_nXScaleShowOption & 0x01)
        this.m_nBottomXScaleHeight = nXScaleHeight;
    else
        this.m_nBottomXScaleHeight = nMargin;

    if (this.m_nXScaleShowOption & 0x02)
        this.m_nTopXScaleHeight = nXScaleHeight;
    else
        this.m_nTopXScaleHeight = nMargin;

    this.m_rectGraphBackground.m_nLeft = this.m_rectBlock.m_nLeft + this.m_nLeftYScaleWidth;
    this.m_rectGraphBackground.m_nRight = this.m_rectBlock.m_nRight - this.m_nRightYScaleWidth;
    this.m_rectGraphBackground.m_nTop = this.m_rectBlock.m_nTop + this.m_nTopXScaleHeight;
    this.m_rectGraphBackground.m_nBottom = this.m_rectBlock.m_nBottom - this.m_nBottomXScaleHeight;

    this.m_rectGraphRegion.m_nLeft = this.m_rectBlock.m_nLeft + this.m_nLeftYScaleWidth + 3;
    this.m_rectGraphRegion.m_nRight = this.m_rectBlock.m_nRight - this.m_nRightYScaleWidth - 3 - rGlobalProperty.GetRightMargin();
    this.m_rectGraphRegion.m_nTop = this.m_rectBlock.m_nTop + this.m_nTopXScaleHeight + LayoutInfo.m_nFontSize;
    this.m_rectGraphRegion.m_nBottom = this.m_rectBlock.m_nBottom - this.m_nBottomXScaleHeight - 3;

    var SelectedGraph = this.GetSelectedGraph();
    if (SelectedGraph === null && this.m_GraphArray.length > 0)
        SelectedGraph = this.m_GraphArray[0];

    if (SelectedGraph !== null && SelectedGraph !== undefined) {
        SelectedGraph.m_rYScale.CalcLayout(this.m_nLeftYScaleWidth, this.m_nRightYScaleWidth, this.m_rectGraphRegion, this.m_rectGraphBackground, this.m_rectBlock, LayoutInfo);
        SelectedGraph.m_rXScale.CalcLayout(this.m_nTopXScaleHeight, this.m_nBottomXScaleHeight, this.m_rectGraphRegion, this.m_rectGraphBackground, this.m_rectBlock, LayoutInfo);

        this.ShowGraphTitle(LayoutInfo);
        this.ShowButton(LayoutInfo);
        this.SetShow(this.m_bShow);
    }
}
CChartBlock.prototype.ShowGraphTitle = function (LayoutInfo) {

    var StartPt = new CPoint(LayoutInfo.m_ScreenCanvas.offsetLeft + this.m_rectGraphBackground.m_nLeft + 5, LayoutInfo.m_ScreenCanvas.offsetTop + this.m_rectGraphBackground.m_nTop + 3);
    var StartOrgPt = new CPoint(StartPt.m_X, StartPt.m_Y);

    LayoutInfo.m_rectGraphRegion.SetRect(this.m_rectGraphRegion.m_nLeft, this.m_rectGraphRegion.m_nTop, this.m_rectGraphRegion.m_nRight, this.m_rectGraphRegion.m_nBottom);
    LayoutInfo.m_rectGraphBackground.SetRect(this.m_rectGraphBackground.m_nLeft, this.m_rectGraphBackground.m_nTop, this.m_rectGraphBackground.m_nRight, this.m_rectGraphBackground.m_nBottom);

    var TitleDivArray = [];

    var nLength = this.m_GraphArray.length;
    for (var i = 0; i < nLength; i++) {

        var vGraph = this.m_GraphArray[i];
        vGraph.ShowTitle(StartPt, LayoutInfo, TitleDivArray);
    }

    StartPt.m_X = StartOrgPt.m_X;
    StartPt.m_Y = StartOrgPt.m_Y;
    this.RepositionGraphTitle(StartPt, LayoutInfo, TitleDivArray);
}

CChartBlock.prototype.GetGraphTitleDivs = function (TitleDivArray) {

    var nLength = this.m_GraphArray.length;
    for (var i = 0; i < nLength; i++)
        this.m_GraphArray[i].GetTitleDiv(TitleDivArray);
}
CChartBlock.prototype.RepositionGraphTitle = function (StartPt, LayoutInfo, TitleDivArray) {

    var StartX = StartPt.m_X;
    var StartY = StartPt.m_Y;
    var rectGraphBackground = this.m_rectGraphBackground;
    var nLeft = LayoutInfo.m_ScreenCanvas.offsetLeft + rectGraphBackground.m_nLeft;
    var nRight = LayoutInfo.m_ScreenCanvas.offsetLeft + rectGraphBackground.m_nRight;
    var nTop = LayoutInfo.m_ScreenCanvas.offsetTop + rectGraphBackground.m_nTop;
    var nBottom = LayoutInfo.m_ScreenCanvas.offsetTop + rectGraphBackground.m_nBottom;
    var nLength = TitleDivArray.length;
    for (var i = 0; i < nLength; i++) {

        var rTitleDiv = TitleDivArray[i];

        rTitleDiv.style.display = 'inline';//생성시점에는 보이지 않도록 처리(chartblock에서 위치조정 후 show(='inline'셋팅)

        var strID = "#" + rTitleDiv.id;

        var Width = rTitleDiv.offsetWidth;
        var Height = rTitleDiv.offsetHeight;

        if (nRight < (StartX + Width)) {
            StartX = nLeft + 5;
            StartY = StartY + Height + 3;
        }

        rTitleDiv.style.left = StartX + "px";
        rTitleDiv.style.top = StartY + "px";

        StartX = StartX + Width + 5;
    }

}

//속도개선
CChartBlock.prototype.ReadyRendering = function (DrawingInfo) {

    var i, length = this.m_GraphArray.length;
    for (i = 0; i < length; i++) {
        var rGraph = this.m_GraphArray[i];
        rGraph.ReadyRendering(DrawingInfo);
    }
}

CChartBlock.prototype.Draw = function (DrawingInfo) {

    if(this.m_bShow === false)
        return;

    DrawingInfo.m_rectGraphRegion.SetRect(this.m_rectGraphRegion.m_nLeft, this.m_rectGraphRegion.m_nTop, this.m_rectGraphRegion.m_nRight, this.m_rectGraphRegion.m_nBottom);
    DrawingInfo.m_rectGraphBackground.SetRect(this.m_rectGraphBackground.m_nLeft, this.m_rectGraphBackground.m_nTop, this.m_rectGraphBackground.m_nRight, this.m_rectGraphBackground.m_nBottom);
    
    DrawingInfo.m_Context.fillStyle = this.m_clrBack;
    DrawingInfo.m_Context.fillRect(this.m_rectGraphBackground.m_nLeft, this.m_rectGraphBackground.m_nTop, this.m_rectGraphBackground.Width(), this.m_rectGraphBackground.Height());
    
    var rGraph = null;
    var rSelectedGraph = this.GetSelectedGraph();
    if (rSelectedGraph === null && this.m_GraphArray.length > 0)
        rSelectedGraph = this.m_GraphArray[0];

    if (rSelectedGraph !== null && rSelectedGraph !== undefined) {

        rSelectedGraph.m_rYScale.Draw(DrawingInfo);
        
        rSelectedGraph.m_rYScale.DrawLastestData(DrawingInfo);//Y축 현재가 출력기능

        rSelectedGraph.m_rXScale.Draw(DrawingInfo);
    }

    /////////////////////////////////////////////////
    //graph draw
    var PriceGraphArray = [];
    var i, nLength = this.m_GraphArray.length;
    for (i = 0; i < nLength; i++) {

        rGraph = this.m_GraphArray[i];
        rGraph.Draw(DrawingInfo);
        if( rGraph.m_strName === "_PRICE_" )
            PriceGraphArray[PriceGraphArray.length] = rGraph;
    }

    // 20190115 전중현 : 기준선, 트레이딩라인 Draw
    DrawingInfo.m_Context.save();
    nLength = PriceGraphArray.length;
    for( i = 0; i < nLength; i++ )
    {
        rGraph = PriceGraphArray[i];
        var rGuideLineMng = rGraph.m_rRQSet.m_GuideLineMng;

        rGuideLineMng.m_rChartBlock = rGraph.m_rBlock;
        rGuideLineMng.Draw(DrawingInfo);

        var rTradingLineMng = this.m_rChart.m_TradingLineMng;
        rTradingLineMng.m_rChartBlock = rGraph.m_rBlock;
        rTradingLineMng.Draw(DrawingInfo, rGraph.m_rRQSet.m_RQInfo.m_strItemCode);

        //LKY SmartSignal 매수,목표가,손절가 라인 그리기 >>
        var rSmartSignalMng = this.m_rChart.m_mapSmartSignalMng[rGraph.m_rRQSet.m_RQInfo.m_strItemCode];
        if(rSmartSignalMng !== undefined && rSmartSignalMng.m_SmartSignalInfoArray.length > 0){
            rSmartSignalMng.m_rChartBlock = rGraph.m_rBlock;

            if(rSmartSignalMng.m_SmartSignalInfoArray[0].m_strSignalType === "0")
                rSmartSignalMng.Draw(DrawingInfo, rGraph.m_rRQSet.m_RQInfo.m_strItemCode);
        }
        //LKY SmartSignal 매수,목표가,손절가 라인 그리기 <<
    }
    DrawingInfo.m_Context.restore();

    DrawingInfo.m_Context.beginPath();
    DrawingInfo.m_Context.strokeStyle = this.m_XScaleArray.length > 0 ? this.m_XScaleArray[0].m_BottomXAxis.m_clrXAxis : this.m_rChart.GetColorByKey("XAxis");
    DrawingInfo.m_Context.lineWidth = 1;
    ////방법1
    var XAxisYPos = Math.floor(this.m_rectGraphBackground.m_nBottom) - 0.5;//0.5를 더하지 않고 빼주는 이유=> +0.5를 하면 다음 차트블록 영역칠하면서 지워버리기 때문
    DrawingInfo.m_Context.moveTo(Math.floor(this.m_rectGraphBackground.m_nLeft) + 0.5, XAxisYPos);
    DrawingInfo.m_Context.lineTo(Math.floor(this.m_rectGraphBackground.m_nRight-1) + 0.5, XAxisYPos);
    DrawingInfo.m_Context.stroke();
    DrawingInfo.m_Context.closePath();

    DrawingInfo.m_Context.strokeStyle = "#B7B7B7";
    DrawingInfo.m_Context.lineWidth = 1;
}

CChartBlock.prototype.DrawTool = function (DrawingInfo) {

    if(this.m_bShow === false)
        return;

    var nRightMargin = this.m_rGlobalProperty.GetRightMargin();

    DrawingInfo.m_rectGraphRegion.SetRect(this.m_rectGraphRegion.m_nLeft, this.m_rectGraphRegion.m_nTop, this.m_rectGraphRegion.m_nRight + nRightMargin, this.m_rectGraphRegion.m_nBottom);
    DrawingInfo.m_rectGraphBackground.SetRect(this.m_rectGraphBackground.m_nLeft, this.m_rectGraphBackground.m_nTop, this.m_rectGraphBackground.m_nRight, this.m_rectGraphBackground.m_nBottom);

    DrawingInfo.m_ScreenContext.save();

    DrawingInfo.m_ScreenContext.beginPath();
    DrawingInfo.m_ScreenContext.rect(DrawingInfo.m_rectGraphRegion.m_nLeft, DrawingInfo.m_rectGraphRegion.m_nTop, DrawingInfo.m_rectGraphRegion.Width(), DrawingInfo.m_rectGraphRegion.Height());
    DrawingInfo.m_ScreenContext.clip();

    DrawingInfo.m_ScreenContext.beginPath();
    DrawingInfo.m_ScreenContext.fillStyle = "#ffffff";
    this.m_ShowToolArray.length = 0;
    var i, nLength = this.m_ToolArray.length;
    for (i = 0; i < nLength; i++) {
        var rTool = this.m_ToolArray[i];
        rTool.Draw(DrawingInfo);
    }
    DrawingInfo.m_ScreenContext.restore();
}

CChartBlock.prototype.CalcYScaleWidth = function (DrawingInfo) {

    var rSelectedGraph = this.GetSelectedGraph();
    if (rSelectedGraph === null && this.m_GraphArray.length > 0) {
        rSelectedGraph = this.m_GraphArray[0];
    }

    if (rSelectedGraph !== undefined && rSelectedGraph !== null) {
        var rYScale = rSelectedGraph.GetYScale();
        return rYScale.CalcYScaleWidth(DrawingInfo);
    }
    return 0;
}
CChartBlock.prototype.GetXScalePacketNameArray = function (rXScalePacketNameArray) {

    var i, nCnt;
    nCnt = rXScalePacketNameArray.length;

    for (i = 0; i < this.m_XScaleArray.length; i++) {
        this.m_XScaleArray[i].GetXScalePacketNameArray(rXScalePacketNameArray);
    }
    if (nCnt < rXScalePacketNameArray.length)
        return true;

    return false;
}

CChartBlock.prototype.SetXScaleMng = function (strXScalePacketName, rXScaleMng) {

    var i;
    for (i = 0; i < this.m_XScaleArray.length; i++) {
        if (this.m_XScaleArray[i].GetXScalePacketName() == strXScalePacketName)
            this.m_XScaleArray[i].SetXScaleMng(rXScaleMng);
    }
}

CChartBlock.prototype.RemoveXScaleMng = function(strXScalePacketName){

    var i;
    for (i = 0; i < this.m_XScaleArray.length; i++) {
        if (this.m_XScaleArray[i].GetXScalePacketName() == strXScalePacketName)
        {
            this.m_XScaleArray[i].splice( i, 1);
            break;
        }
    }
}
/////////////////////////////////
function CMinMaxItem() {

    this.m_nStartPacketIndex = null;
    this.m_nEndPacketIndex = null;
    
    this.m_MinValue = null;
    this.m_MaxValue = null;

    //MinMaxItem의 영역 중간 index까지의 최대최소 추출하는 경우
    this.m_nPartStartPacketIndex = null;
    this.m_nPartEndPacketIndex = null;
    this.m_PartMin = null;
    this.m_PartMax = null;
    this.m_PrevPartMin = null;
    this.m_PrevPartMax = null;

    //실시간 업데이트시 기존 데이터를 제거하고 기존데이터 들어오기 전의 최대,최소값에서 지금 들어온 값을 고려하여 최대,최소를 구해야 한다
    this.m_PrevMin = null;
    this.m_PrevMax = null;


    //해당 item이 min,max 추려야 할 데이터갯수
    this.m_nItemMaxCount = 0;

}
CMinMaxItem.prototype.SetRangeIndex = function (nStartPacketIndex, nEndPacketIndex) {
    this.m_nStartPacketIndex = nStartIndex;
    this.m_nEndPacketIndex = nEndIndex;
}
CMinMaxItem.prototype.SetMinMaxValue = function (MinValue, MaxValue) {
    this.m_MinValue = MinValue;
    this.m_MaxValue = MaxValue;
}
CMinMaxItem.prototype.GetViewMinMaxInfo = function (bPrevMaxMin) {

    gMinMaxInfo.Init();
    var MinMaxInfo = gMinMaxInfo;

    if (!bPrevMaxMin) {

        MinMaxInfo.m_Max = (this.m_PartMax != null ? this.m_PartMax : this.m_MaxValue);
        MinMaxInfo.m_Min = (this.m_PartMin != null ? this.m_PartMin : this.m_MinValue);

    }
    else {

        MinMaxInfo.m_Max = (this.m_PartMax != null ? this.m_PrevPartMax : this.m_PrevMax);
        MinMaxInfo.m_Min = (this.m_PartMin != null ? this.m_PrevPartMin : this.m_PrevMin);
    }

    MinMaxInfo.m_nStartIndex = (this.m_nPartStartPacketIndex != null ? this.m_nPartStartPacketIndex : this.m_nStartPacketIndex);
    MinMaxInfo.m_nEndIndex = (this.m_nPartEndPacketIndex != null ? this.m_nPartEndPacketIndex : this.m_nEndPacketIndex);

    return MinMaxInfo;
}

/////////////////////////////////
function CMinMaxMng(rPacketData) {

    this.m_MinMaxItemArray = [];

    this.m_nViewStartArrayIndex = null;//this.m_nViewStartIndex가 포함되어 있는 배열순번 (0이 아닐 수 있다)
    this.m_nViewEndArrayIndex = null;//this.m_nViewEndIndex가 포함되어 있는 배열순번(length - 1이 아닐 수 있다)

    //보이는 영역에서의 최대,최소값
    this.m_ViewMaxValue = null;
    this.m_ViewMinValue = null;

    this.m_ViewPrevMax = null;//실시간 업데이트시 보이는 영역에서의 이전봉까지의 MinMax 정보(업데이트된 해당봉의 데이터와 해당변수값 비교)
    this.m_ViewPrevMin = null;//실시간 업데이트시 보이는 영역에서의 이전봉까지의 MinMax 정보(업데이트된 해당봉의 데이터와 해당변수값 비교)

    //실시간 업데이트시 이전봉까지의 MinMax 정보
    this.m_PrevMinValueOfFullRange = null;
    this.m_PrevMaxValueOfFullRange = null;

    //PacketData상에 전체데이터에 대한 최대,최소값
    this.m_MaxValueOfFullRange = null;
    this.m_MinValueOfFullRange = null;
    this.m_nMinMaxItemCnt = 0;

    this.m_rPacketData = rPacketData;
}

//전체데이터 갯수에 따라 최대,최소 블록당 데이터 묶음 갯수정리 함수
//(예: 전체500개이하 데이터인 경우 5개 데이터단위로 최대,최소 산정하여 최대,최소 블록하나 생성)=> 최대,최소 산정을 위한 검색 속도향상 처리
CMinMaxMng.prototype.CalcItemDataCnt = function (nTotalDataCnt) {

    if (nTotalDataCnt <= 500)
        return 5;
    else if (nTotalDataCnt <= 1000)
        return 10;
    else if (nTotalDataCnt <= 2000)
        return 20;
    else if (nTotalDataCnt <= 4000)
        return 40;
    else if (nTotalDataCnt <= 8000)
        return 80;
    else if (nTotalDataCnt <= 16000)
        return 160;
    else if (nTotalDataCnt <= 32000)
        return 320;
    else if (nTotalDataCnt <= 64000)
        return 640;
    else if (nTotalDataCnt <= 128000)
        return 1280;
    else if (nTotalDataCnt <= 256000)
        return 2560;
    else if (nTotalDataCnt <= 512000)
        return 5120;
    else
        return 10240;

}

//데이터 추가부르기 조회응답 처리직전에 호출되어야 한다
CMinMaxMng.prototype.IncreasePacketIndex = function (nAddDataCnt) {

    var length = this.m_MinMaxItemArray.length;
    for (var i = 0; i < length; i++) {
        var MinMaxItem = this.m_MinMaxItemArray[i];
        MinMaxItem.m_nStartPacketIndex += nAddDataCnt;
        MinMaxItem.m_nEndPacketIndex += nAddDataCnt;
    }

}
CMinMaxMng.prototype.GetStartPacketIndex = function () {
    return (this.m_MinMaxItemArray.length > 0 ? this.m_MinMaxItemArray[0].m_nStartPacketIndex : -1);
}
CMinMaxMng.prototype.GetEndPacketIndex = function () {
    return (this.m_MinMaxItemArray.length > 0 ? this.m_MinMaxItemArray[this.m_MinMaxItemArray.length - 1].m_nEndPacketIndex : -1);
}

CMinMaxMng.prototype.Init = function () {

    this.m_MinMaxItemArray.length = 0;
    this.m_nViewStartIndex = null;
    this.m_nViewEndIndex = null;

    this.m_ViewMaxValue = null;
    this.m_ViewMinValue = null;

    this.m_ViewPrevMax = null;//실시간 업데이트시 보이는 영역에서의 이전봉까지의 MinMax 정보(업데이트된 해당봉의 데이터와 해당변수값 비교)
    this.m_ViewPrevMin = null;//실시간 업데이트시 보이는 영역에서의 이전봉까지의 MinMax 정보(업데이트된 해당봉의 데이터와 해당변수값 비교)

    this.m_nMinMaxItemCnt = 0;
    this.m_nStartPacketIndex = null;
    this.m_nEndPacketIndex = null;

    this.m_nViewStartArrayIndex = null;//this.m_nViewStartIndex가 포함되어 있는 배열순번 (0이 아닐 수 있다)
    this.m_nViewEndArrayIndex = null;//this.m_nViewEndIndex가 포함되어 있는 배열순번(length - 1이 아닐 수 있다)

    //전체 영역에서의 최대,최소값
    this.m_MaxValueOfFullRange = null;
    this.m_MinValueOfFullRange = null;

    //업데이트 시에 직전위치에서 min,max 값을 얻어내기 위한 사용
    this.m_PrevMinValueOfFullRange = null;
    this.m_PrevMaxValueOfFullRagne = null;
}
CMinMaxMng.prototype.InitFullRangeMinMaxValue = function () {
    this.m_MaxValueOfFullRange = null;
    this.m_MaxValueOfFullRange = null;

    this.m_PrevMinValueOfFullRange = null;
    this.m_PrevMaxValueOfFullRagne = null;
}
CMinMaxMng.prototype.InitViewMinMaxValue = function () {
    this.m_ViewMaxValue = null;
    this.m_ViewMinValue = null;

    this.m_PrevMaxValue = null;
    this.m_PrevMinValue = null;
}
CMinMaxMng.prototype.RemoveMinMaxItemArray = function () {
    this.m_MinMaxItemArray.length = 0;
}

//리턴타입이 {Min:최소값, Max:최대값} 형태의 개체
CMinMaxMng.prototype.ReCalcFullRangeMinMax = function () {

    this.InitFullRangeMinMaxValue();
    var length = this.m_MinMaxItemArray.length;

    var MinMaxItem = this.m_MinMaxItemArray[0];
    this.m_MinValueOfFullRange = MinMaxItem.m_MinValue
    this.m_MaxValueOfFullRange = MinMaxItem.m_MaxValue;

    for (var i = 1; i < length; i++) {

        MinMaxItem = this.m_MinMaxItemArray[i];

        if (MinMaxItem.m_MinValue < this.m_MinValueOfFullRange)
            this.m_MinValueOfFullRange = MinMaxItem.m_MinValue;

        if (this.m_MaxValueOfFullRange < MinMaxItem.m_MaxValue)
            this.m_MaxValueOfFullRange = MinMaxItem.m_MaxValue;
    }

    return { Min: this.m_MinValueOfFullRange, Max: this.m_MaxValueOfFullRange };
}

//조회 데이터 추가시 호출
CMinMaxMng.prototype.AddHeadMinMaxItem = function (nPacketIndex, Value) {

    var nResult = 0;
    var MinMaxItem = null;
    if (this.m_MinMaxItemArray.length <= 0) {

        MinMaxItem = new CMinMaxItem();
        MinMaxItem.m_nItemMaxCount = this.m_nMinMaxItemCnt;
        this.m_MinMaxItemArray[0] = MinMaxItem;
    }
    else {

        MinMaxItem = this.m_MinMaxItemArray[0];//AddHead 함수에서 사용하므로 앞에 부분의 배열요소에 적용하기 위한 처리
        var nDataCnt = MinMaxItem.m_nEndPacketIndex - MinMaxItem.m_nStartPacketIndex + 1;
        if (MinMaxItem.m_nItemMaxCount <= nDataCnt) {

            MinMaxItem = new CMinMaxItem();
            MinMaxItem.m_nItemMaxCount = this.m_nMinMaxItemCnt;
            this.m_MinMaxItemArray.unshift(MinMaxItem);
        }
    }

    if (MinMaxItem.m_nStartPacketIndex == null || MinMaxItem.m_nEndPacketIndex == null) {
        MinMaxItem.m_nStartPacketIndex = MinMaxItem.m_nEndPacketIndex = nPacketIndex;
        MinMaxItem.m_MaxValue = MinMaxItem.m_MinValue = Value;
        nResult |= 0x0300;
    }
    else {

        MinMaxItem.m_nStartPacketIndex = nPacketIndex;//AddHead 함수에서 사용하므로 StartIndex가 이동하도록 처리

        MinMaxItem.m_PrevMax = MinMaxItem.m_MaxValue;//실시간 업데이트 경우에 MinMax 처리 속도를 높이기 위한 전처리작업
        MinMaxItem.m_PrevMin = MinMaxItem.m_MinValue;//실시간 업데이트 경우에 MinMax 처리 속도를 높이기 위한 전처리작업

        if (MinMaxItem.m_MaxValue < Value) {
            MinMaxItem.m_MaxValue = Value;
            nResult |= 0x0100;
        }
        else if (Value < MinMaxItem.m_MinValue) {
            MinMaxItem.m_MinValue = Value;
            nResult |= 0x0200;
        }
    }

    //전체영역에서 최대,최소값 구하는 처리
    this.m_PrevMaxValueOfFullRange = this.m_MaxValueOfFullRange;//실시간 업데이트 경우에 MinMax 처리 속도를 높이기 위한 전처리작업
    this.m_PrevMinValueOfFullRange = this.m_MinValueOfFullRange;//실시간 업데이트 경우에 MinMax 처리 속도를 높이기 위한 전처리작업

    if (this.m_MaxValueOfFullRange == null || this.m_MaxValueOfFullRange < MinMaxItem.m_MaxValue) {
        this.m_MaxValueOfFullRange = MinMaxItem.m_MaxValue;
        nResult |= 0x0004;
    }
    if (this.m_MinValueOfFullRange == null || MinMaxItem.m_MinValue < this.m_MinValueOfFullRange) {
        this.m_MinValueOfFullRange = MinMaxItem.m_MinValue;
        nResult |= 0x0008;
    }
    return nResult;
}

//조회 데이터 추가시 호출
CMinMaxMng.prototype.AddTailMinMaxItem = function (nPacketIndex, Value) {

    var nResult = 0;
    var MinMaxItem = null;

    var rXScaleMng = null;

    //최초 등록
    if (this.m_MinMaxItemArray.length <= 0) {
        MinMaxItem = new CMinMaxItem();
        MinMaxItem.m_nItemMaxCount = this.m_nMinMaxItemCnt;
        this.m_MinMaxItemArray[0] = MinMaxItem;
    }
    else {

        //MinMaxItem 추가여부 판단
        MinMaxItem = this.m_MinMaxItemArray[this.m_MinMaxItemArray.length - 1];
        var nDataCnt = MinMaxItem.m_nEndPacketIndex - MinMaxItem.m_nStartPacketIndex + 1;
        //정해놓은 갯수(m_nItemMaxCount)보다 데이터개수가 많을 경우 새로운 아이템 추가
        if (MinMaxItem.m_nItemMaxCount <= nDataCnt) {

            MinMaxItem = new CMinMaxItem();
            MinMaxItem.m_nItemMaxCount = this.m_nMinMaxItemCnt;
            this.m_MinMaxItemArray[this.m_MinMaxItemArray.length] = MinMaxItem;
        }
    }

    if (MinMaxItem.m_nStartPacketIndex == null || MinMaxItem.m_nEndPacketIndex == null) {
        MinMaxItem.m_nStartPacketIndex = MinMaxItem.m_nEndPacketIndex = nPacketIndex;
        MinMaxItem.m_MaxValue = MinMaxItem.m_MinValue = Value;
        nResult |= 0x0300;
    }
    else {

        MinMaxItem.m_nEndPacketIndex = nPacketIndex;

        MinMaxItem.m_PrevMax = MinMaxItem.m_MaxValue;
        MinMaxItem.m_PrevMin = MinMaxItem.m_MinValue;

        if (MinMaxItem.m_MaxValue < Value) {
            MinMaxItem.m_MaxValue = Value;
            nResult |= 0x0100;
        }
        else if (Value < MinMaxItem.m_MinValue) {
            MinMaxItem.m_MinValue = Value;
            nResult |= 0x0200;
        }
    }


    this.m_PrevMaxValueOfFullRange = this.m_MaxValueOfFullRange;
    this.m_PrevMinValueOfFullRange = this.m_MinValueOfFullRange;

    if (this.m_MaxValueOfFullRange == null || this.m_MaxValueOfFullRange < MinMaxItem.m_MaxValue) {
        this.m_MaxValueOfFullRange = MinMaxItem.m_MaxValue;
        nResult = nResult | 0x0004;
    }
    if (this.m_MinValueOfFullRange == null || MinMaxItem.m_MinValue < this.m_MinValueOfFullRange) {
        this.m_MinValueOfFullRange = MinMaxItem.m_MinValue;
        nResult = nResult | 0x0008;
    }
    return nResult;
}

//실시간 데이터 추가시 호출
CMinMaxMng.prototype.AppendRealDataMinMaxItem = function (nPacketIndex, Value) {

    var nResult = 0;
    var MinMaxItem = null;

    var rXScaleMng = null;

    //최초 등록
    if (this.m_MinMaxItemArray.length <= 0) {
        MinMaxItem = new CMinMaxItem();
        MinMaxItem.m_nItemMaxCount = this.CalcItemDataCnt(this.m_rPacketData.GetDataArraySize());
        this.m_MinMaxItemArray[0] = MinMaxItem;
    }
    else {

        //MinMaxItem 추가여부 판단
        MinMaxItem = this.m_MinMaxItemArray[this.m_MinMaxItemArray.length - 1];
        var nDataCnt = MinMaxItem.m_nEndPacketIndex - MinMaxItem.m_nStartPacketIndex + 1;
        //정해놓은 갯수(m_nItemMaxCount)보다 데이터개수가 많을 경우 새로운 아이템 추가
        if (MinMaxItem.m_nItemMaxCount <= nDataCnt) {

            MinMaxItem = new CMinMaxItem();
            MinMaxItem.m_nItemMaxCount = this.CalcItemDataCnt(this.m_rPacketData.GetDataArraySize());
            this.m_MinMaxItemArray[this.m_MinMaxItemArray.length] = MinMaxItem;
        }
    }

    if (MinMaxItem.m_nStartPacketIndex == null || MinMaxItem.m_nEndPacketIndex == null) {
        MinMaxItem.m_nStartPacketIndex = MinMaxItem.m_nEndPacketIndex = nPacketIndex;
        MinMaxItem.m_MaxValue = MinMaxItem.m_MinValue = Value;
        nResult |= 0x0300;
    }
    else {

        MinMaxItem.m_nEndPacketIndex = nPacketIndex;

        MinMaxItem.m_PrevMax = MinMaxItem.m_MaxValue;
        MinMaxItem.m_PrevMin = MinMaxItem.m_MinValue;

        if (MinMaxItem.m_MaxValue < Value) {
            MinMaxItem.m_MaxValue = Value;
            nResult |= 0x0100;
        }
        else if (Value < MinMaxItem.m_MinValue) {
            MinMaxItem.m_MinValue = Value;
            nResult |= 0x0200;
        }
    }

    this.m_PrevMaxValueOfFullRange = this.m_MaxValueOfFullRange;
    this.m_PrevMinValueOfFullRange = this.m_MinValueOfFullRange;

    if (this.m_MaxValueOfFullRange == null || this.m_MaxValueOfFullRange < MinMaxItem.m_MaxValue) {
        this.m_MaxValueOfFullRange = MinMaxItem.m_MaxValue;
        nResult = nResult | 0x0004;
    }
    if (this.m_MinValueOfFullRange == null || MinMaxItem.m_MinValue < this.m_MinValueOfFullRange) {
        this.m_MinValueOfFullRange = MinMaxItem.m_MinValue;
        nResult = nResult | 0x0008;
    }

    return nResult;
}

//주로 실시간 데이터 업데이트시 호출
CMinMaxMng.prototype.UpdateMinMaxItem = function (nPacketIndex, Value) {

    var MinMaxItem = null;
    if (this.m_MinMaxItemArray.length <= 0)
        return 0;

    var nResult = 0;
    var i, nLength = this.m_MinMaxItemArray.length;
    for (i = nLength - 1; i >= 0; i--) {
        MinMaxItem = this.m_MinMaxItemArray[i];

        if (MinMaxItem.m_nStartPacketIndex <= nPacketIndex && nPacketIndex <= MinMaxItem.m_nEndPacketIndex) {

            //console.log("[CMinMaxMng.UpdateMinMaxItem 전](Value:" + Value + ")=> PrevMax:" + MinMaxItem.m_PrevMax + ", PrevMin: " + MinMaxItem.m_PrevMin + ", MaxValue: " + MinMaxItem.m_MaxValue + ", MinValue: " + MinMaxItem.m_MinValue);

            var bLastDataUpdate = false;
            var rPacketData = this.m_rPacketData;
            var nDataIndex = nPacketIndex - rPacketData.m_nRQStartIndex;
            
            //가장 최근 마지막 위치 데이터의 업데이트인 경우(대부분의 차트 실시간 케이스)
            //데이터배열의 처음부분이나 중간부분의 데이터가 변경되는 경우는 처리하지 않는다!!!
            if (rPacketData.m_DataArray.length - 1 == nDataIndex) {
                ///////////////////////////////////////////
                //MinMaxItem의 영역내에서 최대최소값 구하기
                var OldMaxValue = MinMaxItem.m_MaxValue;
                var OldMinValue = MinMaxItem.m_MinValue;

                //이전봉까지의 Max와 비교해서 Update
                if (MinMaxItem.m_PrevMax == null || MinMaxItem.m_PrevMax < Value)
                    MinMaxItem.m_MaxValue = Value;
                else
                    MinMaxItem.m_MaxValue = MinMaxItem.m_PrevMax;


                //이전봉까지의 Min과 비교해서 Update
                if (MinMaxItem.m_PrevMin == null || Value < MinMaxItem.m_PrevMin)
                    MinMaxItem.m_MinValue = Value;
                else
                    MinMaxItem.m_MinValue = MinMaxItem.m_PrevMin;

                //바로 전 최대최소값과 달라졌을 때 플래그값 셋팅
                //if (OldMaxValue != MinMaxItem.m_MaxValue)
                //    nResult |= 0x0100;

                //if(OldMinValue != MinMaxItem.m_MinValue)
                //    nResult |= 0x0200;


                //////////////////////////////////////////
                //View 영역 끝이 범위 마지막 부분과 동일할 때
                if (nPacketIndex <= MinMaxItem.m_nPartEndPacketIndex) {
                    if (MinMaxItem.m_PrevPartMax == null || MinMaxItem.m_PrevPartMax < Value)
                        MinMaxItem.m_PartMax = Value;
                    else
                        MinMaxItem.m_PartMax = MinMaxItem.m_PrevPartMax;

                    if (MinMaxItem.m_PrevPartMin == null || Value < MinMaxItem.m_PrevPartMin)
                        MinMaxItem.m_PartMin = Value;
                    else
                        MinMaxItem.m_PartMin = MinMaxItem.m_PrevPartMin;
                }

                /////////////////////////////////////////////////
                //전체 영역에 대한 최대최소값 셋팅
                var OldMaxValueOfFullRange = this.m_MaxValueOfFullRange;
                var OldMinValueOfFullRange = this.m_MinValueOfFullRange;

                if (this.m_PrevMaxValueOfFullRange == null || this.m_PrevMaxValueOfFullRange < Value)
                    this.m_MaxValueOfFullRange = Value;
                else
                    this.m_MaxValueOfFullRange = this.m_PrevMaxValueOfFullRange;


                if (this.m_PrevMinValueOfFullRange == null || Value < this.m_PrevMinValueOfFullRange)
                    this.m_MinValueOfFullRange = Value;
                else
                    this.m_MinValueOfFullRange = this.m_PrevMinValueOfFullRange;


                //if (OldMaxValueOfFullRange != this.m_MaxValueOfFullRange)
                //    nResult = nResult | 0x0004;

                //if (OldMinValueOfFullRange != this.m_MinValueOfFullRange)
                //    nResult = nResult | 0x0008;

                //console.log("[CMinMaxMng.UpdateMinMaxItem 마지막데이터 업데이트 경우 후](Value:" + Value + ")=> PrevMax:" + MinMaxItem.m_PrevMax + ", PrevMin: " + MinMaxItem.m_PrevMin + ", MaxValue: " + MinMaxItem.m_MaxValue + ", MinValue: " + MinMaxItem.m_MinValue);

                bLastDataUpdate = true;
            }
            else
                return 0;


            if ( (this.m_nViewEndArrayIndex === i && bLastDataUpdate === true) &&
                ((nPacketIndex === MinMaxItem.m_nEndPacketIndex && MinMaxItem.m_nPartEndPacketIndex === null) ||//보이는 영역의 마지막 MinMaxItem Index와 업데이트되는 MinMaxItem의 Index가 일치하고 가장 최근 마지막 데이터를 업데이트 하는 경우(최근데이터의 실시간 들어오는 것을 보고 있는 경우->가장 일반적인 경우)
                  (nPacketIndex === MinMaxItem.m_nPartEndPacketIndex) ) ) //해당 MinMaxItem의 PacketIndex 범위 중간에 보이는 영역이 끝나는 경우
            {
                var OldViewMaxValue = this.m_ViewMaxValue;
                var OldViewMinValue = this.m_ViewMinValue;

                if (this.m_ViewPrevMax == null || this.m_ViewPrevMax < Value)
                    this.m_ViewMaxValue = Value;
                else
                    this.m_ViewMaxValue = this.m_ViewPrevMax;

                if (this.m_ViewPrevMin == null || Value < this.m_ViewPrevMin)
                    this.m_ViewMinValue = Value;
                else
                    this.m_ViewMinValue = this.m_ViewPrevMin;

                if (OldViewMaxValue != this.m_ViewMaxValue)
                    nResult |= 0x0001;

                if (OldViewMinValue != this.m_ViewMinValue)
                    nResult |= 0x0002;
            }
            break;
        }
    }

    return nResult;
}

CMinMaxMng.prototype.GetFullRangeMinMax = function () {
    return { Min: this.m_MinValueOfFullRange, Max: this.m_MaxValueOfFullRange };
}
CMinMaxMng.prototype.GetViewMinMax = function () {
    return { Min: this.m_ViewMinValue, Max: this.m_ViewMaxValue };
}
CMinMaxMng.prototype.SetViewRangeIndex = function (nViewStartIndex, nViewEndIndex) {
    this.m_nViewStartIndex = nViewStartIndex;
    this.m_nViewEndIndex = nViewEndIndex;
}

///////////////////////////////
function CPacketInfo() {
    this.m_strPacketName = "";
    this.m_nPacketType = 0;//1:숫자(NUMERIC_TYPE), 2:날짜시간(DATETIME_TYPE), 3:문자(STRING_TYPE)
    this.m_strPacketSubType = "1";//숫자나 날짜시간 타입일 경우 사용(숫자(진법표현, 1, 0.1 등),날짜시간(YYYYMMDDHHmmSS, YYYYMMDD 등)
    this.m_nPacketDataLen = 0;//패킷데이터 길이
}
////////////////////////////////
function CPacketStartIndex() {
    this.m_nStartIndex = 0;
}

///////////////////////////////
//CCalcPacketData
function CPacketCalculator(rRQSet, strCalcPacketName, strInputPacketNameArray, nDec, Unit, nDigit) {

    this.m_rRQSet = rRQSet;
    this.m_strPacketName = strCalcPacketName;//"HL2, HLC3 등"

    this.m_strInputPacketNameArray = [];
    this.m_InputPacketDataArray = [];
    var i, nLength = strInputPacketNameArray.length;
    for (i = 0; i < nLength; i++) {
        this.m_strInputPacketNameArray[i] = strInputPacketNameArray[i];
        this.m_InputPacketDataArray[i] = this.m_rRQSet.GetPacketData(this.m_strInputPacketNameArray[i]);
    }

    this.m_rRQSet.AddNumPacketInfo(this.m_strPacketName, -1, CALC_PACKET_USE_TYPE, nDec, Unit, nDigit);
    this.m_rOutputPacketData = this.m_rRQSet.GetPacketData(this.m_strPacketName);
}
CPacketCalculator.prototype.SetInputPackets = function (strInputPacketNameArray) {

    this.m_strInputPacketNameArray.length = 0;
    this.m_InputPacketDataArray.length = 0;

    var i, nLength = strInputPacketNameArray.length;
    for (i = 0; i < nLength; i++) {
        this.m_strInputPacketNameArray[i] = strInputPacketNameArray[i];
        this.m_InputPacketDataArray[i] = this.m_rRQSet.GetPacketData(this.m_strInputPacketNameArray[i]);
    }
}

//연속조회 처리를 위해서 nCalcLength 파라미터 전달 받도록 처리
CPacketCalculator.prototype.Calc = function (nCalcLength) {

    var i, j, k;

    var nLength = this.m_InputPacketDataArray.length;
    if (nLength > 0) {

        var nInputDataLength = this.m_InputPacketDataArray[0].GetDataArraySize();
        if (!nCalcLength)
            nCalcLength = nInputDataLength;
        else
            nCalcLength = (nCalcLength > nInputDataLength ? nInputDataLength : nCalcLength);

        for (i = nCalcLength - 1; i >= 0; i--) {

            var Sum = 0, Result = 0;
            for (j = 0; j < nLength; j++)
                Sum += this.m_InputPacketDataArray[j].m_DataArray[i].m_Data;

            Result = Sum / nLength;

            //일반조회시 처리와 연속조회 처리를 모두 같은 코드로 처리키 위해 AddHead 사용하고 뒤부터(nCalcLength) 계산해서 저장한다
            //this.m_rOutputPacketData.AddTail(i, Result);
            this.m_rOutputPacketData.AddHead(i, Result);
        }
    }
    else
        return false;

    return true;
}

//bAddData : true(봉이 추가되는 상황), false(마지막 봉이 업데이트 되는 상황)
CPacketCalculator.prototype.RealCalc = function (bAddData) {

    var i, j, k;

    var nLength = this.m_InputPacketDataArray.length;
    if (nLength > 0) {

        var nInputDataLength = this.m_InputPacketDataArray[0].GetDataArraySize();
        var nEndIndex = nInputDataLength - 1;
        var Sum = 0, Result = 0;
        for (i = 0; i < nLength; i++)
            Sum += this.m_InputPacketDataArray[i].m_DataArray[nEndIndex].m_Data;

        Result = Sum / nLength;

        var nOutputDataLength = this.m_rOutputPacketData.GetDataArraySize();
        if (nOutputDataLength == nInputDataLength)
            this.m_rOutputPacketData.UpdateData(nOutputDataLength-1, Result);
        else if (nOutputDataLength < nInputDataLength)
            this.m_rOutputPacketData.AppendRealData(nOutputDataLength, Result);

        return true;
    }
    else
        return false;
}

///////////////////////////////
function CPacketData(strPacketName) {

    this.m_nPacketIndex = null;//RQPacketsItem에서 배열로 패킷을 얻어오기 위해 index 저장

    this.m_strPacketName = strPacketName;
    this.m_nPacketType = 0;//1:숫자(NUMERIC_TYPE), 2:날짜시간(DATETIME_TYPE), 3:문자(STRING_TYPE)
    this.m_strPacketSubType = "1";//날짜시간 이나 문자 타입일 경우 사용(날짜시간(YYYYMMDDHHmmSS, YYYYMMDD 등))
    this.m_nPacketDataLen = 0;

    //NUMERIC_TYPE인 경우 의미
    this.m_nDec = 10;//진법변수(기본 10진법)
    this.m_Unit = null;//표현단위 (데이터의 최소 간격 예:호가단위 , 해당값이 null이면 nDigit를 참고하여 최소간격계산 된다 -2이면 0.01로 최소간격 계산)
    this.m_nDigit = null;//표현자리수(예:-2=> 1.234를 1.23으로 표현)

    this.m_rRQSet = null;
    this.m_DataArray = [];
    //this.m_ViewMaxValue = null;
    //this.m_ViewMinValue = null;
    this.m_nViewStartIndex = null;
    this.m_nViewEndIndex = null;
    this.m_rXScalePacketData = null;
    this.m_nPacketUseType = 0x01; //0x01(inputPacket), 0x02(CalcPacket:_HL2_, _HLC3_ 등), 0x04(IndicatorPacket:지표계산결과)
    this.m_MinMaxMng = new CMinMaxMng(this);

    this.m_PacketStartIndexObjArray = [];//CPacketItemData 자신이 m_DataArray에서 몇번째 요소인지 알아낼 때 참조하는 개체의 배열
    this.m_rCurPacketStartIndexObj = null;

    this.m_SubGraphArray = [];//패킷데이터 실시간 변경시 최대,최소값이 업데이트될 때 업데이트된 그래프의 y축을 빠르게 찾아가기 위해 필요
}

CPacketData.prototype.IsLikePacketName = function(strPacketName){

    var nFindPos = this.m_strPacketName.indexOf('_');
    if(nFindPos < 0)
        return false;
    if(this.m_strPacketName.substring(nFindPos) === strPacketName)
        return true;
    return false;
}

CPacketData.prototype.SetUpdateMinMax = function (bUpdateMinMax) {

    var i, nSubGraphLength = this.m_SubGraphArray.length;
    for (i = 0; i < nSubGraphLength; i++) {

        var rSubGraph = this.m_SubGraphArray[i];
        rSubGraph.SetUpdateMinMax(bUpdateMinMax);
    }
}
CPacketData.prototype.DeleteSubGraph = function (rDeleteSubGraph) {

    var i, nSubGraphLength = this.m_SubGraphArray.length;
    for (i = 0; i < nSubGraphLength; i++) {

        var rSubGraph = this.m_SubGraphArray[i];
        if (rSubGraph == rDeleteSubGraph) {

            this.m_SubGraphArray.splice(i, 1);
            return true;
        }
    }
    return false;
}
CPacketData.prototype.AddSubGraph = function (rAddSubGraph) {

    var i, nSubGraphLength = this.m_SubGraphArray.length;
    for (i = 0; i < nSubGraphLength; i++) {

        var rSubGraph = this.m_SubGraphArray[i];
        if (rSubGraph == rAddSubGraph) {

            return false;//이미 존재
        }
    }
    this.m_SubGraphArray[this.m_SubGraphArray.length] = rAddSubGraph;
    return true;
}

CPacketData.prototype.SetPacketUseType = function (nPacketUseType) {
    this.m_nPacketUseType = nPacketUseType;
}

CPacketData.prototype.GetPacketUseType = function () {
    return this.m_nPacketUseType;
}

CPacketData.prototype.SetXScalePacketData = function (rXScalePacketData) {
    this.m_rXScalePacketData = rXScalePacketData;
}

//m_DataArray에 저장되어있는 PacketItemData 자신의 index를 알아내는 루틴에 사용되는 함수
CPacketData.prototype.AppendPacketStartIndexObj = function (nTotalCnt) {//이 함수는 데이터 추가부르기 조회응답 처리시 호출되어야 한다(데이터가 head쪽으로 추가되면서 index가 변경되므로)

    var i, length = this.m_PacketStartIndexObjArray.length;

    for (i = 0; i < length; i++) {
        this.m_PacketStartIndexObjArray[i].m_nStartIndex += nTotalCnt;
    }

    this.m_PacketStartIndexObjArray[length] = new CPacketStartIndex();
}
CPacketData.prototype.GetPacketName = function () {
    return this.m_strPacketName;
}
CPacketData.prototype.RemoveAllData = function () {
    this.m_DataArray.length = 0;
    this.m_MinMaxMng.Init();
    this.m_PacketStartIndexObjArray.length = 0;
    this.m_rCurPacketStartIndexObj = null;
}
CPacketData.prototype.GetPacketType = function () {
    return this.m_nPacketType;
}
CPacketData.prototype.GetPacketSubType = function () {
    return this.m_strPacketSubType;
}
CPacketData.prototype.GetCycle = function () {
    if (!this.m_rRQSet)
        return 0;
    return this.m_rRQSet.GetCycle();
}
CPacketData.prototype.GetInterval = function () {
    if (!this.m_rRQSet)
        return 0;
    return this.m_rRQSet.GetInterval();
}
CPacketData.prototype.GetMarketStartTime = function () {
    if (!this.m_rRQSet)
        return 0;
    return this.m_rRQSet.GetMarketStartTime();
}
CPacketData.prototype.GetMarketEndTime = function () {
    if (!this.m_rRQSet)
        return 0;
    return this.m_rRQSet.GetMarketEndTime();
}
CPacketData.prototype.SetRQSet = function (rRQSet) {
    this.m_rRQSet = rRQSet;
}
CPacketData.prototype.GetRQSet = function () {
    return this.m_rRQSet;
}

CPacketData.prototype.AddTail = function (nIndex, data) {

}
CPacketData.prototype.AddHead = function (nIndex, data) {

}

CPacketData.prototype.UpdateData = function (nIndex, data) {
    return 0;
}
CPacketData.prototype.UpdateSumData = function (nIndex, data) {
}
CPacketData.prototype.GetData = function (index) {
    return this.m_DataArray[index];
}
CPacketData.prototype.GetLastestPacketItemData = function () {
    return this.m_DataArray.length > 0 ? this.m_DataArray[this.m_DataArray.length - 1] : null;
}
CPacketData.prototype.GetDataArray = function () {
    return this.m_DataArray;
}
CPacketData.prototype.GetDataArraySize = function () {
    return this.m_DataArray.length;
}
CPacketData.prototype.Calc = function () {
    return this.m_DataArray.length;
}
CPacketData.prototype.SetDataFormat = function (nDec, Unit, nDigit) {

    this.m_nDec = nDec;
    this.m_Unit = Unit;
    this.m_nDigit = nDigit;
}
CPacketData.prototype.InitDataArray = function () {
    this.m_DataArray.length = 0;

}

/////////////////////////
function CDateTimePacketData(strPacketName) {
    CPacketData.call(this, strPacketName);
}
CDateTimePacketData.prototype = new CPacketData();
CDateTimePacketData.prototype.constructor = CDateTimePacketData;

//조회용으로만 사용
CDateTimePacketData.prototype.AddTail = function (nIndex, strDateTime, strDateTimeType, bAppendHHMMSS, nCycle) {

    var Data = new CDateTimeData(nIndex, this);
    Data.SetPacketStartIndexObj(this.m_PacketStartIndexObjArray[0]);

    if (strDateTimeType == "YYYYMMDD" && bAppendHHMMSS) {
        strDateTime = strDateTime + this.GetMarketStartTime();
        strDateTimeType += "HHMMSS";
    }
    Data.SetDateTime(strDateTime, strDateTimeType, nCycle);
    this.m_DataArray[this.m_DataArray.length] = Data;
}
CDateTimePacketData.prototype.AppendRealDateTimeT = function (tDateTime, strDateTimeType, bAppendHHMMSS, nCycle) {

    var nIndex = 0;
    if (this.m_DataArray.length > 0)
        nIndex = this.m_DataArray[this.m_DataArray.length - 1].GetIndex() + 1;

    var Data = new CDateTimeData(nIndex, this);
    Data.SetPacketStartIndexObj(this.m_PacketStartIndexObjArray[0]);

    if (strDateTimeType == "YYYYMMDD" && bAppendHHMMSS)
        strDateTimeType += "HHMMSS";

    Data.SetDateTimeByDateTimeT(tDateTime, strDateTimeType, nCycle);
    this.m_DataArray[this.m_DataArray.length] = Data;
}
CDateTimePacketData.prototype.AddHead = function (nIndex, strDateTime, strDateTimeType, bAppendHHMMSS, nCycle) {
    var Data = new CDateTimeData(nIndex, this);
    Data.SetPacketStartIndexObj(this.m_PacketStartIndexObjArray[this.m_PacketStartIndexObjArray.length - 1]);

    if (strDateTimeType == "YYYYMMDD" && bAppendHHMMSS) {
        strDateTime = strDateTime + this.GetMarketStartTime();
        strDateTimeType += "HHMMSS";
    }
    Data.SetDateTime(strDateTime, strDateTimeType, nCycle);
    this.m_DataArray.unshift(Data);
}

///////////////////////////////////
function CNumericPacketData(strPacketName) {
    CPacketData.call(this, strPacketName);
    this.m_nRQStartIndex = null;//rq의 기본 패킷(시가,고가,저가,종가, 시간 등) 기준으로 데이터의 시작위치(필요한 경우:5일이평(=>m_nRQStartIndex = 4(5-1)) 등)
}
CNumericPacketData.prototype = new CPacketData();
CNumericPacketData.prototype.constructor = CNumericPacketData;

CNumericPacketData.prototype.InitDataArray = function () {

    CPacketData.prototype.InitDataArray.call(this);
    this.m_nRQStartIndex = null;
}

CNumericPacketData.prototype.SetRQStartIndex = function (nRQStartIndex) {
    this.m_nRQStartIndex = nRQStartIndex;
}
CNumericPacketData.prototype.GetRQStartIndex = function () {
    return this.m_nRQStartIndex;
}
CNumericPacketData.prototype.CalcMinMaxItemCnt = function (nReceiveDataCnt, bAppend) {

    var nSumCnt = nReceiveDataCnt;
    if (bAppend == true)
        nSumCnt += this.m_DataArray.length;
    else
        this.m_MinMaxMng.Init();

    var i;
    var nNewMinMaxItemCnt = this.m_MinMaxMng.CalcItemDataCnt(nSumCnt);

    if (bAppend == true) {

        //데이터가 추가되는 경우 MinMaxItemArray size가 변경되므로 배열index 값이 변경되므로 저장할 필요없으므로 null로 초기화시킨다
        this.m_MinMaxMng.m_nViewStartArrayIndex = null;
        this.m_MinMaxMng.m_nViewEndArrayIndex = null;

        var Ratio = Math.floor(nNewMinMaxItemCnt / this.m_MinMaxMng.m_nMinMaxItemCnt);
        if (Ratio > 1)//Ratio갯수만큼씩 머지
        {
            var bFindPartStart = false;
            var bFindPartEnd = false;
            var RatioIndex = Ratio - 1;
            var NewMinMaxItemArray = [];
            var fMin = null, fMax = null;
            var nStartPacketIndex = null, nEndPacketIndex = null;
            var fStartPartMin = null, fStartPartMax = null;
            var fTempStartPartMin = null, fTempStartPartMax = null;
            var fEndPartMin = null, fEndPartMax = null;
            var fTempEndPartMin = null, fTempEndPartMax = null;
            var nCount = 0, length = this.m_MinMaxMng.m_MinMaxItemArray.length;

            this.m_MinMaxMng.m_nMinMaxItemCnt = nNewMinMaxItemCnt;

            for (i = 0; i < length; i++) {

                var MinMaxItem = this.m_MinMaxMng.m_MinMaxItemArray[i];

                if (nCount == 0) {
                    fMax = MinMaxItem.m_MaxValue;
                    fMin = MinMaxItem.m_MinValue;

                    nStartPacketIndex = MinMaxItem.m_nStartPacketIndex;
                    nEndPacketIndex = MinMaxItem.m_nEndPacketIndex;

                    if (MinMaxItem.m_nPartStartPacketIndex != null) {
                        fStartPartMin = MinMaxItem.m_PartMin;
                        fStartPartMax = MinMaxItem.m_PartMax;

                        bFindPartStart = true;
                    }

                    if (bFindPartStart) {

                        if (MinMaxItem.m_nPartEndPacketIndex == null) {
                            fTempEndPartMin = MinMaxItem.m_MinValue;
                            fTempEndPartMax = MinMaxItem.m_MaxValue;
                        }
                        else {
                            fEndPartMin = MinMaxItem.m_PartMin;
                            fEndPartMax = MinMaxItem.m_PartMax;

                            fTempEndPartMin = null;
                            fTempEndPartMax = null;

                            bFindPartEnd = true;
                        }
                    }
                }
                else {
                    if (fMax < MinMaxItem.m_MaxValue)
                        fMax = MinMaxItem.m_MaxValue;
                    if (MinMaxItem.m_MinValue < fMin)
                        fMin = MinMaxItem.m_MinValue;

                    nEndPacketIndex = MinMaxItem.m_nEndPacketIndex;

                    if (MinMaxItem.m_nPartStartPacketIndex != null && MinMaxItem.m_nPartEndPacketIndex != null) {
                        fStartPartMax = MinMaxItem.m_PartMax;
                        fStartPartMin = MinMaxItem.m_PartMin;
                        fEndPartMin = MinMaxItem.m_PartMin;
                        fEndPartMax = MinMaxItem.m_PartMax;

                        fTempStartPartMax = null;
                        fTempStartPartMin = null;
                        fTempEndPartMax = null;
                        fTempEndPartMin = null;

                        bFindPartStart = true;
                        bFindPartEnd = true;
                    }
                    else {
                        if (MinMaxItem.m_nPartStartPacketIndex != null) {
                            fStartPartMin = MinMaxItem.m_PartMin;
                            fStartPartMax = MinMaxItem.m_PartMax;

                            bFindPartStart = true;
                        }
                        else {
                            if (bFindPartStart == true && bFindPartEnd == false) {
                                if (fStartPartMax != null && fStartPartMax < MinMaxItem.m_MaxValue)
                                    fStartPartMax = MinMaxItem.m_MaxValue;
                                if (fStartPartMin != null && MinMaxItem.m_MinValue < fStartPartMin)
                                    fStartPartMin = MinMaxItem.m_MinValue;
                            }
                        }

                        if (bFindPartStart == true && bFindPartEnd == false) {
                            if (MinMaxItem.m_nPartEndPacketIndex == null) {
                                if (fTempEndPartMin != null && MinMaxItem.m_MinValue < fTempEndPartMin)
                                    fTempEndPartMin = MinMaxItem.m_MinValue;
                                if (fTempEndPartMax != null && fTempEndPartMax < MinMaxItem.m_MaxValue)
                                    fTempEndPartMax = MinMaxItem.m_MaxValue;
                            }
                            else {
                                if (MinMaxItem.m_PartMin < fTempEndPartMin)
                                    fEndPartMin = MinMaxItem.m_PartMin;
                                else
                                    fEndPartMin = fTempEndPartMin;

                                if (fTempEndPartMax < MinMaxItem.m_PartMax)
                                    fEndPartMax = MinMaxItem.m_PartMax;
                                else
                                    fEndPartMax = fTempEndPartMax;

                                fTempEndPartMin = null;
                                fTempEndPartMax = null;

                                bFindPartEnd = true;
                            }
                        }
                    }
                }

                if (nCount == RatioIndex) {

                    var NewMinMaxItem = new CMinMaxItem();
                    NewMinMaxItem.m_MaxValue = fMax;
                    NewMinMaxItem.m_MinValue = fMin;

                    NewMinMaxItem.m_nStartPacketIndex = nStartPacketIndex;
                    NewMinMaxItem.m_nEndPacketIndex = nEndPacketIndex;

                    NewMinMaxItem.m_nItemMaxCount = (NewMinMaxItem.m_nEndPacketIndex - NewMinMaxItem.m_nStartPacketIndex + 1);

                    NewMinMaxItemArray[NewMinMaxItemArray.length] = NewMinMaxItem;

                    if (fStartPartMax != null)
                        NewMinMaxItem.m_PartMax = fStartPartMax;
                    if (fStartPartMin != null)
                        NewMinMaxItem.m_PartMin = fStartPartMin;

                    if (fEndPartMax != null)
                        NewMinMaxItem.m_PartMax = fEndPartMax;
                    if (fEndPartMin != null)
                        NewMinMaxItem.m_PartMin = fEndPartMin;

                    nCount = 0;
                    fMax = null;
                    fMin = null;
                    nStartPacketIndex = null;
                    nEndPacketIndex = null;
                    fStartPartMax = fStartPartMin = null;
                    fEndPartMax = fEndPartMin = null;
                    fTempEndPartMax = fTempEndPartMin = null;
                }
                else
                    nCount++;
            }

            if (nCount > 0) {
                var NewMinMaxItem = new CMinMaxItem();
                NewMinMaxItem.m_MaxValue = fMax;
                NewMinMaxItem.m_MinValue = fMin;

                NewMinMaxItem.m_nStartPacketIndex = nStartPacketIndex;
                NewMinMaxItem.m_nEndPacketIndex = nEndPacketIndex;

                NewMinMaxItem.m_nItemMaxCount = nNewMinMaxItemCnt;

                NewMinMaxItemArray[NewMinMaxItemArray.length] = NewMinMaxItem;

                if (fStartPartMax != null)
                    NewMinMaxItem.m_PartMax = fStartPartMax;
                if (fStartPartMin != null)
                    NewMinMaxItem.m_PartMin = fStartPartMin;

                if (fEndPartMax != null)
                    NewMinMaxItem.m_PartMax = fEndPartMax;
                if (fEndPartMin != null)
                    NewMinMaxItem.m_PartMin = fEndPartMin;

                nCount = 0;
                fMax = null;
                fMin = null;
                fStartPartMax = fStartPartMin = null;
                fEndPartMax = fEndPartMin = null;
                fTempEndPartMax = fTempEndPartMin = null;
            }

            this.m_MinMaxMng.m_MinMaxItemArray.length = 0;
            this.m_MinMaxMng.m_MinMaxItemArray = NewMinMaxItemArray;
        }

        //데이터를 추가로 받은 만큼 index들을 shift 시킨다
        var length = this.m_MinMaxMng.m_MinMaxItemArray.length;
        for (i = 0; i < length; i++) {
            var MinMaxItem = this.m_MinMaxMng.m_MinMaxItemArray[i];

            MinMaxItem.m_nStartPacketIndex += nReceiveDataCnt;
            MinMaxItem.m_nEndPacketIndex += nReceiveDataCnt;

            if (MinMaxItem.m_nPartStartPacketIndex != null)
                MinMaxItem.m_nPartStartPacketIndex += nReceiveDataCnt;
            if (MinMaxItem.m_nPartEndPacketIndex != null)
                MinMaxItem.m_nPartEndPacketIndex += nReceiveDataCnt;
        }
    }
    else {
        this.m_MinMaxMng.m_nMinMaxItemCnt = nNewMinMaxItemCnt;
    }
}
CNumericPacketData.prototype.AppendRealData = function (nIndex, data) {

    //var nIndex = 0;
    //if (this.m_DataArray.length > 0) {
    //    var rPacketItemData = this.m_DataArray[this.m_DataArray.length - 1];
    //    nIndex = rPacketItemData.GetIndex() + 1;//중요!!
    //}
    var NewItemData = new CNumericItemData(nIndex - this.m_PacketStartIndexObjArray[0].m_nStartIndex, data, this);
    NewItemData.SetPacketStartIndexObj(this.m_PacketStartIndexObjArray[0]);

    this.m_DataArray[this.m_DataArray.length] = NewItemData;

    var nPacketIndex = NewItemData.GetPacketIndex();
    var nResult = this.m_MinMaxMng.AppendRealDataMinMaxItem(nPacketIndex, data);
    if (nResult > 0)
        this.SetUpdateMinMax(true);

    return nResult;
}

//조회용으로만 사용(실시간은 AppendRealData사용)
CNumericPacketData.prototype.AddTail = function (nIndex, data) {
    var ItemData = new CNumericItemData(nIndex, data, this);

        ItemData.SetPacketStartIndexObj(this.m_PacketStartIndexObjArray[0]);

    this.m_DataArray[this.m_DataArray.length] = ItemData;

    var nPacketIndex = ItemData.GetPacketIndex();
    this.m_MinMaxMng.AddTailMinMaxItem(nPacketIndex, data);
}

//주로 연속 조회용으로 사용(실시간은 AppendRealData사용)
CNumericPacketData.prototype.AddHead = function (nIndex, data) {
    var ItemData = new CNumericItemData(nIndex, data, this);
    ItemData.SetPacketStartIndexObj(this.m_PacketStartIndexObjArray[this.m_PacketStartIndexObjArray.length - 1]);

    this.m_DataArray.unshift(ItemData);

    var nPacketIndex = ItemData.GetPacketIndex();
    this.m_MinMaxMng.AddHeadMinMaxItem(nPacketIndex, data);
}
CNumericPacketData.prototype.UpdateData = function (nIndex, data) {

    var NumItemData = this.m_DataArray[nIndex - this.m_nRQStartIndex];
    NumItemData.m_Data = data;

    var nPacketIndex = NumItemData.GetPacketIndex();
    var nResult = this.m_MinMaxMng.UpdateMinMaxItem(nPacketIndex, data);
    if (nResult > 0)
        this.SetUpdateMinMax(true);

    return nResult;
}
CNumericPacketData.prototype.UpdateSumData = function (nIndex, data) {

    var NumItemData = this.m_DataArray[nIndex];
    NumItemData.m_Data += data;

    var nPacketIndex = NumItemData.GetPacketIndex();
    var nResult = this.m_MinMaxMng.UpdateMinMaxItem(nPacketIndex, NumItemData.m_Data);
    if (nResult > 0)
        this.SetUpdateMinMax(true);

    return nResult;
}
CNumericPacketData.prototype.InitMinMaxMng = function () {
    this.m_MinMaxMng.Init();
}

//중요 함수(최대,최소값 추출시 속도를 높이는 로직포함)
CNumericPacketData.prototype.ExtractMinMaxValue = function (rXScaleMng, rXScalePacketData, nViewStartIndex, nViewEndIndex) {

    var i;
    var PrevStartMinMaxItem = null;
    var PrevEndMinMaxItem = null;

    //기존에 MinMaxMng에 저장되어 있던 보이는 범위 중 가장 앞에 부분에 대한 정보 및 보이는 범위의 최대,최소값 정보 초기화
    //(보이는 영역의 시작부분이 MinMaxItem 영역의 중간부분에서 시작할 수 있기 때문에 시작부분에 대한 실제범위와 그 범위에 맞춰 MinMaxItem의 최소,최대값 산정 후 저장된 내용)
    //(예: 보이는 영역의 첫 MinMaxItem의 범위가 0번째~100번째이며 그 범위에서 최대값(500),최소값(50)인경우 실제 보이는 영역의 시작이 50번째부터 시작한다면 50번째~100번째 까지의 최소,최대값을 산정해서,
    //범위는 m_nPartStartPacketIndex, m_nPartEndPacketIndex 저장하고 , 최대,최소값은 m_PartMin, m_PartMax 저장한다. 또한 MinMaxMng의 m_nViewStartArrayIndex는 m_MinMaxItemArray의 첫번째 보이는 MinMaxItem의 배열index이다)
    if (this.m_MinMaxMng.m_nViewStartArrayIndex != null) {
        PrevStartMinMaxItem = this.m_MinMaxMng.m_MinMaxItemArray[this.m_MinMaxMng.m_nViewStartArrayIndex];

        PrevStartMinMaxItem.m_nPartStartPacketIndex = null;
        PrevStartMinMaxItem.m_nPartEndPacketIndex = null;
        PrevStartMinMaxItem.m_PartMin = null;
        PrevStartMinMaxItem.m_PartMax = null;
        PrevStartMinMaxItem.m_PrevPartMin = null;
        PrevStartMinMaxItem.m_PrevPartMax = null;
        this.m_MinMaxMng.m_nViewStartArrayIndex = null;
    }

    //기존에 MinMaxMng에 저장되어 있던 보이는 범위 중 가장 뒤에 부분에 대한 정보 및 보이는 범위의 최대,최소값 정보 초기화
    //(보이는 영역의 끝부분이 보이는 영역 마지막 MinMaxItem 영역의 중간부분에서 끝날 수 있기 때문에 끝부분에 대한 실제범위와 그 범위에 맞춰 MinMaxItem의 최소,최대값 산정 후 저장된 내용)
    //(예: 보이는 영역의 마지막 MinMaxItem의 범위가 1100번째~1200번째이며 그 범위에서 최대(1000),최소(500)인경우 실제 보이는 영역의 끝이 1150번째에서 끝났다면 1100번째~1150번째 까지의 최소,최대값을 산정해서,
    //범위는 m_nPartStartPacketIndex, m_nPartEndPacketIndex에 저장하고 , 최대,최소값은 m_PartMin, m_PartMax 저장한다. 또한 MinMaxMng의 m_nViewEndArrayIndex는 m_MinMaxItemArray의 마지막 보이는 MinMaxItem의 배열index이다)
    if (this.m_MinMaxMng.m_nViewEndArrayIndex != null) {
        PrevEndMinMaxItem = this.m_MinMaxMng.m_MinMaxItemArray[this.m_MinMaxMng.m_nViewEndArrayIndex];

        PrevEndMinMaxItem.m_nPartStartPacketIndex = null;
        PrevEndMinMaxItem.m_nPartEndPacketIndex = null;
        PrevEndMinMaxItem.m_PartMin = null;
        PrevEndMinMaxItem.m_PartMax = null;
        PrevEndMinMaxItem.m_PrevPartMin = null;
        PrevEndMinMaxItem.m_PrevPartMax = null;
        this.m_MinMaxMng.m_nViewEndArrayIndex = null;
    }

    //x축 패킷이 시간날짜 타입인 경우만 해당
    if (rXScalePacketData.GetPacketType() == DATETIME_TYPE) {

        var tViewStartTime = rXScaleMng.GetDateTimeTByIndex(nViewStartIndex);
        var tViewEndTime = rXScaleMng.GetDateTimeTByIndex(nViewEndIndex);

        var nCycle = rXScalePacketData.m_rRQSet.m_RQInfo.m_nCycle;
        var nInterval = rXScalePacketData.m_rRQSet.m_RQInfo.m_nInterval;

        //검증
        gTempStartDate.setTime(tViewStartTime * 1000);
        gTempEndDate.setTime(tViewEndTime * 1000);

        ///////////////////////////////////////////////////////////////////////
        //최소최대값 추출을 위한 구간별 값등록처리
        var nMinMaxItemCnt = 0;
        var nDataCnt = nViewEndIndex - nViewStartIndex + 1;

        var nPacketStartIndex = null, nPacketEndIndex = null;
        var nMinMaxItemArrayStartIndex = null, nMinMaxItemArrayEndIndex = null;

        var length = this.m_MinMaxMng.m_MinMaxItemArray.length;

        for (i = 0; i < length; i++) {

            var MinMaxItem = this.m_MinMaxMng.m_MinMaxItemArray[i];

            var rStartDateTimeData = rXScalePacketData.GetData(MinMaxItem.m_nStartPacketIndex);
            var rEndDateTimeData = rXScalePacketData.GetData(MinMaxItem.m_nEndPacketIndex);

            //rEndDateTimeData 봉의 시작시간 rEndDateTimeData.m_tDateTime과 주기,간격을 이용하여 끝나는 시간 계산
            var tEndDateTime = CalcDateTimeT(rEndDateTimeData.m_tDateTime, nCycle, nInterval);

            if (tViewStartTime < tEndDateTime) {

                nMinMaxItemArrayStartIndex = i;

                if (tViewStartTime == rStartDateTimeData.m_tDateTime)
                    nPacketStartIndex = MinMaxItem.m_nStartPacketIndex;

                break;
            }
        }

        if (nMinMaxItemArrayStartIndex != null) {
            for (i = nMinMaxItemArrayStartIndex; i < length; i++) {

                var MinMaxItem = this.m_MinMaxMng.m_MinMaxItemArray[i];
                var rStartDateTimeData = rXScalePacketData.GetData(MinMaxItem.m_nStartPacketIndex);
                var rEndDateTimeData = rXScalePacketData.GetData(MinMaxItem.m_nEndPacketIndex);

                //rEndDateTimeData 봉의 시작시간 rEndDateTimeData.m_tDateTime과 주기,간격을 이용하여 끝나는 시간 계산
                var tEndDateTime = CalcDateTimeT(rEndDateTimeData.m_tDateTime, nCycle, nInterval);

                if (tViewEndTime < tEndDateTime) {

                    nMinMaxItemArrayEndIndex = i;

                    if (tViewEndTime == rEndDateTimeData.m_tDateTime)
                        nPacketEndIndex = MinMaxItem.m_nEndPacketIndex;
                    else if (i == 0 && tViewEndTime < rStartDateTimeData.m_tDateTime) {
                        nMinMaxItemArrayStartIndex = null;
                        nMinMaxItemArrayEndIndex = null;
                    }
                    break;
                }
            }

            if (i >= length) {
                nMinMaxItemArrayEndIndex = length - 1;
            }
        }

        if (nMinMaxItemArrayStartIndex == null || nMinMaxItemArrayEndIndex == null) {

            this.m_MinMaxMng.m_nViewStartArrayIndex = null;
            this.m_MinMaxMng.m_nViewEndArrayIndex = null;

            this.m_MinMaxMng.m_ViewMinValue = null;
            this.m_MinMaxMng.m_ViewMaxValue = null;

            this.m_MinMaxMng.m_ViewPrevMin = null;
            this.m_MinMaxMng.m_ViewPrevMax = null;

            //this.m_ViewMaxValue = null;
            //this.m_ViewMinValue = null;
        }
        //보이는 영역의 시작 Packet Index와 마지막Packet Index가 모두 하나의 MinMaxItem 영역안에 포함되어 있는 경우
        //(nMinMaxItemArrayStartIndex, nMinMaxItemArrayEndIndex이 MinMaxMng의 MinMaxItemArray의 index 의미 함)
        else if (nMinMaxItemArrayStartIndex == nMinMaxItemArrayEndIndex) {

            var fMin = null, fMax = null;
            var fPrevMin = null, fPrevMax = null;

            var rMinMaxItem = this.m_MinMaxMng.m_MinMaxItemArray[nMinMaxItemArrayStartIndex];

            for (i = rMinMaxItem.m_nStartPacketIndex; i <= rMinMaxItem.m_nEndPacketIndex; i++) {

                if (tViewStartTime <= rXScalePacketData.m_DataArray[i].m_tDateTime) {

                    rMinMaxItem.m_nPartStartPacketIndex = i;
                    break;
                }
            }

            for (; i <= rMinMaxItem.m_nEndPacketIndex; i++) {

                if (tViewEndTime < rXScalePacketData.m_DataArray[i].m_tDateTime) {
                    rMinMaxItem.m_nPartEndPacketIndex = i - 1;
                    break;
                }

                var Data = this.m_DataArray[i - this.m_nRQStartIndex].m_Data;

                fPrevMin = fMin;
                fPrevMax = fMax;

                if (fMax == null || fMax < Data)
                    fMax = Data;

                if (fMin == null || Data < fMin)
                    fMin = Data;
            }

            rMinMaxItem.m_PartMax = fMax;
            rMinMaxItem.m_PartMin = fMin;

            rMinMaxItem.m_PrevPartMax = fPrevMax;
            rMinMaxItem.m_PrevPartMin = fPrevMin;

            this.m_MinMaxMng.m_nViewStartArrayIndex = nMinMaxItemArrayStartIndex;
            this.m_MinMaxMng.m_nViewEndArrayIndex = nMinMaxItemArrayEndIndex;
        }
        else {//nMinMaxItemArrayStartIndex != nMinMaxItemArrayEndIndex 경우

            var rStartMinMaxItem = this.m_MinMaxMng.m_MinMaxItemArray[nMinMaxItemArrayStartIndex];
            var rEndMinMaxItem = this.m_MinMaxMng.m_MinMaxItemArray[nMinMaxItemArrayEndIndex];

            var fMin = null, fMax = null;

            if (nPacketStartIndex == null) {//MinMaxItem 범위의 중간에 View범위가 시작하는 경우

                for (var i = rStartMinMaxItem.m_nEndPacketIndex; i >= rStartMinMaxItem.m_nStartPacketIndex; i--) {

                    var Data = this.m_DataArray[i - this.m_nRQStartIndex].m_Data;
                    var rXScaleItemData = rXScalePacketData.m_DataArray[i];

                    if (rXScaleItemData.m_tDateTime < tViewStartTime) {

                        var tEndTime = CalcDateTimeT(rXScaleItemData.m_tDateTime, nCycle, nInterval);

                        if (tViewStartTime < tEndTime) {
                            if (fMax == null || fMax < Data)
                                fMax = Data;
                            if (fMin == null || Data < fMin)
                                fMin = Data;

                            rStartMinMaxItem.m_nPartStartPacketIndex = i;
                        }

                        break;
                    }
                    else {
                        if (fMax == null || fMax < Data)
                            fMax = Data;

                        if (fMin == null || Data < fMin)
                            fMin = Data;

                        rStartMinMaxItem.m_nPartStartPacketIndex = i;
                    }
                }

                if (i < rStartMinMaxItem.m_nStartPacketIndex)
                    rStartMinMaxItem.m_nPartStartPacketIndex = null;

            }
            else {//rStartMinMaxItem 시작 경계부분에서 View범위가 시작하는 경우

                fMax = rStartMinMaxItem.m_MaxValue;
                fMin = rStartMinMaxItem.m_MinValue;
            }

            rStartMinMaxItem.m_PartMax = fMax;
            rStartMinMaxItem.m_PartMin = fMin;
            rStartMinMaxItem.m_nPartEndPacketIndex = null;

            fMin = fMax = null;
            var fPrevMin = null, fPrevMax = null;

            if (nPacketEndIndex == null) {//MinMaxItem 범위의 중간에 View범위가 끝나는 경우

                for (i = rEndMinMaxItem.m_nStartPacketIndex; i <= rEndMinMaxItem.m_nEndPacketIndex; i++) {

                    var Data = this.m_DataArray[i - this.m_nRQStartIndex].m_Data;
                    var rXScaleItemData = rXScalePacketData.m_DataArray[i];

                    fPrevMin = fMin;
                    fPrevMax = fMax;

                    if (tViewEndTime < rXScaleItemData.m_tDateTime) {

                        //if (fMax == null || fMax < Data)
                        //    fMax = Data;
                        //if (fMin == null || Data < fMin)
                        //    fMin = Data;
                        //rEndMinMaxItem.m_nPartEndPacketIndex = i;

                        break;
                    }
                    else {
                        if (fMax == null || fMax < Data)
                            fMax = Data;

                        if (fMin == null || Data < fMin)
                            fMin = Data;

                        rEndMinMaxItem.m_nPartEndPacketIndex = i;
                    }
                }
            }
            else {//rEndMinMaxItem 끝 경계부분에서 View범위가 끝나는 경우

                fMax = rEndMinMaxItem.m_MaxValue;
                fMin = rEndMinMaxItem.m_MinValue;

                fPrevMax = rEndMinMaxItem.m_PrevMax;
                fPrevMin = rEndMinMaxItem.m_PrevMin;
            }

            rEndMinMaxItem.m_PartMax = fMax;
            rEndMinMaxItem.m_PartMin = fMin;

            rEndMinMaxItem.m_PrevPartMax = fPrevMax;
            rEndMinMaxItem.m_PrevPartMin = fPrevMin;

            rEndMinMaxItem.m_nPartStartPacketIndex = null;
        }

        fMin = fMax = null;
        fPrevMin = fPrevMax = null;

        if (nMinMaxItemArrayStartIndex != null && nMinMaxItemArrayEndIndex != null) {

            for (i = nMinMaxItemArrayStartIndex; i < nMinMaxItemArrayEndIndex; i++) {

                var rMinMaxItem = this.m_MinMaxMng.m_MinMaxItemArray[i];

                var MinMaxInfo = rMinMaxItem.GetViewMinMaxInfo(false);

                if (fMax == null || fMax < MinMaxInfo.m_Max)
                    fMax = MinMaxInfo.m_Max;
                if (fMin == null || MinMaxInfo.m_Min < fMin)
                    fMin = MinMaxInfo.m_Min;
            }


            fPrevMin = fMin;
            fPrevMax = fMax;

            ///////////////////////////////////////////////////////////////////////////
            var rMinMaxItem = this.m_MinMaxMng.m_MinMaxItemArray[nMinMaxItemArrayEndIndex];

            var MinMaxInfo = rMinMaxItem.GetViewMinMaxInfo(false);

            if (fMax == null || fMax < MinMaxInfo.m_Max)
                fMax = MinMaxInfo.m_Max;
            if (fMin == null || MinMaxInfo.m_Min < fMin)
                fMin = MinMaxInfo.m_Min;
            
            ///////////////////////////////////////////////////////////////////////////

            var PrevMinMaxInfo = rMinMaxItem.GetViewMinMaxInfo(true);

            if (PrevMinMaxInfo.m_Max != null && (fPrevMax == null || fPrevMax < PrevMinMaxInfo.m_Max))
                fPrevMax = PrevMinMaxInfo.m_Max;
            if (PrevMinMaxInfo.m_Min != null && (fPrevMin == null || PrevMinMaxInfo.m_Min < fPrevMin))
                fPrevMin = PrevMinMaxInfo.m_Min;
        }

        this.m_MinMaxMng.m_nViewStartIndex = nViewStartIndex;
        this.m_MinMaxMng.m_nViewEndIndex = nViewEndIndex;
        this.m_MinMaxMng.m_nViewStartArrayIndex = nMinMaxItemArrayStartIndex;
        this.m_MinMaxMng.m_nViewEndArrayIndex = nMinMaxItemArrayEndIndex;

        this.m_MinMaxMng.m_ViewMinValue = fMin;
        this.m_MinMaxMng.m_ViewMaxValue = fMax;

        this.m_MinMaxMng.m_ViewPrevMin = fPrevMin;
        this.m_MinMaxMng.m_ViewPrevMax = fPrevMax;

    }    
    else if(rXScalePacketData.GetPacketName() === "_HOGA_"){

        var i;
        var dMax = this.m_DataArray[nViewStartIndex].m_Data;
        var dMin = dMax;

        for(i = nViewStartIndex + 1 ; i <= nViewEndIndex; i++ )
        {
            var dData = this.m_DataArray[i].m_Data;

            if(dMax < dData)
                dMax = dData;
            if(dMin > dData)
                dMin = dData;
        }

        this.m_MinMaxMng.m_nViewStartIndex = nViewStartIndex;
        this.m_MinMaxMng.m_nViewEndIndex = nViewEndIndex;
        this.m_MinMaxMng.m_nViewStartArrayIndex = null;
        this.m_MinMaxMng.m_nViewEndArrayIndex = null;

        this.m_MinMaxMng.m_ViewMinValue = dMin;
        this.m_MinMaxMng.m_ViewMaxValue = dMax;

        this.m_MinMaxMng.m_ViewPrevMin = null;
        this.m_MinMaxMng.m_ViewPrevMax = null;
    }

    return true;
}

/////////////////////////
function CStringPacketData(strPacketName) {
    CPacketData.call(this, strPacketName);
}
CStringPacketData.prototype = new CPacketData();
CStringPacketData.prototype.constructor = CStringPacketData;

//조회용으로만 사용(실시간 추가함수 필요하면 추후 AppendRealData함수 제작)
CStringPacketData.prototype.AddTail = function (nIndex, data) {
    var ItemData = new CStringItemData(nIndex, data, this);
	
	ItemData.SetPacketStartIndexObj(this.m_PacketStartIndexObjArray[this.m_PacketStartIndexObjArray.length - 1]);//연속조회를 위한 처리

    this.m_DataArray[this.m_DataArray.length] = ItemData;
}
CStringPacketData.prototype.AddHead = function (nIndex, data) {
    var ItemData = new CStringItemData(nIndex, data, this);
	//연속조회 처리를 위해 변경 >>
	/*
    ItemData.SetPacketStartIndexObj(this.m_PacketStartIndexObjArray.length - 1);
	*/
	ItemData.SetPacketStartIndexObj(this.m_PacketStartIndexObjArray[this.m_PacketStartIndexObjArray.length - 1]);
	//연속조회 처리를 위해 변경	<<

    this.m_DataArray.unshift(ItemData);
}

/////////////////////////
function CPacketItemData(rPacketData) {
    this.m_rPacketData = rPacketData;
    this.m_Data = null;
    this.m_nIndex = null;
    this.m_rPacketStartIndexObj = null;
}
CPacketItemData.prototype.GetPacketType = function () {
    return this.m_rPacketData.m_nPacketType;
}
CPacketItemData.prototype.SetPacketStartIndexObj = function (rPacketStartIndexObj) {
    this.m_rPacketStartIndexObj = rPacketStartIndexObj;
}
CPacketItemData.prototype.SetIndex = function (nIndex) {
    this.m_nIndex = nIndex;
}
CPacketItemData.prototype.GetIndex = function () {
	return this.m_nIndex;
}
CPacketItemData.prototype.GetPacketIndex = function () {
    return (this.m_rPacketStartIndexObj.m_nStartIndex + this.m_nIndex);
}
//////////////////////////
function CNumericItemData(nIndex, NumericData, rPacketData) {
    CPacketItemData.call(this, rPacketData);
    this.m_Data = NumericData;
    this.SetIndex(nIndex);

    this.m_SignalItemData = null;
}
CNumericItemData.prototype = new CPacketItemData();
CNumericItemData.prototype.constructor = CNumericItemData;

// nIndex : 0, PacketData가 없음, 1: PakcetData 있음 nSignalIndex 0: 매수, 1 : 매도
export function CSignalItemData() {
    this.m_BuyArray = [];
    this.m_SellArray = [];
}

CSignalItemData.prototype.AddSignalInfo = function (nBuyOrSell, rSignalInfo){

    if(nBuyOrSell === 0){
        this.m_BuyArray[this.m_BuyArray.length] = rSignalInfo;
    }
    else{
        this.m_SellArray[this.m_SellArray.length] = rSignalInfo;
    }

}

CSignalItemData.prototype.GetSignalType = function (){
    
    var nSignalType = 0;
    
    if(this.m_BuyArray.length > 0)
        nSignalType |= 0x01;
    
    if(this.m_SellArray.length > 0)
        nSignalType |= 0x02;

    return nSignalType;
}

/////////////////////////
function CStringItemData(nIndex, StringData, rPacketData) {
    CPacketItemData.call(this.rPacketData);
    this.m_Data = StringData;
    this.SetIndex(nIndex);
}
CStringItemData.prototype = new CPacketItemData();
CStringItemData.prototype.constructor = CStringItemData;

/////////////////////////
function CDateTimeData(nIndex, rPacketData) {

    CPacketItemData.call(this, rPacketData);
    this.SetIndex(nIndex);

    this.m_tDateTime = 0;
    this.m_nYear = 0;
    this.m_nMonth = 0;
    this.m_nDay = 0;
    this.m_nHour = 0;
    this.m_nMin = 0;
    this.m_nSecond = 0;
    this.m_nDate = null;//요일(0:주일, 1:월, 2:화, 3:수, 4:목, 5:금, 6:토);
    this.m_strDateTimeType = "";
    this.m_DateTime = null;
    this.m_strDateTime = "";

    this.m_rRQPacketsItem = null;//해당 시간에 rq 패킷데이터 레퍼런스(CDateTimeXScaleMng의 m_tTimeArray에 저장되어 있는 RQPacketsItem의 레퍼런스)

    //머지과정에서 해당날짜가 시작되는 XScaleItem블록 index 잠시 저장해놓고 다음 XScaleItem으로 이동할 때 사용되는 저장 변수(머징시에만 필요)
    this.m_tStartTime4Merge = null;
    this.m_nCycle4Merge = null;
    this.m_nInterval4Merge = null;
}
CDateTimeData.prototype = new CPacketItemData();
CDateTimeData.prototype.constructor = CDateTimeData;

CDateTimeData.prototype.SetDateTime = function (strDateTime, strDateTimeType, nCycle) {

    this.m_strDateTimeType = strDateTimeType;

    if (strDateTimeType == "YYYYMM") {
        this.m_nYear = parseInt(strDateTime.slice(0, 4));
        this.m_nMonth = parseInt(strDateTime.slice(4, 6)) - 1;
        this.m_nDay = 1;
        this.m_nHour = 0;
        this.m_nMin = 0;
        this.m_nSecond = 0;
    }
    else if (strDateTimeType == "YYYYMMDD") {
        this.m_nYear = parseInt(strDateTime.slice(0, 4));
        this.m_nMonth = parseInt(strDateTime.slice(4, 6)) - 1;
        this.m_nDay = parseInt(strDateTime.slice(6));
        this.m_nHour = 0;
        this.m_nMin = 0;
        this.m_nSecond = 0;
    }
    else if (strDateTimeType == "YYYYMMDDHHMMSS") {
        this.m_nYear = parseInt(strDateTime.slice(0, 4));
        this.m_nMonth = parseInt(strDateTime.slice(4, 6)) - 1;
        this.m_nDay = parseInt(strDateTime.slice(6, 8));
        this.m_nHour = parseInt(strDateTime.slice(8, 10));
        this.m_nMin = parseInt(strDateTime.slice(10, 12));
        this.m_nSecond = parseInt(strDateTime.slice(12, 14));
    }
    else {
        return -1;
    }

    if (nCycle == 3)//월주기인 경우 일자를 모두 1일자로 맞춘다
        this.m_nDay = 1;

    this.m_DateTime = new Date(this.m_nYear, this.m_nMonth, this.m_nDay, this.m_nHour, this.m_nMin, this.m_nSecond);
    if (nCycle == 2) {
        this.m_DateTime.setDate(this.m_nDay - this.m_DateTime.getDay() + 1);

        this.m_nYear = this.m_DateTime.getFullYear();
        this.m_nMonth = this.m_DateTime.getMonth();
        this.m_nDay = this.m_DateTime.getDate();
        this.m_nHour = this.m_DateTime.getHours();
        this.m_nMin = this.m_DateTime.getMinutes();
        this.m_nSecond = this.m_DateTime.getSeconds();
    }

    var tDateTime = this.m_DateTime.getTime();
    this.m_tDateTime = tDateTime / 1000;

    if (nCycle == 2 || nCycle == 3) {
        if (strDateTimeType == "YYYYMMDDHHMMSS") {
            this.m_strDateTime = "" + this.m_nYear + (this.m_nMonth >= 9 ? (this.m_nMonth + 1) : "0" + (this.m_nMonth + 1)) + (this.m_nDay >= 10 ? this.m_nDay : "0" + this.m_nDay)
                + (this.m_nHour >= 10 ? this.m_nHour : "0" + this.m_nHour) + (this.m_nMin >= 10 ? this.m_nMin : "0" + this.m_nMin) + (this.m_nSecond >= 10 ? this.m_nSecond : "0" + this.m_nSecond);
        }
        else if (strDateTimeType == "YYYYMMDD") {
            this.m_strDateTime = "" + this.m_nYear + (this.m_nMonth >= 9 ? (this.m_nMonth + 1) : "0" + (this.m_nMonth + 1)) + (this.m_nDay >= 10 ? this.m_nDay : "0" + this.m_nDay);
        }
        else if (strDateTimeType == "YYYYMM") {
            this.m_strDateTime = "" + this.m_nYear + (this.m_nMonth >= 9 ? (this.m_nMonth + 1) : "0" + (this.m_nMonth + 1));
        }
    }
    else
        this.m_strDateTime = strDateTime;

    return this.m_tDateTime;
}
CDateTimeData.prototype.SetDateTimeByDateTimeT = function (tDateTime, strDateTimeType, nCycle) {

    this.m_strDateTimeType = strDateTimeType;

    this.m_DateTime = new Date();
    this.m_DateTime.setTime(tDateTime * 1000);
    if (nCycle == 2) {
        var nDate = this.m_DateTime.getDate() - this.m_DateTime.getDay() + 1;
        this.m_DateTime.setDate(nDate);
    }
    else if (nCycle == 3) {
        this.m_DateTime.setDate(1);
    }

    if (strDateTimeType == "YYYYMM") {

        this.m_nYear = this.m_DateTime.getFullYear();
        this.m_nMonth = this.m_DateTime.getMonth();
        this.m_nDay = 1;
        this.m_nHour = 0;
        this.m_nMin = 0;
        this.m_nSecond = 0;
        this.m_DateTime.setHours(this.m_nHour);
        this.m_DateTime.setMinutes(this.m_nMin);
        this.m_DateTime.setSeconds(this.m_nSecond);

        this.m_tDateTime = this.m_DateTime.getTime() / 1000;
        this.m_strDateTime = "" + this.nYear + (this.m_nMonth >= 9 ? (this.m_nMonth + 1) : "0" + (this.m_nMonth + 1));
    }
    else if (strDateTimeType == "YYYYMMDD") {

        this.m_nYear = this.m_DateTime.getFullYear();
        this.m_nMonth = this.m_DateTime.getMonth();
        this.m_nDay = this.m_DateTime.getDate();
        this.m_nHour = 0;
        this.m_nMin = 0;
        this.m_nSecond = 0;
        this.m_DateTime.setHours(this.m_nHour);
        this.m_DateTime.setMinutes(this.m_nMin);
        this.m_DateTime.setSeconds(this.m_nSecond);

        this.m_tDateTime = this.m_DateTime.getTime() / 1000;
        this.m_strDateTime = "" + this.nYear + (this.m_nMonth >= 9 ? (this.m_nMonth + 1) : "0" + (this.m_nMonth + 1)) + (this.m_nDay >= 10 ? this.m_nDay : ("0" + this.m_nDay));
    }
    else if (strDateTimeType == "YYYYMMDDHHMMSS") {

        this.m_nYear = this.m_DateTime.getFullYear();
        this.m_nMonth = this.m_DateTime.getMonth();
        this.m_nDay = this.m_DateTime.getDate();
        this.m_nHour = this.m_DateTime.getHours();
        this.m_nMin = this.m_DateTime.getMinutes();
        this.m_nSecond = this.m_DateTime.getSeconds();

        this.m_tDateTime = tDateTime;
        this.m_strDateTime = "" + this.m_nYear + (this.m_nMonth >= 9 ? (this.m_nMonth + 1) : ("0" + (this.m_nMonth + 1))) + (this.m_nDay >= 10 ? this.m_nDay : ("0" + this.m_nDay)) +
            (this.m_nHour >= 10 ? this.m_nHour : ("0" + this.m_nHour)) + (this.m_nMin >= 10 ? this.m_nMin : ("0" + this.m_nMin)) + (this.m_nSecond >= 10 ? this.m_nSecond : ("0" + this.m_nSecond));
    }
    else {
        return -1;
    }

    return this.m_tDateTime;
}
CDateTimeData.prototype.GetDateTimeT = function () {
    return this.m_tDateTime;
}
CDateTimeData.prototype.GetDateTimeString = function () {
    return this.m_strDateTime;
}

//////////////////////////
function COutputPacketNames() {
    this.m_strPacketNameArray = [];
}

////////////////////////////
function CRenderingInfo() {

    this.m_rXScaleMng = null;
    this.m_nXScaleItemIndex = null;
    this.m_nPrevXScaleItemIndex = null;
    this.m_tDateTime = null;
    this.m_tTimeArray = null;
    this.m_tTimeArrayItem = null;
    this.m_nXScaleItemEndIndex = null;
    this.m_rXScaleMergeIndex = null;// CDateTimeXScaleMng의 m_XScaleMergeArray의 요소 개체 레퍼런스
}

CRenderingInfo.prototype.Init = function () {

    this.m_rXScaleMng = null;
    this.m_nXScaleItemIndex = null;
    this.m_tDateTime = null;
    this.m_tTimeArray = null;
    this.m_tTimeArrayItem = null;
    this.m_rRQPackets = null;
    this.m_nXScaleItemEndIndex = null;
}
////////////////////////////
function CRQInCol() {

    this.m_rChartBlockCol = null;
    this.m_strRQ = null;
    this.m_nRQCycle = null;
    this.m_nRQInterval = null;

    this.m_rRQSet = null;
    this.m_GraphInColArray = [];

    //속도개선처리
    this.m_rPrevRQPackets = null;
    this.m_rRQPackets = null;

    this.m_tPrevEndDateTime = null;
    this.m_BongXPosInfoArray = [];
    this.m_rPrevBongPosInfo = null;
    this.m_nPrevXScaleItemIndex = null;

    this.m_bRenderingBreak = false;

    /////////////////////////////////////////
    //선택그래프 표시기능
    this.m_nStartSignXPos = null;
    /////////////////////////////////////////

    /////////////////////////////////////////
    //Hoga XScale인 경우 사용변수
    this.m_dPrevHoga = null;
    /////////////////////////////////////////
}

CRQInCol.prototype.InitRendering = function () {

    this.m_rPrevRQPackets = null;
    this.m_rRQPackets = null;

    this.m_tPrevEndDateTime = null;
    this.m_rPrevBongPosInfo = null;
    this.m_nPrevXScaleItemIndex = null;

    this.m_bRenderingBreak = false;

    this.m_nStartSignXPos = null;

    this.m_BongXPosInfoArray.length = 0;

    var i, length = this.m_GraphInColArray.length;
    for (i = 0; i < length; i++) {
        var rGraph = this.m_GraphInColArray[i];
        rGraph.InitRendering();
    }
}
CRQInCol.prototype.RenderingInLoop = function (RenderingInfo) {

    var i, j, k, nLength = null;

    var rXScaleMng = RenderingInfo.m_rXScaleMng;
    if(rXScaleMng.GetType() === DATETIME_TYPE)
    {
        var strRQ = this.m_rRQSet.GetRQ();
        var nRQCycle = this.m_rRQSet.m_RQInfo.m_nCycle;
        var nRQInterval = this.m_rRQSet.m_RQInfo.m_nInterval;
        var strRQTimeKey = strRQ + "_TIME";

        var BongMinWidth = this.m_rChartBlockCol.m_BongMinWidth;
        var nViewStartIndex = this.m_rChartBlockCol.m_nViewStartIndex;
        var nDataCnt = this.m_rChartBlockCol.m_nDataCnt;
        var nGraphRegionWidth = this.m_rChartBlockCol.m_nGraphRegionWidth;
        var nChartBlockColLeft = this.m_rChartBlockCol.m_nGraphRegionLeft;

        var rPrevRQPackets = this.m_rPrevRQPackets;
        var rPrevBongPosInfo = this.m_rPrevBongPosInfo;
        var nPrevXScaleItemIndex = this.m_nPrevXScaleItemIndex;    
        var tPrevEndDateTime = this.m_tPrevEndDateTime;
        
        var nStartSignXPos = this.m_nStartSignXPos;    

        var rXScaleMergeIndex = RenderingInfo.m_rXScaleMergeIndex;
        var nXScaleItemIndex = RenderingInfo.m_nXScaleItemIndex;
        var tDateTime = RenderingInfo.m_tDateTime;        

        this.m_rRQPackets = undefined;

        if (RenderingInfo.m_tTimeArrayItem) {

            this.m_rRQPackets = rXScaleMergeIndex.m_mapRQPacketsItem[this.m_strRQ];
            if (this.m_rRQPackets !== undefined)
                tDateTime = this.m_rRQPackets.m_rXScalePacketData.m_tDateTime;//해당 rq에 맞는 정확한 datetime 값
            
            //this.m_rRQPackets = RenderingInfo.m_tTimeArrayItem[this.m_strRQ];

            if (tPrevEndDateTime !== null) {
                if (tPrevEndDateTime <= tDateTime) {
                    if (rPrevBongPosInfo !== null && nPrevXScaleItemIndex !== null) {

                        if (rPrevRQPackets.m_nRelativeEndIndex !== nXScaleItemIndex - nPrevXScaleItemIndex) {

                            rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                            rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                            rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);


                            var nOrgWidth = rPrevRQPackets.m_nRelativeEndIndex * BongMinWidth;
                            var nPrevOrgStartIndex = nXScaleItemIndex - rPrevRQPackets.m_nRelativeEndIndex;

                            if (nPrevOrgStartIndex < nViewStartIndex)
                                rPrevBongPosInfo.m_CenterXPos = (rPrevBongPosInfo.m_LeftXPos - (nOrgWidth - rPrevBongPosInfo.m_Width)) + Math.nOrgWidth / 2;
                            else
                                rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + nOrgWidth / 2;

                            rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                            rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;

                        }
                        else {

                            rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                            rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width / 2;
                            rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                            rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
                            rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                            rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;
                        }

                        /////////////////////////////////////////
                        //선택그래프 표시기능
                        if ((!nStartSignXPos) || (gSelectSignBetween <= rPrevBongPosInfo.m_OpenXPos - nStartSignXPos)) {
                            //SignBongInfoArray[SignBongInfoArray.length] = rPrevBongPosInfo;

                            nLength = this.m_GraphInColArray.length;
                            for (i = 0; i < nLength; i++) {
                                var rGraph = this.m_GraphInColArray[i];
                                rGraph.AddSelectPosInfo();
                            }

                            this.m_nStartSignXPos = rPrevBongPosInfo.m_OpenXPos;
                            nStartSignXPos = rPrevBongPosInfo.m_OpenXPos;
                        }
                        /////////////////////////////////////////

                        this.m_rPrevBongPosInfo = null;
                        this.m_rRQSet.m_tPrevEndDateTime = null;
                        rPrevBongPosInfo = null;
                        tPrevEndDateTime = null;
                    }
                }
            }

            if (this.m_rRQPackets === undefined && nXScaleItemIndex === nViewStartIndex) {
                
                var tPrevStartDateTime = rXScaleMng.m_tTimeArray[tDateTime][strRQTimeKey];
                if (tPrevStartDateTime !== undefined) {

                    this.m_rRQPackets = rXScaleMng.m_tTimeArray[tPrevStartDateTime][strRQ];
                    if (this.m_rRQPackets !== undefined)
                        tDateTime = tPrevStartDateTime;
                }
            }

            if (this.m_rRQPackets !== undefined) {
                
                var xPos = nChartBlockColLeft + nGraphRegionWidth / nDataCnt * (nXScaleItemIndex - nViewStartIndex);
                if (xPos < nChartBlockColLeft)
                    xPos = nChartBlockColLeft;

                var BongXPosInfo = new CBongXPosInfo();
                BongXPosInfo.m_LeftXPos = xPos;
                this.m_BongXPosInfoArray[this.m_BongXPosInfoArray.length] = BongXPosInfo;            

                nLength = this.m_GraphInColArray.length;
                for (i = 0; i < nLength; i++) {

                    var rGraph = this.m_GraphInColArray[i];
                    rGraph.RenderingInLoop(RenderingInfo);
                }

                ///////////////////////////////////////////////////////////////////////
                if (rPrevRQPackets)
                    rPrevRQPackets.m_nRelativeNextStartIndex = nXScaleItemIndex - nPrevXScaleItemIndex;

                this.m_rRQPackets.m_nRelativeStartIndex = nXScaleItemIndex - nViewStartIndex;
                ///////////////////////////////////////////////////////////////////////

                this.m_rPrevBongPosInfo = BongXPosInfo;
                this.m_rPrevRQPackets = this.m_rRQPackets;
                this.m_nPrevXScaleItemIndex = nXScaleItemIndex;

                this.m_tPrevEndDateTime = CalcNextTime(tDateTime, nRQCycle, nRQInterval);
                this.m_tPrevStartDateTime = tDateTime;
            }
            else {
                if (rPrevRQPackets) {
                    if (tPrevEndDateTime && tPrevEndDateTime <= tDateTime) {
                        if (rPrevBongPosInfo && nPrevXScaleItemIndex) {

                            if (rPrevRQPackets.m_nRelativeEndIndex != nXScaleItemIndex - nPrevXScaleItemIndex) {

                                rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                                rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                                rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);

                                var nOrgWidth = rPrevRQPackets.m_nRelativeEndIndex * BongMinWidth;
                                var nPrevOrgStartIndex = nXScaleItemIndex - rPrevRQPackets.m_nRelativeEndIndex;

                                if (nPrevOrgStartIndex < nViewStartIndex)
                                    rPrevBongPosInfo.m_CenterXPos = (rPrevBongPosInfo.m_LeftXPos - (nOrgWidth - rPrevBongPosInfo.m_Width)) + nOrgWidth / 2;
                                else
                                    rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + nOrgWidth / 2;

                                rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                                rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;

                            }
                            else {

                                rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                                rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width / 2;
                                rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                                rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
                                rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                                rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;
                            }

                            /////////////////////////////////////////
                            //선택그래프 표시기능
                            if ((!nStartSignXPos) || (gSelectSignBetween <= rPrevBongPosInfo.m_OpenXPos - nStartSignXPos)) {
                                //SignBongInfoArray[SignBongInfoArray.length] = rPrevBongPosInfo;
                                nLength = this.m_GraphInColArray.length;
                                for (i = 0; i < nLength; i++) {
                                    var rGraph = this.m_GraphInColArray[i];
                                    rGraph.AddSelectPosInfo();
                                }
                                this.m_nStartSignXPos = rPrevBongPosInfo.m_OpenXPos;
                            }
                            /////////////////////////////////////////

                            this.m_rPrevBongPosInfo = null;
                            this.m_tPrevEndDateTime = null;
                            rPrevBongPosInfo = null;
                            tPrevEndDateTime = null;
                        }
                    }
                }
            }
        }
        else {
            if (rPrevRQPackets !== null) {
                if (tPrevEndDateTime !== null && tPrevEndDateTime <= tDateTime) {
                    if (rPrevBongPosInfo !== null && nPrevXScaleItemIndex !== null) {

                        if (rPrevRQPackets.m_nRelativeEndIndex !== nXScaleItemIndex - nPrevXScaleItemIndex) {

                            rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                            rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                            rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);


                            var nOrgWidth = rPrevRQPackets.m_nRelativeEndIndex * BongMinWidth;
                            var nPrevOrgStartIndex = nXScaleItemIndex - rPrevRQPackets.m_nRelativeEndIndex;

                            if (nPrevOrgStartIndex < nViewStartIndex)
                                rPrevBongPosInfo.m_CenterXPos = (rPrevBongPosInfo.m_LeftXPos - (nOrgWidth - rPrevBongPosInfo.m_Width)) + nOrgWidth / 2;
                            else
                                rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + nOrgWidth / 2;

                            rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                            rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;

                        }
                        else {

                            rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                            rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width / 2;
                            rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                            rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
                            rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                            rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;
                        }

                        /////////////////////////////////////////
                        //선택그래프 표시기능
                        if ((!nStartSignXPos) || (gSelectSignBetween <= rPrevBongPosInfo.m_OpenXPos - nStartSignXPos)) {
                            //SignBongInfoArray[SignBongInfoArray.length] = rPrevBongPosInfo;
                            nLength = this.m_GraphInColArray.length;
                            for (i = 0; i < nLength; i++) {
                                var rGraph = this.m_GraphInColArray[i];
                                rGraph.AddSelectPosInfo();
                            }
                            this.m_nStartSignXPos = rPrevBongPosInfo.m_OpenXPos;
                        }
                        /////////////////////////////////////////

                        this.m_rPrevBongPosInfo = null;
                        this.m_tPrevEndDateTime = null;
                        rPrevBongPosInfo = null;
                        tPrevEndDateTime = null;

                    }
                }
            }
        }
    }
    else if(rXScaleMng.GetType() === NUMERIC_TYPE)
    {
        if(rXScaleMng.GetXScalePacketName() === "_HOGA_")
        {
            var strRQ = this.m_rRQSet.GetRQ();
            
            var BongMinWidth = this.m_rChartBlockCol.m_BongMinWidth;
            var nViewStartIndex = this.m_rChartBlockCol.m_nViewStartIndex;
            var nDataCnt = this.m_rChartBlockCol.m_nDataCnt;
            var nGraphRegionWidth = this.m_rChartBlockCol.m_nGraphRegionWidth;
            var nChartBlockColLeft = this.m_rChartBlockCol.m_nGraphRegionLeft;
    
            var rPrevRQPackets = this.m_rPrevRQPackets;
            var rPrevBongPosInfo = this.m_rPrevBongPosInfo;
            var nPrevXScaleItemIndex = this.m_nPrevXScaleItemIndex;    
            var nXScaleItemIndex = RenderingInfo.m_nXScaleItemIndex;
            var nStartSignXPos = this.m_nStartSignXPos;
    
            this.m_rRQPackets = undefined;
    
            var dHoga = null;
            var dPrevHoga = this.m_dPrevHoga;
            var rXScaleItem = rXScaleMng.m_XScaleItemArray[nXScaleItemIndex];
            var rPrevXSCaleItem = rXScaleMng.m_XScaleItemArray[nPrevXScaleItemIndex];            

            if (rXScaleItem) {
    
                this.m_rRQPackets = rXScaleItem.m_mapRQPacketsItem[this.m_strRQ];
                dHoga = rXScaleItem.m_dHoga;                
                
                if (dPrevHoga !== null) {
                    if (dPrevHoga <= dHoga || dHoga == 0.0 ) {
                        if (rPrevBongPosInfo !== null && nPrevXScaleItemIndex !== null) {
    
                            if (rPrevRQPackets.m_nRelativeEndIndex !== nXScaleItemIndex - nPrevXScaleItemIndex) {
    
                                rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                                rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                                rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
        
                                var nOrgWidth = rPrevRQPackets.m_nRelativeEndIndex * BongMinWidth;
                                var nPrevOrgStartIndex = nXScaleItemIndex - rPrevRQPackets.m_nRelativeEndIndex;
    
                                if (nPrevOrgStartIndex < nViewStartIndex)
                                    rPrevBongPosInfo.m_CenterXPos = (rPrevBongPosInfo.m_LeftXPos - (nOrgWidth - rPrevBongPosInfo.m_Width)) + Math.nOrgWidth / 2;
                                else
                                    rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + nOrgWidth / 2;
    
                                rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                                rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;
    
                            }
                            else {
    
                                rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                                rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width / 2;
                                rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                                rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
                                rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                                rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;
                            }
    
                            /////////////////////////////////////////
                            //선택그래프 표시기능
                            if ((!nStartSignXPos) || (gSelectSignBetween <= rPrevBongPosInfo.m_OpenXPos - nStartSignXPos)) {
                                //SignBongInfoArray[SignBongInfoArray.length] = rPrevBongPosInfo;
    
                                nLength = this.m_GraphInColArray.length;
                                for (i = 0; i < nLength; i++) {
                                    var rGraph = this.m_GraphInColArray[i];
                                    rGraph.AddSelectPosInfo();
                                }
    
                                this.m_nStartSignXPos = rPrevBongPosInfo.m_OpenXPos;
                                nStartSignXPos = rPrevBongPosInfo.m_OpenXPos;
                            }
                            /////////////////////////////////////////
    
                            this.m_rPrevBongPosInfo = null;                            
                            rPrevBongPosInfo = null;
                            dPrevHoga = null;
                        }
                    }
                }
    
                if (this.m_rRQPackets !== undefined) {
                    
                    var xPos = nChartBlockColLeft + nGraphRegionWidth / nDataCnt * (nXScaleItemIndex - nViewStartIndex);
                    if (xPos < nChartBlockColLeft)
                        xPos = nChartBlockColLeft;
    
                    var BongXPosInfo = new CBongXPosInfo();
                    BongXPosInfo.m_LeftXPos = xPos;
                    this.m_BongXPosInfoArray[this.m_BongXPosInfoArray.length] = BongXPosInfo;            
    
                    nLength = this.m_GraphInColArray.length;
                    for (i = 0; i < nLength; i++) {
    
                        var rGraph = this.m_GraphInColArray[i];
                        rGraph.RenderingInLoop(RenderingInfo);
                    }
    
                    ///////////////////////////////////////////////////////////////////////
                    if (rPrevRQPackets)
                        rPrevRQPackets.m_nRelativeNextStartIndex = nXScaleItemIndex - nPrevXScaleItemIndex;
    
                    this.m_rRQPackets.m_nRelativeStartIndex = nXScaleItemIndex - nViewStartIndex;
                    ///////////////////////////////////////////////////////////////////////
    
                    this.m_rPrevBongPosInfo = BongXPosInfo;
                    this.m_rPrevRQPackets = this.m_rRQPackets;
                    this.m_nPrevXScaleItemIndex = nXScaleItemIndex;
    
                    this.m_dPrevHoga = dHoga;                    
                }
                else {
                    if (rPrevRQPackets) {
                        if (dPrevHoga && dPrevHoga <= dHoga || dHoga == 0.0) {
                            if (rPrevBongPosInfo && nPrevXScaleItemIndex) {
    
                                if (rPrevRQPackets.m_nRelativeEndIndex != nXScaleItemIndex - nPrevXScaleItemIndex) {
    
                                    rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                                    rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                                    rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
    
                                    var nOrgWidth = rPrevRQPackets.m_nRelativeEndIndex * BongMinWidth;
                                    var nPrevOrgStartIndex = nXScaleItemIndex - rPrevRQPackets.m_nRelativeEndIndex;
    
                                    if (nPrevOrgStartIndex < nViewStartIndex)
                                        rPrevBongPosInfo.m_CenterXPos = (rPrevBongPosInfo.m_LeftXPos - (nOrgWidth - rPrevBongPosInfo.m_Width)) + nOrgWidth / 2;
                                    else
                                        rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + nOrgWidth / 2;
    
                                    rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                                    rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;
    
                                }
                                else {
    
                                    rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                                    rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width / 2;
                                    rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                                    rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
                                    rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                                    rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;
                                }
    
                                /////////////////////////////////////////
                                //선택그래프 표시기능
                                if ((!nStartSignXPos) || (gSelectSignBetween <= rPrevBongPosInfo.m_OpenXPos - nStartSignXPos)) {
                                    //SignBongInfoArray[SignBongInfoArray.length] = rPrevBongPosInfo;
                                    nLength = this.m_GraphInColArray.length;
                                    for (i = 0; i < nLength; i++) {
                                        var rGraph = this.m_GraphInColArray[i];
                                        rGraph.AddSelectPosInfo();
                                    }
                                    this.m_nStartSignXPos = rPrevBongPosInfo.m_OpenXPos;
                                }
                                /////////////////////////////////////////
    
                                this.m_rPrevBongPosInfo = null;
                                this.m_dPrevHoga = null;
                                rPrevBongPosInfo = null;
                                dPrevHoga = null;
                            }
                        }
                    }
                }
            }
            else {
                if (rPrevRQPackets !== null) {
                    if (dPrevHoga !== null && dPrevHoga <= dHoga || dHoga == 0.0 ) {
                        if (rPrevBongPosInfo !== null && nPrevXScaleItemIndex !== null) {
    
                            if (rPrevRQPackets.m_nRelativeEndIndex !== nXScaleItemIndex - nPrevXScaleItemIndex) {
    
                                rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                                rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                                rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
        
                                var nOrgWidth = rPrevRQPackets.m_nRelativeEndIndex * BongMinWidth;
                                var nPrevOrgStartIndex = nXScaleItemIndex - rPrevRQPackets.m_nRelativeEndIndex;
    
                                if (nPrevOrgStartIndex < nViewStartIndex)
                                    rPrevBongPosInfo.m_CenterXPos = (rPrevBongPosInfo.m_LeftXPos - (nOrgWidth - rPrevBongPosInfo.m_Width)) + nOrgWidth / 2;
                                else
                                    rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + nOrgWidth / 2;
    
                                rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                                rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;
    
                            }
                            else {
    
                                rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                                rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width / 2;
                                rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                                rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
                                rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                                rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;
                            }
    
                            /////////////////////////////////////////
                            //선택그래프 표시기능
                            if ((!nStartSignXPos) || (gSelectSignBetween <= rPrevBongPosInfo.m_OpenXPos - nStartSignXPos)) {
                                //SignBongInfoArray[SignBongInfoArray.length] = rPrevBongPosInfo;
                                nLength = this.m_GraphInColArray.length;
                                for (i = 0; i < nLength; i++) {
                                    var rGraph = this.m_GraphInColArray[i];
                                    rGraph.AddSelectPosInfo();
                                }
                                this.m_nStartSignXPos = rPrevBongPosInfo.m_OpenXPos;
                            }
                            /////////////////////////////////////////
    
                            this.m_rPrevBongPosInfo = null;
                            this.m_dPrevHoga = null;
                            rPrevBongPosInfo = null;
                            dPrevHoga = null;
                        }
                    }
                }
            }
        }
    }
}

CRQInCol.prototype.RenderingOnLast = function (RenderingInfo) {

    var i, j, k, nLength = null;

    var strRQ = this.m_rRQSet.GetRQ();
    var rXScaleMng = RenderingInfo.m_rXScaleMng;    
    if(rXScaleMng.GetType() === DATETIME_TYPE)
    {
        var nRQCycle = this.m_rRQSet.m_RQInfo.m_nCycle;
        var nRQInterval = this.m_rRQSet.m_RQInfo.m_nInterval;

        var BongMinWidth = this.m_rChartBlockCol.m_BongMinWidth;
        var nViewStartIndex = this.m_rChartBlockCol.m_nViewStartIndex;
        var nViewEndIndex = this.m_rChartBlockCol.m_nViewEndIndex;
        var nDataCnt = this.m_rChartBlockCol.m_nDataCnt;
        var nGraphRegionWidth = this.m_rChartBlockCol.m_nGraphRegionWidth;

        var rPrevRQPackets = this.m_rPrevRQPackets;
        var rPrevBongPosInfo = this.m_rPrevBongPosInfo;
        var nPrevXScaleItemIndex = this.m_nPrevXScaleItemIndex;
        var tPrevEndDateTime = this.m_tPrevEndDateTime;
        
        var nStartSignXPos = this.m_nStartSignXPos;

        var nXScaleItemIndex = RenderingInfo.m_nXScaleItemIndex;
        var nXScaleItemEndIndex = RenderingInfo.m_nXScaleItemEndIndex;
        var tDateTime = RenderingInfo.m_tDateTime;
        
        
        if (nViewEndIndex < nXScaleItemIndex) {

            if (rPrevBongPosInfo !== null && nPrevXScaleItemIndex !== null) {

                if (rPrevRQPackets.m_nRelativeEndIndex !== nXScaleItemIndex - nPrevXScaleItemIndex) {

                    rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                    rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                    rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);

                    var nOrgWidth = rPrevRQPackets.m_nRelativeEndIndex * BongMinWidth;
                    var nPrevOrgStartIndex = nXScaleItemIndex - rPrevRQPackets.m_nRelativeEndIndex;

                    if (nPrevOrgStartIndex < nViewStartIndex)
                        rPrevBongPosInfo.m_CenterXPos = (rPrevBongPosInfo.m_LeftXPos - (nOrgWidth - rPrevBongPosInfo.m_Width)) + nOrgWidth / 2;
                    else
                        rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + nOrgWidth / 2;

                    rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                    rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;

                }
                else {

                    rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                    rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width / 2;
                    rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                    rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
                    rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                    rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;
                }

                /////////////////////////////////////////
                //선택그래프 표시기능
                if ((!nStartSignXPos) || (gSelectSignBetween <= rPrevBongPosInfo.m_OpenXPos - nStartSignXPos)) {
                    //SignBongInfoArray[SignBongInfoArray.length] = rPrevBongPosInfo;
                    nLength = this.m_GraphInColArray.length;
                    for (i = 0; i < nLength; i++) {
                        var rGraph = this.m_GraphInColArray[i];
                        rGraph.AddSelectPosInfo();
                    }
                    this.m_nStartSignXPos = rPrevBongPosInfo.m_OpenXPos;                
                }
                /////////////////////////////////////////
                
                this.m_rPrevBongPosInfo = null;            
                this.m_tPrevEndDateTime = null;
                rPrevBongPosInfo = null;
                tPrevEndDateTime = null;
            }

            this.m_bRenderingBreak = true;
            return false;
        }
        else if (nXScaleItemIndex >= nXScaleItemEndIndex) {

            if (tPrevEndDateTime !== null && tPrevEndDateTime <= tDateTime) {

                if (rPrevBongPosInfo !== null && nPrevXScaleItemIndex !== null) {

                    if (rPrevRQPackets.m_nRelativeEndIndex !== nXScaleItemIndex - nPrevXScaleItemIndex) {

                        rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                        rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                        rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);

                        var nOrgWidth = rPrevRQPackets.m_nRelativeEndIndex * BongMinWidth;
                        var nPrevOrgStartIndex = nXScaleItemIndex - rPrevRQPackets.m_nRelativeEndIndex;

                        if (nPrevOrgStartIndex < nViewStartIndex)
                            rPrevBongPosInfo.m_CenterXPos = (rPrevBongPosInfo.m_LeftXPos - (nOrgWidth - rPrevBongPosInfo.m_Width)) + nOrgWidth / 2;
                        else
                            rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + nOrgWidth / 2;

                        rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                        rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;

                    }
                    else {

                        rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                        rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width / 2;
                        rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                        rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
                        rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                        rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;
                    }

                    /////////////////////////////////////////
                    //선택그래프 표시기능
                    if ((!nStartSignXPos) || (gSelectSignBetween <= rPrevBongPosInfo.m_OpenXPos - nStartSignXPos)) {
                        //SignBongInfoArray[SignBongInfoArray.length] = rPrevBongPosInfo;
                        nLength = this.m_GraphInColArray.length;
                        for (i = 0; i < nLength; i++) {
                            var rGraph = this.m_GraphInColArray[i];
                            rGraph.AddSelectPosInfo();
                        }
                        this.m_nStartSignXPos = rPrevBongPosInfo.m_OpenXPos;
                    }
                    /////////////////////////////////////////

                    this.m_rPrevBongPosInfo = null;
                    this.m_tPrevEndDateTime = null;                
                }
            }
        }
        return true;
    }
    else if(rXScaleMng.GetType() === NUMERIC_TYPE){

        if(rXScaleMng.GetXScalePacketName() === "_HOGA_")
        {        
            var BongMinWidth = this.m_rChartBlockCol.m_BongMinWidth;
            var nViewStartIndex = this.m_rChartBlockCol.m_nViewStartIndex;
            var nViewEndIndex = this.m_rChartBlockCol.m_nViewEndIndex;
            var nDataCnt = this.m_rChartBlockCol.m_nDataCnt;
            var nGraphRegionWidth = this.m_rChartBlockCol.m_nGraphRegionWidth;
    
            var rPrevRQPackets = this.m_rPrevRQPackets;
            var rPrevBongPosInfo = this.m_rPrevBongPosInfo;
            var nPrevXScaleItemIndex = this.m_nPrevXScaleItemIndex;
            var nStartSignXPos = this.m_nStartSignXPos;
    
            var nXScaleItemIndex = RenderingInfo.m_nXScaleItemIndex;
            var nXScaleItemEndIndex = RenderingInfo.m_nXScaleItemEndIndex;

            var dHoga = null;
            var dPrevHoga = this.m_dPrevHoga;            
            
            if (nViewEndIndex < nXScaleItemIndex) {
    
                if (rPrevBongPosInfo !== null && nPrevXScaleItemIndex !== null) {
    
                    if (rPrevRQPackets.m_nRelativeEndIndex !== nXScaleItemIndex - nPrevXScaleItemIndex) {
    
                        rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                        rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                        rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
    
                        var nOrgWidth = rPrevRQPackets.m_nRelativeEndIndex * BongMinWidth;
                        var nPrevOrgStartIndex = nXScaleItemIndex - rPrevRQPackets.m_nRelativeEndIndex;
    
                        if (nPrevOrgStartIndex < nViewStartIndex)
                            rPrevBongPosInfo.m_CenterXPos = (rPrevBongPosInfo.m_LeftXPos - (nOrgWidth - rPrevBongPosInfo.m_Width)) + nOrgWidth / 2;
                        else
                            rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + nOrgWidth / 2;
    
                        rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                        rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;    
                    }
                    else {
    
                        rPrevBongPosInfo.m_Width = (nXScaleItemIndex - nPrevXScaleItemIndex) * BongMinWidth;
                        rPrevBongPosInfo.m_CenterXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width / 2;
                        rPrevBongPosInfo.m_OpenXPos = rPrevBongPosInfo.m_LeftXPos + (rPrevBongPosInfo.m_Width > 4 ? 1 : 0);
                        rPrevBongPosInfo.m_CloseXPos = rPrevBongPosInfo.m_LeftXPos + rPrevBongPosInfo.m_Width + (rPrevBongPosInfo.m_Width > 4 ? -1 : 0);
                        rPrevBongPosInfo.m_HighXPos = rPrevBongPosInfo.m_CenterXPos;
                        rPrevBongPosInfo.m_LowXPos = rPrevBongPosInfo.m_CenterXPos;
                    }
    
                    /////////////////////////////////////////
                    //선택그래프 표시기능
                    if ((!nStartSignXPos) || (gSelectSignBetween <= rPrevBongPosInfo.m_OpenXPos - nStartSignXPos)) {
                        //SignBongInfoArray[SignBongInfoArray.length] = rPrevBongPosInfo;
                        nLength = this.m_GraphInColArray.length;
                        for (i = 0; i < nLength; i++) {
                            var rGraph = this.m_GraphInColArray[i];
                            rGraph.AddSelectPosInfo();
                        }
                        this.m_nStartSignXPos = rPrevBongPosInfo.m_OpenXPos;                
                    }
                    /////////////////////////////////////////
                    
                    this.m_rPrevBongPosInfo = null;                    
                    rPrevBongPosInfo = null;
                    dPrevHoga = null;
                }
    
                this.m_bRenderingBreak = true;
                return false;
            }            
        }
        return true;
    }
    return true;
}


///////////////////////////
function CRQPacketsItem(strRQ, nCycle, nInterval) {

    this.m_strRQ = strRQ;
    this.m_nCycle = nCycle;
    this.m_nInterval = nInterval;
    this.m_rXScalePacketData = null;
    this.m_rPrevRQPacketsItem = null;
    this.m_rNextRQPacketsItem = null;
    this.m_nRelativeStartIndex = null;
    this.m_nRelativeEndIndex = 1;//Start time에서 end time까지의 최소봉 갯수(단일rq에서는 기본적으로 한봉이 하나의 최소봉이 되므로 1로 셋팅)
    this.m_nRelativeNextStartIndex = null;//next data 시작지점까지 상대거리
    this.m_rXScaleMergeIndex = null;
    this.m_tStartTime = null;
    this.m_tEndTime = null;
    this.m_Packets = [];//배열로 변경
}

////////////////////////
function CRQSet(rChart, mapXScaleMng) {

    this.m_rChart = rChart;
    this.m_rGlobalProperty = (this.m_rChart !== null ? this.m_rChart.GetGlobalProperty() : null);

    this.m_strRQ = "";
    this.m_RQInfo = new CRQInfo();
    this.m_tTradeTimeInDay;

    this.m_nDateTimePacketIndex = null;
    this.m_nClosePacketIndex = null;
    this.m_nOpenPacketIndex = null;
    this.m_nLowPacketIndex = null;
    this.m_nHighPacketIndex = null;
    this.m_nVolumePacketIndex = null;
    this.m_nHL2PacketIndex = null;
    this.m_nHLC3PacketIndex = null;

    this.m_PacketDataArray = [];

    this.m_PacketCalculatorArray = [];

    this.m_rSelectGraph = null;
    this.m_GraphArray = [];
    this.m_mapXScaleMng = mapXScaleMng;
    this.m_bSelectedRQ = false;
    this.m_CommonInfo = {};//rq에 속한 개체들과 공유해야 하는 정보를 담아두는 object (예:가격차트 속성(다른 그래프들에서 상황에 따라 참고해야 한다))

    this.m_nPriceDigit = 0;
    this.m_nOrderUnitQty = 0;

    // 20190115 전중현 : 기준선 관리자
    this.m_GuideLineMng = new CGuideLineMng(rChart);

    //속도개선처리
    this.m_rPrevRQPackets = null;
    this.m_rRQPackets = null;

    this.m_nViewStartIndex = null;
    this.m_nViewEndIndex = null;
    this.m_bRenderingBreak = false;

    this.m_rPriceIndicator = null;
}

CRQSet.prototype.ChangeLang = function(){

    this.m_GuideLineMng.ChangeLang();
}
CRQSet.prototype.GetChartFullProperty = function () {
    
    var RQProperty = new CRQProperty();
    RQProperty.SetProperty(this.m_strRQ, this.m_RQInfo.m_strItemCode, this.m_RQInfo.m_strItemName, this.m_RQInfo.m_nCycle,
        this.m_RQInfo.m_nInterval, this.m_RQInfo.m_nRequestDataCnt, this.m_RQInfo.m_bRealBong, "00000000", "99999999");
    
    return RQProperty;
}

//속도개선처리
CRQSet.prototype.InitRendering = function (rXScaleMng) {
    
    this.m_rPrevRQPackets = null;
    this.m_rRQPackets = null;
    this.m_bRenderingBreak = false;

    this.m_nViewStartIndex = rXScaleMng.m_nViewStartIndex;
    this.m_nViewEndIndex = rXScaleMng.m_nViewEndIndex;
}

CRQSet.prototype.RenderingInLoop = function (rRenderingInfo) {//rXScaleMng, nXScaleItemIndex, nPrevXScaleItemIndex, tDateTime, tTimeArray , DrawingInfo

    var i, nLength = this.m_GraphArray.length;
    
    this.m_rRQPackets = rRenderingInfo.m_tTimeArrayItem[this.m_strRQ];

    for (i = 0; i < nLength; i++) {

        var rGraph = this.m_GraphArray[i];
        rGraph.RenderingInLoop(rRenderingInfo);
    }
}

CRQSet.prototype.MakeNextDateTime = function (tCurDateTime, tPrevDateTime) {

    if (tPrevDateTime === null) {

        var nDay;
        var tCurFullDateTime= tCurDateTime * 1000, tPrevFullDateTime = null;
        var strStartTime = this.m_RQInfo.m_strMarketStartTime;

        switch (this.m_RQInfo.m_nCycle) {
            case 1://일
            case 5://분
            case 6://초
                {
                    gTempDate.setTime(tCurFullDateTime);
                    gTempDate.setHours(parseInt(strStartTime.slice(0, 1)), parseInt(strStartTime.slice(2, 3)), parseInt(strStartTime.slice(4, 5)));
                    tPrevFullDateTime = gTempDate.getTime();
                    if (tCurFullDateTime < tPrevFullDateTime) {
                        gTempDate.setDate(gTempDate.getDate() - 1);
                        tPrevFullDateTime = gTempDate.getTime();
                    }
                    tPrevDateTime = tPrevFullDateTime / 1000;
                }
                break;
            case 2://주
                {
                    gTempDate.setTime(tCurFullDateTime);
                    nDay = gTempDate.getDay();
                    gTempDate.setDate(gTempDate.getDate() - nDay);
                    gTempDate.setHours(parseInt(strStartTime.slice(0, 1)), parseInt(strStartTime.slice(2, 3)), parseInt(strStartTime.slice(4, 5)));
                    tPrevFullDateTime = gTempDate.getTime();
                    if (tCurFullDateTime < tPrevFullDateTime) {
                        gTempDate.setDate(gTempDate.getDate() - 7);
                        tPrevFullDateTime = gTempDate.getTime();
                    }
                    tPrevDateTime = tPrevFullDateTime / 1000;
                }
                break;
            case 3://월
            case 4://년
                {
                    gTempDate.setFullYear(1971, 0, 1);
                    gTempDate.setHours(parseInt(strStartTime.slice(0, 1)), parseInt(strStartTime.slice(2, 3)), parseInt(strStartTime.slice(4, 5)));
                    tPrevDateTime = gTempDate.getTime() / 1000;
                }
                break;
            
        }
    }
    return CalcNextStartExclusiveEnd(tPrevDateTime, tCurDateTime, this.m_RQInfo.m_nCycle, this.m_RQInfo.m_nInterval);
}
CRQSet.prototype.IsExistGraphName = function (strGraphName) {
    var i, nLength = this.m_GraphArray.length;
    for (i = 0; i < nLength; i++) {
        var rGraph = this.m_GraphArray[i];
        if (rGraph.m_strName == strGraphName)
            return rGraph;
    }
    return null;
}
CRQSet.prototype.FindGraphByKey = function (strGraphKey) {
    var i, nLength = this.m_GraphArray.length;
    for (i = 0; i < nLength; i++) {
        var rGraph = this.m_GraphArray[i];
        if (rGraph.m_strKey === strGraphKey)
            return rGraph;
    }
    return null;
}
CRQSet.prototype.SetCommonInfo = function (strCommonKey, CommonInfo) {
    this.m_CommonInfo[strCommonKey] = CommonInfo;
}
CRQSet.prototype.GetCommonInfo = function (strCommonKey) {
    return this.m_CommonInfo[strCommonKey];
}
CRQSet.prototype.Select = function (bSelect) {
    this.m_bSelected = bSelect;
}
CRQSet.prototype.IsSelected = function () {
    return this.m_bSelected;
}
CRQSet.prototype.GetXScaleMng = function (strXScalePacketName) {
    //var rXScaleMng = this.m_mapXScaleMng.get( strXScalePacketName );//20171115 이문수
    var rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];
    return rXScaleMng;
}
CRQSet.prototype.AddPacketInfo = function (strPacketName, nPacketType, strPacketSubType, nPacketDataLen, nPacketUseType) {

    var rPacketData = null;
    var length = this.m_PacketDataArray.length;
    for (var i = 0; i < length; i++) {
        var PacketData = this.m_PacketDataArray[i];
        if (PacketData.m_strPacketName === strPacketName) {
            rPacketData = PacketData;

            if (strPacketName === "_HIGH_")
                this.m_nHighPacketIndex = i;
            else if (strPacketName === "_LOW_")
                this.m_nLowPacketIndex = i;
            else if (strPacketName === "_OPEN_")
                this.m_nOpenPacketIndex = i;
            else if (strPacketName == "_CLOSE_")
                this.m_nClosePacketIndex = i;
            else if (strPacketName === "_VOLUME_")
                this.m_nVolumePacketIndex = i;
            else if (strPacketName === "_DATETIME_")
                this.m_nDateTimePacketIndex = i;

            break;
        }
    }

    if (rPacketData === null) {

        switch (nPacketType) {
            case NUMERIC_TYPE:
                rPacketData = new CNumericPacketData(strPacketName);
                this.m_PacketDataArray[this.m_PacketDataArray.length] = rPacketData;
                break;
            case DATETIME_TYPE:
                rPacketData = new CDateTimePacketData(strPacketName);
                this.m_PacketDataArray[this.m_PacketDataArray.length] = rPacketData;
                break;
            case STRING_TYPE:
                rPacketData = new CStringPacketData(strPacketName);
                this.m_PacketDataArray[this.m_PacketDataArray.length] = rPacketData;
                break;
            default:
                return null;
        }

        rPacketData.m_nPacketIndex = this.m_PacketDataArray.length - 1;

        if (strPacketName === "_HIGH_")
            this.m_nHighPacketIndex = this.m_PacketDataArray.length - 1;
        else if (strPacketName === "_LOW_")
            this.m_nLowPacketIndex = this.m_PacketDataArray.length - 1;
        else if (strPacketName === "_OPEN_")
            this.m_nOpenPacketIndex = this.m_PacketDataArray.length - 1;
        else if (strPacketName === "_CLOSE_")
            this.m_nClosePacketIndex = this.m_PacketDataArray.length - 1;
        else if (strPacketName === "_VOLUME_")
            this.m_nVolumePacketIndex = this.m_PacketDataArray.length - 1;
        else if (strPacketName === "_DATETIME_")
            this.m_nDateTimePacketIndex = this.m_PacketDataArray.length - 1;
    }
    
    //rPacketData.m_strPacketName = strPacketName;
    rPacketData.m_nPacketType = nPacketType;
    rPacketData.m_strPacketSubType = strPacketSubType;
    rPacketData.m_nPacketDataLen = nPacketDataLen;
    rPacketData.SetRQSet(this);
    rPacketData.SetPacketUseType(nPacketUseType);

    // 20190207 전중현 : PriceCandleInfo 세팅은 LoadIndicatorDefaultProperty 함수에서 하기로 함
    /*//약속한 가격차트 패킷이 들어오면 가격차트속성을 RQ의 CommonInfo에 생성해 놓는다
    if (strPacketName === "_CLOSE_") {

        var PriceCandleInfo = this.GetCommonInfo("PriceCandleInfo");
        if (PriceCandleInfo === null) {
            var PriceCandleInfo = new CPriceCandleInfo();
            this.SetCommonInfo("PriceCandleInfo", PriceCandleInfo);
        }
    }*/

    return rPacketData.m_nPacketIndex;
}

CRQSet.prototype.AddIndicatorNumPacketInfo = function (strPacketName, nPacketDataLen, bInputType, nDec, Unit, nDigit) {
    return this.AddNumPacketInfo(strPacketName, nPacketDataLen, INDICATOR_PACKET_USE_TYPE, nDec, Unit, nDigit);
}

CRQSet.prototype.AddNumPacketInfo = function (strPacketName, nPacketDataLen, nPacketUseType, nDec, Unit, nDigit) {

    var i, rPacketData = null, PacketData = null;
    var length = this.m_PacketDataArray.length;
    for ( i = 0; i < length; i++) {
         PacketData = this.m_PacketDataArray[i];
        if (PacketData.m_strPacketName == strPacketName) {
            rPacketData = PacketData;

            if (strPacketName == "_HIGH_")
                this.m_nHighPacketIndex = i;
            else if (strPacketName == "_LOW_")
                this.m_nLowPacketIndex = i;
            else if (strPacketName == "_OPEN_")
                this.m_nOpenPacketIndex = i;
            else if (strPacketName == "_CLOSE_")
                this.m_nClosePacketIndex = i;
            else if (strPacketName == "_VOLUME_")
                this.m_nVolumePacketIndex = i;
            else if (strPacketName == "_DATETIME_")
                this.m_nDateTimePacketIndex = i;

            break;
        }
    }

    //패킷명이 앞에 키값만 제외하면 같고 어떤 SubGraph하고도 연결되어 있지 않은 패킷을 찾은 경우 재활용
    if (rPacketData == null) {

        var strMainPacketName = strPacketName;
        var nFindPos = strPacketName.indexOf('_');
        if(nFindPos >= 0)
            strMainPacketName = strPacketName.substring(nFindPos);

        for ( i = 0; i < length; i++) {
            PacketData = this.m_PacketDataArray[i];

            //패킷명이 앞에 키값만 제외하면 같고 어떤 SubGraph하고도 연결되어 있지 않은 패킷을 찾은 경우 재활용
            if(PacketData.IsLikePacketName(strMainPacketName) && PacketData.m_SubGraphArray.length <= 0)
            {
                rPacketData = PacketData;
                rPacketData.m_strPacketName = strPacketName;//삭제된 지표가 사용하던 패킷을 재활용하는 것으로 키값 포함된 패킷명은 새것으로 교체
                break;
            }
        }

        //유사패킷명을 재활용할 수 없는 경우 새로 생성
        if (rPacketData === null) {

            rPacketData = new CNumericPacketData(strPacketName);

            this.m_PacketDataArray[this.m_PacketDataArray.length] = rPacketData;

            rPacketData.m_nPacketIndex = this.m_PacketDataArray.length - 1;

            if (strPacketName == "_HIGH_")
                this.m_nHighPacketIndex = this.m_PacketDataArray.length - 1;
            else if (strPacketName == "_LOW_")
                this.m_nLowPacketIndex = this.m_PacketDataArray.length - 1;
            else if (strPacketName == "_OPEN_")
                this.m_nOpenPacketIndex = this.m_PacketDataArray.length - 1;
            else if (strPacketName == "_CLOSE_")
                this.m_nClosePacketIndex = this.m_PacketDataArray.length - 1;
            else if (strPacketName == "_VOLUME_")
                this.m_nVolumePacketIndex = this.m_PacketDataArray.length - 1;
        }
    }
    
    rPacketData.m_nPacketType = NUMERIC_TYPE;
    rPacketData.m_nPacketDataLen = nPacketDataLen;
    rPacketData.SetRQSet(this);
    rPacketData.SetPacketUseType(nPacketUseType);

    rPacketData.m_nDec = nDec;
    rPacketData.m_Unit = Unit;
    rPacketData.m_nDigit = nDigit;

    // 20190207 전중현 : PriceCandleInfo 세팅은 LoadIndicatorDefaultProperty 함수에서 하기로 함
    /*//약속한 가격차트 패킷이 들어오면 가격차트속성을 RQ의 CommonInfo에 생성해 놓는다
    if (strPacketName == "_CLOSE_") {

        var PriceCandleInfo = this.GetCommonInfo("PriceCandleInfo");
        if (PriceCandleInfo == null) {
            var PriceCandleInfo = new CPriceCandleInfo();
            this.SetCommonInfo("PriceCandleInfo", PriceCandleInfo);
        }
    }*/

    return rPacketData.m_nPacketIndex;
}

CRQSet.prototype.AddDateTimePacketInfo = function (strPacketName, strPacketSubType, nPacketDataLen, nPacketUseType) {

    var rPacketData = null;
    var length = this.m_PacketDataArray.length;
    for (var i = 0; i < length; i++) {
        var PacketData = this.m_PacketDataArray[i];
        if (PacketData.m_strPacketName == strPacketName) {

            rPacketData = PacketData;
            this.m_nDateTimePacketIndex = i;
            break;
        }
    }

    if (rPacketData == null) {

        rPacketData = new CDateTimePacketData(strPacketName);
        this.m_PacketDataArray[this.m_PacketDataArray.length] = rPacketData;
        this.m_nDateTimePacketIndex = this.m_PacketDataArray.length - 1;

        rPacketData.m_nPacketIndex = this.m_nDateTimePacketIndex;
    }
    
    rPacketData.m_nPacketType = DATETIME_TYPE;
    rPacketData.m_strPacketSubType = strPacketSubType;
    rPacketData.m_nPacketDataLen = nPacketDataLen;
    rPacketData.SetRQSet(this);
    rPacketData.SetPacketUseType(nPacketUseType);

    return rPacketData.m_nPacketIndex;
}

CRQSet.prototype.AddTextPacketInfo = function (strPacketName, strPacketSubType, nPacketDataLen, nPacketUseType) {


    var rPacketData = null;
    var length = this.m_PacketDataArray.length;
    for (var i = 0; i < length; i++) {
        var PacketData = this.m_PacketDataArray[i];
        if (PacketData.m_strPacketName == strPacketName) {

            rPacketData = PacketData;
            break;
        }
    }

    if (rPacketData == null) {

        rPacketData = new CStringPacketData(strPacketName);
        this.m_PacketDataArray[this.m_PacketDataArray.length] = rPacketData;

        rPacketData.m_nPacketIndex = this.m_PacketDataArray.length - 1;
    }
    
    rPacketData.m_nPacketType = STRING_TYPE;
    rPacketData.m_strPacketSubType = strPacketSubType;
    rPacketData.m_nPacketDataLen = nPacketDataLen;
    rPacketData.SetRQSet(this);
    rPacketData.SetPacketUseType(nPacketUseType);

    return rPacketData.m_nPacketIndex;
}

CRQSet.prototype.AddPacketCalculator = function (strPacketName, strInputPacketNameArray, nDec, Unit, nDigit) {

    var rPacketCalculator = this.GetPacketDataByName(strPacketName);
    if (rPacketCalculator == null) {

        rPacketCalculator = new CPacketCalculator(this, strPacketName, strInputPacketNameArray, nDec, Unit, nDigit);
        this.m_PacketCalculatorArray[this.m_PacketCalculatorArray.length] = rPacketCalculator;

        if (strPacketName == "_HL2_")
            this.m_nHL2PacketIndex = this.m_PacketCalculatorArray.length - 1;

        if (strPacketName == "_HLC3_")
            this.m_nHLC3PacketIndex = this.m_PacketCalculatorArray.length - 1;

        return true;
    }
    return false;//이미 존재
}

//bAscendingOrder:true(과거부터 현재시점방향으로 rStrData 데이터 적재), false(현재에서 과거시점방향으로 rStrData 데이터 적재)
CRQSet.prototype.SetPacketData = function (rStrData, nDataLen, bAppend, bAscendingOrder) {

    var nFindPos = rStrData.indexOf("!");
    if (nFindPos < 0)
        return false;

    var nTotalCnt = parseInt(rStrData.substring(0, nFindPos));
    var nStartPos = nFindPos + 1;
    if (nDataLen <= nStartPos)
        return false;

    if (bAppend === false) {
        this.RemoveAllDataInPacketData();
    }

    var i = 0;
    var j = 0;

    var nRowSize = 0;
    var rXScalePacketData = null;
    var nXScalePacketIndex = null;
    //if(!bAscendingOrder)
    {
        var nMinMaxItemCnt = null;
        var length = this.m_PacketDataArray.length;
        for (i = 0; i < length; i++) {

            var rPacketData = this.m_PacketDataArray[i];

            //MinMaxItemCnt 계산 및 셋팅 그 후 아래 for문에서 데이터 셋팅
            if (rPacketData.GetPacketType() === NUMERIC_TYPE) {
                rPacketData.CalcMinMaxItemCnt(nTotalCnt, bAppend);//신규조회인 경우 기존 MinMaxItemArray의 초기화 진행
            }

            var nPacketUseType = rPacketData.GetPacketUseType();
            if (nPacketUseType === INPUT_PACKET_USE_TYPE)
            {
                rPacketData.AppendPacketStartIndexObj(nTotalCnt);

                nRowSize += rPacketData.m_nPacketDataLen;

                if (this.m_mapXScaleMng[rPacketData.m_strPacketName] !== undefined) {
                    rXScalePacketData = rPacketData;
                    nXScalePacketIndex = i;
                }
            }
            else if (nPacketUseType === CALC_PACKET_USE_TYPE)
                rPacketData.AppendPacketStartIndexObj(nTotalCnt);
        }
    }

    var RQPacketsItem = null;
    var PrevRQPacketsItem = null;
    var nHeaderLen = nFindPos + 1;
    var nPacketDataLen = this.m_PacketDataArray.length;

    var nLength = null;

    if (!bAppend)
	{//연속조회 처리

	    for (i = 0; i < nTotalCnt; i++)
		{
	        nStartPos = nHeaderLen + (nTotalCnt - 1 - i) * nRowSize;
	
	        //console.log("" + i + ":" + rStrData.substring(nStartPos, nStartPos + nRowSize));
	
            if (rXScalePacketData !== null)
	            RQPacketsItem = new CRQPacketsItem(this.m_strRQ, this.m_RQInfo.m_nCycle, this.m_RQInfo.m_nInterval);
	
	        for (j = 0; j < nPacketDataLen; j++)
			{
                var PacketData = this.m_PacketDataArray[j];
                if (PacketData.GetPacketUseType() !== INPUT_PACKET_USE_TYPE)
	                continue;
	
	            switch (PacketData.m_nPacketType)
				{
	                case NUMERIC_TYPE://숫자형
	                    {
	                        var Data = parseFloat(rStrData.substring(nStartPos, nStartPos + PacketData.m_nPacketDataLen));
	
	                        if (!bAscendingOrder) {
	                            PacketData.AddTail(i, Data);
                                if (RQPacketsItem)
                                    RQPacketsItem.m_Packets[PacketData.m_nPacketIndex] = PacketData.GetData(PacketData.GetDataArraySize() - 1);
	                        }
	                        else {
	                            PacketData.AddHead(nTotalCnt - i - 1, Data);
	                            if (RQPacketsItem)
                                    RQPacketsItem.m_Packets[PacketData.m_nPacketIndex] = PacketData.GetData(0);
	                        }
	                    }
	                    break;
	                case DATETIME_TYPE://날짜형
	                    {
	                        var Data = rStrData.substring(nStartPos, nStartPos + PacketData.m_nPacketDataLen);
	                        if (!bAscendingOrder) {
	                            PacketData.AddTail(i, Data, PacketData.m_strPacketSubType, true, this.m_RQInfo.m_nCycle);
	                            if (RQPacketsItem)
                                    RQPacketsItem.m_Packets[PacketData.m_nPacketIndex] = PacketData.GetData(PacketData.GetDataArraySize() - 1);
	                        }
	                        else {
	                            PacketData.AddHead(nTotalCnt - i - 1, Data, PacketData.m_strPacketSubType, true);
	                            if (RQPacketsItem)
                                    RQPacketsItem.m_Packets[PacketData.m_nPacketIndex] = PacketData.GetData(0);
	                        }
	                    }
	                    break;
	                case STRING_TYPE://문자형
	                    {
	                        var Data = rStrData.substring(nStartPos, nStartPos + PacketData.m_nPacketDataLen);
	                        if (!bAscendingOrder) {
	                            PacketData.AddTail(i, Data);
	                            if (RQPacketsItem)
                                    RQPacketsItem.m_Packets[PacketData.m_nPacketIndex] = PacketData.GetData(PacketData.GetDataArraySize() - 1);
	                        }
	                        else {
	                            PacketData.AddHead(nTotalCnt - i - 1, Data);
	                            if (RQPacketsItem)
                                    RQPacketsItem.m_Packets[PacketData.m_nPacketIndex] = PacketData.GetData(0);
	                        }
	                    }
	                    break;
	                default://없는 타입이 설정되어 오류처리
	                    {
	                        this.RemoveAllDataInPacketData();
	                        return false;
	                    }
	            }
	            nStartPos += PacketData.m_nPacketDataLen;
	        }
	
	        if (RQPacketsItem)
            {
                RQPacketsItem.m_rXScalePacketData = RQPacketsItem.m_Packets[rXScalePacketData.m_nPacketIndex];

	            if (PrevRQPacketsItem)
				{
	                RQPacketsItem.m_rPrevRQPacketsItem = PrevRQPacketsItem;
	                PrevRQPacketsItem.m_rNextRQPacketsItem = RQPacketsItem;
                }

                var rXScaleMng = this.m_mapXScaleMng[rXScalePacketData.m_strPacketName];
                if (rXScaleMng)
                    rXScaleMng.SetRQPacketsItem(this.m_strRQ, RQPacketsItem.m_Packets[rXScalePacketData.m_nPacketIndex], RQPacketsItem);
	
	            PrevRQPacketsItem = RQPacketsItem;
	        }
	    }

        ////////////////////////////////////////////////////////
        nLength = this.m_PacketCalculatorArray.length;
	    for (i = 0; i < nLength; i++) {
	        this.m_PacketCalculatorArray[i].Calc();
	    }

    	nLength = this.m_GraphArray.length;
	    for (i = 0; i < nLength; i++) {
	        var Graph = this.m_GraphArray[i];
	        Graph.Calc();
	    }
        ////////////////////////////////////////////////////////
    }
    else
	{//Append 인 경우

        var nRowIndex = 0;
        for (i = 0; i < nTotalCnt; i++)
		{

            if (bAscendingOrder)//순차
                nStartPos = nHeaderLen + (nTotalCnt - 1 - i) * nRowSize;
            else//역순
                nStartPos = nHeaderLen + i * nRowSize;

            nRowIndex = nTotalCnt - 1 - i;

            //console.log("" + i + ":" + rStrData.substring(nStartPos, nStartPos + nRowSize));

            if (rXScalePacketData !== null)
                RQPacketsItem = new CRQPacketsItem(this.m_strRQ, this.m_RQInfo.m_nCycle, this.m_RQInfo.m_nInterval);

            for (j = 0; j < nPacketDataLen; j++)
			{

                var PacketData = this.m_PacketDataArray[j];
                if (PacketData.GetPacketUseType() !== INPUT_PACKET_USE_TYPE)
                    continue;

                switch (PacketData.m_nPacketType)
				{
                    case NUMERIC_TYPE://숫자형
                        {
                            var Data = parseFloat(rStrData.substring(nStartPos, nStartPos + PacketData.m_nPacketDataLen));

                            PacketData.AddHead(nRowIndex, Data);
                            if (RQPacketsItem)
                                RQPacketsItem.m_Packets[PacketData.m_nPacketIndex] = PacketData.GetData(0);
                        }
                        break;
                    case DATETIME_TYPE://날짜형
                        {
                            var Data = rStrData.substring(nStartPos, nStartPos + PacketData.m_nPacketDataLen);

                            PacketData.AddHead(nRowIndex, Data, PacketData.m_strPacketSubType, true, this.m_RQInfo.m_nCycle);
                            if (RQPacketsItem)
                                RQPacketsItem.m_Packets[PacketData.m_nPacketIndex] = PacketData.GetData(0);
                        }
                        break;
                    case STRING_TYPE://문자형
                        {
                            var Data = rStrData.substring(nStartPos, nStartPos + PacketData.m_nPacketDataLen);

                            PacketData.AddHead(nRowIndex, Data);
                            if (RQPacketsItem)
                                RQPacketsItem.m_Packets[PacketData.m_nPacketIndex] = PacketData.GetData(0);
                        }
                        break;
                    default://없는 타입이 설정되어 오류처리
                        {
                            this.RemoveAllDataInPacketData();
                            return false;
                        }
                }
                nStartPos += PacketData.m_nPacketDataLen;
            }

            if (RQPacketsItem)
            {
                RQPacketsItem.m_rXScalePacketData = RQPacketsItem.m_Packets[rXScalePacketData.m_nPacketIndex];

                if (PrevRQPacketsItem) {
                    RQPacketsItem.m_rPrevRQPacketsItem = PrevRQPacketsItem;
                    PrevRQPacketsItem.m_rNextRQPacketsItem = RQPacketsItem;
                }

                var rXScaleMng = this.m_mapXScaleMng[rXScalePacketData.m_strPacketName];
                if (rXScaleMng)
                    rXScaleMng.SetRQPacketsItem(this.m_strRQ, RQPacketsItem.m_Packets[rXScalePacketData.m_nPacketIndex], RQPacketsItem);

                PrevRQPacketsItem = RQPacketsItem;
            }
        }

        /////////////////////////////////////////////////////////
        nLength = this.m_PacketCalculatorArray.length;
        for (i = 0; i < nLength; i++) {
            this.m_PacketCalculatorArray[i].Calc(nTotalCnt);
        }

        nLength = this.m_GraphArray.length;
        for (i = 0; i < nLength; i++) {
            var Graph = this.m_GraphArray[i];
            Graph.Calc();
        }
        /////////////////////////////////////////////////////////
    }

    return true;
}

CRQSet.prototype.SetRealData = function (nRealDataType, nXScalePacketIndex, RealDataArray) {

    var nPacketIndex, nLength = RealDataArray.length;
    var nPacketDataLength = this.m_PacketDataArray.length;
    var nRQCycle = this.m_RQInfo.m_nCycle;
    var nRQInterval = this.m_RQInfo.m_nInterval;

    if (nPacketDataLength <= nXScalePacketIndex)
        return -1;

    var Data = RealDataArray[nXScalePacketIndex];

    var rXScalePacketData = this.m_PacketDataArray[nXScalePacketIndex];
    var nXScalePacketDataSize = rXScalePacketData.GetDataArraySize();
    var rXScaleLastData = null, tEndDateTime = null, tPrevDateTime = null;
    if (nXScalePacketDataSize > 0)
        rXScaleLastData = rXScalePacketData.GetData(nXScalePacketDataSize - 1);

    if (nRealDataType === PRICE_REAL_TYPE) {

        var nYear = parseInt(Data.slice(0, 4));
        var nMonth = parseInt(Data.slice(4, 6));
        var nDay = parseInt(Data.slice(6, 8));
        var nHour = parseInt(Data.slice(8, 10));
        var nMin = parseInt(Data.slice(10, 12));
        var nSecond = parseInt(Data.slice(12, 14));

        gTempDate.setFullYear(nYear, nMonth - 1, nDay);
        gTempDate.setHours(nHour, nMin, nSecond);

        var tCurDateTime = Math.floor(gTempDate.getTime() / 1000);
        if (rXScaleLastData) {
            tPrevDateTime = rXScaleLastData.GetDateTimeT();
            tEndDateTime = CalcDateTimeT(tPrevDateTime, nRQCycle, nRQInterval);
        }

        if (tEndDateTime && tCurDateTime < tEndDateTime) {//update

            var nUpdateState = 0;

            for (nPacketIndex = 0; nPacketIndex < nLength; nPacketIndex++) {

                if (nPacketIndex === nXScalePacketIndex)
                    continue;

                if (RealDataArray[nPacketIndex] === null)
                    continue;

                var Data = RealDataArray[nPacketIndex];

                var rPacketData = this.m_PacketDataArray[nPacketIndex];
                var nEndIndex = rPacketData.GetDataArraySize() - 1;

                if (nPacketIndex === this.m_nVolumePacketIndex)//거래량패킷인 경우만 누적합계처리
                    nUpdateState |= rPacketData.UpdateSumData(nEndIndex, Data);
                else
                    nUpdateState |= rPacketData.UpdateData(nEndIndex, Data);

                if (nPacketIndex === this.m_nClosePacketIndex) {

                    var rHighPacketData = this.m_PacketDataArray[this.m_nHighPacketIndex];
                    var rHighPacketItem = rHighPacketData.GetData(nEndIndex);
                    if (rHighPacketItem.m_Data < Data)
                        nUpdateState |= rHighPacketData.UpdateData(nEndIndex, Data);

                    var rLowPacketData = this.m_PacketDataArray[this.m_nLowPacketIndex];
                    var rLowPacketItem = rLowPacketData.GetData(nEndIndex);
                    if (Data < rLowPacketItem.m_Data)
                        nUpdateState |= rLowPacketData.UpdateData(nEndIndex, Data);

                    /////////////////////////////////////////////////////////////////////
                    //사용할 곳에서 계산하지 않고 미리 한곳에서 계산하여 속도향상을 한다
                    this.SetRealCurPrice(Data);
                    /////////////////////////////////////////////////////////////////////
                }
            }

            var nLength = this.m_PacketCalculatorArray.length;
            for (var i = 0; i < nLength; i++) {
                this.m_PacketCalculatorArray[i].RealCalc(false);
            }

            nLength = this.m_GraphArray.length;
            for (var i = 0; i < nLength; i++) {
                var Graph = this.m_GraphArray[i];
                Graph.RealCalc(false);
            }

            return nUpdateState;
        }
        else {//append

            var rXScaleMng = this.m_mapXScaleMng[rXScalePacketData.GetPacketName()];
            if (rXScaleMng === undefined)
                return -1;
            
            var PrevRQPacketsItem = null;
            if (tPrevDateTime) {
                
                if (rXScaleMng.m_tTimeArray[tPrevDateTime] === undefined)
                    return -1;
                PrevRQPacketsItem = rXScaleMng.m_tTimeArray[tPrevDateTime][this.m_strRQ];
                tEndDateTime = this.MakeNextDateTime(tCurDateTime, tPrevDateTime);
            }
            else
                tEndDateTime = this.MakeNextDateTime(tCurDateTime, null);//조회데이터가 없고 실시간 데이터가 첫데이터인 경우

            var rDateTimePacketData = this.m_PacketDataArray[nXScalePacketIndex];

            var RQPacketsItem = new CRQPacketsItem(this.m_strRQ, this.m_RQInfo.m_nCycle, this.m_RQInfo.m_nInterval);

            rDateTimePacketData.AppendRealDateTimeT( tEndDateTime, rDateTimePacketData.m_strPacketSubType, true);

            RQPacketsItem.m_Packets[rDateTimePacketData.m_nPacketIndex] = rDateTimePacketData.GetData(rDateTimePacketData.GetDataArraySize() - 1);

            var nResult = 0x10;//append

            for (nPacketIndex = 0; nPacketIndex < nLength; nPacketIndex++) {

                if (nPacketIndex === nXScalePacketIndex)
                    continue;

                if (RealDataArray[nPacketIndex] === null)
                    continue;

                var Data = RealDataArray[nPacketIndex];

                var rPacketData = this.m_PacketDataArray[nPacketIndex];
                var nEndIndex = rPacketData.GetDataArraySize();

                nResult |= rPacketData.AppendRealData(nEndIndex, Data);
                RQPacketsItem.m_Packets[rPacketData.m_nPacketIndex] = rPacketData.GetData(rPacketData.GetDataArraySize() - 1);

                if (nPacketIndex === this.m_nClosePacketIndex) {

                    if (this.m_nHighPacketIndex >= 0) {
                        var rHighPacketData = this.m_PacketDataArray[this.m_nHighPacketIndex];
                        nResult |= rHighPacketData.AppendRealData(nEndIndex, Data);
                        RQPacketsItem.m_Packets[rHighPacketData.m_nPacketIndex] = rHighPacketData.GetData(rHighPacketData.GetDataArraySize() - 1);
                    }

                    if (this.m_nLowPacketIndex >= 0) {
                        var rLowPacketData = this.m_PacketDataArray[this.m_nLowPacketIndex];
                        nResult |= rLowPacketData.AppendRealData(nEndIndex, Data);
                        RQPacketsItem.m_Packets[rLowPacketData.m_nPacketIndex] = rLowPacketData.GetData(rLowPacketData.GetDataArraySize() - 1);
                    }

                    if (this.m_nOpenPacketIndex >= 0) {
                        var rOpenPacketData = this.m_PacketDataArray[this.m_nOpenPacketIndex];
                        nResult |= rOpenPacketData.AppendRealData(nEndIndex, Data);
                        RQPacketsItem.m_Packets[rOpenPacketData.m_nPacketIndex] = rOpenPacketData.GetData(rOpenPacketData.GetDataArraySize() - 1);
                    }

                    /////////////////////////////////////////////////////////////////////
                    //사용할 곳에서 계산하지 않고 미리 한곳에서 계산하여 속도향상을 한다
                    this.SetRealCurPrice(Data);
                    /////////////////////////////////////////////////////////////////////
                }
            }

            if (PrevRQPacketsItem) {
                RQPacketsItem.m_rPrevRQPacketsItem = PrevRQPacketsItem;
                PrevRQPacketsItem.m_rNextRQPacketsItem = RQPacketsItem;
            }

            RQPacketsItem.m_rXScalePacketData = RQPacketsItem.m_Packets[nXScalePacketIndex];

            rXScaleMng.SetRQPacketsItem(this.m_strRQ, RQPacketsItem.m_Packets[nXScalePacketIndex], RQPacketsItem);

            var i, nLength = this.m_PacketCalculatorArray.length;
            for (i = 0; i < nLength; i++) {
                this.m_PacketCalculatorArray[i].RealCalc(true);
            }

            nLength = this.m_GraphArray.length;
            for (i = 0; i < nLength; i++) {
                var rGraph = this.m_GraphArray[i];
                rGraph.RealCalc(true);
            }

            return nResult;
        }//append
    }
    return -1;
}

//사용할 곳에서 계산하지 않고 미리 한곳에서 계산하여 속도향상을 한다
CRQSet.prototype.SetRealCurPrice = function (CurPrice) {

    var PrevPrice = this.m_RQInfo.m_PrevPrice;
    this.m_RQInfo.m_CurPrice = CurPrice;//현재가 셋팅
    this.m_RQInfo.m_PriceChange = CurPrice - PrevPrice;//대비계산
    this.m_RQInfo.m_ChangeRatio = this.m_RQInfo.m_PriceChange / PrevPrice * 100;//등락율 계산
}
CRQSet.prototype.GetPacketDataArraySize = function () {
    return this.m_PacketDataArray.length;
}
CRQSet.prototype.GetPacketData = function (strPacketName) {

    for (var i = 0; i < this.m_PacketDataArray.length; i++) {
        var PacketData = this.m_PacketDataArray[i];
        if (PacketData.m_strPacketName == strPacketName)
            return PacketData;//이미 존재
    }
    return null;
}
CRQSet.prototype.RemoveAllDataInPacketData = function () {

    for (var i = 0; i < this.m_PacketDataArray.length; i++) {
        this.m_PacketDataArray[i].RemoveAllData();
    }
}

CRQSet.prototype.SetRQInfo = function (RQInfo) {

    this.m_RQInfo = clone(RQInfo);

    this.m_RQInfo.m_nCycle = Number(this.m_RQInfo.m_nCycle);//1:일, 2:주
    this.m_RQInfo.m_nInterval = Number(this.m_RQInfo.m_nInterval);//N 간격
    this.m_RQInfo.m_nRequestDataCnt = Number(this.m_RQInfo.m_nRequestDataCnt);

    this.m_nPriceDigit = GetDigit(this.m_RQInfo.m_strPriceDigit);
    this.m_nOrderUnitQty = GetDigit(this.m_RQInfo.m_strOrderUnitQty);
}
//LJH 2019.01.02 연속조회 키 추가
CRQSet.prototype.SetRQInfoNextKey = function (strNextKey) {
    this.m_RQInfo.m_strNextKey = strNextKey;
}
CRQSet.prototype.GetRQInfo = function (RQInfo) {
    RQInfo = clone(this.m_RQInfo);
}
CRQSet.prototype.GetCycle = function () {
    return this.m_RQInfo.m_nCycle;
}
CRQSet.prototype.GetInterval = function () {
    return this.m_RQInfo.m_nInterval;
}
CRQSet.prototype.GetMarketStartTime = function () {
    return this.m_RQInfo.m_strMarketStartTime;
}
CRQSet.prototype.GetMarketEndTime = function () {
    return this.m_RQInfo.m_strMarketEndTime;
}
CRQSet.prototype.SetRQ = function (strRQ) {
    this.m_strRQ = strRQ;

    // 20190115 전중현 : 기준선 관리자 생성
    this.m_GuideLineMng.CreateGuideLineMng( this);
}
CRQSet.prototype.GetRQ = function () {
    return this.m_strRQ;
}
CRQSet.prototype.GetPacketDataByName = function (strPacketName) {
    var i;
    for (i = 0; i < this.m_PacketDataArray.length; i++) {
        if (this.m_PacketDataArray[i].m_strPacketName == strPacketName)
            return this.m_PacketDataArray[i];
    }
    return null;
}
CRQSet.prototype.GetPacketDataByIndex = function (nIndex) {
    if (0 <= nIndex && nIndex < this.m_PacketDataArray.length)
        return this.m_PacketDataArray[nIndex];
    return null;
}
CRQSet.prototype.GetCalcPacketDataByIndex = function (nIndex) {
    if (0 <= nIndex && nIndex < this.m_PacketCalculatorArray.length)
        return this.m_PacketCalculatorArray[nIndex];
    return null;
}
CRQSet.prototype.AddGraph = function (rGraph) {
    this.m_GraphArray.push(rGraph);
}
CRQSet.prototype.GetSelectedGraph = function () {
    return this.m_rSelectGraph;
}
CRQSet.prototype.SelectGraphByKey = function (strGraphKey) {

    var i, j, rSelectGraph = null;

    if (this.m_rSelectGraph)
        this.m_rSelectGraph.Select(false);

    var length = this.m_GraphArray.length;
    for (i = 0; i < length; i++) {
        var rGraph = this.m_GraphArray[i];
        if (rGraph.m_strKey == strGraphKey) {

            //블록안에서는 하나만 선택되도록 처리
            var rBlock = rGraph.m_rBlock;
            var nGraphLength = rBlock.m_GraphArray.length;
            for (j = 0; j < nGraphLength; j++)
                rBlock.m_GraphArray[j].Select(false);

            rGraph.Select(true);
            this.m_rSelectGraph = rGraph;
            return rGraph;
        }
    }
    return null;
}
CRQSet.prototype.SelectGraph = function (rGraph) {

    if (this.m_rSelectGraph)
        this.m_rSelectGraph.Select(false);

    //블록안에서는 하나만 선택되도록 처리
    var rBlock = rGraph.m_rBlock;
    var nGraphLength = rBlock.m_GraphArray.length;
    for (var j = 0; j < nGraphLength; j++)
        rBlock.m_GraphArray[j].Select(false);

    rGraph.Select(true);
    this.m_rSelectGraph = rGraph;
}

// 20190115 전중현 : 기준선 설정 정보 받아오기
CRQSet.prototype.GetPropertyInfo = function () {
    
    this.m_GuideLineMng.GetPropertyInfo();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//LJH 2018.1.11 TRIANGLE_TOOL 추가
export const TOOL_TYPE = {
    LINE_TOOL: 0,
    RECT_TOOL: 1,
    CIRCLE_TOOL: 2,
    VERT_LINE_TOOL: 3,
    HOZR_LINE_TOOL: 4,
    CROSS_LINE_TOOL: 5,
    TRIANGLE_TOOL: 6
}
export var LINE_TOOL = 0, RECT_TOOL = 1, CIRCLE_TOOL = 2, VERT_LINE_TOOL = 3, HOZR_LINE_TOOL = 4, CROSS_LINE_TOOL = 5, TRIANGLE_TOOL = 6;
export var START_POS = 1, END_POS = 2, LINE_POS = 3;

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//CBaseTool
export function CBaseTool(rXScaleMng, rRQSet, rChartBlock) {
    this.m_rRQSet = rRQSet;
    this.m_rXScaleMng = rXScaleMng;
    this.m_rChartBlock = rChartBlock;
    this.m_ToolInfo = null;
    this.m_rectClip = null;
    this.m_bSelected = false;

    //클릭한 위치정보
    this.m_nHitTestPosInfo = 0;//도형에 따라 정보값은 달라진다 (예:선인 경우=>START_POS(클릭한 위치가 시작점), END_POS(클릭한 위치가 끝점), LINE_POS(클릭한 위치가 선분))
    this.m_HitPosition = null;

    //Copy 대상 아닌 변수들
    this.m_srcTool = null;//이동을 위한 복사본인 경우만 원본 레퍼런스를 저장하는 변수(복사본의 내용을 원본에 적용할 때 필요)
    this.m_bDelete = false;//이동 중 마우스가 영역 밖으로 나가면 삭제를 하기 위해 사용하는 삭제 플래그
    this.m_nSelectedIndex = null;//선택하여 이동시 선택된 툴의 배열에서 인덱스 번호값 임시저장(삭제시 배열에서 삭제처리필요)
    this.m_bReCalc = false;  // 설정창을 연동하여 가격이나 일자, 옵션등이 바뀌었을 경우 재계산을 위해 사용
}
CBaseTool.prototype.SetSelectedIndex = function (nIndex) {
    this.m_nSelectedIndex = nIndex;
}
CBaseTool.prototype.GetSelectedIndex = function () {
    return this.m_nSelectedIndex;
}
CBaseTool.prototype.SetDelete = function (bDelete) {
    this.m_bDelete = bDelete;
}
CBaseTool.prototype.IsDelete = function () {
    return this.m_bDelete;
}
CBaseTool.prototype.SetSrcTool = function (srcTool) {
    this.m_srcTool = srcTool;
}
CBaseTool.prototype.Draw = function (DrawingInfo) {
}
CBaseTool.prototype.IsInMine = function (X, Y) {
    return false;
}
CBaseTool.prototype.DrawToolOnMouseMove = function (DrawingInfo) {
}
CBaseTool.prototype.Copy = function (rCopy) {
    //return clone(this);
    return null;
}
CBaseTool.prototype.OnMouseMove = function (e, rCurChartBlock) {

}
CBaseTool.prototype.OnMouseUp = function (e) {

}

function CFindStartXIndexInBongRange() {
    this.m_nFindXIndex = null;
    this.m_tFindDateTime = null;
    this.m_nXScaleItemArrayIndex = null;
    this.m_rDateTimeXScaleItem = null;
}
var gFindStartXIndexInBongRange = new CFindStartXIndexInBongRange();

CBaseTool.prototype.FindStartXIndexInBongRange = function (strRQ, rXScaleMng, nFindXIndex, nXScaleItemArrayIndex, rDateTimeXScaleItem) {

    var tDateTime = null;
    var nXScaleIndex = null;

    if (nXScaleItemArrayIndex === undefined || rDateTimeXScaleItem === undefined) {

        rDateTimeXScaleItem = new CDateTimeXScaleItem(rXScaleMng);
        nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(nFindXIndex, 0, rXScaleMng.m_XScaleItemArray.length - 1, rDateTimeXScaleItem, true);
        if (nXScaleItemArrayIndex < 0 || rDateTimeXScaleItem === null)
            return null;
    }

    var bFutureTime = rDateTimeXScaleItem.m_bFutureTime;
    tDateTime = rDateTimeXScaleItem.m_tFindIndexTimeT;
    nXScaleIndex = nXScaleItemArrayIndex;

    if (rXScaleMng.m_tTimeArray[tDateTime] !== undefined) {

        var bDataSet = false;
        var rRQPackets = rXScaleMng.m_tTimeArray[tDateTime][strRQ];
        if (rRQPackets === undefined) {

            var strKey = strRQ + "_TIME";
            var tPrevStartDateTime = rXScaleMng.m_tTimeArray[tDateTime][strKey];
            if (tPrevStartDateTime !== undefined) {

                if (rXScaleMng.m_tTimeArray[tPrevStartDateTime] !== undefined) {
                    rRQPackets = rXScaleMng.m_tTimeArray[tPrevStartDateTime][strRQ];
                    if (rRQPackets !== undefined) {

                        tDateTime = tPrevStartDateTime;

                        //for (nXScaleIndex = nXScaleItemArrayIndex; (nFindXIndex = rDateTimeXScaleItem.GetIndexByDateTimeT(tDateTime)) === -2 && nXScaleIndex > 0;)
                        //    rDateTimeXScaleItem = rXScaleMng.m_XScaleItemArray[--nXScaleIndex];
                        nFindXIndex = rRQPackets.m_rXScaleMergeIndex.m_nIndex;
                        nXScaleIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(nFindXIndex, nXScaleIndex, 0, rDateTimeXScaleItem, true);
                        if (nXScaleIndex < 0 || rDateTimeXScaleItem === null)
                            return null;
                    }
                }
            }
            else {//rq에 소속된 봉이 위치해 있지 않은 영역을 클릭한 경우 (해당영역의 최소단위, 최소봉계산)

                bDataSet = true;
                nXScaleIndex = nXScaleItemArrayIndex;
            }
        }

        if (rRQPackets !== undefined || bDataSet === true) {

            gFindStartXIndexInBongRange.m_nFindXIndex = nFindXIndex;
            gFindStartXIndexInBongRange.m_nXScaleItemArrayIndex = nXScaleIndex;
            gFindStartXIndexInBongRange.m_rDateTimeXScaleItem = rDateTimeXScaleItem;
            gFindStartXIndexInBongRange.m_tFindDateTime = tDateTime;

            return gFindStartXIndexInBongRange;
        }
    }
    //미래여백에 추세선 존재하는 경우
    else if (bFutureTime) {

        gFindStartXIndexInBongRange.m_nFindXIndex = nFindXIndex;
        gFindStartXIndexInBongRange.m_nXScaleItemArrayIndex = nXScaleIndex;
        gFindStartXIndexInBongRange.m_rDateTimeXScaleItem = rDateTimeXScaleItem;
        gFindStartXIndexInBongRange.m_tFindDateTime = tDateTime;

        return gFindStartXIndexInBongRange;
    }

    return null;
}

//nStartXIndex부터 nEndXIndex까지의 RQ그래프 이동 봉거리 계산
CBaseTool.prototype.CountMoveBongCnt = function (nStartXIndex, nEndXIndex, nXScaleItemArrayIndex, rXScaleMng, strRQ) {

    var bFinishCount = false;
    var nMoveBongCnt = 0;
    var tPrevTime = null;
    
    var nXScaleItemLastIndex = rXScaleMng.m_XScaleItemArray.length - 1;
    var bIncludeFuture = false;

    var nXScaleMergeArrayLength = rXScaleMng.m_XScaleMergeArray.length;
    var nSXIndex = (nStartXIndex < nXScaleMergeArrayLength ? nStartXIndex : null);
    var nEXIndex = (nEndXIndex < nXScaleMergeArrayLength ? nEndXIndex : nXScaleMergeArrayLength - 1);
    var nXIndex = nSXIndex;

    var rRQPackets = undefined;
    var strKey = strRQ + "_TIME";
    var tTime = null;

    if (nSXIndex !== null) {

        while (nXIndex <= nEXIndex) {

            var rXScaleMergeIndex = rXScaleMng.m_XScaleMergeArray[nXIndex];
            rRQPackets = rXScaleMergeIndex.m_mapRQPacketsItem[strRQ];
            tTime = rXScaleMergeIndex.m_tStart;

            if (rRQPackets === undefined) {

                var tPrevStartDateTime = rXScaleMng.m_tTimeArray[tTime][strKey];
                if (tPrevStartDateTime !== undefined) {

                    if (rXScaleMng.m_tTimeArray[tPrevStartDateTime] !== undefined)
                        tTime = tPrevStartDateTime;
                    else {
                        nXIndex++;
                        continue;
                    }
                }
            }
            else//rq 데이터가 존재하는 경우는 시간값을 더 정확하게 셋팅
                tTime = rRQPackets.m_rXScalePacketData.m_tDateTime;
            
            if (tPrevTime !== tTime) {
                if (tPrevTime)
                    nMoveBongCnt++;//이동한 실제 봉 갯수

                tPrevTime = tTime;
            }

            //if (rRQPackets)//위치에 rq봉이 존재하는 경우
            //    nXIndex += rRQPackets.m_nRelativeEndIndex;
            //else//위치에 rq봉이 존재하지 않는 경우는 최소봉만큼 이동
            //  nXIndex++;
            nXIndex++;
        }

        //미래영역 포함처리
        if (nEXIndex < nEndXIndex) {

            var rXScaleItem = rXScaleMng.m_XScaleItemArray[nXScaleItemLastIndex];

            while (nXIndex <= nEndXIndex) {

                var tTime = rXScaleItem.GetDateTimeTByIndex(nXIndex, true);
                if (rXScaleMng.m_tTimeArray[tTime] === undefined) {

                    if (rXScaleItem.m_tEnd <= tTime)//미래여백의 시간 위치
                    {
                        if (tPrevTime)
                            nMoveBongCnt++;

                        tPrevTime = tTime;
                    }

                    nXIndex++;
                    continue;
                }

                rRQPackets = rXScaleMng.m_tTimeArray[tTime][strRQ];
                if (rRQPackets === undefined) {

                    var tPrevStartDateTime = rXScaleMng.m_tTimeArray[tTime][strKey];
                    if (tPrevStartDateTime !== undefined) {

                        tTime = tPrevStartDateTime;
                    }
                    else {

                        nXIndex++;
                        continue;
                    }
                }

                if (tPrevTime !== tTime) {
                    if (tPrevTime)
                        nMoveBongCnt++;//이동한 실제 봉 갯수

                    tPrevTime = tTime;
                }

                //if (rRQPackets)//위치에 rq봉이 존재하는 경우
                //    nXIndex += rRQPackets.m_nRelativeEndIndex;
                //else//위치에 rq봉이 존재하지 않는 경우는 최소봉만큼 이동
                //    nXIndex++;
                nXIndex++;
            }
        }
    }
    else {

        //미래영역 포함처리(start, end 모두 미래영역인 경우)
        nXIndex = nStartXIndex;

        var rXScaleItem = rXScaleMng.m_XScaleItemArray[nXScaleItemLastIndex];

        while (nXIndex <= nEndXIndex) {

            var tTime = rXScaleItem.GetDateTimeTByIndex(nXIndex, true);

            if (rXScaleItem.m_tEnd <= tTime)//미래여백의 시간 위치
            {
                if (tPrevTime)
                    nMoveBongCnt++;

                tPrevTime = tTime;
            }

            nXIndex++;
        }
    }
    
    return nMoveBongCnt;
}

function CResultMoveIndex() {
    this.m_nNewIndex = null;
    this.m_tNewDateTime = null;
    this.m_nBongCnt = 0;
}
var gResultMoveIndex = new CResultMoveIndex();

CBaseTool.prototype.MoveUpperIndex = function (MoveStartXIndex, tMoveStartDateTime, nMoveBongCnt, nFindStartXScaleItemArrayIndex, bIsUpper, rXScaleMng, strRQ) {

    var rDateTimeXScaleItem = new CDateTimeXScaleItem(rXScaleMng);
    var nXScaleItemArrayIndex = null;

    if (bIsUpper)
        nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(MoveStartXIndex, nFindStartXScaleItemArrayIndex, rXScaleMng.m_XScaleItemArray.length - 1, rDateTimeXScaleItem, true);
    else
        nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(MoveStartXIndex, nFindStartXScaleItemArrayIndex, 0, rDateTimeXScaleItem, true);

    if (nXScaleItemArrayIndex < 0 || rDateTimeXScaleItem === null) {
        //console.log("OnMouseMove 6");
        return null;
    }

    var tPrevTime = null;
    var nXIndex = MoveStartXIndex, nNewXIndex = MoveStartXIndex;
    var tNewDateTime = tMoveStartDateTime;
    var nBongCnt = 0;
    var nLength = rXScaleMng.m_XScaleItemArray.length;
    var bFinishMove = false;

    if (rDateTimeXScaleItem.m_bFutureTime === false) {

        for (var nXScaleIndex = nXScaleItemArrayIndex; nXScaleIndex < nLength; nXScaleIndex++) {

            var rXScaleItem = rXScaleMng.m_XScaleItemArray[nXScaleIndex];

            var nRangeStartIndex = rXScaleItem.GetStartPos();
            var nRangeEndIndex = nRangeStartIndex + rXScaleItem.GetIntervalCnt() - 1;

            while (nRangeStartIndex <= nXIndex && nXIndex <= nRangeEndIndex) {

                if (nBongCnt >= nMoveBongCnt) {
                    bFinishMove = true;
                    break;
                }

                var tTime = rXScaleItem.GetDateTimeTByIndex(nXIndex);
                if (rXScaleMng.m_tTimeArray[tTime] === undefined) {
                    nXIndex++;
                    continue;
                }

                var rRQPackets = rXScaleMng.m_tTimeArray[tTime][strRQ];
                if (rRQPackets === undefined) {
                    var strKey = strRQ + "_TIME";
                    var tPrevStartDateTime = rXScaleMng.m_tTimeArray[tTime][strKey];
                    if (tPrevStartDateTime !== undefined) {

                        if (rXScaleMng.m_tTimeArray[tPrevStartDateTime] !== undefined)
                            tTime = tPrevStartDateTime;
                        else {
                            nXIndex++;
                            continue;
                        }
                    }
                }

                if (tPrevTime !== tTime) {
                    if (tPrevTime)
                        nBongCnt++;//이동할 실제 봉 갯수

                    tPrevTime = tTime;
                    nNewXIndex = nXIndex;
                    tNewDateTime = tTime;
                }

                if (rRQPackets)
                    nXIndex += rRQPackets.m_nRelativeEndIndex;
                else
                    nXIndex++;
            }
            if (nBongCnt >= nMoveBongCnt) {
                bFinishMove = true;
                break;
            }
        }

        if (bFinishMove === false)
            nXIndex--;
    }

    if (bFinishMove === false) {

        var nDiffCount = nMoveBongCnt - nBongCnt;
        nBongCnt = nMoveBongCnt;

        nNewXIndex = nXIndex + nDiffCount;
        tNewDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(nNewXIndex, true);
    }

    gResultMoveIndex.m_nBongCnt = nBongCnt;
    gResultMoveIndex.m_nNewIndex = nNewXIndex;
    gResultMoveIndex.m_tNewDateTime = tNewDateTime;

    return gResultMoveIndex;
}

CBaseTool.prototype.MoveLowerIndex = function (MoveStartXIndex, tMoveStartDateTime, nMoveBongCnt, nFindStartXScaleItemArrayIndex, bIsUpper, rXScaleMng, strRQ) {

    var rDateTimeXScaleItem = new CDateTimeXScaleItem(rXScaleMng);
    var nXScaleItemArrayIndex = null;

    if (bIsUpper)
        nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(MoveStartXIndex, nFindStartXScaleItemArrayIndex, rXScaleMng.m_XScaleItemArray.length - 1, rDateTimeXScaleItem, true);
    else
        nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(MoveStartXIndex, nFindStartXScaleItemArrayIndex, 0, rDateTimeXScaleItem, true);

    if (nXScaleItemArrayIndex < 0 || rDateTimeXScaleItem === null)
        return null;

    var tPrevTime = null;
    var nXIndex = MoveStartXIndex, nNewXIndex = MoveStartXIndex;
    var tNewDateTime = tMoveStartDateTime;
    var nBongCnt = 0;
    var nLength = rXScaleMng.m_XScaleItemArray.length;

    var bFinishMove = false;
    if (rDateTimeXScaleItem.m_bFutureTime) {

        var nRangeStartIndex = rDateTimeXScaleItem.GetStartPos();
        var nRangeEndIndex = nRangeStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;

        //미래영역에 MoveStartXIndex가 존재하는 경우는 nRagneEndIndex보다 큰값(우측)이다
        nBongCnt = MoveStartXIndex - nRangeEndIndex;
        if (nBongCnt > nMoveBongCnt) {//미래여백 내에서 이동

            bFinishMove = true;
            nNewXIndex = nXIndex - nMoveBongCnt;
            tNewDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(nNewXIndex, true);
        }
        else {
            nXIndex -= nBongCnt;//미래여백에서 실제데이터시간 영역으로 이동

            tPrevTime = rDateTimeXScaleItem.GetDateTimeTByIndex(nXIndex);
            nNewXIndex = nXIndex;
            tNewDateTime = tPrevTime;
        }
    }

    if (bFinishMove === false) {

        for (var nXScaleIndex = nXScaleItemArrayIndex; nXScaleIndex >= 0; nXScaleIndex--) {

            var rXScaleItem = rXScaleMng.m_XScaleItemArray[nXScaleIndex];

            var nRangeStartIndex = rXScaleItem.GetStartPos();
            var nRangeEndIndex = nRangeStartIndex + rXScaleItem.GetIntervalCnt() - 1;

            while (nRangeStartIndex <= nXIndex && nXIndex <= nRangeEndIndex) {

                if (nBongCnt > nMoveBongCnt)
                    break;

                var tTime = rXScaleItem.GetDateTimeTByIndex(nXIndex);
                if (rXScaleMng.m_tTimeArray[tTime] === undefined) {
                    nXIndex--;
                    continue;
                }

                var rRQPackets = rXScaleMng.m_tTimeArray[tTime][strRQ];
                if (rRQPackets === undefined) {
                    var strKey = strRQ + "_TIME";
                    var tPrevStartDateTime = rXScaleMng.m_tTimeArray[tTime][strKey];
                    if (tPrevStartDateTime !== undefined) {

                        if (rXScaleMng.m_tTimeArray[tPrevStartDateTime] !== undefined) {

                            rRQPackets = rXScaleMng.m_tTimeArray[tPrevStartDateTime][strRQ];
                            if (rRQPackets === undefined) {
                                nXIndex--;
                                continue;
                            }
                            tTime = tPrevStartDateTime;
                            nXIndex = rRQPackets.m_rXScaleMergeIndex.m_nIndex;
                        }
                        else {
                            nXIndex--;
                            continue;
                        }
                    }
                }

                if (tPrevTime !== tTime) {
                    if (tPrevTime)
                        nBongCnt++;//이동할 실제 봉 갯수

                    tPrevTime = tTime;
                    nNewXIndex = nXIndex;
                    tNewDateTime = tTime;
                }

                nXIndex--;

                if (nBongCnt >= nMoveBongCnt)
                    break;
            }

            if (nBongCnt >= nMoveBongCnt)
                break;
        }

    }

    gResultMoveIndex.m_nBongCnt = nBongCnt;
    gResultMoveIndex.m_nNewIndex = nNewXIndex;
    gResultMoveIndex.m_tNewDateTime = tNewDateTime;

    return gResultMoveIndex;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
function CBaseToolInfo(nToolType, nXScaleType, KeyCode, Cycle, nInterval) {
    //console.log("Tool________nToolType:" + nToolType);
    this.m_nToolType = nToolType;
    this.m_nXScaleType = nXScaleType;
    this.m_KeyCode = KeyCode;
    this.m_Cycle = Cycle;
    this.m_nInterval = nInterval;
    this.m_KeyNumber = Date.now();
    this.m_nThickness = 1;
    this.m_nToolLineType = PS_SOLID;
    this.m_clrTool = "#23987F";
    this.m_ColIndex = null;
    this.m_RowIndex = null;
}

CBaseToolInfo.prototype.SetPropertyInfo = function (rSrcBaseToolProperty)
{
    if (rSrcBaseToolProperty === undefined)
        return false;

    this.m_nToolType = rSrcBaseToolProperty.m_nToolType;
    this.m_nXScaleType = rSrcBaseToolProperty.m_nXScaleType;
    this.m_KeyCode = rSrcBaseToolProperty.m_KeyCode;
    this.m_Cycle = rSrcBaseToolProperty.m_Cycle;
    this.m_nInterval = rSrcBaseToolProperty.m_nInterval;
    this.m_KeyNumber = rSrcBaseToolProperty.m_KeyNumber;
    this.m_nThickness = rSrcBaseToolProperty.m_nThickness;
    this.m_nToolLineType = rSrcBaseToolProperty.m_nToolLineType;
    this.m_clrTool = rSrcBaseToolProperty.m_clrTool;
    this.m_ColIndex = rSrcBaseToolProperty.m_ColIndex;
    this.m_RowIndex = rSrcBaseToolProperty.m_RowIndex;

    return true;
}

CBaseToolInfo.prototype.Copy = function (rCopy) {
    rCopy.m_nToolType = this.m_nToolType;
    rCopy.m_nXScaleType = this.m_nXScaleType;
    rCopy.m_KeyCode = this.m_KeyCode;
    rCopy.m_Cycle = this.m_Cycle;
    rCopy.m_nInterval = this.m_nInterval;
    rCopy.m_KeyNumber = this.m_KeyNumber;
    rCopy.m_nThickness = this.m_nThickness;
    rCopy.m_nToolLineType = this.m_nToolLineType;
    rCopy.m_clrTool = this.m_clrTool;
    rCopy.m_ColIndex = this.m_ColIndex;
    rCopy.m_RowIndex = this.m_RowIndex;
}

export function CBasicToolInfo( nToolType, nXScaleType, KeyCode, Cycle, nInterval, strToolKey) {

    //console.log("Tool________strToolKey:" + strToolKey);

    CBaseToolInfo.call(this, nToolType, nXScaleType, KeyCode, Cycle, nInterval);

    this.m_strToolKey = "";
    if (strToolKey === undefined)
        this.m_strToolKey = "LINE_" + this.m_KeyNumber;
    else//저장 로드시 사용됨
        this.m_strToolKey = strToolKey;

    this.m_StartDateTimeT = null;
    this.m_strStartDateTime = null;
    this.m_StartXIndex = null;
    this.m_StartYValue = null;
    this.m_strStartValue = null;

    this.m_EndDateTimeT = null;
    this.m_strEndDateTime = null;
    this.m_EndXIndex = null;
    this.m_EndYValue = null;
    this.m_strEndValue = null;

    this.m_clrTool = "#23987F";
    this.m_nThickness = 1;

    this.m_bExpandLeft = false;
    this.m_bExpandRight = false;

    this.m_bShowLeftText = false;
    this.m_bShowRightText = false;
    this.m_bShowTopText = false;
    this.m_bShowBottomText = false;
}
CBasicToolInfo.prototype = new CBaseToolInfo();
CBasicToolInfo.prototype.constructor = CBasicToolInfo;

CBasicToolInfo.prototype.SetPropertyInfo = function (rSrcToolProperty)
{
    if (rSrcToolProperty === undefined)
        return false;

    CBaseToolInfo.prototype.SetPropertyInfo.call(this, rSrcToolProperty);

    this.m_strToolKey = rSrcToolProperty.m_strToolKey;

    this.m_StartDateTimeT = rSrcToolProperty.m_StartDateTimeT;
    this.m_strStartDateTime = rSrcToolProperty.m_strStartDateTime;
    this.m_StartXIndex = rSrcToolProperty.m_StartXIndex;
    this.m_StartYValue = rSrcToolProperty.m_StartYValue;
    this.m_strStartValue = rSrcToolProperty.m_strStartValue;

    this.m_EndDateTimeT = rSrcToolProperty.m_EndDateTimeT;
    this.m_strEndDateTime = rSrcToolProperty.m_strEndDateTime;
    this.m_EndXIndex = rSrcToolProperty.m_EndXIndex;
    this.m_EndYValue = rSrcToolProperty.m_EndYValue;
    this.m_strEndValue = rSrcToolProperty.m_strEndValue;
   
    this.m_bExpandLeft = rSrcToolProperty.m_bExpandLeft;
    this.m_bExpandRight = rSrcToolProperty.m_bExpandRight;

    this.m_bShowLeftText = rSrcToolProperty.m_bShowLeftText;
    this.m_bShowRightText = rSrcToolProperty.m_bShowRightText;
    this.m_bShowTopText = rSrcToolProperty.m_bShowTopText;
    this.m_bShowBottomText = rSrcToolProperty.m_bShowBottomText;

    return true;
}

CBasicToolInfo.prototype.SetStringDateTime = function ( ChartUniversalTime )
{
    var tDateTime;
    if( this.m_StartDateTimeT !== null )
    {
        tDateTime = Number( this.m_StartDateTimeT );
        this.m_strStartDateTime = GetStrDateTimeBytTime( ChartUniversalTime, tDateTime, this.m_Cycle, false );
    }
    if( this.m_EndDateTimeT !== null )
    {
        tDateTime = Number( this.m_EndDateTimeT );
        this.m_strEndDateTime = GetStrDateTimeBytTime( ChartUniversalTime, tDateTime, this.m_Cycle, false );
    }
}

CBasicToolInfo.prototype.SetStringPrice = function ( rChartBlock )
{
    if( rChartBlock === undefined )
        return false;
    
    var rYScale = rChartBlock.GetSelectedYScale();
    if( rYScale === undefined )
        return false;

    if( this.m_StartYValue !== null )
    {
        this.m_strStartValue = ConvertNumToDigitText(this.m_StartYValue, rYScale.m_nDec, 1, rYScale.m_nDigit, -1, rChartBlock.m_rGlobalProperty.m_bShowThousandComma);
    }

    if( this.m_EndYValue !== null )
    {
        this.m_strEndValue = ConvertNumToDigitText(this.m_EndYValue, rYScale.m_nDec, 1, rYScale.m_nDigit, -1, rChartBlock.m_rGlobalProperty.m_bShowThousandComma);
    }
}

CBasicToolInfo.prototype.SetPriceToString = function ()
{
    var strPrice;
    if( this.m_strStartValue !== null )
    {
        strPrice = this.m_strStartValue.replace(/\,/g,'');
        this.m_StartYValue = Number( strPrice );
    }
    if( this.m_strEndValue !== null )
    {
        strPrice = this.m_strEndValue.replace(/\,/g,'');
        this.m_EndYValue = Number( strPrice );
    }
}

CBasicToolInfo.prototype.SetDatetPosToString = function ( rRQSet, rXScaleMng, rChartBlock )
{
    if( rRQSet === undefined || rXScaleMng === undefined )
        return false;

    if( rXScaleMng.m_nType === DATETIME_TYPE)
    {
        var rDateTimePacket = rRQSet.GetPacketData("_DATETIME_");
        if (rDateTimePacket === null )
            return false;

        var tDateTime;
        var strDateTimeType = rDateTimePacket.m_DataArray[0].m_strDateTimeType;
        if( this.m_strStartDateTime !== null )
        {
            tDateTime = GetDateTimeByString( this.m_strStartDateTime, strDateTimeType, this.m_Cycle, rRQSet.GetMarketStartTime() );
            this.m_StartDateTimeT = tDateTime;
        }
        if( this.m_strEndDateTime !== null )
        {
            tDateTime = GetDateTimeByString( this.m_strEndDateTime, strDateTimeType, this.m_Cycle, rRQSet.GetMarketStartTime() );
            this.m_EndDateTimeT = tDateTime;
        }

        this.SetToolXPos( rXScaleMng, rChartBlock, true );
    }
}

CBasicToolInfo.prototype.SetToolXPos = function ( rXScaleMng, rChartBlock, bUserSetup  )
{
    var nFindXIndex;
    if( this.m_StartDateTimeT !== null )
    {
        // 현재 데이터보다 과거의 날짜로 세팅되어 있는경우
        if( rXScaleMng.m_XScaleMergeArray[0].m_tStart > this.m_StartDateTimeT )
        {
            if( bUserSetup === true)
            {
                nFindXIndex = 0;
                this.m_StartDateTimeT =rXScaleMng.GetDateTimeTByIndex( nFindXIndex );
            }
            else
                nFindXIndex = -1;
        }
        else
        {
            nFindXIndex = rXScaleMng.GetIndexByDateTimeT( this.m_StartDateTimeT, true );
            if( nFindXIndex === null)
            {
                if( bUserSetup)
                    nFindXIndex = GetXIndexByXPos(rChartBlock.m_rectGraphBackground.m_nRight, rChartBlock.m_rectGraphRegion, rXScaleMng.m_nViewStartIndex, rXScaleMng.m_nViewEndIndex);
                else
                    nFindXIndex = -1;
            }
        }
        this.m_StartXIndex = nFindXIndex;
    }
    if( this.m_EndDateTimeT !== null )
    {
        // 현재 데이터보다 과거의 날짜로 세팅되어 있는경우
        if( rXScaleMng.m_XScaleMergeArray[0].m_tStart > this.m_EndDateTimeT )
        {
            if( bUserSetup === true)
            {
                nFindXIndex = 0;
                this.m_EndDateTimeT =rXScaleMng.GetDateTimeTByIndex( nFindXIndex );
            }
            else
                nFindXIndex = -1;
        }
        else
        {
            nFindXIndex = rXScaleMng.GetIndexByDateTimeT( this.m_EndDateTimeT, true );
            if( nFindXIndex === null)
            {
                if( bUserSetup)
                    nFindXIndex = GetXIndexByXPos(rChartBlock.m_rectGraphBackground.m_nRight, rChartBlock.m_rectGraphRegion, rXScaleMng.m_nViewStartIndex, rXScaleMng.m_nViewEndIndex);
                else
                    nFindXIndex = -1;
            }
        }
        this.m_EndXIndex = nFindXIndex;
    }
}

CBasicToolInfo.prototype.InitToolInfo = function () {

    this.m_clrTool = "#23987F";
    this.m_nToolLineType = PS_SOLID;
    this.m_nThickness = 1;
    
    this.m_bExpandLeft = false;
    this.m_bExpandRight = false;

    this.m_bShowLeftText = false;
    this.m_bShowRightText = false;
    this.m_bShowTopText = false;
    this.m_bShowBottomText = false;
}

CBasicToolInfo.prototype.Copy = function (rCopy) {

    if (rCopy === undefined )
        rCopy = new CBasicToolInfo();

    CBaseToolInfo.prototype.Copy.call(this, rCopy);

    rCopy.m_strToolKey = this.m_strToolKey;

    rCopy.m_StartDateTimeT = this.m_StartDateTimeT;
    rCopy.m_strStartDateTime = this.m_strStartDateTime;
    rCopy.m_StartXIndex = this.m_StartXIndex;
    rCopy.m_StartYValue = this.m_StartYValue;
    rCopy.m_strStartValue = this.m_strStartValue;

    rCopy.m_EndDateTimeT = this.m_EndDateTimeT;
    rCopy.m_strEndDateTime = this.m_strEndDateTime;
    rCopy.m_EndXIndex = this.m_EndXIndex;
    rCopy.m_EndYValue = this.m_EndYValue;
    rCopy.m_strEndValue = this.m_strEndValue;

    rCopy.m_bExpandLeft = this.m_bExpandLeft;
    rCopy.m_bExpandRight = this.m_bExpandRight;

    rCopy.m_bShowLeftText = this.m_bShowLeftText;
    rCopy.m_bShowRightText = this.m_bShowRightText;
    rCopy.m_bShowTopText = this.m_bShowTopText;
    rCopy.m_bShowBottomText = this.m_bShowBottomText;

    return rCopy;
}

//블록
function CToolBlockInfo(ColIndex, RowIndex) {
    this.m_ColIndex = ColIndex;
    this.m_RowIndex = RowIndex;
    this.m_ToolInfoArray = [];//툴배열속성
}

//주기
function CToolCycleInfo(nCycle) {
    this.m_nCycle = nCycle;
    this.m_ToolBlockInfoArray = [];//블록배열속성
}

//코드 키
function CToolKeyCodeInfo(KeyCode) {
    this.m_KeyCode = KeyCode;
    this.m_mapToolCycleInfo = {};//주기개체속성
}

//X Scale
function CToolXScaleInfo(nXScaleType) {
    this.m_nXScaleType = nXScaleType;
}

//DateTime X Scale (X Scale 종류별로 상속받아 구현할 수 있음-하위 그룹들이 XScale 종류에 따라 달라지므로 상속처리)
function CToolDateTimeXScaleInfo(nXScaleType) {
    CToolXScaleInfo.call(this, nXScaleType);
    this.m_mapKeyCodeInfo = {};
}
CToolDateTimeXScaleInfo.prototype = new CToolXScaleInfo();
CToolDateTimeXScaleInfo.prototype.constructor = CToolDateTimeXScaleInfo;

////////////////////////////////////////////////////////////////////////////////////////////////////
function CToolMng(rMainBlock) {
    this.m_ToolArray = [];
    this.m_rMainBlock = rMainBlock;
    this.m_mapToolXScaleInfo = {};
    this.m_nAddToolType = null;//LINE_TOOL(추세선), RECT_TOOL(사각 추세선), ...

    this.m_DrawingTool = null;
    this.m_MovingTool = null;
    this.m_SelectedTool = null;
    this.m_rCopyToolProperty = null;
    this.m_bDeleteFalg = false;
    this.m_strEraseType = 'eraser default';
}

CToolMng.prototype.SelectingTool = function (rTool) {

    this.UnSelectTool();
    this.SelectTool(rTool);
}
CToolMng.prototype.SelectTool = function (rTool) {
    this.m_SelectedTool = rTool;
    this.m_SelectedTool.m_bSelected = true;
}
CToolMng.prototype.UnSelectTool = function () {

    if (this.m_SelectedTool !== null ) {
        this.m_SelectedTool.m_bSelected = false;
        this.m_SelectedTool = null;
        return true;
    }
    return false;
}
CToolMng.prototype.DrawToolOnMouseMove = function (DrawingInfo) {

    if (this.m_DrawingTool !== null || Object.keys(this.m_mapToolXScaleInfo).length > 0) {

        this.m_rMainBlock.m_rChart.BitBlt();

        if (this.m_DrawingTool !== null && this.m_DrawingTool.IsDelete() === false) {
            this.m_DrawingTool.DrawToolOnMouseMove(DrawingInfo);
        }
    }
}

CToolMng.prototype.IsDrawingTool = function () {
    return (this.m_DrawingTool !== null);
}

CToolMng.prototype.OnMouseDown = function (e, rChartBlock) {

    var X = e.ChartXPos;
    var Y = e.ChartYPos;

    if (this.m_nAddToolType !== null) {//새로 추가

        var rSelectedGraph = rChartBlock.GetSelectedGraph();

        var rXScaleMng = rSelectedGraph.GetXScaleMng();

        if (rXScaleMng.m_nType === DATETIME_TYPE) {

            var rYScale = rSelectedGraph.GetYScale();
            var rRQSet = rSelectedGraph.GetRQSet();
            var nRightMargin = rChartBlock.m_rChart.GetGlobalProperty().GetRightMargin();

            var nViewDataCnt = rXScaleMng.m_nViewEndIndex - rXScaleMng.m_nViewStartIndex + 1;
            var nGraphRegionWidth = rChartBlock.m_rectGraphRegion.Width();
            if (nGraphRegionWidth + nRightMargin > 0) {

                var strRQ = rRQSet.GetRQ();
                var nFindXIndex = Math.floor((X - rChartBlock.m_rectGraphRegion.m_nLeft) * (nViewDataCnt / rChartBlock.m_rectGraphRegion.Width()) + rXScaleMng.m_nViewStartIndex);

                var rOutDateTimeXScaleItem = new CDateTimeXScaleItem(rXScaleMng);
                var nLastIndex = rXScaleMng.m_XScaleItemArray.length - 1;
                var nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(nFindXIndex, 0, nLastIndex, rOutDateTimeXScaleItem, true);
                if (nXScaleItemArrayIndex < 0 || rOutDateTimeXScaleItem === null)
                    return null;

                var yMin, yMax, yDiff, StartYValue;

                var bLog = rYScale.GetLog();
                var bInvert = rYScale.GetInvert();

                var tDateTime = rOutDateTimeXScaleItem.m_tFindIndexTimeT;
                //var nXScaleItemCycle = rOutDateTimeXScaleItem.m_nCycle;
                //var rXScaleItemInterval = rOutDateTimeXScaleItem.m_rInterval;

                if (rXScaleMng.m_tTimeArray[tDateTime] !== undefined) {

                    var bCreateTool = false;
                    var rRQPackets = rXScaleMng.m_tTimeArray[tDateTime][strRQ];
                    if (rRQPackets === undefined) {

                        var strKey = strRQ + "_TIME";
                        var tPrevStartDateTime = rXScaleMng.m_tTimeArray[tDateTime][strKey];
                        if (tPrevStartDateTime !== undefined) {

                            if (rXScaleMng.m_tTimeArray[tPrevStartDateTime] !== undefined) {
                                rRQPackets = rXScaleMng.m_tTimeArray[tPrevStartDateTime][strRQ];
                                tDateTime = tPrevStartDateTime;
                                nFindXIndex = rRQPackets.m_rXScaleMergeIndex.m_nIndex;
                            }
                        }
                        else {//rq에 소속된 봉이 위치해 있지 않은 영역을 클릭한 경우 (해당영역의 최소단위, 최소봉계산)

                            bCreateTool = true;
                        }
                    }

                    if (rRQPackets !== undefined || bCreateTool === true) {

                        var StartXIndex = nFindXIndex;
                        var StartDateTimeT = tDateTime;

                        var nGraphRegionHeight = rChartBlock.m_rectGraphRegion.Height();
                        
                        if (bLog === true) {

                            yMin = Log(rYScale.m_MinMaxInfo.m_LowerLimit);
                            yMax = Log(rYScale.m_MinMaxInfo.m_UpperLimit);
                            yDiff = yMax - yMin;

                            if (bInvert === true)
                                StartYValue = Exp(yMax - (rChartBlock.m_rectGraphRegion.m_nBottom - Y) / nGraphRegionHeight * yDiff);
                            else
                                StartYValue = Exp((rChartBlock.m_rectGraphRegion.m_nBottom - Y) / nGraphRegionHeight * yDiff + yMin);
                        }
                        else {

                            yMin = rYScale.m_MinMaxInfo.m_LowerLimit;
                            yMax = rYScale.m_MinMaxInfo.m_UpperLimit;
                            yDiff = yMax - yMin;

                            if (bInvert === true)
                                StartYValue = yMax - (rChartBlock.m_rectGraphRegion.m_nBottom - Y) / nGraphRegionHeight * yDiff;
                            else
                                StartYValue = (rChartBlock.m_rectGraphRegion.m_nBottom - Y) / nGraphRegionHeight * yDiff + yMin;
                        }

                        this.m_DrawingTool = this.CreateToolOnDateTimeXScale(rXScaleMng, rRQSet, rChartBlock, StartDateTimeT, StartXIndex, StartYValue);
                    }
                }
                else if (rOutDateTimeXScaleItem.m_bFutureTime === true){
                    
                    var StartXIndex = nFindXIndex;
                    var StartDateTimeT = tDateTime;

                    var nGraphRegionHeight = rChartBlock.m_rectGraphRegion.Height();
                    
                    if (bLog) {

                        yMin = Log(rYScale.m_MinMaxInfo.m_LowerLimit);
                        yMax = Log(rYScale.m_MinMaxInfo.m_UpperLimit);
                        yDiff = yMax - yMin;

                        if (bInvert === true)
                            StartYValue = Exp(yMax - (rChartBlock.m_rectGraphRegion.m_nBottom - Y) * yDiff / nGraphRegionHeight);
                        else
                            StartYValue = Exp((rChartBlock.m_rectGraphRegion.m_nBottom - Y) * yDiff / nGraphRegionHeight + yMin);
                    }
                    else {

                        yMin = rYScale.m_MinMaxInfo.m_LowerLimit;
                        yMax = rYScale.m_MinMaxInfo.m_UpperLimit;
                        yDiff = yMax - yMin;

                        if (bInvert === true)
                            StartYValue = yMax - (rChartBlock.m_rectGraphRegion.m_nBottom - Y) * yDiff / nGraphRegionHeight;
                        else
                            StartYValue = (rChartBlock.m_rectGraphRegion.m_nBottom - Y) * yDiff / nGraphRegionHeight + yMin;
                    }

                    this.m_DrawingTool = this.CreateToolOnDateTimeXScale(rXScaleMng, rRQSet, rChartBlock, StartDateTimeT, StartXIndex, StartYValue);
                }
            }
        }

        return true;//계속 그리기 상태를 의미(추세선 그리기 동작 외에 마우스 동작을 막기 위한 처리)
    }
    else {//moving

        this.UnSelectTool();

        var bSelect = false;

        var i, nLength = rChartBlock.m_ShowToolArray.length;
        for (i = 0; i < nLength; i++) {
            var rTool = rChartBlock.m_ShowToolArray[i];

            if (rTool.IsInMine(X, Y) === true) {

                if( this.m_bDeleteFalg === true )
                {
                    this.RemoveOneTool( rTool );
                    return bSelect;
                }

                this.SelectTool(rTool);

                var rCopyTool = rTool.Copy();

                rCopyTool.SetSelectedIndex(i);

                this.m_DrawingTool = rCopyTool;

                bSelect = true;

                break;
            }
        }

        // R메뉴 클릭시 삭제모드 해제
        if( this.m_bDeleteFalg === true && e.which === 3 )
            this.SetDeleteFlag( false );

        this.m_rMainBlock.m_rChart.BitBlt();

        return bSelect;
    }
}
CToolMng.prototype.OnMouseMove = function (e, rCurChartBlock) {

    if (this.m_DrawingTool !== null) {

        this.m_DrawingTool.OnMouseMove(e, rCurChartBlock);
    }
    else {//마우스가 분석툴 위에 존재하는지 체크

        var i, nLength = rCurChartBlock.m_ShowToolArray.length;
        for (i = 0; i < nLength; i++) {
            var rTool = rCurChartBlock.m_ShowToolArray[i];
            if (rTool.IsInMine(X, Y) !== null) {
                //마우스 커서 변경
            }
        }
    }
}

CToolMng.prototype.OnMouseUp = function (e) {

    if (this.m_DrawingTool !== null) {

        this.m_DrawingTool.OnMouseUp(e);

        if (this.m_DrawingTool.m_srcTool !== null ) {

            if (this.m_DrawingTool.IsDelete() === true) {//삭제

                this.UnSelectTool();
                var rChartBlock = this.m_DrawingTool.m_rChartBlock;
                rChartBlock.m_ToolArray.splice(this.m_DrawingTool.GetSelectedIndex(), 1);
            }
            else {//이동, 변경
                var rSrcTool = this.m_DrawingTool.m_srcTool;
                this.m_DrawingTool.Copy(rSrcTool);
                this.SelectingTool(rSrcTool);
            }
        }
        else {//새로 추가

            var rChartBlock = this.m_DrawingTool.m_rChartBlock;
            rChartBlock.m_ToolArray[rChartBlock.m_ToolArray.length] = this.m_DrawingTool;
            this.SelectingTool(this.m_DrawingTool);

        }

        this.m_DrawingTool.m_nHitTestPosInfo = 0;

        this.m_DrawingTool = null;

        this.m_nAddToolType = null;

        return true;
    }
    else if (this.m_MovingTool !== null) {

        this.m_MovingTool.m_nHitTestPosInfo = 0;

        return true;
    }

    return false;
}

CToolMng.prototype.SetAddToolType = function (AddToolType) {
    this.m_nAddToolType = AddToolType;
}
CToolMng.prototype.GetAddToolType = function () {
    return this.m_nAddToolType;
}
CToolMng.prototype.CreateToolOnDateTimeXScale = function (rXScaleMng, rRQSet, rChartBlock, StartDateTimeT, StartXIndex, StartYValue) {

    var rTool = null;
    switch (this.m_nAddToolType) {
        case LINE_TOOL:

            rTool = new CLineTool(rXScaleMng, rRQSet, rChartBlock);

            rTool.m_ToolInfo.m_ColIndex = rChartBlock.m_nColIndex;
            rTool.m_ToolInfo.m_RowIndex = rChartBlock.m_nRowIndex;
            rTool.m_ToolInfo.m_StartXIndex = StartXIndex;
            rTool.m_ToolInfo.m_StartYValue = StartYValue;
            rTool.m_ToolInfo.m_StartDateTimeT = StartDateTimeT;
            rTool.m_nHitTestPosInfo = END_POS;

            this.m_nAddToolType = null;

            return rTool;

        case HOZR_LINE_TOOL:

            rTool = new CHozrLineTool(rXScaleMng, rRQSet, rChartBlock);

            rTool.m_ToolInfo.m_ColIndex = rChartBlock.m_nColIndex;
            rTool.m_ToolInfo.m_RowIndex = rChartBlock.m_nRowIndex;

            rTool.m_ToolInfo.m_StartYValue = StartYValue;
            rTool.m_ToolInfo.m_EndYValue = StartYValue;

            rTool.m_nHitTestPosInfo = END_POS;
            this.m_nAddToolType = null;
            return rTool;
        
        case VERT_LINE_TOOL:

            rTool = new CVertLineTool(rXScaleMng, rRQSet, rChartBlock);

            rTool.m_ToolInfo.m_ColIndex = rChartBlock.m_nColIndex;
            rTool.m_ToolInfo.m_RowIndex = rChartBlock.m_nRowIndex;

            rTool.m_ToolInfo.m_StartXIndex = StartXIndex;
            rTool.m_ToolInfo.m_StartDateTimeT = StartDateTimeT;

            rTool.m_ToolInfo.m_EndXIndex = StartXIndex;
            rTool.m_ToolInfo.m_EndDateTimeT = StartDateTimeT;

            rTool.m_nHitTestPosInfo = END_POS;
            this.m_nAddToolType = null;
            return rTool;

        case CROSS_LINE_TOOL:

            rTool = new CCrossLineTool(rXScaleMng, rRQSet, rChartBlock);

            rTool.m_ToolInfo.m_ColIndex = rChartBlock.m_nColIndex;
            rTool.m_ToolInfo.m_RowIndex = rChartBlock.m_nRowIndex;

            rTool.m_ToolInfo.m_StartXIndex = StartXIndex;
            rTool.m_ToolInfo.m_StartYValue = StartYValue;
            rTool.m_ToolInfo.m_StartDateTimeT = StartDateTimeT;

            rTool.m_ToolInfo.m_EndXIndex = StartXIndex;
            rTool.m_ToolInfo.m_EndYValue = StartYValue;
            rTool.m_ToolInfo.m_EndDateTimeT = StartDateTimeT;

            rTool.m_nHitTestPosInfo = END_POS;

            this.m_nAddToolType = null;

            return rTool;
        case RECT_TOOL:

            rTool = new CRectTool(rXScaleMng, rRQSet, rChartBlock);

            rTool.m_ToolInfo.m_ColIndex = rChartBlock.m_nColIndex;
            rTool.m_ToolInfo.m_RowIndex = rChartBlock.m_nRowIndex;

            rTool.m_ToolInfo.m_StartXIndex = StartXIndex;
            rTool.m_ToolInfo.m_StartDateTimeT = StartDateTimeT;
            rTool.m_ToolInfo.m_StartYValue = StartYValue;

            rTool.m_nHitTestPosInfo = END_POS;

            this.m_nAddToolType = null;

            return rTool;
        case CIRCLE_TOOL:

            rTool = new CCircleTool(rXScaleMng, rRQSet, rChartBlock);

            rTool.m_ToolInfo.m_ColIndex = rChartBlock.m_nColIndex;
            rTool.m_ToolInfo.m_RowIndex = rChartBlock.m_nRowIndex;

            rTool.m_ToolInfo.m_StartXIndex = StartXIndex;
            rTool.m_ToolInfo.m_StartDateTimeT = StartDateTimeT;
            rTool.m_ToolInfo.m_StartYValue = StartYValue;
            
            rTool.m_nHitTestPosInfo = END_POS;

            this.m_nAddToolType = null;

            return rTool;
        case TRIANGLE_TOOL:
            rTool = new CTriangleTool(rXScaleMng, rRQSet, rChartBlock);

            rTool.m_ToolInfo.m_ColIndex = rChartBlock.m_nColIndex;
            rTool.m_ToolInfo.m_RowIndex = rChartBlock.m_nRowIndex;

            rTool.m_ToolInfo.m_StartXIndex = StartXIndex;
            rTool.m_ToolInfo.m_StartYValue = StartYValue;
            rTool.m_ToolInfo.m_StartDateTimeT = StartDateTimeT;

            rTool.m_nHitTestPosInfo = END_POS;

            this.m_nAddToolType = null;

            return rTool;
    }

    return null;
}
CToolMng.prototype.AddToolInfo = function (Tool) {

    //XScale 타입에 따른 분류
    var rToolXScaleInfo = this.m_mapToolXScaleInfo[Tool.m_ToolInfo.m_nXScaleType];
    if (rToolXScaleInfo === undefined) {
        rToolXScaleInfo = new CToolDateTimeXScaleInfo(Tool.m_ToolInfo.m_nXScaleType);
        this.m_mapToolXScaleInfo[Tool.m_ToolInfo.m_nXScaleType] = rToolXScaleInfo;
    }

    //코드 키값에 따른 분류
    var rKeyCodeInfo = rToolXScaleInfo.m_mapKeyCodeInfo[Tool.m_ToolInfo.m_KeyCode];
    if (rKeyCodeInfo === undefined) {
        rKeyCodeInfo = new CToolKeyCodeInfo(Tool.m_ToolInfo.m_KeyCode);
        rToolXScaleInfo.m_mapKeyCodeInfo[Tool.m_ToolInfo.m_KeyCode] = rKeyCodeInfo;
    }

    //주기에 따른 분류
    var rToolCycleInfo = rKeyCodeInfo.m_mapToolCycleInfo[Tool.m_ToolInfo.m_Cycle];
    if (rToolCycleInfo === undefined) {
        rToolCycleInfo = new CToolCycleInfo(Tool.m_ToolInfo.m_Cycle);
        rKeyCodeInfo.m_mapToolCycleInfo[Tool.m_ToolInfo.m_Cycle] = rToolCycleInfo;
    }

    //블록에 따른 분류
    var rFindToolBlockInfo = null;
    var i, nLength = rToolCycleInfo.m_ToolBlockInfoArray.length;
    for (i = 0; i < nLength; i++) {
        var rToolBlockInfo = rToolCycleInfo.m_ToolBlockInfoArray[i];
        if (rToolBlockInfo.m_ColIndex === Tool.m_ToolInfo.m_ColIndex && rToolBlockInfo.m_RowIndex === Tool.m_ToolInfo.m_RowIndex) {
            rFindToolBlockInfo = rToolBlockInfo;
            break;
        }
    }
    if (rFindToolBlockInfo === null) {
        rFindToolBlockInfo = new CToolBlockInfo(Tool.m_ToolInfo.m_ColIndex, Tool.m_ToolInfo.m_RowIndex);
        rToolCycleInfo.m_ToolBlockInfoArray[rToolCycleInfo.m_ToolBlockInfoArray.length] = rFindToolBlockInfo;
    }

    rFindToolBlockInfo.m_ToolInfoArray[rFindToolBlockInfo.m_ToolInfoArray.length] = Tool.m_ToolInfo;

    return true;
}

CToolMng.prototype.LoadToolInfo = function( rRQSet, strItemCode, nCycle )
{
    var rXScaleMng = this.m_rMainBlock.GetSelectedXScaleMng();
    if( rXScaleMng === null )
        return;

    //XScale 타입에 따른 분류
    var rToolXScaleInfo = this.m_mapToolXScaleInfo[rXScaleMng.GetType()];
    if( rToolXScaleInfo === undefined )
        return;

    //코드 키값에 따른 분류
    var rKeyCodeInfo = rToolXScaleInfo.m_mapKeyCodeInfo[strItemCode];
    if( rKeyCodeInfo === undefined )
        return;
    
    //주기에 따른 분류
    var rToolCycleInfo = rKeyCodeInfo.m_mapToolCycleInfo[nCycle];
    if (rToolCycleInfo === undefined)
        return;

    //블록에 따른 분류
    var rToolInfo = null;
    var rToolBlockInfo = null;
    var i, j, nLength = rToolCycleInfo.m_ToolBlockInfoArray.length;
    for (i = 0; i < nLength; i++)
    {
        rToolBlockInfo = rToolCycleInfo.m_ToolBlockInfoArray[i];
        if( rToolBlockInfo !== null && rToolBlockInfo !== undefined )
        {
            if( rToolBlockInfo.m_ToolInfoArray.length > 0 )
            {
                this.CreateToolOnToolInfo( rXScaleMng, rRQSet, rToolBlockInfo );
                rToolBlockInfo.m_ToolInfoArray = [];
            }
        }
    }
}

CToolMng.prototype.CreateToolOnToolInfo = function ( rXScaleMng, rRQSet, rToolBlockInfo )
{
    var rChartBlock = null, rToolInfo = null
    var nBlockCnt = this.m_rMainBlock.m_ChartBlockArray.length;
    for( var i = 0; i < nBlockCnt; i++ )
    {
        rChartBlock = this.m_rMainBlock.m_ChartBlockArray[i];
        if( rChartBlock.m_nColIndex === rToolBlockInfo.m_ColIndex && rChartBlock.m_nRowIndex === rToolBlockInfo.m_RowIndex )
        {
            var nToolLength = rToolBlockInfo.m_ToolInfoArray.length;
            for( var j = 0; j < nToolLength; j++ )
            {
                var rTool = null;
                rToolInfo = rToolBlockInfo.m_ToolInfoArray[j];
                switch( rToolInfo.m_nToolType )
                {
                case LINE_TOOL:
                    {
                        rTool = new CLineTool(rXScaleMng, rRQSet, rChartBlock);
                        //rTool.m_nHitTestPosInfo = END_POS;
                    }break;
                
                case HOZR_LINE_TOOL:
                    {
                        rTool = new CHozrLineTool(rXScaleMng, rRQSet, rChartBlock);
                        //rTool.m_nHitTestPosInfo = END_POS;
                    }break;

                case VERT_LINE_TOOL:
                    {
                        rTool = new CVertLineTool(rXScaleMng, rRQSet, rChartBlock);
                        //rTool.m_nHitTestPosInfo = END_POS;
                    }break;

                case CROSS_LINE_TOOL:
                    {
                        rTool = new CCrossLineTool(rXScaleMng, rRQSet, rChartBlock);
                        //rTool.m_nHitTestPosInfo = END_POS;
                    }break;

                case RECT_TOOL:
                    {
                        rTool = new CRectTool(rXScaleMng, rRQSet, rChartBlock);
                        //rTool.m_nHitTestPosInfo = END_POS;
                    }break;

                case CIRCLE_TOOL:
                    {
                        rTool = new CCircleTool(rXScaleMng, rRQSet, rChartBlock);
                        //rTool.m_nHitTestPosInfo = END_POS;
                    }break;
                    
                case TRIANGLE_TOOL:
                    {
                        rTool = new CTriangleTool(rXScaleMng, rRQSet, rChartBlock);
                        //rTool.m_nHitTestPosInfo = END_POS;
                    }break;
                }

                if( rTool !== null )
                {
                    rToolInfo.SetToolXPos( rXScaleMng, rChartBlock, false );
                    rTool.m_ToolInfo.SetPropertyInfo( rToolInfo );
                    rChartBlock.m_ToolArray[rChartBlock.m_ToolArray.length] = rTool;
                }

            }
        }
    }
}

CToolMng.prototype.LoadAllToolInfo = function( mapAllToolProperty )
{
    var bAddFalg = false;
    var rToolXScaleInfo, rKeyCodeInfo, rToolCycleInfo, rToolBlockInfo, rToolInfo;
    var srcToolXScaleInfo, srcKeyCodeInfo, srcToolCycleInfo, srcToolBlockInfo, srcToolInfo;

    this.m_mapToolXScaleInfo = {};
    for( var nScaleType in mapAllToolProperty )
    {
        rToolXScaleInfo = new CToolDateTimeXScaleInfo(nScaleType);
        this.m_mapToolXScaleInfo[nScaleType] = rToolXScaleInfo;

        srcToolXScaleInfo = mapAllToolProperty[nScaleType];
        for( var strKeyCode in srcToolXScaleInfo.m_mapKeyCodeInfo )
        {
            rKeyCodeInfo = new CToolKeyCodeInfo(strKeyCode);
            rToolXScaleInfo.m_mapKeyCodeInfo[strKeyCode] = rKeyCodeInfo;

            srcKeyCodeInfo = srcToolXScaleInfo.m_mapKeyCodeInfo[strKeyCode];
            for( var nCycle in srcKeyCodeInfo.m_mapToolCycleInfo )
            {
                rToolCycleInfo = new CToolCycleInfo(nCycle);
                rKeyCodeInfo.m_mapToolCycleInfo[nCycle] = rToolCycleInfo;

                srcToolCycleInfo = srcKeyCodeInfo.m_mapToolCycleInfo[nCycle];
                var i, nLength = srcToolCycleInfo.m_ToolBlockInfoArray.length;
                for( i = 0; i < nLength; i++ )
                {
                    srcToolBlockInfo = srcToolCycleInfo.m_ToolBlockInfoArray[i];
                    rToolBlockInfo = new CToolBlockInfo(srcToolBlockInfo.m_ColIndex, srcToolBlockInfo.m_RowIndex);
                    rToolCycleInfo.m_ToolBlockInfoArray[rToolCycleInfo.m_ToolBlockInfoArray.length] = rToolBlockInfo;
                    
                    var j, nToolLen = srcToolBlockInfo.m_ToolInfoArray.length;
                    for( j = 0; j < nToolLen; j++ )
                    {
                        srcToolInfo = srcToolBlockInfo.m_ToolInfoArray[j];
                        rToolInfo = new CBasicToolInfo();
                        rToolInfo.SetPropertyInfo(srcToolInfo);

                        rToolBlockInfo.m_ToolInfoArray[rToolBlockInfo.m_ToolInfoArray.length] = rToolInfo;
                        bAddFalg = true;
                    }
                }
            }
        }
    }

    return bAddFalg;
}

// 20190214 전중현 : 분석툴 설정창 이벤트 >>
CToolMng.prototype.OnLButtonDblclick = function ( e, rChart )
{
    if( this.m_SelectedTool === null )
        return;
    
    var rToolProperty = this.GetSelectedToolPropertyInfo( this.m_SelectedTool, true );

    if( rToolProperty === undefined )
        return;

    this.m_rCopyToolProperty = rToolProperty.Copy();
    rChart.SendEvent( "Event_OpenToolSetup", rToolProperty );
}

CToolMng.prototype.GetSelectedToolPropertyInfo = function ( rTool, bCopy )
{
    if( rTool === undefined || rTool === null )
        return undefined;

    if( rTool.m_ToolInfo === undefined || rTool.m_ToolInfo === null )
        return undefined;

    if( !bCopy )
        return rTool.m_ToolInfo;

    var CopyPropertyInfo = rTool.m_ToolInfo.Copy();

    // tool property 타입에 따라 설정정보 변환함수 호출
    if( CopyPropertyInfo instanceof CBasicToolInfo )
    {
        CopyPropertyInfo.SetStringDateTime( this.m_rMainBlock.m_rGlobalProperty.m_ChartUniversalTime );
        CopyPropertyInfo.SetStringPrice( rTool.m_rChartBlock );
    }
    
    return CopyPropertyInfo;
}

CToolMng.prototype.SetSelectedToolPropertyInfo = function ( ToolPropertyInfo, bDraw )
{
    if( this.m_SelectedTool === null )
        return false;

    if( ToolPropertyInfo.m_strToolKey !== this.m_SelectedTool.m_ToolInfo.m_strToolKey )
        return false;

    // tool property 타입에 따라 사용자 설정내용 변환
    if( ToolPropertyInfo instanceof CBasicToolInfo )
    {
        ToolPropertyInfo.SetDatetPosToString( this.m_SelectedTool.m_rRQSet, this.m_SelectedTool.m_rXScaleMng, this.m_SelectedTool.m_rChartBlock );
        ToolPropertyInfo.SetPriceToString();
    }

    this.m_SelectedTool.m_ToolInfo.SetPropertyInfo( ToolPropertyInfo );
    this.m_SelectedTool.m_bReCalc = true;

    if( bDraw === true )
        this.m_rMainBlock.m_rChart.Draw( DRAW_CASE_REAL );

    return true;
}

CToolMng.prototype.RollBackToolPropertyInfo = function ()
{
    if( this.m_rCopyToolProperty === null )
        return false;

    this.SetSelectedToolPropertyInfo( this.m_rCopyToolProperty, true);
    this.m_rCopyToolProperty = null;
    return true;
}

// 20190214 전중현 : 분석툴 설정창 이벤트 <<

CToolMng.prototype.SetDeleteFlag = function ( bFlag )
{
    this.SetEraseIcon();

    if( bFlag === true )
        this.m_rMainBlock.m_rChart.m_DrawingInfo.m_ScreenCanvas.className = this.m_strEraseType;
    else
        this.m_rMainBlock.m_rChart.m_DrawingInfo.m_ScreenCanvas.className = "";
    
    this.m_bDeleteFalg = bFlag;
}

CToolMng.prototype.SetEraseIcon = function ()
{
    if( this.m_rMainBlock.m_rChart.m_strThemeName === "default" )
        this.m_strEraseType = 'eraser default';
    else
        this.m_strEraseType = 'eraser full';
}
CToolMng.prototype.RemoveOneTool = function( rTargetTool ){

    if( rTargetTool === undefined || rTargetTool === null )
        return;

    var rChartBlock = rTargetTool.m_rChartBlock;
    var i, nLength = rChartBlock.m_ToolArray.length;
    for (i = 0; i < nLength; i++)
    {
        var rSrcTool = rChartBlock.m_ToolArray[i];
        if( rSrcTool === rTargetTool )
            rChartBlock.m_ToolArray.splice(i, 1);
    }

    rChartBlock.m_rChart.Draw(DRAW_CASE_REAL);
}



/////////////////////////////////////////////////////////////////////////////////
//CMainBlock
export function CMainBlock(rChart, rMapXScaleMng) {

    this.m_rChart = rChart;
    this.m_rGlobalProperty = (this.m_rChart !== undefined ? this.m_rChart.GetGlobalProperty() : null);

    this.m_mapXScaleMng = rMapXScaleMng;
    this.m_rectMainBlock = new CRect();
    this.m_rectMainBlock.SetRect(0, 0, 0, 0);

    if (this.m_rChart !== undefined) {
        this.m_clrBack = this.m_rChart.GetColorByKey("background");
        if (this.m_clrBack === null)
            this.m_clrBack = "#ffffff";
    }

    this.m_nBlockType = VERT_BLOCK_TYPE;//0:세로형, 1: 가로형, 2:비정형그리드형, 3:탭형
    this.m_ChartBlockArray = [];

    /////////////////////////////////////
    //툴팁
    /////////////////////////////////////
    this.m_ToolTipDiv = null;
    this.m_nToolTipNum = 0;
    this.ToolTipX = null;
    this.ToolTipY = null;

    /////////////////////////////////////
    //수치조회
    /////////////////////////////////////
    this.m_DataListDiv = null;
    this.m_nDataListNum = 0;
    this.m_nDataListShowSide = null;//1:좌측, 2:우측


    this.m_ToolMng = new CToolMng(this);
    this.m_SelectedChartBlock = null;
    this.m_DrawSelectedSubGraph = null;

    //SetCapture 이벤트 관련
    this.m_fMouseMove = null;
    this.m_fMouseUp = null;

    //확대축소 관련처리
    this.m_rectMagnify = new CRect();
    this.m_rectMagnify.SetRect(0, 0, 0, 0);
    this.m_rRectMagnify = null;//확대,축소 여부 체크는 레퍼런스 변수를 사용(메모리 증가를 막기 위한 방법)
    this.m_MagnifyStartXPos = null;
    if (this.m_rChart !== undefined) {
        this.m_clrRectMagnify = this.m_rChart.GetColorByKey("clrMagnifyRect");//확대축소 박스선
        if (this.m_clrRectMagnify === null)
            this.m_clrRectMagnify = "#000000";
    }

    //십자선 관련처리
    this.m_CrossPoint = new CCrossPoint(-1, -1, PRICE_CROSS_POINT_TYPE);//20190123 이문수 초기에 십자선 X축표기에 null 표시되는 오류수정>>
    this.m_rCrossPoint = null;
    this.m_clrCrossPoint = null;//현재 HogaDepth차트인 경우만 사용
    this.m_strCrossLineXTitle = null;
    this.m_strCrossLineYValue = null;
    this.m_nFindXScaleArrayIndex = null;//마우스 위치로 X축 정보 뽑은 것을 보관하는 변수(OnMouseMove에서 계속 검색시도시 이전 검색 위치로 사용 -> 검색속도를 높이기 위해)
    this.m_rFindXScaleItem = null;//마우스 위치로 X축 정보 뽑은 것을 보관하는 변수(OnMouseMove에서 계속 검색시도시 이전 검색 위치로 사용 -> 검색속도를 높이기 위해)
    this.m_rFindChartBlock = null;
    
    if (this.m_rChart !== undefined) {
        this.m_clrCrossLine = this.m_rGlobalProperty.m_clrCrossLine;
        if (this.m_clrCrossLine === null)
            this.m_clrCrossLine = "#000000";

        this.m_clrCrossTextBack = this.m_rGlobalProperty.m_clrCrossTextBack;//십자선 데이터박스 배경색
        if (this.m_clrCrossTextBack === null)
            this.m_clrCrossTextBack = "#424242";

        this.m_clrCrossText = this.m_rGlobalProperty.m_clrCrossText;//십자선 데이터 글자색
        if (this.m_clrCrossText === null)
            this.m_clrCrossText = "#ffffff";

        this.m_nCrossLineType = this.m_rGlobalProperty.m_nCrossLineType;
        this.m_nCrossLineThickness = this.m_rGlobalProperty.m_nCrossLineThickness;
    }
    else {

        this.m_clrCrossLine = "#000000";//십자선색
        this.m_clrCrossTextBack = "#424242";//십자선 데이터박스 배경색
        this.m_clrCrossText = "#ffffff";//십자선 데이터 글자색
        this.m_nCrossLineType = PS_SOLID;
        this.m_nCrossLineThickness = 1;
    }

    //resize관련
    this.m_BlockSizeRatioArray = [];//(AddBlock, DeleteBlock 에서 VBlock, HBlock인 경우 사용)

    //수치조회, 툴팁처리시 메모리 증가현상 막는 코드
    this.m_RQGraphFindDataPerXScaleMng = new CRQGraphFindDataPerXScaleMng(null);
    this.m_RQGraphFindDataPerXScaleMng4DataList = new CRQGraphFindDataPerXScaleMng(null);

    //LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 >>>
    this.m_DragMouseInfo = new CDragInfo();
    //LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 <<<
    
    //LKY 블록 확대 축소 이벤트 처리 관련 >>>
    this.m_rMaximumBlock = null;
    //LKY 블록 확대 축소 이벤트 처리 관련 <<<
}

CMainBlock.prototype.ChangeLang = function(){

    var i, rChartBlock, nChartBlockArrayLen = this.m_ChartBlockArray.length;
    for( i = 0 ; i < nChartBlockArrayLen; i++)
    {
        rChartBlock = this.m_ChartBlockArray[i];
        rChartBlock.ChangeLang();
    }
}
CMainBlock.prototype.RemoveAllIndicatorExceptIndicator = function(strRemoveExceptIndicatorNameArray){

    var i, rChartBlock, nLen = this.m_ChartBlockArray.length;
    for(i = 0 ; i < nLen; i++)
    {
        rChartBlock = this.m_ChartBlockArray[i];
        rChartBlock.RemoveAllIndicatorExceptIndicator(strRemoveExceptIndicatorNameArray);
    }
}

CMainBlock.prototype.CheckMaximumBlockUsingProperty = function(rMainBlockProperty){

    if(!rMainBlockProperty.m_bBlockMaximize)
        return;

    var i, rChartBlockProperty, nLen = rMainBlockProperty.m_ChartBlockPropertyArray.length;
    for( i = 0 ; i < nLen ; i++ ){

        rChartBlockProperty = rMainBlockProperty.m_ChartBlockPropertyArray[i];
        if(rChartBlockProperty.m_bBlockMaximize){
            this.m_rMaximumBlock = this.m_ChartBlockArray[i];
            break;
        }
    }
}

CMainBlock.prototype.GetChartFullProperty = function () {

    var MainBlockProperty = new CMainBlockProperty();
    MainBlockProperty.m_nBlockType = this.GetBlockType();
    MainBlockProperty.m_bBlockMaximize = this.m_rMaximumBlock !== null;

    var i, rChartBlock, rChartBlockProperty, nLen = this.m_ChartBlockArray.length;

    for (i = 0; i < nLen; i++) {

        rChartBlock = this.m_ChartBlockArray[i];
        rChartBlockProperty = rChartBlock.GetChartFullProperty();
        rChartBlockProperty.m_BlockSizeRatio = this.m_BlockSizeRatioArray[i];
        MainBlockProperty.m_ChartBlockPropertyArray[i] = rChartBlockProperty;
    }

    return MainBlockProperty;
}

CMainBlock.prototype.GetTotalIndicatorProp = function (mapTotalIndicatorProp) {

    var i, nLen = this.m_ChartBlockArray.length;
    for (i = 0; i < nLen; i++) {

        var rChartBlock = this.m_ChartBlockArray[i];
        rChartBlock.GetTotalIndicatorProp(mapTotalIndicatorProp);
    }
}

CMainBlock.prototype.ChangeSubGraphSubType = function (strGraphKey, strSubGraphName, nSubGraphSubType) {

    var i, nLen = this.m_ChartBlockArray.length;
    for (i = 0; i < nLen; i++) {

        var rChartBlock = this.m_ChartBlockArray[i];
        if (rChartBlock.ChangeSubGraphSubType(strGraphKey, strSubGraphName, nSubGraphSubType))
            return true;
    }
    return false;
}

CMainBlock.prototype.SetGlobalPropertyToChart = function () {

    //차트블록별 설정 셋팅
    this.m_clrBack = this.m_rGlobalProperty.m_clrBack;
    let i, rChartBlock, nChartBlockLen = this.m_ChartBlockArray.length;
    for (i = 0; i < nChartBlockLen; i++) {

        rChartBlock = this.m_ChartBlockArray[i];
        rChartBlock.SetGlobalPropertyToChart();
    }

    //십자선관련 설정 셋팅
    this.m_clrCrossLine = this.m_rGlobalProperty.m_clrCrossLine;
    this.m_clrCrossTextBack = this.m_rGlobalProperty.m_clrCrossTextBack;
    this.m_clrCrossText = this.m_rGlobalProperty.m_clrCrossText;
    this.m_nCrossLineType = this.m_rGlobalProperty.m_nCrossLineType;
    this.m_nCrossLineThickness = this.m_rGlobalProperty.m_nCrossLineThickness;
}

CMainBlock.prototype.MaximizeChartBlock = function (rSelectChartBlock, bDraw) {

    if (this.m_rMaximumBlock === null) {

        this.m_rMaximumBlock = rSelectChartBlock;

        var rChartBlock, i, nChartBlockArrayLen = this.m_ChartBlockArray.length;
        for (i = 0; i < nChartBlockArrayLen; i++) {

            rChartBlock = this.m_ChartBlockArray[i];
            rChartBlock.SetShow(false);
        }

        this.m_rMaximumBlock.SetShow(true);
        this.ResizeBlocks();

        if (bDraw === true)
            this.m_rChart.Draw(DRAW_CASE_RESIZE);

        return true;
    }
    return false;
}

CMainBlock.prototype.RestoreChartBlock = function ( bDraw) {

    if (this.m_rMaximumBlock !== null) {

        var rChartBlock, i, nChartBlockArrayLen = this.m_ChartBlockArray.length;
        for (i = 0; i < nChartBlockArrayLen; i++) {

            rChartBlock = this.m_ChartBlockArray[i];
            rChartBlock.SetShow(true);
        }
        this.m_rMaximumBlock = null;
        
        this.ResizeBlocks();

        if (bDraw === true)
            this.m_rChart.Draw(DRAW_CASE_RESIZE);

        return true;
    }
    return false;
}

CMainBlock.prototype.SetInvertYScaleByXY = function (X, Y, bInvert) {

    var i, rChartBlock, nChartBlockLen = this.m_ChartBlockArray.length;
    for (i = 0; i < nChartBlockLen; i++) {

        rChartBlock = this.m_ChartBlockArray[i];
        if (rChartBlock.IsInBlock(X, Y)) {
            return rChartBlock.SetInvertYScale(bInvert);
        }
    }
    return null;
}

CMainBlock.prototype.GetInvertYScaleByXY = function (X, Y) {

    var i, rChartBlock, nChartBlockLen = this.m_ChartBlockArray.length;
    for (i = 0; i < nChartBlockLen; i++) {

        rChartBlock = this.m_ChartBlockArray[i];
        if (rChartBlock.IsInBlock(X, Y)) {
            return rChartBlock.GetInvertYScale();
        }
    }
    return null;
}

CMainBlock.prototype.SetLogYScaleByXY = function (X, Y, bLog) {

    var i, rChartBlock, nChartBlockLen = this.m_ChartBlockArray.length;
    for (i = 0; i < nChartBlockLen; i++) {

        rChartBlock = this.m_ChartBlockArray[i];
        if (rChartBlock.IsInBlock(X, Y)) {
            return rChartBlock.SetLogYScale(bLog);
        }
    }
    return null;
}

CMainBlock.prototype.GetLogYScaleByXY = function (X, Y) {

    var i, rChartBlock, nChartBlockLen = this.m_ChartBlockArray.length;
    for (i = 0; i < nChartBlockLen; i++) {

        rChartBlock = this.m_ChartBlockArray[i];
        if (rChartBlock.IsInBlock(X, Y)) {
            return rChartBlock.GetLogYScale();
        }
    }
    return null;
}

CMainBlock.prototype.Initialize = function () {

    if (this.m_rGlobalProperty !== null)
        this.ShowCrossLine(this.m_rGlobalProperty.IsVisibleCrossLine());
}

CMainBlock.prototype.GetSelectedXScaleMng = function () {

    if (this.m_ChartBlockArray.length <= 0)
        return null;

    var rChartBlock = this.m_ChartBlockArray[0];
    var rGraph = rChartBlock.GetSelectedGraph();
    if (rGraph !== null)
        return rGraph.m_rXScale.m_rXScaleMng;
    return null;
}
CMainBlock.prototype.ShowCrossLine = function (bDrawCrossLine) {
    if (bDrawCrossLine)
        this.m_rCrossPoint = this.m_CrossPoint;
    else
        this.m_rCrossPoint = null;
}
CMainBlock.prototype.IsVisibleCrossLine = function () {
    return this.m_rGlobalProperty.IsVisibleCrossLine();
}
CMainBlock.prototype.SendEvent = function (strEventName, EventInfoData) {

    this.m_rChart.SendEvent(strEventName, EventInfoData);
}
CMainBlock.prototype.AddTool = function (nToolType) {
    this.m_ToolMng.SetAddToolType(nToolType);
}
CMainBlock.prototype.DrawTool = function (DrawingInfo) {
    var i, nLength = this.m_ChartBlockArray.length;
    for (i = 0; i < nLength; i++) {
        var ChartBlock = this.m_ChartBlockArray[i];
        ChartBlock.DrawTool(DrawingInfo);
    }
}

CMainBlock.prototype.DrawCrossLine = function (DrawingInfo) {

	//20190123 이문수 초기에 십자선 X축표기에 null 표시되는 오류수정>>
    if (this.m_rCrossPoint !== null && (this.m_rCrossPoint.m_X >= 0 && this.m_rCrossPoint.m_Y >= 0)) {
        //20190123 이문수 초기에 십자선 X축표기에 null 표시되는 오류수정<<

        //console.log("this.m_rCrossPoint Draw X:" + this.m_rCrossPoint.m_X + "Y:" + this.m_rCrossPoint.m_Y);
        if(this.m_rCrossPoint.m_nType === PRICE_CROSS_POINT_TYPE)
        {
            switch (this.GetBlockType()) {
                case VERT_BLOCK_TYPE://세로형
                    {
                        DrawingInfo.m_ScreenContext.save();

                        DrawingInfo.m_ScreenContext.beginPath();

                        var rFirstChartBlock = this.m_ChartBlockArray[0];
                        var rLastChartBlock = this.m_ChartBlockArray[this.m_ChartBlockArray.length - 1];

                        var nLeft = rFirstChartBlock.m_rectGraphBackground.m_nLeft;
                        var nRight = rFirstChartBlock.m_rectGraphBackground.m_nRight;
                        var nTop = rFirstChartBlock.m_rectGraphBackground.m_nTop;
                        var nBottom = rLastChartBlock.m_rectGraphBackground.m_nBottom;

                        var nLimitLeft = rFirstChartBlock.m_rectBlock.m_nLeft + 1;
                        var nLimitRight = rFirstChartBlock.m_rectBlock.m_nRight - 1;
                        var nLimitTop = rFirstChartBlock.m_rectBlock.m_nTop + 1;
                        var nLimitBottom = rLastChartBlock.m_rectBlock.m_nBottom - 1;

                        var nBoxLeft, nBoxRight, nBoxTop, nBoxBottom;

                        DrawingInfo.m_ScreenContext.rect(nLimitLeft, nLimitTop, nLimitRight - nLimitLeft, nLimitBottom - nLimitTop);
                        DrawingInfo.m_ScreenContext.clip();

                        DrawingInfo.m_ScreenContext.beginPath();
                        DrawingInfo.m_ScreenContext.strokeStyle = this.m_clrCrossLine;
                        DrawingInfo.m_ScreenContext.lineWidth = this.m_nCrossLineThickness;

                        switch (this.m_nCrossLineType) {
                            case PS_SOLID: DrawingInfo.m_ScreenContext.setLineDash([0, 0]); break;
                            case PS_DASH: DrawingInfo.m_ScreenContext.setLineDash([8, 4]); break;
                            case PS_DOT: DrawingInfo.m_ScreenContext.setLineDash([2, 3]); break;
                        }

                        var nCrossPointX = this.m_rCrossPoint.m_X + 0.5;
                        var nCrossPointY = this.m_rCrossPoint.m_Y + 0.5;
                        var nCrossLeft = nLeft + 0.5;
                        var nCrossRight = nRight + 0.5;
                        var nCrossTop = nTop + 0.5;
                        var nCrossBottom = nBottom + 0.5;

                        DrawingInfo.m_ScreenContext.moveTo(nCrossLeft, nCrossPointY);
                        DrawingInfo.m_ScreenContext.lineTo(nCrossRight, nCrossPointY);
                        DrawingInfo.m_ScreenContext.moveTo(nCrossPointX, nCrossTop);
                        DrawingInfo.m_ScreenContext.lineTo(nCrossPointX, nCrossBottom);

                        DrawingInfo.m_ScreenContext.stroke();

                        var bTopXAxisShowOption = ((rFirstChartBlock.GetXScaleShowOption() & 0x02) !== 0);
                        var bBottomXAxisShowOption = ((rLastChartBlock.GetXScaleShowOption() & 0x01) !== 0);
                        if (bBottomXAxisShowOption === true || bTopXAxisShowOption === true) {//마지막블록의 아래 X축이 보이는 경우만 X축에 글자가 보이도록 드로잉

                            var rXScale = null;
                            var nBoxWidth = DrawingInfo.m_ScreenContext.measureText(this.m_strCrossLineXTitle).width + 4;//this.m_strCrossLineXTitle.length * this.m_rChart.m_nTextLen + 4;
                            nBoxLeft = Math.floor(this.m_rCrossPoint.m_X - nBoxWidth / 2);
                            if (nBoxLeft <= nLeft) nBoxLeft = nLeft + 1;
                            nBoxLeft += 0.5;

                            if (bBottomXAxisShowOption === true) {

                                rXScale = rLastChartBlock.GetSelectedXScale();
                                nBoxTop = rXScale.m_BottomXAxis.m_rectAxis.m_nTop;

                                DrawingInfo.m_ScreenContext.fillStyle = this.m_clrCrossTextBack;
                                DrawingInfo.m_ScreenContext.fillRect(nBoxLeft, nBoxTop, nBoxWidth, DrawingInfo.m_nFontHeight);

                                DrawingInfo.m_ScreenContext.fillStyle = this.m_clrCrossText;
                                DrawingInfo.m_ScreenContext.textBaseline = "middle";
                                DrawingInfo.m_ScreenContext.fillText(this.m_strCrossLineXTitle, nBoxLeft, Math.floor(nBoxTop + DrawingInfo.m_nFontHeight / 2) + 0.5);
                            }
                            if (bTopXAxisShowOption === true) {

                                rXScale = rFirstChartBlock.GetSelectedXScale();
                                nBoxBottom = rXScale.m_TopXAxis.m_rectAxis.m_nBottom;

                                DrawingInfo.m_ScreenContext.fillStyle = this.m_clrCrossTextBack;
                                DrawingInfo.m_ScreenContext.fillRect(nBoxLeft, nBoxBottom - DrawingInfo.m_nFontHeight, nBoxWidth, DrawingInfo.m_nFontHeight);

                                DrawingInfo.m_ScreenContext.fillStyle = this.m_clrCrossText;
                                DrawingInfo.m_ScreenContext.textBaseline = "middle";
                                DrawingInfo.m_ScreenContext.fillText(this.m_strCrossLineXTitle, nBoxLeft, Math.floor(nBoxBottom - DrawingInfo.m_nFontHeight / 2) + 0.5);
                            }
                        }

                        if (this.m_rFindChartBlock !== null) {

                            var nValueWidth = DrawingInfo.m_ScreenContext.measureText(this.m_strCrossLineYValue).width + 4;//this.m_strCrossLineYValue.length * this.m_rChart.m_nTextLen + 4;

                            var rYScale = this.m_rFindChartBlock.GetSelectedYScale();
                            var nLeftAxisWidth = rYScale.m_LeftYAxis.m_rectAxis.Width();
                            var nRightAxisWidth = rYScale.m_RightYAxis.m_rectAxis.Width();

                            if (nLeftAxisWidth > 0 || nRightAxisWidth > 0) {//출력공간이 있으면 출력

                                var nFontHalfH = (DrawingInfo.m_nFontHeight + 2) / 2;
                                nBoxTop = Math.floor(this.m_rCrossPoint.m_Y - nFontHalfH) + 0.5;

                                if (nLeftAxisWidth > 0) {

                                    if (nLeftAxisWidth < nValueWidth)
                                        nBoxLeft = rYScale.m_LeftYAxis.m_rectAxis.m_nLeft + 0.5;
                                    else
                                        nBoxLeft = rYScale.m_LeftYAxis.m_rectAxis.m_nRight - nValueWidth + 0.5;

                                    DrawingInfo.m_ScreenContext.fillStyle = this.m_clrCrossTextBack;
                                    DrawingInfo.m_ScreenContext.fillRect(nBoxLeft, nBoxTop, nValueWidth, DrawingInfo.m_nFontHeight);

                                    DrawingInfo.m_ScreenContext.fillStyle = this.m_clrCrossText;
                                    DrawingInfo.m_ScreenContext.textBaseline = "middle";
                                    DrawingInfo.m_ScreenContext.fillText(this.m_strCrossLineYValue, nBoxLeft, nCrossPointY);
                                }

                                if (nRightAxisWidth > 0) {

                                    if (nRightAxisWidth < nValueWidth)
                                        nBoxLeft = rYScale.m_RightYAxis.m_rectAxis.m_nRight - nValueWidth + 0.5;
                                    else
                                        nBoxLeft = rYScale.m_RightYAxis.m_rectAxis.m_nLeft + 0.5;

                                    DrawingInfo.m_ScreenContext.fillStyle = this.m_clrCrossTextBack;
                                    DrawingInfo.m_ScreenContext.fillRect(nBoxLeft, nBoxTop, nValueWidth, DrawingInfo.m_nFontHeight);

                                    DrawingInfo.m_ScreenContext.fillStyle = this.m_clrCrossText;
                                    DrawingInfo.m_ScreenContext.textBaseline = "middle";
                                    DrawingInfo.m_ScreenContext.fillText(this.m_strCrossLineYValue, nBoxLeft, nCrossPointY);
                                }
                            }
                        }

                        DrawingInfo.m_ScreenContext.closePath();
                        DrawingInfo.m_ScreenContext.restore();
                    }
                    break;
                case HORZ_BLOCK_TYPE://가로형
                    break;
            }
        }
        else if(this.m_rCrossPoint.m_nType === HOGA_DEPTH_CROSS_POINT_TYPE)
        {
            var rFindChartBlock = this.m_rFindChartBlock;
            
            var nTop = rFindChartBlock.m_rectGraphBackground.m_nTop;
            var nBottom = rFindChartBlock.m_rectGraphBackground.m_nBottom;
            var nBoxLeft, nBoxRight, nBoxTop, nBoxBottom;
         
            DrawingInfo.m_ScreenContext.save();
            DrawingInfo.m_ScreenContext.beginPath();
            DrawingInfo.m_ScreenContext.strokeStyle = this.m_clrCrossLine;
            DrawingInfo.m_ScreenContext.lineWidth = this.m_nCrossLineThickness;

            switch (this.m_nCrossLineType) {
                case PS_SOLID: DrawingInfo.m_ScreenContext.setLineDash([0, 0]); break;
                case PS_DASH: DrawingInfo.m_ScreenContext.setLineDash([8, 4]); break;
                case PS_DOT: DrawingInfo.m_ScreenContext.setLineDash([2, 3]); break;
            }

            var nCrossPointX = Math.floor(this.m_rCrossPoint.m_X) + 0.5;
            var nCrossPointY = Math.floor(this.m_rCrossPoint.m_Y) + 0.5;            
            var nCrossTop = Math.floor(nTop) + 0.5;
            var nCrossBottom = Math.floor(nBottom) + 0.5;

            DrawingInfo.m_ScreenContext.moveTo(nCrossPointX, nCrossTop);
            DrawingInfo.m_ScreenContext.lineTo(nCrossPointX, nCrossBottom);
            DrawingInfo.m_ScreenContext.stroke();

            DrawingInfo.m_ScreenContext.beginPath();
            DrawingInfo.m_ScreenContext.strokeStyle = "#000000";
            DrawingInfo.m_ScreenContext.fillStyle = this.m_clrCrossPoint;
            DrawingInfo.m_ScreenContext.lineWidth = 3;
            DrawingInfo.m_ScreenContext.arc( nCrossPointX, nCrossPointY, 5, 0, (Math.PI/180)*360, false);
            DrawingInfo.m_ScreenContext.fill();

            DrawingInfo.m_ScreenContext.closePath();
            DrawingInfo.m_ScreenContext.restore();
        }
    }
}

CMainBlock.prototype.DrawMagnifyRect = function (DrawingInfo) {

    if (this.m_rRectMagnify !== null && this.m_rGlobalProperty.GetUseDragForScroll() === false) {

        DrawingInfo.m_ScreenContext.beginPath();
        DrawingInfo.m_ScreenContext.strokeStyle = this.m_clrRectMagnify;
        DrawingInfo.m_ScreenContext.lineWidth = 2;

        DrawingInfo.m_ScreenContext.setLineDash([1, 2]);
        DrawingInfo.m_ScreenContext.rect(this.m_rRectMagnify.m_nLeft, this.m_rRectMagnify.m_nTop, this.m_rRectMagnify.Width(), this.m_rRectMagnify.Height());

        DrawingInfo.m_ScreenContext.stroke();
        DrawingInfo.m_ScreenContext.closePath();
        DrawingInfo.m_ScreenContext.setLineDash([0, 0]);

    }
}

//수치조회 및 툴팁기능
CMainBlock.prototype.FindRQGraphDataPerXScaleMng = function (e) {

    var X = e.ChartXPos;
    var Y = e.ChartYPos;
    var tooltipX = e.clientX;
    var tooltipY = e.clientY;

    var rGlobalProperty = this.m_rChart.GetGlobalProperty();
    var nShowDataListMode = rGlobalProperty.GetShowDataListMode();
    var nOpacity = rGlobalProperty.GetDataListOpacity();

    var bShowDataListMode = (nShowDataListMode !== 0);//mode값이 1,2,3은 모두 수치조회 처리 필요

    var RQGraphFindDataPerXScaleMng = this.m_RQGraphFindDataPerXScaleMng;
    RQGraphFindDataPerXScaleMng.Init(null);

    this.m_RQGraphFindDataPerXScaleMng4DataList.Init(null);

    var length = this.m_ChartBlockArray.length;

    for (var strXScaleKey in this.m_mapXScaleMng) {
        var rXScaleMng = this.m_mapXScaleMng[strXScaleKey];
        if (rXScaleMng != undefined) {

            var i, rFindInfo = null;
            var mapFindInfo = null;
            var nFindBlockIndex = null;
            rXScaleMng.m_tFindDateTime = null;

            RQGraphFindDataPerXScaleMng.SetXScaleMng(rXScaleMng);

            for (i = 0; i < length; i++) {

                var rChartBlock = this.m_ChartBlockArray[i];

                mapFindInfo = rChartBlock.FindRQGraphDataPerXScaleMng(X, Y, rXScaleMng, RQGraphFindDataPerXScaleMng, bShowDataListMode);
                if (nShowDataListMode === 0 && mapFindInfo != null) {//수치조회 기능이 켜지면 툴팁 기능을 막도록 한다

                    if (RQGraphFindDataPerXScaleMng.m_strFindToolTipRQ) {//해당 차트블록안에 마우스포인터가 위치한 경우

                        this.ShowToolTip(tooltipX, tooltipY, this.m_rectMainBlock.m_nLeft, this.m_rectMainBlock.m_nRight, this.m_rectMainBlock.m_nTop, this.m_rectMainBlock.m_nBottom, RQGraphFindDataPerXScaleMng);

                        /////////////////////////////////////////////////////////////////////////////////////////
                        //툴팁 위치보정 (ToolTipDiv.offsetWidth, offsetHeight 가 ShowToolTip 함수를 벗어나야 실제 값이 셋팅되어 위치보정은 함수 나온 후 처리함, 그 값 또한 정확하지 않은 상태임)
                        var nToolTipRight = this.ToolTipX + this.m_ToolTipDiv.firstElementChild.offsetWidth;
                        var nToolTipBottom = this.ToolTipY + this.m_ToolTipDiv.firstElementChild.offsetHeight;

                        if (window.innerWidth < nToolTipRight) {
                            this.ToolTipX -= (this.m_ToolTipDiv.firstElementChild.offsetWidth + gToolTipMarginX);
                            this.m_ToolTipDiv.firstElementChild.style.left = this.ToolTipX + 'px';
                        }

                        if (window.innerHeight < nToolTipBottom) {
                            this.ToolTipY -= (this.m_ToolTipDiv.firstElementChild.offsetHeight + gToolTipMarginY + 10);
                            this.m_ToolTipDiv.firstElementChild.style.top = this.ToolTipY + 'px';
                        }
                    }
                    /////////////////////////////////////////////////////////////////////////////////////////

                    nFindBlockIndex = i;

                    break;
                }
            }

            if (!mapFindInfo || !RQGraphFindDataPerXScaleMng.m_strFindToolTipRQ) {
                this.HideToolTip();
            }

            //수치조회 옵션이 설정된 경우
            if (nShowDataListMode !== 0) {

                var RQGraphFindDataPerXScaleMng4DataList = this.m_RQGraphFindDataPerXScaleMng4DataList;
                RQGraphFindDataPerXScaleMng4DataList.SetXScaleMng(rXScaleMng);

                if (nShowDataListMode === 1 || nShowDataListMode === 3) {//마우스 x 시간축에 걸치는 모든 그래프의 데이터를 추출하는 경우

                    for (i = 0; i < length; i++) {

                        var rChartBlock = this.m_ChartBlockArray[i];

                        //nFindBlockIndex인 경우는 위에서 일부 검색한 결과 데이터를 이용해 속도가 조금이라도 불필요하게 늦어지는 것을 막기 위해 RQGraphFindDataPerXScaleMng 매개변수로 넘긴다
                        if (nFindBlockIndex === i)
                            rChartBlock.GetRQGraphFindDataPerXScaleMng(rXScaleMng, RQGraphFindDataPerXScaleMng4DataList, RQGraphFindDataPerXScaleMng);
                        else
                            rChartBlock.GetRQGraphFindDataPerXScaleMng(rXScaleMng, RQGraphFindDataPerXScaleMng4DataList);
                    }
                }

                this.ShowDataList(e, RQGraphFindDataPerXScaleMng4DataList, nOpacity);
            }
        }
    }
}

CMainBlock.prototype.OnMouseDown = function (e) {

    var X = e.ChartXPos;
    var Y = e.ChartYPos;
    if (X < this.m_rectMainBlock.m_nLeft || this.m_rectMainBlock.m_nRight < X) {
        return false;
    }
    if (Y < this.m_rectMainBlock.m_nTop || this.m_rectMainBlock.m_nBottom < Y) {
        return false;
    }

     //LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 >>>>>>>>>
     var length = this.m_ChartBlockArray.length;

     for (var i = 0; i < length; i++) {
         var rChartBlock = this.m_ChartBlockArray[i];
 
         var nMinBackgroundBottom = rChartBlock.m_rectGraphBackground.m_nBottom - 3;
         var nMaxBackgroundBottom = rChartBlock.m_rectGraphBackground.m_nBottom + 3;
 
         if (nMinBackgroundBottom <= Y && Y <= nMaxBackgroundBottom) {
 
             this.m_DragMouseInfo.m_bClickFlag = true;
             this.m_DragMouseInfo.m_nSelectChartIndex = i;
             this.m_DragMouseInfo.m_nSelectNextChartIndex = i + 1;
             this.m_SelectedChartBlock = this.m_ChartBlockArray[i];
             this.m_ChartBlockArray[i].OnMouseDown(e);
 
             break;
         }
     }
     //LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 <<<<<<<<<<

    if (this.m_DragMouseInfo.m_bClickFlag === false) {

	    this.m_SelectedChartBlock = null;
	    var nResult = CB_NO_SELECT;
	    var length = this.m_ChartBlockArray.length;
	    for (var i = 0; i < length; i++) {
	
	        nResult = this.m_ChartBlockArray[i].OnMouseDown(e);
	        if (nResult === CB_SELECT || nResult === CB_SELECT_TOOL || nResult === CB_SELECT_GRAPH) {
	            this.m_SelectedChartBlock = this.m_ChartBlockArray[i];
	            break;
	        }
	    }
	
	    if (nResult === CB_SELECT) {
	
	        this.m_MagnifyStartXPos = X;
	        this.m_rRectMagnify = this.m_rectMagnify;
	        this.m_rRectMagnify.SetRect(X, this.m_rectMainBlock.m_nTop + 2, X, this.m_rectMainBlock.m_nBottom - 2);
	
	        //console.log("this.m_fMouseDown X: " + X);
	    }
    }
    ///////////////////////////////////////////////////////////////////

    //분석도구 그리기 모드인 경우 차트 영역 외부로 마우스 나간 경우도 이벤트를 받을 수 있도록 document에 이벤트 등록처리
    if(nResult === CB_SELECT_TOOL || this.m_DragMouseInfo.m_bClickFlag === true)
    {
        var self = this;

        if (!this.m_fMouseMove) {

            this.m_fMouseMove = function (e) {

                self.m_rChart.OnMouseMove(e);
                //console.log("this.m_fMouseMove");
            }
        }
        if (!this.m_fMouseUp) {
            this.m_fMouseUp = function (e) {

                self.m_rChart.OnMouseUp(e);

                //console.log("this.m_fMouseUp");

                document.removeEventListener("mousemove", self.m_fMouseMove);
                document.removeEventListener("mouseup", self.m_fMouseUp);

                self.m_rChart.SetEventReg();
            }
        }
        
        if (this.m_fMouseMove) {

            if (this.m_rChart.m_DrawingInfo.m_ScreenCanvas.onmousemove)
                this.m_rChart.m_DrawingInfo.m_ScreenCanvas.onmousemove = null;

            if (this.m_rChart.m_DrawingInfo.m_ScreenCanvas.onmouseout)
                this.m_rChart.m_DrawingInfo.m_ScreenCanvas.onmouseout = null;

            document.addEventListener("mousemove", self.m_fMouseMove);
        }

        if (this.m_fMouseUp) {

            if (this.m_rChart.m_DrawingInfo.m_ScreenCanvas.onmouseup)
                this.m_rChart.m_DrawingInfo.m_ScreenCanvas.onmouseup = null;

            document.addEventListener("mouseup", self.m_fMouseUp);
        }
        
    }
    
    ///////////////////////////////////////////////////////////////////
    return true;
}
CMainBlock.prototype.OnMouseUp = function (e) {

    var X = e.ChartXPos;
    var Y = e.ChartYPos;

    //LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 >>>>>>>>>
    if (this.m_DragMouseInfo.m_bClickFlag === true) {
        this.m_DragMouseInfo.m_bClickFlag = false;
        this.m_DragMouseInfo.m_nSelectChartIndex = null;
        this.m_DragMouseInfo.m_nSelectNextChartIndex = null;
        return true;
    }
    //LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 <<<<<<<<<

    if (!this.m_ToolMng.IsDrawingTool() && this.m_rRectMagnify === null) {
        if (X < this.m_rectMainBlock.m_nLeft || this.m_rectMainBlock.m_nRight < X) {
            return false;
        }
        if (Y < this.m_rectMainBlock.m_nTop || this.m_rectMainBlock.m_nBottom < Y) {
            return false;
        }
    }

    var length = this.m_ChartBlockArray.length;
    for (var i = 0; i < length; i++) {
        if (this.m_ChartBlockArray[i].OnMouseUp(e))
            break;
    }

    if (this.m_SelectedChartBlock) {

        if (this.m_MagnifyStartXPos && this.m_rRectMagnify !== null) {

            //pc웹 마우스 드래그로 확대축소 처리
            if (this.m_rGlobalProperty.GetUseDragForScroll() === false) {
                //확대
                if (this.m_MagnifyStartXPos < this.m_rRectMagnify.m_nRight) {

                    var rSelectedGraph = this.m_SelectedChartBlock.GetSelectedGraph();
                    var rXScaleMng = rSelectedGraph.GetXScaleMng();
                    var nGraphRegionWidth = this.m_SelectedChartBlock.m_rectGraphRegion.Width();

                    //if (rXScaleMng.m_nType == DATETIME_TYPE) 
                    {

                        if (nGraphRegionWidth > 0) {

                            var nTotalCnt = rXScaleMng.GetMergeDataCnt();

                            //X pixel 좌표값으로부터 최소시간단위봉의 index 얻어냄
                            var nStartXIndex = GetXIndexByXPos(this.m_rRectMagnify.m_nLeft, this.m_SelectedChartBlock.m_rectGraphRegion, rXScaleMng.m_nViewStartIndex, rXScaleMng.m_nViewEndIndex);

                            if (this.m_rRectMagnify.m_nRight > this.m_SelectedChartBlock.m_rectGraphRegion.m_nRight)
                                this.m_rRectMagnify.m_nRight = this.m_SelectedChartBlock.m_rectGraphRegion.m_nRight;

                            var nEndXIndex = GetXIndexByXPos(this.m_rRectMagnify.m_nRight, this.m_SelectedChartBlock.m_rectGraphRegion, rXScaleMng.m_nViewStartIndex, rXScaleMng.m_nViewEndIndex);

                            if (nTotalCnt <= nEndXIndex)
                                nEndXIndex = nTotalCnt - 1;

                            if (nStartXIndex < nEndXIndex) {

                                var nViewCnt = nEndXIndex - nStartXIndex + 1;

                                this.m_rChart.InitialViewInfo(nViewCnt);

                                var nMoveScroll = nStartXIndex - this.m_rChart.m_ScrollCtrl.m_Pos;//스크롤 이동되어야 할 최소봉폭 개수

                                this.m_rChart.ExtractYScaleMinMax(true);
                                this.m_rChart.m_ScrollCtrl.Scroll(nMoveScroll);
                                this.m_rChart.Draw(DRAW_CASE_RESIZE);
                            }
                        }
                    }
                }
                //축소
                else if (this.m_rRectMagnify.m_nLeft < this.m_MagnifyStartXPos) {

                    var rSelectedGraph = this.m_SelectedChartBlock.GetSelectedGraph();
                    var rXScaleMng = rSelectedGraph.GetXScaleMng();
                    var nGraphRegionWidth = this.m_SelectedChartBlock.m_rectGraphRegion.Width();

                    //if (rXScaleMng.m_nType == DATETIME_TYPE) 
                    {
                        if (nGraphRegionWidth > 0) {

                            //X pixel 좌표값으로부터 최소시간단위봉의 index 얻어냄
                            var nViewCnt = rXScaleMng.GetMergeDataCnt();
                            this.m_rChart.InitialViewInfo(nViewCnt);

                            this.m_rChart.ExtractYScaleMinMax(true);
                            this.m_rChart.Draw(DRAW_CASE_RESIZE);
                        }
                    }
                }
            }
        }
        this.m_rRectMagnify = null;
        this.m_MagnifyStartXPos = null;

        this.m_rChart.BitBlt();
        this.m_SelectedChartBlock = null;
    }

    return true;
}
CMainBlock.prototype.OnMouseMove = function (e) {

    var X = e.ChartXPos;
    var Y = e.ChartYPos;

    //console.dir("CMainBlock.prototype.OnMouseMove e=" + e.currentTarget.id);

    if (!this.m_ToolMng.IsDrawingTool() && this.m_ToolMng.m_bDeleteFalg === false &&
        this.m_rRectMagnify === null && this.m_DragMouseInfo.m_bClickFlag === false) {

        if (e.currentTarget.id !== this.m_rChart.m_DrawingInfo.m_strScreenCanvasId) {

            this.m_rChart.SetCursor('default');

            this.m_rCrossPoint = null;
            return false;
        }

        if (X < this.m_rectMainBlock.m_nLeft || this.m_rectMainBlock.m_nRight < X) {

            this.m_rChart.SetCursor('default');

            this.m_rCrossPoint = null;
            return false;
        }

        if (Y < this.m_rectMainBlock.m_nTop || this.m_rectMainBlock.m_nBottom < Y) {

            this.m_rChart.SetCursor('default');            

            this.m_rCrossPoint = null;
            return false;
        }
    }

    //LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 >>>>>>>>>
    if (this.m_DragMouseInfo.m_bClickFlag === true) {
        this.ChartBlockClickDragMove(X, Y);
        return true;
    }
    //LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 <<<<<<<<<

	//예외처리 추가
    if (this.m_ChartBlockArray.length <= 0)
        return false;

    if (e.currentTarget.id === this.m_rChart.m_DrawingInfo.m_strScreenCanvasId && this.IsVisibleCrossLine()) {

        var i, j, nChartBlockLen = this.m_ChartBlockArray.length;
        var nRightMargin = this.m_rGlobalProperty.GetRightMargin();

        switch (this.GetBlockType()) {
            case VERT_BLOCK_TYPE://세로형
                {
                    var rFindChartBlock = null;
                    this.m_strCrossLineXTitle = null;
                    this.m_strCrossLineYValue = null;                    

                    if (this.m_rMaximumBlock !== null) {

                        rFindChartBlock = this.m_rMaximumBlock;
                    }
                    else {


                        for (i = 0; i < nChartBlockLen; i++) {

                            var rChartBlock = this.m_ChartBlockArray[i];

                            //LKY 마우스 이동시 Div 버튼 Show&Hide 처리 >>>>>>>>>
                            rChartBlock.SetShowDivButton(i);
                            //LKY 마우스 이동시 Div 버튼 Show&Hide 처리 <<<<<<<<<

                            //LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 >>>>>>>>>
                            var nMinBackgroundBottom = rChartBlock.m_rectGraphBackground.m_nBottom - 3;
                            var nMaxBackgroundBottom = rChartBlock.m_rectGraphBackground.m_nBottom + 3;
                            if (nMinBackgroundBottom <= Y && Y <= nMaxBackgroundBottom && i < nChartBlockLen - 1) {
                                this.m_rChart.SetCursor('n-resize');
                                break;
                            }
                            else {
                                    this.m_rChart.SetCursor('default');
                            }
                            //LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 <<<<<<<<<

                            if ((rChartBlock.m_rectGraphRegion.m_nLeft < X && X < rChartBlock.m_rectGraphRegion.m_nRight + nRightMargin) &&
                                (rChartBlock.m_rectGraphRegion.m_nTop < Y && Y < rChartBlock.m_rectGraphRegion.m_nBottom)) {

                                rFindChartBlock = rChartBlock;
                                break;
                            }
                        }
                    }

                    if (rFindChartBlock !== null) {

                        var nLeft, nRight, nTop, nBottom;

                        if (this.m_rMaximumBlock === null) {

                            var rFirstChartBlock = this.m_ChartBlockArray[0];
                            var rLastChartBlock = this.m_ChartBlockArray[this.m_ChartBlockArray.length - 1];

                            nLeft = rFirstChartBlock.m_rectGraphRegion.m_nLeft;
                            nRight = rFirstChartBlock.m_rectGraphRegion.m_nRight + nRightMargin;
                            nTop = rFirstChartBlock.m_rectGraphBackground.m_nTop;
                            nBottom = rLastChartBlock.m_rectGraphBackground.m_nBottom;
                        }
                        else {

                            nLeft = rFindChartBlock.m_rectGraphRegion.m_nLeft;
                            nRight = rFindChartBlock.m_rectGraphRegion.m_nRight + nRightMargin;
                            nTop = rFindChartBlock.m_rectGraphBackground.m_nTop;
                            nBottom = rFindChartBlock.m_rectGraphBackground.m_nBottom;
                        }

                        if (this.m_rCrossPoint === null)
                            this.m_rCrossPoint = this.m_CrossPoint;

                        this.m_rCrossPoint.m_X = X;
                        this.m_rCrossPoint.m_Y = Y;
                        this.m_nType = PRICE_CROSS_POINT_TYPE;
                        ///////////////////////////////////////////////////////

                        var rXScaleMng = this.m_rChart.GetSelectedXScaleMng();
                        if (rXScaleMng !== null) {

                            var nViewDataCnt = rXScaleMng.m_nViewEndIndex - rXScaleMng.m_nViewStartIndex + 1;
                            var nGraphRegionWidth = rFindChartBlock.m_rectGraphRegion.Width();
                            if (nGraphRegionWidth + nRightMargin > 0) {

                                var nFindXIndex = Math.floor((X - rFindChartBlock.m_rectGraphRegion.m_nLeft) * (nViewDataCnt / rFindChartBlock.m_rectGraphRegion.Width()) + rXScaleMng.m_nViewStartIndex);

                                if (rXScaleMng.GetType() === DATETIME_TYPE) {

                                    if (this.m_rFindXScaleItem !== null && this.m_nFindXScaleArrayIndex >= 0) {

                                        do {

                                            var nStartXIndex = this.m_rFindXScaleItem.GetStartPos();
                                            var nIntervalCnt = this.m_rFindXScaleItem.GetIntervalCnt();
                                            var nEndXIndex = nStartXIndex + nIntervalCnt - 1;

                                            //검색범위에 들어옴
                                            if (nStartXIndex <= nFindXIndex && nFindXIndex <= nEndXIndex) {

                                                var tDateTime = this.m_rFindXScaleItem.GetDateTimeTByIndex(nFindXIndex, undefined, nIntervalCnt);

                                                //LKY 세계시간 적용 >>
                                                var GlobaloffsetDateTime = ChangeGlobalTime(this.m_rGlobalProperty.m_ChartUniversalTime, tDateTime);                                                
                                                //LKY 세계시간 적용 <<

                                                var nYear = GlobaloffsetDateTime.getFullYear();
                                                var nMonth = GlobaloffsetDateTime.getMonth() + 1;
                                                var nDay = GlobaloffsetDateTime.getDate();
                                                var nH = GlobaloffsetDateTime.getHours();
                                                var nM = GlobaloffsetDateTime.getMinutes();
                                                var nS = GlobaloffsetDateTime.getSeconds();
                                                var strDate = gDateArray[GlobaloffsetDateTime.getDay()];

                                                switch (this.m_rFindXScaleItem.GetCycle()) {

                                                    case 1://일
                                                    case 2://주
                                                        this.m_strCrossLineXTitle = "" + nYear + "/" + (nMonth >= 10 ? nMonth : "0" + nMonth) + "/" + (nDay >= 10 ? nDay : "0" + nDay) + " (" + strDate + ")"; break;
                                                    case 3://월
                                                        this.m_strCrossLineXTitle = "" + nYear + "/" + (nMonth >= 10 ? nMonth : "0" + nMonth); break;
                                                    case 4://년
                                                        this.m_strCrossLineXTitle = "" + nYear; break;
                                                    case 5://분
                                                        this.m_strCrossLineXTitle = "" + nYear + "/" + (nMonth >= 10 ? nMonth : "0" + nMonth) + "/" + (nDay >= 10 ? nDay : "0" + nDay) + " " + (nH >= 10 ? nH : "0" + nH) + " " + (nM >= 10 ? nM : "0" + nM); break;
                                                    case 6://초
                                                        this.m_strCrossLineXTitle = "" + nYear + "/" + (nMonth >= 10 ? nMonth : "0" + nMonth) + "/" + (nDay >= 10 ? nDay : "0" + nDay) + " " + (nH >= 10 ? nH : "0" + nH) + " " + (nM >= 10 ? nM : "0" + nM) + " " + (nS >= 10 ? nS : "0" + nS); break;
                                                }

                                                break;
                                            }
                                            //범위가 들어오지 않아 검색해야 함
                                            else {

                                                if (nFindXIndex < nStartXIndex) {//nStartXIndex부터 역으로 검색(즉, this.m_nFindXScaleArrayIndex -1 부터 검색)

                                                    if (this.m_nFindXScaleArrayIndex - 1 >= 0) {

                                                        var nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(nFindXIndex, this.m_nFindXScaleArrayIndex - 1, 0, this.m_rFindXScaleItem);
                                                        if (nXScaleItemArrayIndex < 0 || this.m_rFindXScaleItem === null) {
                                                            //검색실패                                                                    
                                                            break;
                                                        }

                                                        this.m_nFindXScaleArrayIndex = nXScaleItemArrayIndex;
                                                    }
                                                    else {

                                                        //검색실패
                                                        break;
                                                    }
                                                }
                                                else {

                                                    if (this.m_nFindXScaleArrayIndex + 1 < rXScaleMng.m_XScaleItemArray.length) {

                                                        var nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(nFindXIndex, this.m_nFindXScaleArrayIndex + 1, rXScaleMng.m_XScaleItemArray.length - 1, this.m_rFindXScaleItem);
                                                        if (nXScaleItemArrayIndex < 0 || this.m_rFindXScaleItem === null) {
                                                            //검색실패                                                                    
                                                            break;
                                                        }

                                                        this.m_nFindXScaleArrayIndex = nXScaleItemArrayIndex;
                                                    }
                                                    else {
                                                        //검색실패                                                                
                                                        break;
                                                    }
                                                }
                                            }
                                        }while (1);

                                    }
                                    //마우스가 차트영역으로 초기화 이후 처음 들어올 때
                                    else {

                                        this.m_nFindXScaleArrayIndex = null;

                                        if ((nFindXIndex - rXScaleMng.m_nViewStartIndex) < (rXScaleMng.m_nViewEndIndex - nFindXIndex)) {

                                            this.m_rFindXScaleItem = new CDateTimeXScaleItem(rXScaleMng);
                                            var nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(nFindXIndex, 0, rXScaleMng.m_XScaleItemArray.length - 1, this.m_rFindXScaleItem);
                                            if (nXScaleItemArrayIndex >= 0 && this.m_rFindXScaleItem !== null) {

                                                this.m_nFindXScaleArrayIndex = nXScaleItemArrayIndex;
                                            }
                                        }
                                        else {

                                            this.m_rFindXScaleItem = new CDateTimeXScaleItem(rXScaleMng);
                                            var nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(nFindXIndex, rXScaleMng.m_XScaleItemArray.length - 1, 0, this.m_rFindXScaleItem);
                                            if (nXScaleItemArrayIndex >= 0 && this.m_rFindXScaleItem !== null) {

                                                this.m_nFindXScaleArrayIndex = nXScaleItemArrayIndex;
                                            }
                                        }

                                        if (this.m_rFindXScaleItem !== null && this.m_nFindXScaleArrayIndex >= 0) {

                                            var nStartXIndex = this.m_rFindXScaleItem.GetStartPos();
                                            var nIntervalCnt = this.m_rFindXScaleItem.GetIntervalCnt();
                                            var nEndXIndex = nStartXIndex +  nIntervalCnt - 1;

                                            //검색범위에 들어옴
                                            if (nStartXIndex <= nFindXIndex && nFindXIndex <= nEndXIndex) {

                                                var tDateTime = this.m_rFindXScaleItem.GetDateTimeTByIndex(nFindXIndex, undefined, nIntervalCnt);

                                                var GlobaloffsetDateTime = ChangeGlobalTime(this.m_rGlobalProperty.m_ChartUniversalTime, tDateTime);                                                

                                                var nYear = GlobaloffsetDateTime.getFullYear();
                                                var nMonth = GlobaloffsetDateTime.getMonth() + 1;
                                                var nDay = GlobaloffsetDateTime.getDate();
                                                var nH = GlobaloffsetDateTime.getHours();
                                                var nM = GlobaloffsetDateTime.getMinutes();
                                                var nS = GlobaloffsetDateTime.getSeconds();
                                                var strDate = gDateArray[GlobaloffsetDateTime.getDay()];
                                                
                                                switch (this.m_rFindXScaleItem.GetCycle()) {

                                                    case 1://일
                                                    case 2://주
                                                        this.m_strCrossLineXTitle = "" + nYear + "/" + (nMonth >= 10 ? nMonth : "0" + nMonth) + "/" + (nDay >= 10 ? nDay : "0" + nDay) + " (" + strDate + ")"; break;
                                                    case 3://월
                                                        this.m_strCrossLineXTitle = "" + nYear + "/" + (nMonth >= 10 ? nMonth : "0" + nMonth); break;
                                                    case 4://년
                                                        this.m_strCrossLineXTitle = "" + nYear; break;
                                                    case 5://분
                                                        this.m_strCrossLineXTitle = "" + nYear + "/" + (nMonth >= 10 ? nMonth : "0" + nMonth) + "/" + (nDay >= 10 ? nDay : "0" + nDay) + " " + (nH >= 10 ? nH : "0" + nH) + " " + (nM >= 10 ? nM : "0" + nM); break;
                                                    case 6://초
                                                        this.m_strCrossLineXTitle = "" + nYear + "/" + (nMonth >= 10 ? nMonth : "0" + nMonth) + "/" + (nDay >= 10 ? nDay : "0" + nDay) + " " + (nH >= 10 ? nH : "0" + nH) + " " + (nM >= 10 ? nM : "0" + nM) + " " + (nS >= 10 ? nS : "0" + nS); break;
                                                }
                                            }
                                        }
                                    }

                                    //////////////////////////////////////////////////////
                                    //y축
                                    if (this.m_strCrossLineXTitle != null && this.m_strCrossLineXTitle.length > 0) {                                    
                                        
                                        var rYScale = rFindChartBlock.GetSelectedYScale();

                                        if (rYScale.m_nPacketType === NUMERIC_TYPE) {

                                            var yMin, yMax, DiffYValue, DiffY, nMarkPos, ratio, YValue;
                                            var bLog = rYScale.GetLog();
                                            var bInvert = rYScale.GetInvert();
                                            if (bLog === true) {

                                                yMin = Log(rYScale.m_MinMaxInfo.m_LowerLimit);
                                                yMax = Log(rYScale.m_MinMaxInfo.m_UpperLimit);
                                                DiffYValue = yMax - yMin;

                                                DiffY = rFindChartBlock.m_rectGraphRegion.Height();
                                                nMarkPos = rFindChartBlock.m_rectGraphRegion.m_nBottom - Y;

                                                ratio = nMarkPos / DiffY;

                                                if (bInvert === true)
                                                    YValue = Exp(yMax - DiffYValue * ratio);
                                                else
                                                    YValue = Exp(DiffYValue * ratio + yMin);
                                            }
                                            else {

                                                yMin = rYScale.m_MinMaxInfo.m_LowerLimit;
                                                yMax = rYScale.m_MinMaxInfo.m_UpperLimit;
                                                DiffYValue = yMax - yMin;

                                                DiffY = rFindChartBlock.m_rectGraphRegion.Height();
                                                nMarkPos = rFindChartBlock.m_rectGraphRegion.m_nBottom - Y;

                                                ratio = nMarkPos / DiffY;

                                                if (bInvert === true)
                                                    YValue = (yMax - DiffYValue * ratio);
                                                else
                                                    YValue = (DiffYValue * ratio + yMin);
                                            }

                                            this.m_strCrossLineYValue = ConvertNumToDigitText(YValue, rYScale.m_nDec, 1, rYScale.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);
                                        }

                                        this.m_rFindChartBlock = rFindChartBlock;
                                        //console.log("XTitle:" + this.m_strCrossLineXTitle + ", YValue:" + this.m_strCrossLineYValue);
                                    }
                                }
                                else if (rXScaleMng.GetXScalePacketName() === "_HOGA_")
                                {
                                    this.m_rCrossPoint.m_nType = HOGA_DEPTH_CROSS_POINT_TYPE;

                                    this.m_rFindXScaleItem = rXScaleMng.m_XScaleItemArray[nFindXIndex];                                    
                                    if (this.m_rFindXScaleItem != null) {

                                        var strRQ = null;
                                        var dHoga = this.m_rFindXScaleItem.m_dHoga;
                                        var rRQPacketsItem = null;
                                        var rXPacketItemData = null;
                                        for( strRQ in this.m_rFindXScaleItem.m_mapRQPacketsItem)
                                        {
                                            rRQPacketsItem = this.m_rFindXScaleItem.m_mapRQPacketsItem[strRQ];
                                            rXPacketItemData = rRQPacketsItem.m_rXScalePacketData;
                                            break;
                                        }
                                        if(dHoga > 0 && rXPacketItemData)
                                        {
                                            var clrBuyLine = "#ff0000";
                                            var clrSellLine = "#0000ff";
                                            var rGraphPropertyInfo = null;
                                            var rHogaDepthGraph = rXPacketItemData.m_rPacketData.m_rRQSet.IsExistGraphName("_HOGADEPTH_");
                                            if(rHogaDepthGraph)
                                            {
                                                clrBuyLine = rHogaDepthGraph.GetBuyLineColor();
                                                clrSellLine = rHogaDepthGraph.GetSellLineColor();
                                            }
                                            this.m_clrCrossPoint = this.m_rFindXScaleItem.m_nBuyOrSell === 0 ? clrBuyLine : clrSellLine;
                                            this.m_strCrossLineXTitle = ConvertNumToDigitText(dHoga, rXPacketItemData.m_rPacketData.m_nDec, 1, rXPacketItemData.m_rPacketData.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);
                                            
                                            //Y값
                                            var rHogaRestPacketData = rXPacketItemData.m_rPacketData.m_rRQSet.GetPacketData("_HOGAREST_");                                            
                                            if(rHogaRestPacketData)
                                            {
                                                var rYScale = null;
                                                var rHogaRestPacketItemData = rHogaRestPacketData.GetData(nFindXIndex);
                                                if(rHogaRestPacketItemData && rHogaRestPacketData.m_SubGraphArray.length > 0)
                                                {
                                                    
                                                    var rSubGraph = rHogaRestPacketData.m_SubGraphArray[0];
                                                    rYScale = rSubGraph.m_Graph.m_rYScale;
                                                    if(rYScale && rYScale.m_nPacketType === NUMERIC_TYPE)
                                                    {
                                                        var yMin, yMax, DiffYValue, dHogaRest;
                                                        var bLog = rYScale.GetLog();
                                                        var bInvert = rYScale.GetInvert();
                                                        if(bLog === true)  
                                                        {                                                      
                                                            dHogaRest = Log(rHogaRestPacketItemData.m_Data);
                                                            yMin = Log(rYScale.m_MinMaxInfo.m_LowerLimit);
                                                            yMax = Log(rYScale.m_MinMaxInfo.m_UpperLimit);
                                                        }
                                                        else
                                                        {
                                                            dHogaRest = rHogaRestPacketItemData.m_Data;
                                                            yMin = rYScale.m_MinMaxInfo.m_LowerLimit;
                                                            yMax = rYScale.m_MinMaxInfo.m_UpperLimit;
                                                        }
                                                        DiffYValue = yMax - yMin;

                                                        var rectGraphRegion = rFindChartBlock.m_rectGraphRegion;
                                                        var yPos = rectGraphRegion.m_nBottom - (dHogaRest - yMin) / DiffYValue * rectGraphRegion.Height();

                                                        if (bInvert === true)
                                                            yPos = rectGraphRegion.m_nBottom - yPos + rectGraphRegion.m_nTop;

                                                        this.m_rCrossPoint.m_Y = yPos;
                                                        
                                                        this.m_strCrossLineYValue = ConvertNumToDigitText(dHogaRest, rYScale.m_nDec, 1, rYScale.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

                                                        this.m_rFindChartBlock = rFindChartBlock;
                                                    }
                                                }
                                            }
                                        }                                        
                                    }
                                }                                
                            }
                        }
                    }

                    if (this.m_strCrossLineXTitle == null && this.m_strCrossLineYValue == null) {

                        //검색실패
                        this.m_rCrossPoint = null;
                        this.m_nFindXScaleArrayIndex = null;
                        this.m_rFindXScaleItem = null;
                        this.m_rFindChartBlock = null;
                    }                
                }
                break;
        }
    }
    else
        this.m_rCrossPoint = null;



    if (this.m_rRectMagnify !== null) {

        if (e.currentTarget.id === this.m_rChart.m_DrawingInfo.m_strScreenCanvasId) {
            //확대축소처리
            if (this.m_rGlobalProperty.GetUseDragForScroll() === false) {

                if (this.m_MagnifyStartXPos === X) {
                    this.m_rRectMagnify.m_nLeft = X;
                    this.m_rRectMagnify.m_nRight = X;
                }
                else if (this.m_MagnifyStartXPos < X) {

                    if (this.m_SelectedChartBlock !== null) {

                        //if (this.m_SelectedChartBlock.m_rectGraphRegion.m_nRight < X)
                        if (this.m_SelectedChartBlock.m_rectGraphBackground.m_nRight < X)
                            X = this.m_SelectedChartBlock.m_rectGraphBackground.m_nRight;
                    }
                    this.m_rRectMagnify.m_nLeft = this.m_MagnifyStartXPos;
                    this.m_rRectMagnify.m_nRight = (this.m_rectMainBlock.m_nRight < X ? this.m_rectMainBlock.m_nRight : X);
                } else {

                    if (this.m_SelectedChartBlock !== null) {

                        //if (X < this.m_SelectedChartBlock.m_rectGraphRegion.m_nLeft)
                        if (X < this.m_SelectedChartBlock.m_rectGraphBackground.m_nLeft)
                            X = this.m_SelectedChartBlock.m_rectGraphRegion.m_nLeft;
                    }

                    this.m_rRectMagnify.m_nLeft = (X < this.m_rectMainBlock.m_nLeft ? this.m_rectMainBlock.m_nLeft : X);
                    this.m_rRectMagnify.m_nRight = this.m_MagnifyStartXPos;
                }

                //console.log("magnifyRect left=" + this.m_rRectMagnify.m_nLeft + ", right=" + this.m_rRectMagnify.m_nRight);

                this.m_rChart.BitBlt();
            }
            else {//드래그 스크롤 처리

                if (this.m_SelectedChartBlock !== null) {

                    if (rXScaleMng) {

                        var nStartIndex = GetXIndexByXPos(this.m_rRectMagnify.m_nLeft, this.m_SelectedChartBlock.m_rectGraphRegion, rXScaleMng.m_nViewStartIndex, rXScaleMng.m_nViewEndIndex);
                        var nEndIndex = GetXIndexByXPos(X, this.m_SelectedChartBlock.m_rectGraphRegion, rXScaleMng.m_nViewStartIndex, rXScaleMng.m_nViewEndIndex);

                        var nMoveScroll = nStartIndex - nEndIndex;//스크롤 이동되어야 할 최소봉폭 개수

                        this.m_rChart.ExtractYScaleMinMax(true);
                        var nRealMove = this.m_rChart.m_ScrollCtrl.Scroll(nMoveScroll);
                        this.m_rChart.Draw(DRAW_CASE_SCROLL);

                        this.m_rRectMagnify.m_nLeft = X;

                        //과거쪽으로 드래그 스크롤 시 끝에 도착하면 화면에 이벤트를 전달하여 추가조회되도록 처리
                        if (nMoveScroll < 0 && nRealMove !== nMoveScroll)
                            this.m_rChart.SendEvent("Event_Scroll");
                    }
                    else {

                        this.m_rRectMagnify = null;
                    }
                }
            }
        }

        return true;
    }

    var length = this.m_ChartBlockArray.length;
    for (var i = 0; i < length; i++) {
        if (this.m_ChartBlockArray[i].OnMouseMove(e))
            break;
    }

    if (this.m_ToolMng.IsDrawingTool() === true)
        this.m_ToolMng.DrawToolOnMouseMove(this.m_rChart.m_DrawingInfo);
    else
        this.m_rChart.BitBlt();

    /////////////////////////
    //수치조회 및 툴팁기능
    this.FindRQGraphDataPerXScaleMng(e);
    /////////////////////////

    return true;
}

CMainBlock.prototype.OnMouseOut = function () {

    this.m_rChart.SetCursor('default');

    var length = this.m_ChartBlockArray.length;
    for (var i = 0; i < length; i++) {
        this.m_ChartBlockArray[i].OnMouseOut();
    }

    if (this.m_rCrossPoint) {
        this.m_rCrossPoint = null;
        this.m_rChart.BitBlt();
        this.m_nFindXScaleArrayIndex = null;
        this.m_rFindXScaleItem = null;
        this.m_rFindChartBlock = null;
    }

    //수치조회 창 숨기기
    this.HideDataList();
}

CMainBlock.prototype.OnLButtonDblclick = function (e)
{
    var X = e.ChartXPos;
    var Y = e.ChartYPos;
    if (X < this.m_rectMainBlock.m_nLeft || this.m_rectMainBlock.m_nRight < X) {
        return false;
    }
    if (Y < this.m_rectMainBlock.m_nTop || this.m_rectMainBlock.m_nBottom < Y) {
        return false;
    }

    if( this.m_ToolMng.m_MovingTool !== null || this.m_ToolMng.IsDrawingTool() )
        return;

	// 20190214 전중현 : 분석툴 설정창 이벤트
    if( this.m_ToolMng.m_SelectedTool !== null && this.m_ToolMng.m_MovingTool === null )
    {
        this.m_ToolMng.OnLButtonDblclick( e, this.m_rChart );
        return true;
    }

    return false;
}


//LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 >>>>>>>>>>
CMainBlock.prototype.ChartBlockClickDragMove = function(X, Y) {
    var rectClient = this.GetMainBlockRect();

    var nH = rectClient.Height();

    var rSelectBlock = this.m_ChartBlockArray[this.m_DragMouseInfo.m_nSelectChartIndex];
    if(!rSelectBlock)
        return;

    rSelectBlock.m_nColIndex = 0;
    rSelectBlock.m_nRowIndex = this.m_DragMouseInfo.m_nSelectChartIndex;
    var nTop = rSelectBlock.m_rectBlock.m_nTop;
    var nBottom = Y;

    if (nBottom - nTop <= 30) {
        Y = rSelectBlock.m_rectBlock.m_nTop + 30;
    }

    var SelectBlockHeight = rSelectBlock.m_rectBlock.Height();

    var rNextChartBlock = this.m_ChartBlockArray[this.m_DragMouseInfo.m_nSelectNextChartIndex];
    if(!rNextChartBlock)
        return;

    rNextChartBlock.m_nColIndex = 0;
    rNextChartBlock.m_nRowIndex = this.m_DragMouseInfo.m_nSelectNextChartIndex;

    nTop = Y;
    nBottom = rNextChartBlock.m_rectGraphBackground.m_nBottom;
    if (nBottom - nTop <=  30) {
        Y = rNextChartBlock.m_rectGraphBackground.m_nBottom - 30;
    }

    rSelectBlock.m_rectBlock.SetRect(rSelectBlock.m_rectBlock.m_nLeft, rSelectBlock.m_rectBlock.m_nTop, rSelectBlock.m_rectBlock.m_nRight, Y);
    rNextChartBlock.m_rectBlock.SetRect(rNextChartBlock.m_rectBlock.m_nLeft, Y, rNextChartBlock.m_rectBlock.m_nRight, rNextChartBlock.m_rectBlock.m_nBottom);

    var rNexChartBlockHeight = rNextChartBlock.m_rectBlock.Height();

    this.m_BlockSizeRatioArray[this.m_DragMouseInfo.m_nSelectChartIndex] = SelectBlockHeight / nH;
    this.m_BlockSizeRatioArray[this.m_DragMouseInfo.m_nSelectNextChartIndex] = rNexChartBlockHeight / nH;
    this.m_rChart.Draw(DRAW_CASE_RESIZE);
}
//LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 <<<<<<<<<

/**********************확대 축소 버튼*************************************************/
CMainBlock.prototype.ZoomIn = function (nZoomViewCnt) {

    var length = this.m_ChartBlockArray.length;
    if (length <= 0)
        return;

    var ChartFirstBlock = this.m_ChartBlockArray[0];

    if (ChartFirstBlock) {
        var rSelectedGraph = ChartFirstBlock.GetSelectedGraph();
        var rXScaleMng = rSelectedGraph.GetXScaleMng();
        var nGraphRegionWidth = ChartFirstBlock.m_rectGraphRegion.Width();

        if (rXScaleMng.GetXScalePacketName() === "_HOGA_") 
            nZoomViewCnt = 1;

        {
            if (nGraphRegionWidth > 0) {
                var nTotalCnt = rXScaleMng.GetMergeDataCnt();

                var nViewEndIndex = rXScaleMng.m_nViewEndIndex;

                var nViewCnt = rXScaleMng.m_nViewEndIndex - rXScaleMng.m_nViewStartIndex + 1;

                if (nViewCnt <= 1)
                    return;

                nViewCnt -= nZoomViewCnt;

                if (nViewCnt < 1)
                    nViewCnt = 1;

                this.m_rChart.InitialViewInfo(nViewCnt);

                var nViewStartIndex = nViewEndIndex - nViewCnt + 1;
                if (nViewStartIndex < 0)
                    nViewStartIndex = 0;

                var nMoveScroll = nViewStartIndex - this.m_rChart.m_ScrollCtrl.m_Pos;//스크롤 이동되어야 할 최소봉폭 개수

                this.m_rChart.ExtractYScaleMinMax(true);
                this.m_rChart.m_ScrollCtrl.Scroll(nMoveScroll);
                this.m_rChart.Draw(DRAW_CASE_RESIZE);
            }
        }

    }
}

CMainBlock.prototype.ZoomOut = function (nZoomViewCnt) {

    var length = this.m_ChartBlockArray.length;
    if (length <= 0)
        return;

    var ChartFirstBlock = this.m_ChartBlockArray[0];

    if (ChartFirstBlock) {
        var rSelectedGraph = ChartFirstBlock.GetSelectedGraph();
        var rXScaleMng = rSelectedGraph.GetXScaleMng();
        var nGraphRegionWidth = ChartFirstBlock.m_rectGraphRegion.Width();

        if (rXScaleMng.GetXScalePacketName() === "_HOGA_") 
            nZoomViewCnt = 1;
        
        {
            if (nGraphRegionWidth > 0) {
                var nTotalCnt = rXScaleMng.GetMergeDataCnt();

                var nViewEndIndex = rXScaleMng.m_nViewEndIndex;

                var nViewCnt = rXScaleMng.m_nViewEndIndex - rXScaleMng.m_nViewStartIndex + 1;

                if (nViewCnt >= nTotalCnt)
                    return;

                nViewCnt += nZoomViewCnt;

                if (nViewCnt > nTotalCnt)
                    nViewCnt = nTotalCnt;

                this.m_rChart.InitialViewInfo(nViewCnt);

                var nViewStartIndex = nViewEndIndex - nViewCnt + 1;
                if (nViewStartIndex < 0)
                    nViewStartIndex = 0;

                var nMoveScroll = nViewStartIndex - this.m_rChart.m_ScrollCtrl.m_Pos;//스크롤 이동되어야 할 최소봉폭 개수

                this.m_rChart.ExtractYScaleMinMax(true);
                this.m_rChart.m_ScrollCtrl.Scroll(nMoveScroll);
                this.m_rChart.Draw(DRAW_CASE_RESIZE);
            }
        }

    }
}
/*********************************************************************************/

CMainBlock.prototype.ExtractYScaleMinMax = function (bFullScan) {
    for (var i = 0; i < this.m_ChartBlockArray.length; i++) {
        var ChartBlock = this.m_ChartBlockArray[i];
        ChartBlock.ExtractYScaleMinMax(bFullScan);
    }
}
CMainBlock.prototype.ExtractYScaleMinMaxOnRealData = function (bFullScan) {
    for (var i = 0; i < this.m_ChartBlockArray.length; i++) {
        var ChartBlock = this.m_ChartBlockArray[i];
        ChartBlock.ExtractYScaleMinMaxOnRealData(bFullScan);
    }
}
CMainBlock.prototype.SetRect = function (nLeft, nTop, nRight, nBottom) {
    this.m_rectMainBlock.SetRect(nLeft, nTop, nRight, nBottom);
}
CMainBlock.prototype.GetRect = function () {
    return this.m_rectMainBlock;
}
CMainBlock.prototype.GetXScalePacketName = function (rXScalePacketNameArray) {
    var i;
    for (i = 0; i < this.m_ChartBlockArray.length; i++) {
        var Block = this.m_ChartBlockArray[i];
        Block.GetXScalePacketNameArray(rXScalePacketNameArray);
    }
    return rXScalePacketNameArray.length > 0;
}
CMainBlock.prototype.SetXScaleMng = function (strXScalePacketName, rXScaleMng) {
    for (var i = 0; i < this.m_ChartBlockArray.length; i++) {
        var rBlock = this.m_ChartBlockArray[i];
        rBlock.SetXScaleMng(strXScalePacketName, rXScaleMng);
    }
}
CMainBlock.prototype.RemoveXScaleMng = function(strXScalePacketName){

    for (var i = 0; i < this.m_ChartBlockArray.length; i++) {
        var rBlock = this.m_ChartBlockArray[i];
        rBlock.RemoveXScaleMng(strXScalePacketName);
    }
}
CMainBlock.prototype.SetBlockType = function (nBlockType) {
    this.m_nBlockType = nBlockType;
}
CMainBlock.prototype.GetBlockType = function () {
    return this.m_nBlockType;
}
CMainBlock.prototype.GetMainBlockRect = function () {
    return this.m_rectMainBlock;
}

//차트 생성시점에만 호출(차트가 그려진 후에 해당 함수 호출은 금지)
//CMainBlock.prototype.CreateBlockLayout = function (nBlockType, nBlockCount, BlockSizeRatioArray, BlockRatioArray, bBlockMaximize) {
CMainBlock.prototype.CreateBlockLayout = function (rMainBlockProperty) {

    var nMainBlockType = rMainBlockProperty.m_nBlockType;
    
    this.SetBlockType(nMainBlockType);
    
    switch (nMainBlockType) {
        case VERT_BLOCK_TYPE://세로형
            return this.CreateVBlockLayout(rMainBlockProperty.m_ChartBlockPropertyArray);
        case HORZ_BLOCK_TYPE://가로형
            return this.CreateHBlockLayout(rMainBlockProperty.m_ChartBlockPropertyArray);
        default:
            return false;
    }
}

CMainBlock.prototype.CreateVBlockLayout = function (rChartBlockPropertyArray) {

    var rectClient = this.GetMainBlockRect();
    var nH = rectClient.Height();
    var nW = rectClient.Width();

    ///////////////////////////////////////
    var i, dRatioSum = 0, nBlockCount = rChartBlockPropertyArray.length;

    ///////////////////////////////////////
    var NewBlock, rChartBlockProperty;
    var nPrevBottom = rectClient.m_nTop, nBottom = 0;
    var nBlockH = 0;
    for (i = 0; i < nBlockCount - 1; i++) {

        rChartBlockProperty = rChartBlockPropertyArray[i];

        NewBlock = new CChartBlock(this);
        NewBlock.m_nColIndex = 0;
        NewBlock.m_nRowIndex = i;

        nBottom = nPrevBottom + (nH * rChartBlockProperty.m_BlockSizeRatio);
        NewBlock.m_rectBlock.SetRect(rectClient.m_nLeft, nPrevBottom, rectClient.m_nRight, nBottom);

        NewBlock.SetXScaleShowOption(0x00);
        NewBlock.SetYScaleShowOption(0x02);
        NewBlock.SetBlockRatio(rChartBlockProperty.m_nBlockRatio);
        this.m_ChartBlockArray[this.m_ChartBlockArray.length] = NewBlock;

        nPrevBottom = nBottom;

        if(rChartBlockProperty.m_bBlockMaximize)
            this.m_rMaximumBlock = NewBlock;
    }

    rChartBlockProperty = rChartBlockPropertyArray[i];

    NewBlock = new CChartBlock(this);
    NewBlock.m_nColIndex = 0;
    NewBlock.m_nRowIndex = i;
    NewBlock.m_rectBlock.SetRect(rectClient.m_nLeft, nPrevBottom, rectClient.m_nRight, rectClient.m_nBottom);
    NewBlock.SetXScaleShowOption(0x01);
    NewBlock.SetYScaleShowOption(0x02);
    NewBlock.SetBlockRatio(rChartBlockProperty.m_nBlockRatio);
    this.m_ChartBlockArray[this.m_ChartBlockArray.length] = NewBlock;
    if(rChartBlockProperty.m_bBlockMaximize)
        this.m_rMaximumBlock = NewBlock;

    /////////////////
    //resize시 블록크기 비율이 유지될 수 있도록 처리
    for (i = 0; i < nBlockCount ; i++) {
        this.m_BlockSizeRatioArray[i] = this.m_ChartBlockArray[i].m_rectBlock.Height() / nH;
    }
    //////////////////

    return true;
}

CMainBlock.prototype.CreateHBlockLayout = function (rChartBlockPropertyArray) {

    var rectClient = this.GetMainBlockRect();
    var nH = rectClient.Height();
    var nW = rectClient.Width();

    ///////////////////////////////////////
    var i, dRatioSum = 0, nBlockCount = rChartBlockPropertyArray.length;

    ///////////////////////////////////////
    var NewBlock, rChartBlockProperty;
    var nPrevRight = rectClient.m_nLeft, nRight = 0;
    var nBlockW = 0;
    for (i = 0; i < nBlockCount - 1; i++) {

        rChartBlockProperty = rChartBlockPropertyArray[i];

        NewBlock = new CChartBlock(this);
        NewBlock.m_nColIndex = i;
        NewBlock.m_nRowIndex = 0;

        nRight = nPrevRight + nW * rChartBlockProperty.m_BlockSizeRatio;
        NewBlock.m_rectBlock.SetRect(nPrevLeft, rectClient.m_nTop, nRight, rectClient.m_nBottom);

        NewBlock.SetXScaleShowOption(0x01);
        NewBlock.SetYScaleShowOption(0x02);
        NewBlock.SetBlockRatio(rChartBlockProperty.m_nBlockRatio);
        this.m_ChartBlockArray[this.m_ChartBlockArray.length] = NewBlock;

        nPrevRight = nRight;

        if(rChartBlockProperty.m_bBlockMaximize)
            this.m_rMaximumBlock = NewBlock;
    }

    rChartBlockProperty = rChartBlockPropertyArray[i];

    NewBlock = new CChartBlock(this);
    NewBlock.m_nColIndex = i;
    NewBlock.m_nRowIndex = 0;
    NewBlock.m_rectBlock.SetRect(nPrevRight, rectClient.m_nTop, rectClient.m_nRight, rectClient.m_nBottom);
    NewBlock.SetXScaleShowOption(0x01);
    NewBlock.SetYScaleShowOption(0x02);
    NewBlock.SetBlockRatio(rChartBlockProperty.m_nBlockRatio);
    this.m_ChartBlockArray[this.m_ChartBlockArray.length] = NewBlock;
    if(rChartBlockProperty.m_bBlockMaximize)
        this.m_rMaximumBlock = NewBlock;

    /////////////////
    //resize시 블록크기 비율이 유지될 수 있도록 처리
    for (i = 0; i < nBlockCount; i++) {
        this.m_BlockSizeRatioArray[i] = this.m_ChartBlockArray[i].m_rectBlock.Width() / nW;
    }
    //////////////////

    return true;
}

CMainBlock.prototype.AddBlock = function (nBlockRatio) {
    var rNewBlock = null;
    switch (this.GetBlockType()) {
        case VERT_BLOCK_TYPE://세로형
            rNewBlock = this.AddVBlock(nBlockRatio);
            break;
        case HORZ_BLOCK_TYPE://가로형
            rNewBlock = this.AddHBlock(nBlockRatio);//비율값을 저장만 해놓고 나중에 세로형타입으로 변경될 때 적용하도록 한다
            break;
    }
    return rNewBlock;
}

CMainBlock.prototype.ResetVBlockHeight = function () {

    //최대화블록 상태인 경우는 동작시키지 않는다
    if (this.m_rMaximumBlock !== null)
        return;

    var rBlock = null;
    var rectClient = this.GetMainBlockRect();

    var nH = rectClient.Height();
    var nW = rectClient.Width();

    var i, nBlockCnt;
    nBlockCnt = this.m_ChartBlockArray.length;

    //추가 이전의 각 블록 높이 저장
    var nHeightRatioSum = 0;
    for (i = 0; i < this.m_ChartBlockArray.length; i++) {
        rBlock = this.m_ChartBlockArray[i];
        nHeightRatioSum += rBlock.GetBlockRatio();
    }

    var nHeightUnit = nH / nHeightRatioSum;
    var nPrevBottom = rectClient.m_nTop;

    //저장한 블록높이의 비율에 맞게 전체 블록높이 재조정
    for (i = 0; i < this.m_ChartBlockArray.length; i++) {

        rBlock = this.m_ChartBlockArray[i];
        var nBlockNewH = nHeightUnit * rBlock.GetBlockRatio();

        rBlock.m_rectBlock.SetRect(rectClient.m_nLeft, nPrevBottom, rectClient.m_nRight, nPrevBottom + nBlockNewH);

        nPrevBottom = nPrevBottom + nBlockNewH;
    }
}

CMainBlock.prototype.AddVBlock = function (nHeightRatioInVertType) {

    var rectClient = this.GetMainBlockRect();

    var nH = rectClient.Height();
    var nW = rectClient.Width();

    var i, nBlockCnt = this.m_ChartBlockArray.length;

    var nHeightRatioSum = nHeightRatioInVertType;
    for (i = 0; i < nBlockCnt; i++)
        nHeightRatioSum += this.m_ChartBlockArray[i].GetBlockRatio();
    
    var nPrevBottom = rectClient.m_nTop;
    var nBottom = 0;

    //저장한 블록높이의 비율에 맞게 전체 블록높이 재조정
    for (i = 0; i < nBlockCnt; i++) {

        var rBlock = this.m_ChartBlockArray[i];
        nBottom = nPrevBottom + nH * (rBlock.GetBlockRatio() / nHeightRatioSum);
        rBlock.m_rectBlock.SetRect(rectClient.m_nLeft, nPrevBottom, rectClient.m_nRight, nBottom);
        rBlock.SetXScaleShowOption(0x00);

        nPrevBottom = nBottom;
    }

    var NewBlock = new CChartBlock(this);
    NewBlock.m_nColIndex = 0;
    NewBlock.m_nRowIndex = i;
    NewBlock.m_rectBlock.SetRect(rectClient.m_nLeft, nPrevBottom, rectClient.m_nRight, rectClient.m_nBottom);
    NewBlock.SetXScaleShowOption(0x01);
    NewBlock.SetYScaleShowOption(0x02);
    NewBlock.SetBlockRatio(nHeightRatioInVertType);

    this.m_ChartBlockArray[this.m_ChartBlockArray.length] = NewBlock;

    /////////////////
    //resize시 블록크기 비율이 유지될 수 있도록 처리
    for (i = 0; i < this.m_ChartBlockArray.length; i++) {
        this.m_BlockSizeRatioArray[i] = this.m_ChartBlockArray[i].m_rectBlock.Height() / nH;
    }
    //////////////////

    return NewBlock;
}
CMainBlock.prototype.AddHBlock = function (nRatioInHorzType) {

    var rectClient = this.GetMainBlockRect();

    var nW = rectClient.Width();
    var nH = rectClient.Height();

    var i, nBlockCnt = this.m_ChartBlockArray.length;
    var nWidthRatioSum = nRatioHorzType;
    for (i = 0; i < nBlockCnt; i++)
        nWidthRatioSum += this.m_ChartBlockArray[i].GetBlockRatio();

    var nPrevRight = rectClient.m_nLeft;
    var nRight = 0;

    //저장한 블록높이의 비율에 맞게 전체 블록높이 재조정
    for (i = 0; i < nBlockCnt ; i++) {
        var rBlock = this.m_ChartBlockArray[i];
        nRight = nPrevLeft + nW * (rBlock.GetBlockRatio() / nWidthRatioSum);
        rBlock.m_rectBlock.SetRect(nPrevRight, rectClient.m_nTop, nRight, rectClient.m_nBottom);

        nPrevRight = nRight;
    }

    var NewBlock = new CChartBlock(this);
    NewBlock.m_nColIndex = i;
    NewBlock.m_nRowIndex = 0;
    NewBlock.m_rectBlock.SetRect(nPrevRight, rectClient.m_nTop, rectClient.m_nRight, rectClient.m_nBottom);
    NewBlock.SetXScaleShowOption(0x01);
    NewBlock.SetYScaleShowOption(0x02);
    NewBlock.SetBlockRatio(nRatioInHorzType);
    this.m_ChartBlockArray[this.m_ChartBlockArray.length] = NewBlock;

    /////////////////
    //resize시 블록크기 비율이 유지될 수 있도록 처리
    for (i = 0; i < this.m_ChartBlockArray.length; i++) {
        this.m_BlockSizeRatioArray[i] = this.m_ChartBlockArray[i].m_rectBlock.Width() / nW;
    }
    //////////////////

    return NewBlock;
}
CMainBlock.prototype.ResizeBlocks = function () {

    switch (this.GetBlockType()) {
        case VERT_BLOCK_TYPE://세로형
            this.ResizeVBlocks();
            break;
        case HORZ_BLOCK_TYPE://가로형
            this.ResizeHBlocks();
            break;
    }
}
CMainBlock.prototype.ResizeVBlocks = function () {

    var rectClient = this.GetMainBlockRect();

    var nH = rectClient.Height();
    var nW = rectClient.Width();

    var i, nBlockCnt;
    nBlockCnt = this.m_ChartBlockArray.length;
    if (nBlockCnt <= 0)
        return;

    var nPrevBottom = rectClient.m_nTop;

    //LKY 블록 확대 축소 기능 이벤트 구현 >>>
    if(this.m_rMaximumBlock !== null){

        this.m_rMaximumBlock.m_rectBlock.SetRect(rectClient.m_nLeft, rectClient.m_nTop, rectClient.m_nRight, rectClient.m_nBottom);
    }
    else {
//저장한 블록높이의 비율에 맞게 전체 블록높이 재조정
        var dHSum = 0;
        for (i = 0; i < nBlockCnt - 1; i++) {
            var Block = this.m_ChartBlockArray[i];
	
            var nBlockNewH = this.m_BlockSizeRatioArray[i] * nH;
	
            Block.m_rectBlock.SetRect(rectClient.m_nLeft, nPrevBottom, rectClient.m_nRight, nPrevBottom + nBlockNewH);
	
            Block.m_nColIndex = 0;
            Block.m_nRowIndex = i;
	
            nPrevBottom = nPrevBottom + nBlockNewH;
        }
	
        var rLastBlock = this.m_ChartBlockArray[this.m_ChartBlockArray.length - 1];
        rLastBlock.m_nColIndex = 0;
        rLastBlock.m_nRowIndex = this.m_ChartBlockArray.length - 1;
        rLastBlock.m_rectBlock.SetRect(rectClient.m_nLeft, nPrevBottom, rectClient.m_nRight, rectClient.m_nBottom);
	}
    //LKY 블록 확대 축소 기능 이벤트 구현 <<<
}
CMainBlock.prototype.ResizeHBlocks = function () {

    var rectClient = this.GetMainBlockRect();

    var nH = rectClient.Height();
    var nW = rectClient.Width();

    var i, nBlockCnt;
    nBlockCnt = this.m_ChartBlockArray.length;

    var nPrevRight = rectClient.m_nLeft;

    //저장한 블록높이의 비율에 맞게 전체 블록높이 재조정
    for (i = 0; i < nBlockCnt - 1; i++) {

        var Block = this.m_ChartBlockArray[i];

        var nBlockNewW = this.m_BlockSizeRatioArray[i] * nW;

        Block.m_rectBlock.SetRect(nPrevRight, rectClient.m_nTop, nPrevRight + nBlockNewW, rectClient.m_nBottom);

        Block.m_nColIndex = i;
        Block.m_nRowIndex = 0;

        nPrevRight = nPrevRight + nBlockNewW;
    }

    var rLastBlock = this.m_ChartBlockArray[this.m_ChartBlockArray.length - 1];
    rLastBlock.m_nColIndex = this.m_ChartBlockArray.length - 1;
    rLastBlock.m_nRowIndex = 0;
    rLastBlock.m_rectBlock.SetRect(nPrevRight, rectClient.m_nTop, rectClient.m_nRight, rectClient.m_nBottom);
}
CMainBlock.prototype.AddIndicator = function (rRQSet, strIndicatorName, nBlockColIndex, nBlockRowIndex, nVertScaleIndex, nBlockRatio, IndicatorPropertyInfo) {

    if (!rRQSet)
        return "";

    //ColIndex나 RowIndex 잘못 전달됨
    if (nBlockColIndex * nBlockRowIndex < 0)
        return "";

    var rSelectBlock = null;
    var strIndicatorKey = "";

    //최대화블록 복원시킴
    if (this.m_rMaximumBlock !== null)
        this.RestoreChartBlock(false);
    

    //block 새로 생성
    if (nBlockColIndex < 0 && nBlockRowIndex < 0) {
        rSelectBlock = this.AddBlock(nBlockRatio);
    }
    else {
        var i;
        for (i = 0; i < this.m_ChartBlockArray.length; i++) {
            var Block = this.m_ChartBlockArray[i];
            if (Block.m_nColIndex === nBlockColIndex &&
                Block.m_nRowIndex === nBlockRowIndex) {
                rSelectBlock = Block;
                break;
            }
        }
    }

    if (!rSelectBlock)
        return strIndicatorKey;

    strIndicatorKey = rSelectBlock.AddIndicator(rRQSet, strIndicatorName, nVertScaleIndex, IndicatorPropertyInfo);

    //this.m_rChart.RegXScaleMngByIndicator();//새로운 X Scale 종류를 사용하는 지표가 추가될 수 있으므로 지표추가하면서 XScaleMng 생성 여부 체크한다

    return strIndicatorKey;
}
CMainBlock.prototype.DeleteIndicator = function (strIndicatorKey) {

    //최대화블록 복원시킴
    if (this.m_rMaximumBlock !== null)
        this.RestoreChartBlock(false);

    var i, j, nLength = this.m_ChartBlockArray.length;
    for (i = 0; i < nLength; i++) {
        var rChartBlock = this.m_ChartBlockArray[i];
        if (rChartBlock.DeleteIndicator(strIndicatorKey)) {

            if (rChartBlock.m_GraphArray.length <= 0) {

                var nRealSize = 0;

                switch (this.GetBlockType()) {
                    case VERT_BLOCK_TYPE://세로형
                        nRealSize = this.m_rectMainBlock.Height() - rChartBlock.m_rectBlock.Height();
                        break;
                    case HORZ_BLOCK_TYPE://가로형
                        nRealSize = this.m_rectMainBlock.Width() - rChartBlock.m_rectBlock.Width();
                        break;
                }

                rChartBlock.Remove();

                this.m_ChartBlockArray.splice(i, 1);

                this.m_BlockSizeRatioArray.length = 0;
                for (j = 0; j < this.m_ChartBlockArray.length; j++) {

                    switch (this.GetBlockType()) {
                        case VERT_BLOCK_TYPE://세로형
                            this.m_BlockSizeRatioArray[j] = this.m_ChartBlockArray[j].m_rectBlock.Height() / nRealSize;
                            break;
                        case HORZ_BLOCK_TYPE://가로형
                            this.m_BlockSizeRatioArray[j] = this.m_ChartBlockArray[j].m_rectBlock.Width() / nRealSize;
                            break;
                    }
                    
                }

                var rLastBlock = this.m_ChartBlockArray[this.m_ChartBlockArray.length - 1];

                if (i == nLength - 1) {
                    switch (this.GetBlockType()) {
                        case VERT_BLOCK_TYPE://세로형
                            rLastBlock.SetXScaleShowOption(0x01);
                            break;
                        case HORZ_BLOCK_TYPE://가로형
                            rLastBlock.SetYScaleShowOption(0x02);
                            break;
                    }
                }

                //Block Resize
                this.ResizeBlocks();
            }

            //this.m_rChart.RegXScaleMngByIndicator();//지표가 제거되면서 X ScaleMng도 사용여부 체크하여 사용하지 않으면 제거

            return true;
        }
    }
    return false;
}
CMainBlock.prototype.SetPropertyInfo = function (strIndicatorKey, IndicatorPropertyInfo, bSetup) {
    var i, nLength = this.m_ChartBlockArray.length;
    for (i = 0; i < nLength; i++) {
        if (this.m_ChartBlockArray[i].SetPropertyInfo(strIndicatorKey, IndicatorPropertyInfo, bSetup))
            return true;
    }
    return false;
}
CMainBlock.prototype.GetPropertyInfo = function (strIndicatorKey) {
    var IndicatorPropertyInfo = null;
    var i, nLength = this.m_ChartBlockArray.length;
    for (i = 0; i < nLength; i++) {
        IndicatorPropertyInfo = this.m_ChartBlockArray[i].GetPropertyInfo(strIndicatorKey);
        if (IndicatorPropertyInfo != null)
            return IndicatorPropertyInfo;
    }
    return null;
}
CMainBlock.prototype.CalcLayout = function (LayoutInfo) {

    var i,j,k, iIndex;
    var nMaxYScaleWidth = 0;
    var bLeftYScaleShow = false;
    var bRightYScaleShow = false;
    var bBottomXScaleShow = false;
    var bTopXScaleShow = false;
    var length = this.m_ChartBlockArray.length;
    var nFontH = LayoutInfo.m_nFontSize;
    var rRQInCol = null;
    var rChartBlock, rGraph;
    var nYScaleWidth, nYShowOption;
    var rFindRQInCol, rChartBlockCol, rFindChartBlockCol, rXScaleMng, rXScale;
    var nGraphArrayLen, nLength, nRQInColArrayLen, nXScaleArrayLen, nGraphInColArrayLen;
    var strXScalePacketName;

    switch (this.m_nBlockType) {
        case VERT_BLOCK_TYPE://세로형
            {
                for (i = 0; i < length; i++) {
                    rChartBlock = this.m_ChartBlockArray[i];
                    nYScaleWidth = rChartBlock.CalcYScaleWidth(LayoutInfo);
                    if (nYScaleWidth > nMaxYScaleWidth)
                        nMaxYScaleWidth = nYScaleWidth;

                    nYShowOption = rChartBlock.m_nYScaleShowOption;
                    if (nYShowOption & 0x01)
                        bLeftYScaleShow = true;
                    if (nYShowOption & 0x02)
                        bRightYScaleShow = true;
                }

                //LKY 블록 확대 축소 이벤트 구현 >>>
                if(this.m_rMaximumBlock != null){
                    this.m_rMaximumBlock.SetXScaleShowOption(0x01);
                }
                else {

                    for (i = 0; i < this.m_ChartBlockArray.length -1; i++) {
                        rChartBlock = this.m_ChartBlockArray[i];
                        rChartBlock.SetXScaleShowOption(0x00);
                    }
                }
                //LKY 블록 확대 축소 이벤트 구현 <<<

                for (i = 0; i < length; i++) {
                    rChartBlock = this.m_ChartBlockArray[i];
                    rChartBlock.CalcLayoutVert(bLeftYScaleShow, bRightYScaleShow, nMaxYScaleWidth, LayoutInfo);
                }

                //그리기 속도개선
                if (LayoutInfo.m_nDrawCase & DRAW_CASE_ADD_CHARTBLOCK || LayoutInfo.m_nDrawCase & DRAW_CASE_DEL_CHARTBLOCK) {

                    rChartBlockCol = null;

                    for ( strXScalePacketName in this.m_mapXScaleMng) {
                        rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];
                        rXScaleMng.m_ChartBlockColArray.length = 0;
                    }

                    for (i = 0; i < length; i++) {

                        rChartBlock = this.m_ChartBlockArray[i];

                        nGraphArrayLen = rChartBlock.m_GraphArray.length;
                        for (j = 0; j < nGraphArrayLen; j++) {

                            rGraph = rChartBlock.m_GraphArray[j];

                            //그래프의 XScale 데이터패킷과 ChartBlockCol의 XScale 데이터패킷이 다르면 ChartBlockCol에 XScale 데이터 추가시키지 않도록 처리
                            //(CChartBlockCol은 XScaleMng의 하위계층구조이므로 서로 다른 XScaleMng의 Graph는 저장하지 않는다!!)
                            strXScalePacketName = rGraph.m_rXAxisPacket.m_strPacketName;
                            rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];
                            if (rXScaleMng === undefined)
                                continue;

                            if (rXScaleMng.m_ChartBlockColArray.length <= 0) {

                                rChartBlockCol = new CChartBlockCol();
                                rChartBlockCol.m_rXScaleMng = rXScaleMng;
                                rChartBlockCol.m_nLeft = rChartBlock.m_rectBlock.m_nLeft;
                                rChartBlockCol.m_nRight = rChartBlock.m_rectBlock.m_nRight;
                                rChartBlockCol.m_nGraphRegionLeft = rChartBlock.m_rectGraphRegion.m_nLeft;
                                rChartBlockCol.m_nGraphRegionRight = rChartBlock.m_rectGraphRegion.m_nRight;

                                rXScaleMng.m_ChartBlockColArray[0] = rChartBlockCol;
                            }
                            else {
                                rChartBlockCol = rXScaleMng.m_ChartBlockColArray[0];
                            }

                            rFindRQInCol = null;
                            nRQInColArrayLen = rChartBlockCol.m_RQInColArray.length;
                            for (k = 0; k < nRQInColArrayLen; k++) {

                                rRQInCol = rChartBlockCol.m_RQInColArray[k];
                                if (rRQInCol.m_strRQ === rGraph.m_rRQSet.m_strRQ) {

                                    rRQInCol.m_GraphInColArray[rRQInCol.m_GraphInColArray.length] = rGraph;
                                    rGraph.SetRQInCol(rRQInCol);

                                    rFindRQInCol = rRQInCol;

                                    break;
                                }
                            }
                            if (!rFindRQInCol) {

                                rFindRQInCol = new CRQInCol();

                                rFindRQInCol.m_strRQ = rGraph.m_rRQSet.m_strRQ;
                                rFindRQInCol.m_nRQCycle = rGraph.m_rRQSet.m_RQInfo.m_nCycle;
                                rFindRQInCol.m_nRQInterval = rGraph.m_rRQSet.m_RQInfo.m_nInterval;
                                rFindRQInCol.m_rRQSet = rGraph.m_rRQSet;

                                rFindRQInCol.m_rChartBlockCol = rChartBlockCol;
                                rFindRQInCol.m_GraphInColArray[0] = rGraph;
                                rGraph.SetRQInCol(rFindRQInCol);

                                rChartBlockCol.m_RQInColArray[rChartBlockCol.m_RQInColArray.length] = rFindRQInCol;
                            }
                        }

                        if (rChartBlockCol !== null) {

                            nXScaleArrayLen = rChartBlock.m_XScaleArray.length;
                            for (k = 0; k < nXScaleArrayLen; k++) {

                                var rXScale = rChartBlock.m_XScaleArray[k];
                                if (rXScale.m_strXScalePacketName === strXScalePacketName) {
                                    rXScale.SetChartBlockCol(rChartBlockCol);
                                    break;
                                }
                            }
                        }
                    }
                }
                else {

                    for ( strXScalePacketName in this.m_mapXScaleMng) {

                        rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];

                        var nLength = rXScaleMng.m_ChartBlockColArray.length;
                        for (i = 0; i < nLength; i++) {

                            rChartBlockCol = rXScaleMng.m_ChartBlockColArray[i];
                            nRQInColArrayLen = rChartBlockCol.m_RQInColArray.length;
                            for (j = 0; j < nRQInColArrayLen; j++) {
                                
                                rRQInCol = rChartBlockCol.m_RQInColArray[j];
                                nGraphInColArrayLen = rRQInCol.m_GraphInColArray.length;
                                for (k = 0; k < nGraphInColArrayLen; k++) {

                                    rGraph = rRQInCol.m_GraphInColArray[k];
                                    if (rGraph !== null && rGraph.m_rChartBlock !== null) {

                                        rChartBlock = (this.m_rMaximumBlock !== null ? this.m_rMaximumBlock : rGraph.m_rBlock);
                                        rChartBlockCol.m_nLeft = rChartBlock.m_rectBlock.m_nLeft;
                                        rChartBlockCol.m_nRight = rChartBlock.m_rectBlock.m_nRight;
                                        rChartBlockCol.m_nGraphRegionLeft = rChartBlock.m_rectGraphRegion.m_nLeft;
                                        rChartBlockCol.m_nGraphRegionRight = rChartBlock.m_rectGraphRegion.m_nRight;
                                        break;
                                    }
                                }
                                if (k < nGraphInColArrayLen)
                                    break;
                            }
                        }
                    }
                }
            }
            break;
        case HORZ_BLOCK_TYPE://가로형
            {
                //블록 중 XScaleShow 옵션을 모두 체크
                for (i = 0; i < length; i++) {
                    rChartBlock = this.m_ChartBlockArray[i];

                    if (rChartBlock.m_nXScaleShowOption & 0x01)
                        bBottomXScaleShow = true;
                    if (rChartBlock.m_nXScaleShowOption & 0x02)
                        bTopXScaleShow = true;
                }

                //위 루프에서 체크된 옵션을 이용해서 셋팅(위 루프안에 코드 넣지 않도록 한다)
                for (i = 0; i < length; i++) {
                    rChartBlock = this.m_ChartBlockArray[i];
                    rChartBlock.CalcLayoutHorz(bTopXScaleShow, bBottomXScaleShow, nFontH, LayoutInfo);
                }

                //그리기 속도개선
                if (this.m_rMaximumBlock === null && (LayoutInfo.m_nDrawCase & DRAW_CASE_ADD_CHARTBLOCK || LayoutInfo.m_nDrawCase & DRAW_CASE_DEL_CHARTBLOCK)) {

                    rChartBlockCol = null;

                    for ( strXScalePacketName in this.m_mapXScaleMng) {
                        rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];
                        rXScaleMng.m_ChartBlockColArray.length = 0;
                    }

                    for (i = 0; i < length; i++) {

                        rChartBlock = this.m_ChartBlockArray[i];

                        nGraphArrayLen = rChartBlock.m_GraphArray.length;
                        for (j = 0; j < nGraphArrayLen; j++) {

                            rGraph = rChartBlock.m_GraphArray[j];

                            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //그래프의 XScale 데이터패킷과 ChartBlockCol의 XScale 데이터패킷이 다르면 ChartBlockCol에 XScale 데이터 추가시키지 않도록 처리
                            //(CChartBlockCol은 XScaleMng의 하위계층구조이므로 서로 다른 XScaleMng의 Graph는 저장하지 않는다!!)
                            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            strXScalePacketName = rGraph.m_rXAxisPacket.m_strPacketName;
                            rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];
                            if (rXScaleMng === undefined)
                                continue;

                            rFindChartBlockCol = null;
                            //ChartBlockCol 생성 및 추가, ChartBlockCol에 ChartBlock 등록
                            for (k = 0; k < rXScaleMng.m_ChartBlockColArray.length; k++) {

                                rChartBlockCol = rXScaleMng.m_ChartBlockColArray[k];
                                if (rChartBlockCol.m_nLeft === rChartBlock.m_rectBlock.m_nLeft &&
                                    rChartBlockCol.m_nRight === rChartBlock.m_rectBlock.m_nRight) {

                                    rFindChartBlockCol = rChartBlockCol;
                                    break;
                                }
                            }

                            if (rFindChartBlockCol === null) {

                                rChartBlockCol = new CChartBlockCol();
                                rChartBlockCol.m_rXScaleMng = rXScaleMng;
                                rChartBlockCol.m_nLeft = rChartBlock.m_rectBlock.m_nLeft;
                                rChartBlockCol.m_nRight = rChartBlock.m_rectBlock.m_nRight;
                                rChartBlockCol.m_nGraphRegionLeft = rChartBlock.m_rectGraphRegion.m_nLeft;
                                rChartBlockCol.m_nGraphRegionRight = rChartBlock.m_rectGraphRegion.m_nRight;

                                rXScaleMng.m_ChartBlockColArray[rXScaleMng.m_ChartBlockColArray.length] = rChartBlockCol;

                                nXScaleArrayLen = rChartBlock.m_XScaleArray.length;
                                for (k = 0; k < nXScaleArrayLen; k++) {

                                    rXScale = rChartBlock.m_XScaleArray[k];
                                    if (rXScale.m_strXScalePacketName === strXScalePacketName) {
                                        rXScale.SetChartBlockCol(rChartBlockCol);
                                        break;
                                    }
                                }

                                rFindChartBlockCol = rChartBlockCol;
                            }

                            /////////////////////////////////////////
                            //ChartBlockCol에 RQInCol 등록
                            ////////////////////////////////////////
                            rFindRQInCol = null;
                            nRQInColArrayLen = rFindChartBlockCol.m_RQInColArray.length;
                            for (k = 0; k < nRQInColArrayLen; k++) {//기존에 해당RQ가 등록되어 있는지 확인

                                rRQInCol = rFindChartBlockCol.m_RQInColArray[k];
                                if (rRQInCol.m_strRQ === rGraph.m_rRQSet.m_strRQ) {//해당rq가 이미 등록

                                    rRQInCol.m_GraphInColArray[rRQInCol.m_GraphInColArray.length] = rGraph;

                                    rFindRQInCol = rRQInCol;

                                    rGraph.SetRQInCol(rRQInCol);

                                    break;
                                }
                            }

                            //해당rq가 등록되어 있지 않은 경우
                            if (rFindRQInCol === null) {

                                rFindRQInCol = new CRQInCol();

                                rFindRQInCol.m_strRQ = rGraph.m_rRQSet.m_strRQ;
                                rFindRQInCol.m_nRQCycle = rGraph.m_rRQSet.m_RQInfo.m_nCycle;
                                rFindRQInCol.m_nRQInterval = rGraph.m_rRQSet.m_RQInfo.m_nInterval;
                                rFindRQInCol.m_rRQSet = rGraph.m_rRQSet;

                                rFindRQInCol.m_GraphInColArray[0] = rGraph;
                                rFindRQInCol.m_rChartBlockCol = rChartBlockCol;
                                rGraph.SetRQInCol(rFindRQInCol);

                                rChartBlockCol.m_RQInColArray[rChartBlockCol.m_RQInColArray.length] = rFindRQInCol;
                            }
                        }
                    }
                }
                else {

                    for (strXScalePacketName in this.m_mapXScaleMng) {

                        rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];

                        var nLength = rXScaleMng.m_ChartBlockColArray.length;
                        for (i = 0; i < nLength; i++) {

                            rChartBlockCol = rXScaleMng.m_ChartBlockColArray[i];
                            nRQInColArrayLen = rChartBlockCol.m_RQInColArray.length;
                            for (j = 0; j < nRQInColArrayLen; j++) {

                                rRQInCol = rChartBlockCol.m_RQInColArray[j];
                                nGraphInColArrayLen = rRQInCol.m_GraphInColArray.length;
                                for (k = 0; k < nGraphInColArrayLen; k++) {

                                    rGraph = rRQInCol.m_GraphInColArray[k];
                                    if (rGraph !== null && rGraph.m_rChartBlock !== null) {

                                        rChartBlock = (this.m_rMaximumBlock !== null ? this.m_rMaximumBlock : rGraph.m_rBlock);
                                        rChartBlockCol.m_nLeft = rChartBlock.m_rectBlock.m_nLeft;
                                        rChartBlockCol.m_nRight = rChartBlock.m_rectBlock.m_nRight;
                                        rChartBlockCol.m_nGraphRegionLeft = rChartBlock.m_rectGraphRegion.m_nLeft;
                                        rChartBlockCol.m_nGraphRegionRight = rChartBlock.m_rectGraphRegion.m_nRight;
                                        break;
                                    }
                                }
                                if (k < nGraphInColArrayLen)
                                    break;
                            }
                        }
                    }
                }
            }
            break;
    }

}
CMainBlock.prototype.RealCalcLayout = function (LayoutInfo) {

    var i,j,k;
    var nMaxYScaleWidth = 0;
    var bLeftYScaleShow = false;
    var bRightYScaleShow = false;
    var bBottomXScaleShow = false;
    var bTopXScaleShow = false;
    var length = this.m_ChartBlockArray.length;
    var nFontH = LayoutInfo.m_nFontSize;
    var rChartBlock, rChartBlockCol, rRQInCol, rGraph, rXScaleMng;
    var nYScaleWidth, nYShowOption;
    var strXScalePacketName;
    var nLength, nRQInColArrayLen, nGraphInColArrayLen;
    
    switch (this.m_nBlockType) {
        case VERT_BLOCK_TYPE://세로형
            {
                for (i = 0; i < length; i++) {
                    rChartBlock = this.m_ChartBlockArray[i];
                    nYScaleWidth = rChartBlock.CalcYScaleWidth(LayoutInfo);
                    if (nYScaleWidth > nMaxYScaleWidth)
                        nMaxYScaleWidth = nYScaleWidth;

                    nYShowOption = rChartBlock.m_nYScaleShowOption;
                    if (nYShowOption & 0x01)
                        bLeftYScaleShow = true;
                    if (nYShowOption & 0x02)
                        bRightYScaleShow = true;
                }

                for (i = 0; i < length; i++) {
                    rChartBlock = this.m_ChartBlockArray[i];
                    rChartBlock.CalcLayoutVert(bLeftYScaleShow, bRightYScaleShow, nMaxYScaleWidth, LayoutInfo);
                }

                //그리기 속도개선
                for (strXScalePacketName in this.m_mapXScaleMng) {

                    rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];

                    nLength = rXScaleMng.m_ChartBlockColArray.length;
                    for (i = 0; i < nLength; i++) {

                        rChartBlockCol = rXScaleMng.m_ChartBlockColArray[i];
                        nRQInColArrayLen = rChartBlockCol.m_RQInColArray.length;
                        for (j = 0; j < nRQInColArrayLen; j++) {

                            rRQInCol = rChartBlockCol.m_RQInColArray[j];
                            nGraphInColArrayLen = rRQInCol.m_GraphInColArray.length;
                            for (k = 0; k < nGraphInColArrayLen; k++) {

                                rGraph = rRQInCol.m_GraphInColArray[k];
                                if (rGraph !== null && rGraph.m_rChartBlock !== null) {

                                    rChartBlock = (this.m_rMaximumBlock !== null ? this.m_rMaximumBlock : rGraph.m_rBlock);
                                    rChartBlockCol.m_nLeft = rChartBlock.m_rectBlock.m_nLeft;
                                    rChartBlockCol.m_nRight = rChartBlock.m_rectBlock.m_nRight;
                                    rChartBlockCol.m_nGraphRegionLeft = rChartBlock.m_rectGraphRegion.m_nLeft;
                                    rChartBlockCol.m_nGraphRegionRight = rChartBlock.m_rectGraphRegion.m_nRight;
                                    break;
                                }
                            }
                            if (k < nGraphInColArrayLen)
                                break;
                        }
                    }
                }
            }
            break;
        case HOZR_LINE_TOOL://가로형
            {
                for (i = 0; i < length; i++) {
                    rChartBlock = this.m_ChartBlockArray[i];

                    if (rChartBlock.m_nXScaleShowOption & 0x01)
                        bBottomXScaleShow = true;
                    if (rChartBlock.m_nXScaleShowOption & 0x02)
                        bTopXScaleShow = true;
                }

                for (i = 0; i < length; i++) {
                    rChartBlock = this.m_ChartBlockArray[i];
                    rChartBlock.CalcLayoutHorz(bTopXScaleShow, bBottomXScaleShow, nFontH, LayoutInfo);
                }

                //그리기 속도개선
                for (strXScalePacketName in this.m_mapXScaleMng) {

                    rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];

                    nLength = rXScaleMng.m_ChartBlockColArray.length;
                    for (i = 0; i < nLength; i++) {

                        rChartBlockCol = rXScaleMng.m_ChartBlockColArray[i];
                        nRQInColArrayLen = rChartBlockCol.m_RQInColArray.length;
                        for (j = 0; j < nRQInColArrayLen; j++) {

                            rRQInCol = rChartBlockCol.m_RQInColArray[j];
                            nGraphInColArrayLen = rRQInCol.m_GraphInColArray.length;
                            for (k = 0; k < nGraphInColArrayLen; k++) {

                                rGraph = rRQInCol.m_GraphInColArray[k];
                                if (rGraph !== null && rGraph.m_rChartBlock !== null) {

                                    rChartBlock = (this.m_rMaximumBlock !== null ? this.m_rMaximumBlock : rGraph.m_rBlock);
                                    rChartBlockCol.m_nLeft = rChartBlock.m_rectBlock.m_nLeft;
                                    rChartBlockCol.m_nRight = rChartBlock.m_rectBlock.m_nRight;
                                    rChartBlockCol.m_nGraphRegionLeft = rChartBlock.m_rectGraphRegion.m_nLeft;
                                    rChartBlockCol.m_nGraphRegionRight = rChartBlock.m_rectGraphRegion.m_nRight;
                                    break;
                                }
                            }
                            if (k < nGraphInColArrayLen)
                                break;
                        }
                    }
                }
            }
            break;
    }

}
CMainBlock.prototype.Draw = function (DrawingInfo) {

    var i;
    var nMaxYScaleWidth = 0;
    var nLeftYScaleShow = false;
    var nRightYScaleShow = false;
    var nBottomXScaleShow = false;
    var nTopXScaleShow = false;
    var length = this.m_ChartBlockArray.length;

    if ((DrawingInfo.m_nDrawCase & (DRAW_CASE_RESIZE | DRAW_CASE_ADD_CHARTBLOCK | DRAW_CASE_DEL_CHARTBLOCK | DRAW_CASE_SET_GLOBAL_PROPERTY)) != 0)
        this.CalcLayout(DrawingInfo);
    else if (DrawingInfo.m_nDrawCase & DRAW_CASE_REAL) {
        this.RealCalcLayout(DrawingInfo);
    }

    DrawingInfo.m_DrawSelectedSubGraph = this.m_DrawSelectedSubGraph;

    //////////////////////////////////////////////////////////
    //속도개선코드 >>>>>>>
    

    for (i = 0; i < length; i++) {
        var ChartBlock = this.m_ChartBlockArray[i];
        ChartBlock.ReadyRendering(DrawingInfo);
    }

    for (var strXScaleKey in this.m_mapXScaleMng) {

        var rXScaleMng = this.m_mapXScaleMng[strXScaleKey];
        if (rXScaleMng && rXScaleMng.GetType() === DATETIME_TYPE) {

            var RenderingInfo = new CRenderingInfo();

            var i, j, k, nLength, nXScaleMergeArrayLength;
            nLength = rXScaleMng.m_XScaleItemArray.length;
            nXScaleMergeArrayLength= rXScaleMng.m_XScaleMergeArray.length;

            var nViewStartIndex = rXScaleMng.m_nViewStartIndex;
            var nViewEndIndex = rXScaleMng.m_nViewEndIndex;

            if (nViewStartIndex < 0 || nXScaleMergeArrayLength <= nViewStartIndex)
                continue;

            if (nXScaleMergeArrayLength <= nViewEndIndex)
                nViewEndIndex = nXScaleMergeArrayLength;

            //var rDateTimeXScaleItem = new CDateTimeXScaleItem(rXScaleMng);
            //var nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(nViewStartIndex, 0, nLength, rDateTimeXScaleItem);
            //if (nXScaleItemArrayIndex < 0 || rDateTimeXScaleItem === null)
            //    continue;

            //var nXScaleItemStartIndex = nViewStartIndex;

            //RenderingInfo 개체 초기화 및 기본값 셋팅
            var nChartBlockColLen = rXScaleMng.m_ChartBlockColArray.length;
            for (i = 0; i < nChartBlockColLen ; i++) {
                var rChartBlockCol = rXScaleMng.m_ChartBlockColArray[i];
                rChartBlockCol.InitRendering(rXScaleMng);
            }

            ///////////////////////////////////////////////////////////////////////
            //X축 텍스트 출력 관련 로직
            ///////////////////////////////////////////////////////////////////////
            //XScale에 속한 rq중에 최대 주기를 얻어낸다
            var nMaxCycle = null, nMaxInterval = null;
            for (var strRQ in rXScaleMng.m_mapRQSet) {

                var rRQSet = rXScaleMng.m_mapRQSet[strRQ];
                var nCycle = rRQSet.m_RQInfo.m_nCycle;
                var nInterval = rRQSet.m_RQInfo.m_nInterval;

                if (nMaxCycle === null) {
                    nMaxCycle = nCycle;
                    nMaxInterval = nInterval;
                }
                else if ((nMaxCycle === 5 && nMaxCycle > nCycle) ||//현재까지 최대주기가 분주기(5) 인 경우 nCycle이 분주기보다 큰 경우 최대주기로 셋팅
                    (nMaxCycle < 5 && nCycle < 5 && nMaxCycle < nCycle)) //현재까지 최대주기가 일(1),주(2),월(3),년(4) 주기 중 하나인경우 최대주기보다 nCycle값이 크면 최대주기로 셋팅
                {
                    nMaxCycle = nCycle;
                    nMaxInterval = nInterval;
                }
                //현재까지 최대주기와 nCycle주기가 같은 경우 nMinInterval과 nInterval의 최소공배수 주기계산하여 nMaxInterval로 셋팅(예:2분, 3분 주기인 경우 nMax은 6분)
                else if (nMaxCycle === nCycle && nMaxInterval !== nInterval) {
                    nMaxInterval = CalcLCM(nMaxInterval, nInterval);
                }
            }

            var strType = null;
            var nXTextLen = null;
            var nMaxXCnt = null;
            var nDataCnt = nViewEndIndex  - nViewStartIndex - 1;
            
            switch (nMaxCycle) {
                case 1: nXTextLen = this.m_rChart.m_nXDayTextLen; strType = "M";
                    nMaxXCnt = CalcDiffTimes(rXScaleMng.m_tViewStartDateTime * 1000, rXScaleMng.m_tViewEndDateTime * 1000, strType);
                    break;
                case 2: nXTextLen = this.m_rChart.m_nXWeekTextLen; strType = "M";
                    nMaxXCnt = CalcDiffTimes(rXScaleMng.m_tViewStartDateTime * 1000, rXScaleMng.m_tViewEndDateTime * 1000, strType);
                    break;
                case 3: nXTextLen = this.m_rChart.m_nXMonthTextLen; strType = "Y";
                    nMaxXCnt = CalcDiffTimes(rXScaleMng.m_tViewStartDateTime * 1000, rXScaleMng.m_tViewEndDateTime * 1000, strType);
                    break;
                case 4: nXTextLen = this.m_rChart.m_nXYearTextLen; strType = "Y";
                    nMaxXCnt = CalcDiffTimes(rXScaleMng.m_tViewStartDateTime * 1000, rXScaleMng.m_tViewEndDateTime * 1000, strType);
                    break;
                case 5: nXTextLen = this.m_rChart.m_nXMinTextLen; strType = "H";
                    nMaxXCnt = nDataCnt / 60;//분데이터안에 몇시간이 들어있는지 계산(실봉에서는 한시간에 분봉이 2개만 들어있는 경우도 있으므로 정확한 계산은 안되지만 최소시간 개수는 카운트할 수 있음)
                    break;
                case 6: nXTextLen = this.m_rChart.m_nXSecTextLen; strType = "m";
                    nMaxXCnt = nDataCnt / 60;//초데이터안에 몇분이 들어있는지 계산(실봉에서는 1분안에 초봉이 2개만 들어있는 경우도 있으므로 정확한 계산은 안되지만 최소분 개수는 카운트할 수 있음)
                    break;
            }

            for (k = 0; k < nChartBlockColLen; k++) {

                var rChartBlockCol = rXScaleMng.m_ChartBlockColArray[k];

                var nXTextCnt = Math.ceil(rChartBlockCol.m_nGraphRegionWidth / nXTextLen);

                if (nMaxXCnt <= nXTextCnt) {
                    rChartBlockCol.m_strXCycleType = strType;
                    rChartBlockCol.m_nXTextInterval = 1;
                }
                else {

                    switch (nMaxCycle) {
                        case 1://일주기
                        case 2://주주기

                            rChartBlockCol.m_strXCycleType = strType;
                            if (nMaxXCnt / 3 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 2;//3개월간격
                            else if (nMaxXCnt / 6 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 6;//6개월간격
                            else if (nMaxXCnt / 12 <= nXTextCnt) {
                                rChartBlockCol.m_strXCycleType = "Y";
                                rChartBlockCol.m_nXTextInterval = 1;//1년간격
                            }
                            else {
                                rChartBlockCol.m_strXCycleType = "Y";
                                rChartBlockCol.m_nXTextInterval = 2;//2년간격
                            }

                            break;

                        case 3: //월, 년 주기
                        case 4:
                            rChartBlockCol.m_strXCycleType = strType;
                            if (nMaxXCnt / 2 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 2;//2년간격
                            else if (nMaxXCnt / 3 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 3;//3년간격
                            else if (nMaxXCnt / 6 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 6;//6년간격
                            else if (nMaxXCnt / 12 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 12;//12년간격
                            else
                                rChartBlockCol.m_nXTextInterval = 24;//24년간격
                            break;

                        case 5: //분 주기
                            rChartBlockCol.m_strXCycleType = strType;
                            if (nMaxXCnt / 3 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 3;//3시간간격
                            else if (nMaxXCnt / 6 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 6;//6시간간격
                            else if (nMaxXCnt / 12 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 12;//12시간간격
                            else if (nMaxXCnt / 24 <= nXTextCnt) {//하루주기
                                rChartBlockCol.m_strXCycleType = "D";
                                rChartBlockCol.m_nXTextInterval = 1;
                            }
                            else {//한달주기
                                rChartBlockCol.m_strXCycleType = "M";
                                rChartBlockCol.m_nXTextInterval = 1;
                            }
                            break;

                        case 6://초주기
                            rChartBlockCol.m_strXCycleType = strType;
                            if (nMaxXCnt / 5 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 5;//5분간격
                            else if (nMaxXCnt / 10 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 10;//10분간격
                            else if (nMaxXCnt / 30 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 30;//30분간격
                            else if (nMaxXCnt / 60 <= nXTextCnt)
                                rChartBlockCol.m_nXTextInterval = 60;//1시간간격
                            else if (nMaxXCnt / 1440 <= nXTextCnt) {
                                rChartBlockCol.m_strXCycleType = "D";
                                rChartBlockCol.m_nXTextInterval = 1;//(하루)
                            }
                            else {
                                rChartBlockCol.m_strXCycleType = "M";
                                rChartBlockCol.m_nXTextInterval = 1;//(한달)
                            }
                            break;
                    }
                }
            }
            ///////////////////////////////////////////////////////////////////////

            RenderingInfo.Init();
            RenderingInfo.m_rXScaleMng = rXScaleMng;
            RenderingInfo.m_tTimeArray = rXScaleMng.m_tTimeArray;

            for (j = nViewStartIndex; j <= nViewEndIndex; j++) {

                var rXScaleMergeIndex = rXScaleMng.m_XScaleMergeArray[j];
                var tDateTime = rXScaleMergeIndex.m_tStart;

                RenderingInfo.m_rXScaleMergeIndex = rXScaleMergeIndex;
                RenderingInfo.m_nXScaleItemIndex = j;
                RenderingInfo.m_tDateTime = tDateTime;
                RenderingInfo.m_tTimeArrayItem = rXScaleMng.m_tTimeArray[tDateTime];

                //LKY 세계시간 적용 >>                    
                var GlobaloffsetDateTime = ChangeGlobalTime(this.m_rGlobalProperty.m_ChartUniversalTime, tDateTime);
                var tGlobaloffsetTime = GlobaloffsetDateTime.getTime() / 1000;

                ///////////////////////////////////////////////////////////////
                //X축 텍스트 관련 처리                    
                var nY = GlobaloffsetDateTime.getFullYear();
                var nM = GlobaloffsetDateTime.getMonth();
                var nD = GlobaloffsetDateTime.getDate();
                var nH = GlobaloffsetDateTime.getHours();
                var nMin = GlobaloffsetDateTime.getMinutes();
                var nS = GlobaloffsetDateTime.getSeconds();
                ///////////////////////////////////////////////////////////////
                //LKY 세계시간 적용 <<

                var nLen = rXScaleMng.m_ChartBlockColArray.length;
                for (k = 0; k < nLen; k++) {

                    var rChartBlockCol = rXScaleMng.m_ChartBlockColArray[k];
                    rChartBlockCol.RenderingInLoop(RenderingInfo);

                    ///////////////////////////////////////////////////////////////
                    //X축 텍스트 관련 처리
                    switch (rChartBlockCol.m_strXCycleType) {

                        case "D":
                            var strXTextCompare = "" + nY + nM + nD;
                            if (rChartBlockCol.m_strPrevXTextCompare === null) {//좌측 첫 눈금

                                var XScalePosInfo = new CXScalePosInfo();
                                XScalePosInfo.m_tDateTime = tGlobaloffsetTime;
                                XScalePosInfo.m_nYear = nY;
                                XScalePosInfo.m_nMonth = nM;
                                XScalePosInfo.m_nDate = nD;
                                XScalePosInfo.m_nHour = nH;
                                XScalePosInfo.m_nPosIndex = j;
                                XScalePosInfo.m_bKeyPosition = true;
                                XScalePosInfo.m_strScaleText = (nM < 9 ? "0" + (nM + 1) : "" + (nM + 1)) + "/" + (nD < 10 ? "0" + nD : "" + nD);
                                XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n5TextLen;
                                rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length] = XScalePosInfo;

                                rChartBlockCol.m_strPrevXTextCompare = strXTextCompare;
                            }
                            else if (rChartBlockCol.m_strPrevXTextCompare !== strXTextCompare) {

                                var n = nD % rChartBlockCol.m_nXTextInterval;
                                if (n === 0) {

                                    var XScalePosInfo = new CXScalePosInfo();
                                    XScalePosInfo.m_tDateTime = tGlobaloffsetTime;
                                    XScalePosInfo.m_nYear = nY;
                                    XScalePosInfo.m_nMonth = nM;
                                    XScalePosInfo.m_nDate = nD;
                                    XScalePosInfo.m_nHour = nH;
                                    XScalePosInfo.m_nPosIndex = j;

                                    var rPrevXScalePosInfo = rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length - 1];
                                    if (rPrevXScalePosInfo.m_nMonth !== nM) {
                                        XScalePosInfo.m_strScaleText = (nM < 9 ? "0" + (nM + 1) : "" + (nM + 1)) + "/" + (nD < 10 ? "0" + nD : "" + nD);
                                        XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n5TextLen;
                                        XScalePosInfo.m_bKeyPosition = true;
                                    }
                                    else {
                                        XScalePosInfo.m_strScaleText = (nD < 10) ? "0" + nD : "" + nD;
                                        XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n2TextLen;
                                    }

                                    rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length] = XScalePosInfo;

                                    rChartBlockCol.m_strPrevXTextCompare = strXTextCompare;
                                }
                            }
                            break;
                        case "M":
                            var strXTextCompare = "" + nY + nM;
                            if (rChartBlockCol.m_strPrevXTextCompare === null) {//좌측 첫 눈금

                                var XScalePosInfo = new CXScalePosInfo();
                                XScalePosInfo.m_tDateTime = tGlobaloffsetTime;
                                XScalePosInfo.m_nYear = nY;
                                XScalePosInfo.m_nMonth = nM;
                                XScalePosInfo.m_nDate = nD;
                                XScalePosInfo.m_nHour = nH;
                                XScalePosInfo.m_nPosIndex = j;
                                XScalePosInfo.m_bKeyPosition = true;
                                XScalePosInfo.m_strScaleText = (nM < 9) ? nY + "/0" + (nM + 1) : nY + "/" + (nM + 1);
                                XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n7TextLen;
                                rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length] = XScalePosInfo;

                                rChartBlockCol.m_strPrevXTextCompare = strXTextCompare;
                            }
                            else if (rChartBlockCol.m_strPrevXTextCompare != strXTextCompare) {

                                var n = nM % rChartBlockCol.m_nXTextInterval;
                                if (n === 0) {

                                    var XScalePosInfo = new CXScalePosInfo();
                                    XScalePosInfo.m_tDateTime = tGlobaloffsetTime;
                                    XScalePosInfo.m_nYear = nY;
                                    XScalePosInfo.m_nMonth = nM;
                                    XScalePosInfo.m_nDate = nD;
                                    XScalePosInfo.m_nHour = nH;
                                    XScalePosInfo.m_nPosIndex = j;                                                                                

                                    var rPrevXScalePosInfo = rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length - 1];
                                    if (rPrevXScalePosInfo.m_nYear !== nY) {
                                        XScalePosInfo.m_strScaleText = (nM < 9) ? nY + "/0" + (nM + 1) : nY + "/" + (nM + 1);
                                        XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n7TextLen;
                                        XScalePosInfo.m_bKeyPosition = true;
                                    }
                                    else {
                                        XScalePosInfo.m_strScaleText = (nM < 9) ? "0" + (nM + 1) : "" + (nM + 1);
                                        XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n2TextLen;
                                    }

                                    rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length] = XScalePosInfo;

                                    rChartBlockCol.m_strPrevXTextCompare = strXTextCompare;
                                }

                            }
                            break;
                        case "Y":
                            var strXTextCompare = "" + nY;
                            if (rChartBlockCol.m_strPrevXTextCompare === null) {//좌측 첫 눈금

                                var XScalePosInfo = new CXScalePosInfo();
                                XScalePosInfo.m_tDateTime = tGlobaloffsetTime;
                                XScalePosInfo.m_nYear = nY;
                                XScalePosInfo.m_nMonth = nM;
                                XScalePosInfo.m_nDate = nD;
                                XScalePosInfo.m_nHour = nH;
                                XScalePosInfo.m_nPosIndex = j;
                                XScalePosInfo.m_bKeyPosition = true;
                                XScalePosInfo.m_strScaleText = "" + nY;                                    
                                XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n4TextLen;
                                rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length] = XScalePosInfo;

                                rChartBlockCol.m_strPrevXTextCompare = strXTextCompare;
                            }
                            else if (rChartBlockCol.m_strPrevXTextCompare !== strXTextCompare) {

                                var n = nY % rChartBlockCol.m_nXTextInterval;
                                if (n === 0) {

                                    var XScalePosInfo = new CXScalePosInfo();
                                    XScalePosInfo.m_tDateTime = tGlobaloffsetTime;
                                    XScalePosInfo.m_nYear = nY;
                                    XScalePosInfo.m_nMonth = nM;
                                    XScalePosInfo.m_nDate = nD;
                                    XScalePosInfo.m_nHour = nH;
                                    XScalePosInfo.m_nPosIndex = j;
                                    XScalePosInfo.m_strScaleText = "" + nY;
                                    XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n4TextLen;
                                    rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length] = XScalePosInfo;

                                    rChartBlockCol.m_strPrevXTextCompare = strXTextCompare;
                                }
                            }

                            break;
                        case "H":
                            var strXTextCompare = "" + nY + nM + nD + nH;
                            if (rChartBlockCol.m_strPrevXTextCompare === null) {//좌측 첫 눈금

                                var XScalePosInfo = new CXScalePosInfo();
                                XScalePosInfo.m_tDateTime = tGlobaloffsetTime;
                                XScalePosInfo.m_nYear = nY;
                                XScalePosInfo.m_nMonth = nM;
                                XScalePosInfo.m_nDate = nD;
                                XScalePosInfo.m_nHour = nH;
                                XScalePosInfo.m_nPosIndex = j;
                                XScalePosInfo.m_bKeyPosition = true;
                                XScalePosInfo.m_strScaleText = (nM < 9 ? "0" + (nM + 1) : "" + (nM + 1)) + "/" + (nD < 10 ? "0" + nD : "" + nD);
                                XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n8TextLen;
                                rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length] = XScalePosInfo;

                                rChartBlockCol.m_strPrevXTextCompare = strXTextCompare;
                            }
                            else if (rChartBlockCol.m_strPrevXTextCompare !== strXTextCompare) {

                                var rPrevXScalePosInfo = rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length - 1];
                                if (rPrevXScalePosInfo.m_nDate !== nD) {

                                    var XScalePosInfo = new CXScalePosInfo();
                                    XScalePosInfo.m_tDateTime = tGlobaloffsetTime;
                                    XScalePosInfo.m_nYear = nY;
                                    XScalePosInfo.m_nMonth = nM;
                                    XScalePosInfo.m_nDate = nD;
                                    XScalePosInfo.m_nHour = nH;
                                    XScalePosInfo.m_nPosIndex = j;
                                    XScalePosInfo.m_bKeyPosition = true;

                                    XScalePosInfo.m_strScaleText = (nM < 9 ? "0" + (nM + 1) : "" + (nM + 1)) + "/" + (nD < 10 ? "0" + nD : "" + nD);
                                    XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n5TextLen;

                                    rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length] = XScalePosInfo;

                                    rChartBlockCol.m_strPrevXTextCompare = strXTextCompare;
                                }
                                else {

                                    var n = nH % rChartBlockCol.m_nXTextInterval;
                                    if (n === 0) {

                                        var XScalePosInfo = new CXScalePosInfo();
                                        XScalePosInfo.m_tDateTime = tGlobaloffsetTime;
                                        XScalePosInfo.m_nYear = nY;
                                        XScalePosInfo.m_nMonth = nM;
                                        XScalePosInfo.m_nDate = nD;
                                        XScalePosInfo.m_nHour = nH;
                                        XScalePosInfo.m_nPosIndex = j;
                                        
                                        XScalePosInfo.m_strScaleText = (nH < 10) ? "0" + nH : "" + nH;
                                        XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n2TextLen;                                            

                                        rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length] = XScalePosInfo;

                                        rChartBlockCol.m_strPrevXTextCompare = strXTextCompare;
                                    }
                                }
                            }
                            break;
                        case "m":
                            var strXTextCompare = "" + nY + nM + nD + nH + nMin;
                            if (rChartBlockCol.m_strPrevXTextCompare === null) {//좌측 첫 눈금

                                var XScalePosInfo = new CXScalePosInfo();
                                XScalePosInfo.m_tDateTime = tGlobaloffsetTime;
                                XScalePosInfo.m_nYear = nY;
                                XScalePosInfo.m_nMonth = nM;
                                XScalePosInfo.m_nDate = nD;
                                XScalePosInfo.m_nHour = nH;
                                XScalePosInfo.m_nPosIndex = j;
                                XScalePosInfo.m_bKeyPosition = true;
                                XScalePosInfo.m_strScaleText = (nM < 9 ? "0" + (nM + 1) : "" + (nM + 1)) + "/" + (nD < 10 ? "0" + nD : "" + nD) + " " + (nH < 10 ? "0" + nH : "" + nH);
                                XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n8TextLen;
                                rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length] = XScalePosInfo;

                                rChartBlockCol.m_strPrevXTextCompare = strXTextCompare;
                            }
                            else if (rChartBlockCol.m_strPrevXTextCompare !== strXTextCompare) {

                                var n = nMin % rChartBlockCol.m_nXTextInterval;
                                if (n === 0) {

                                    var XScalePosInfo = new CXScalePosInfo();
                                    XScalePosInfo.m_tDateTime = tGlobaloffsetTime;
                                    XScalePosInfo.m_nYear = nY;
                                    XScalePosInfo.m_nMonth = nM;
                                    XScalePosInfo.m_nDate = nD;
                                    XScalePosInfo.m_nHour = nH;
                                    XScalePosInfo.m_nPosIndex = j;

                                    var rPrevXScalePosInfo = rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length - 1];
                                    if (rPrevXScalePosInfo.m_nDate !== nD) {
                                        XScalePosInfo.m_strScaleText = (nM < 9 ? "0" + (nM + 1) : "" + (nM + 1)) + "/" + (nD < 10 ? "0" + nD : "" + nD);
                                        XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n5TextLen;
                                        XScalePosInfo.m_bKeyPosition = true;
                                    }
                                    else {
                                        XScalePosInfo.m_strScaleText = (nH < 10 ? "0" + nH : "" + nH) + ":" + (nMin < 10 ? "0" + nMin : "" + nMin);
                                        XScalePosInfo.m_nScaleTextLen = this.m_rChart.m_n5TextLen;
                                    }

                                    rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length] = XScalePosInfo;

                                    rChartBlockCol.m_strPrevXTextCompare = strXTextCompare;
                                }
                            }
                            break;
                    }


                    if (j === nViewEndIndex) {

                        var rXScalePosInfo = rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length - 1];
                        switch (nMaxCycle) {
                            case 1://일주기
                            case 2://주주기
                                rXScalePosInfo.m_strLastDataText = nY + "/" + (nM < 9 ? "0" + (nM + 1) : (nM + 1)) + "/" + (nD < 10 ? "0" + nD : nD);
                                break;
                            case 3://월 주기
                                rXScalePosInfo.m_strLastDataText = nY + "/" + (nM < 9 ? "0" + (nM + 1) : (nM + 1));
                                break;
                            case 4://년 주기
                                rXScalePosInfo.m_strLastDataText = "" + nY;
                                break;                                    
                            case 5: //분 주기
                                rXScalePosInfo.m_strLastDataText = (nH < 10 ? "0" + nH : nH) + ":" + (nMin < 10 ? "0" + nMin : nMin);
                                break;
                            case 6://초주기
                                rXScalePosInfo.m_strLastDataText = (nH < 10 ? "0" + nH : nH) + ":" + (nMin < 10 ? "0" + nMin : nMin) + ":" + (nS < 10 ? "0" + nS : nS);
                                break;                                    
                        }

                    }
                    ///////////////////////////////////////////////////////////////

                }

            }

            RenderingInfo.m_nXScaleItemIndex = j;
            RenderingInfo.m_nXScaleItemEndIndex = j;

            var bBreak = true;
            
            var nLen = rXScaleMng.m_ChartBlockColArray.length;
            for (k = 0; k < nLen; k++) {

                var rChartBlockCol = rXScaleMng.m_ChartBlockColArray[k];
                if (rChartBlockCol.RenderingOnLast(RenderingInfo))
                    bBreak = false;
            }
        }
        else if (rXScaleMng && rXScaleMng.GetType() === NUMERIC_TYPE) {
            
            if(rXScaleMng.GetXScalePacketName() === "_HOGA_"){
                
                var RenderingInfo = new CRenderingInfo();

                var i, j, k, nLength;
                nLength = rXScaleMng.m_XScaleItemArray.length;                

                var nViewStartIndex = rXScaleMng.m_nViewStartIndex;
                var nViewEndIndex = rXScaleMng.m_nViewEndIndex;

                if (nViewStartIndex < 0 || nLength <= nViewStartIndex)
                    continue;

                if (nLength <= nViewEndIndex)
                    nViewEndIndex = nLength;

                //RenderingInfo 개체 초기화 및 기본값 셋팅
                var nChartBlockColLen = rXScaleMng.m_ChartBlockColArray.length;
                for (i = 0; i < nChartBlockColLen ; i++) {
                    var rChartBlockCol = rXScaleMng.m_ChartBlockColArray[i];
                    rChartBlockCol.InitRendering(rXScaleMng);
                }

                RenderingInfo.Init();
                RenderingInfo.m_rXScaleMng = rXScaleMng;
                RenderingInfo.m_tTimeArray = null;//XScale이 호가인 경우는 사용하지 않음
    
                var rSelRQInfo = this.m_rChart.GetSelectedRQInfo();
                var nSellHogaStartIndex = Math.floor(nLength / 2);
                var nXScaleTextLen = null;

                var nLen = rXScaleMng.m_ChartBlockColArray.length;
                
                for (k = 0; k < nLen; k++) {

                    var rChartBlockCol = rXScaleMng.m_ChartBlockColArray[k];
                    rChartBlockCol.m_bFindCurPrice = false;
                }

                for (j = nViewStartIndex; j <= nViewEndIndex; j++) {

                    RenderingInfo.m_nXScaleItemIndex = j;
                    
                    nLen = rXScaleMng.m_ChartBlockColArray.length;
                    for (k = 0; k < nLen; k++) {

                        var rChartBlockCol = rXScaleMng.m_ChartBlockColArray[k];
                        rChartBlockCol.RenderingInLoop(RenderingInfo);

                        //X축 위치계산
                        var rXScaleItem = rXScaleMng.m_XScaleItemArray[j];
                        var XScalePosInfo = new CXScalePosInfo();
                        XScalePosInfo.m_nPosIndex = j;
                        
                        if(rXScaleItem.m_dHoga > 0)
                        {
                            if((nSellHogaStartIndex - 1 === j || nSellHogaStartIndex === j) &&                             
                                rSelRQInfo.m_CurPrice === rXScaleItem.m_dHoga)//최근 체결된 호가를 매수1호가, 매도1호가에서 찾는다
                            {
                                XScalePosInfo.m_bKeyPosition = true;
                                rChartBlockCol.m_bFindCurPrice = true;
                            }
                            else{
                                XScalePosInfo.m_bKeyPosition = false;
                            }

                            XScalePosInfo.m_strScaleText = ConvertNumToDigitText(rXScaleItem.m_dHoga, rXScaleMng.m_nDec, 1, rXScaleMng.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);
                            if( nXScaleTextLen === null)                            
                                nXScaleTextLen = DrawingInfo.m_Context.measureText(XScalePosInfo.m_strScaleText).width + 4;                            
                            XScalePosInfo.m_nScaleTextLen = nXScaleTextLen;
                            
                        }
                        else
                        {
                            XScalePosInfo.m_bKeyPosition = false;
                            XScalePosInfo.m_strScaleText = "";
                            XScalePosInfo.m_nScaleTextLen = 0;
                        }
                        rChartBlockCol.m_XScaleTextPosArray[rChartBlockCol.m_XScaleTextPosArray.length] = XScalePosInfo;
                        
                    }
                }
                //현재가와 매칭되는 매수1호가 또는 매도1호가를 못 찾은경우 매수1호가 가격을 보여주도록 한다.
                for (k = 0; k < nLen; k++) {

                    var rChartBlockCol = rXScaleMng.m_ChartBlockColArray[k];
                    if(rChartBlockCol.m_bFindCurPrice === false)
                    {
                        var rXScalePosInfo = rChartBlockCol.m_XScaleTextPosArray[nSellHogaStartIndex - 1];
                        if(rXScalePosInfo && XScalePosInfo.m_strScaleText.length > 0)
                            rXScalePosInfo.m_bKeyPosition = true;
                        else{
                            rXScalePosInfo = rChartBlockCol.m_XScaleTextPosArray[nSellHogaStartIndex];
                            if(rXScalePosInfo && XScalePosInfo.m_strScaleText.length > 0)
                                rXScalePosInfo.m_bKeyPosition = true;
                        }
                    }
                }

                RenderingInfo.m_nXScaleItemIndex = j;
                RenderingInfo.m_nXScaleItemEndIndex = j;

                var bBreak = true;
                
                var nLen = rXScaleMng.m_ChartBlockColArray.length;
                for (k = 0; k < nLen; k++) {

                    var rChartBlockCol = rXScaleMng.m_ChartBlockColArray[k];
                    if (rChartBlockCol.RenderingOnLast(RenderingInfo))
                        bBreak = false;
                }

                //X축 라인 위치계산

            }
        }
    }
    //속도개선코드 <<<<<<<

    for (i = 0; i < length; i++) {
        var ChartBlock = this.m_ChartBlockArray[i];
        ChartBlock.Draw(DrawingInfo);
    }
}

//특정블록의 타이틀을 업데이트 할 경우
CMainBlock.prototype.ShowGraphTitle = function (ChartBlock, DrawingInfo) {

}

CMainBlock.prototype.ShowToolTip = function (x, y, L, R, T, B, RQGraphFindDataPerXScaleMng4ToolTip) {

    this.HideToolTip();

    this.ToolTipX = (x + this.m_rChart.m_DrawingInfo.m_ScreenCanvas.offsetLeft) + gToolTipMarginX;
    this.ToolTipY = (y + this.m_rChart.m_DrawingInfo.m_ScreenCanvas.offsetTop) + gToolTipMarginY;
   
    this.m_ToolTipDiv = document.createElement('div');
    this.m_ToolTipDiv.classList.add('tooltip_area');
    this.m_ToolTipDiv.classList.add(this.m_rChart.m_strThemeName);

    var ToolTipInnerHtml = '';
    let nDataListOpacity = this.m_rGlobalProperty.GetDataListOpacity();
    let strSignal = "";

    if (RQGraphFindDataPerXScaleMng4ToolTip !== undefined && RQGraphFindDataPerXScaleMng4ToolTip.m_strFindToolTipRQ !== null) {
        var RQGraphFindData = RQGraphFindDataPerXScaleMng4ToolTip.GetRQGraphFindData(RQGraphFindDataPerXScaleMng4ToolTip.m_strFindToolTipRQ);
        if (RQGraphFindData !== null) {

            ToolTipInnerHtml += '  <ul class="chart_data_slide">';
            
            //XScale이 호가인 경우는 날짜축이 아니므로 넣지 않는다
            if(RQGraphFindDataPerXScaleMng4ToolTip.m_rXScaleMng.GetXScalePacketName() !== "_HOGA_")
            {
                // 날짜
                ToolTipInnerHtml += '    <li>';
                ToolTipInnerHtml += `      <strong class="tit" style="opacity: ${nDataListOpacity};">` + RQGraphFindData.m_strXData + '</strong>';
                ToolTipInnerHtml += '    </li>';
            }

            var nIndex, nLen = RQGraphFindData.m_arrGraphFindData.length;
            for (nIndex = 0; nIndex < nLen; nIndex++) {

                var GraphFindData = RQGraphFindData.m_arrGraphFindData[nIndex];

                ToolTipInnerHtml += '    <li>';

                // 타이틀
                if (GraphFindData.m_strGraphName) {
                    ToolTipInnerHtml += `      <strong class="tit sub_tit" style="opacity: ${nDataListOpacity};">` + GraphFindData.m_strGraphName + '</strong>';
                }

                var nSubIndex = 0,
                    nLength = GraphFindData.m_arrSubGraphFindData.length;
                for (nSubIndex = 0; nSubIndex < nLength; nSubIndex++) {

                    ToolTipInnerHtml += `      <ul class="data_lst" style="opacity: ${nDataListOpacity};">`;

                    var SubGraphFindData = GraphFindData.m_arrSubGraphFindData[nSubIndex];
                    var i, length = SubGraphFindData.m_SubGraphFindSubDataArray.length;
                    for (i = 0; i < length; i++) {

                        ToolTipInnerHtml += '        <li>';

                        var SubGraphFindSubData = SubGraphFindData.m_SubGraphFindSubDataArray[i];
                        strSignal = Number(SubGraphFindSubData.m_strSubGraphFindData) < 0 ? "minus" : "plus";
                        ToolTipInnerHtml += '          <span class="lft_txt">' + SubGraphFindSubData.m_strSubGraphTitle + '</span>';
                        ToolTipInnerHtml += `          <span class="rgt_txt ${strSignal}">` + SubGraphFindSubData.m_strSubGraphFindData;

                        if (SubGraphFindSubData.m_strSubGraphFindSubData.length > 0) {
                            ToolTipInnerHtml += '(' + SubGraphFindSubData.m_strSubGraphFindSubData + ')';
                        }

                        ToolTipInnerHtml += '          </span>';
                        ToolTipInnerHtml += '        </li>';
                    }
                    ToolTipInnerHtml += '      </ul>';
                }
                ToolTipInnerHtml += '    </li>';
            }
            ToolTipInnerHtml += '  </ul>';
        }
    }

    this.m_ToolTipDiv.innerHTML = ToolTipInnerHtml;
    this.m_ToolTipDiv.style.left = this.ToolTipX + 'px';
    this.m_ToolTipDiv.style.top = this.ToolTipY + 'px';

    var rChartPopupWrapper = document.getElementById("chart-popup-wrapper");
    if (rChartPopupWrapper !== null)
        rChartPopupWrapper.appendChild(this.m_ToolTipDiv);
    //test
    else
        this.m_rChart.m_ChartParentDIV.appendChild(this.m_ToolTipDiv);
}

CMainBlock.prototype.HideToolTip = function () {
    if (this.m_ToolTipDiv != null && this.m_ToolTipDiv.parentNode) {
        this.m_ToolTipDiv.parentNode.removeChild(this.m_ToolTipDiv);
        this.m_ToolTipDiv = null;
    }
}

CMainBlock.prototype.ShowDataList = function (e, RQGraphFindDataPerXScaleMng, nOpacity) {

    this.HideDataList();
    
    const DataListInnerHtml = [];
    const nDataListOpacity = this.m_rGlobalProperty.GetDataListOpacity();
    let strSignal = '';

    let bAppendDiv = false;
    for (var strRQKey in RQGraphFindDataPerXScaleMng.m_arrRQGraphFindData) {

      var RQGraphFindData = RQGraphFindDataPerXScaleMng.m_arrRQGraphFindData[strRQKey];
      if (RQGraphFindData) {
        DataListInnerHtml.push('<ul class="chart_data_slide">');
        // 날짜
        DataListInnerHtml.push('<li>');
        DataListInnerHtml.push(`<strong class="tit" style="opacity: ${nDataListOpacity};">`);
        DataListInnerHtml.push(RQGraphFindData.m_strXData);
        DataListInnerHtml.push('</strong>');
        DataListInnerHtml.push('</li>');

        for (var strGraphKey in RQGraphFindData.m_arrGraphFindData) {
          var GraphFindData = RQGraphFindData.m_arrGraphFindData[strGraphKey];
          
          DataListInnerHtml.push('<li>');

          // 타이틀
          if (GraphFindData.m_strGraphName) {
              DataListInnerHtml.push(`<strong class="tit sub_tit" style="opacity: ${nDataListOpacity};">`);
              DataListInnerHtml.push(GraphFindData.m_strGraphName);
              DataListInnerHtml.push('</strong>');
          }

          for (var strSubGraphKey in GraphFindData.m_arrSubGraphFindData) {
              DataListInnerHtml.push(`<ul class="data_lst" style="opacity: ${nDataListOpacity};">`);

            var SubGraphFindData = GraphFindData.m_arrSubGraphFindData[strSubGraphKey];

            for (var strSubGraphFindSubDataKey in SubGraphFindData.m_SubGraphFindSubDataArray) {
                DataListInnerHtml.push('<li>');

              var SubGraphFindSubData = SubGraphFindData.m_SubGraphFindSubDataArray[strSubGraphFindSubDataKey];
              strSignal = Number(SubGraphFindSubData.m_strSubGraphFindData) < 0 ? "minus" : "plus";
              DataListInnerHtml.push('<span class="lft_txt">');
              DataListInnerHtml.push(SubGraphFindSubData.m_strSubGraphTitle);
              DataListInnerHtml.push('</span>');

              DataListInnerHtml.push(`<span class="rgt_txt ${strSignal}">`);
              DataListInnerHtml.push(SubGraphFindSubData.m_strSubGraphFindData);

              if (SubGraphFindSubData.m_strSubGraphFindSubData.length > 0) {
                  DataListInnerHtml.push(`(${SubGraphFindSubData.m_strSubGraphFindSubData})`);
              }

              DataListInnerHtml.push('</span>');
              DataListInnerHtml.push('</li>');
            }
            DataListInnerHtml.push('</ul>');
          }
          DataListInnerHtml.push('</li>');
        }
        DataListInnerHtml.push('</ul>');
      }

      bAppendDiv = true;
    }

    if (bAppendDiv) {
        
        // html 생성
        this.m_DataListDiv = document.createElement('div');
        this.m_DataListDiv.classList.add('tooltip_area');
        this.m_DataListDiv.classList.add(this.m_rChart.m_strThemeName);
        this.m_DataListDiv.innerHTML = DataListInnerHtml.join('');

        var L = e.clientX - e.ChartXPos; // 수치창 좌측 공간
        var T = e.clientY - e.ChartYPos; // 수치창 상단 공간

        ///////////////////////////////////////////////////
        //수치조회 창의 top, bottom, left, right 좌표 계산
        ///////////////////////////////////////////////////
        var offsetTop = T + this.m_rectMainBlock.m_nTop;
        var offsetBottom = offsetTop + this.m_rectMainBlock.m_nBottom;
        var offsetLeft = L + this.m_rectMainBlock.m_nLeft;
        var offsetRight = offsetLeft + this.m_rectMainBlock.m_nRight;
        
        this.m_DataListDiv.firstElementChild.style.left = offsetLeft + 'px';
        this.m_DataListDiv.firstElementChild.style.top = offsetTop + 'px';

        //this.m_rChart.AppendModal(this.m_DataListDiv);

        var rChartPopupWrapper = document.getElementById("chart-popup-wrapper");
        if (rChartPopupWrapper !== null)
          rChartPopupWrapper.appendChild(this.m_DataListDiv);
        //test
        else
          this.m_rChart.m_ChartParentDIV.appendChild(this.m_DataListDiv);

        ///////////////////////////////////////////////////
        // 수치조회 창 차트 우측위치의 경우 left 계산
        ///////////////////////////////////////////////////
        if (this.m_nDataListShowSide == 2) //
            offsetLeft = offsetRight - this.m_DataListDiv.firstElementChild.offsetWidth;

        /////////////////////////////////////////////////////////////////////////////
        //현재 마우스 위치를 차트기준에서 화면 위치 기준으로 환산(위치 비교를 위해)
        /////////////////////////////////////////////////////////////////////////////
        var CurX = e.clientX - this.m_rectMainBlock.m_nLeft;
        var CurY = e.clientY - this.m_rectMainBlock.m_nTop;

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //현재 마우스 위치와 수치조회 창 좌표 비교하여 수치조회 창 내부에 마우스 위치하는 경우 수치조회 창을 반대편으로 이동시킴
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        var datalistRight = offsetLeft + this.m_DataListDiv.firstElementChild.offsetWidth;
        var datalistBottom = offsetTop + this.m_DataListDiv.firstElementChild.offsetHeight;
        if ((offsetLeft <= CurX && CurX <= datalistRight) && (offsetTop <= CurY && CurY <= datalistBottom)) {
            if (this.m_nDataListShowSide == 2) {
                offsetLeft = L + this.m_rectMainBlock.m_nLeft;
                this.m_nDataListShowSide = 1;
            } else {
                offsetLeft = offsetRight - this.m_DataListDiv.firstElementChild.offsetWidth;
                this.m_nDataListShowSide = 2;
            }
        }

        //console.log("ShowSide:" + this.m_nDataListShowSide + ", L:" + offsetLeft + ",R:" + offsetRight + ",T:" + offsetTop + ",B:" + offsetBottom + ", CurX:" + CurX + ", CurY:" + CurY);

        this.m_DataListDiv.firstElementChild.style.left = offsetLeft + 'px';
    }
}

CMainBlock.prototype.HideDataList = function () {
    if (this.m_DataListDiv != null && this.m_DataListDiv.parentNode) {
        this.m_DataListDiv.parentNode.removeChild(this.m_DataListDiv);
        this.m_DataListDiv = null;
    }
}


//LKY 차트 블록 순서 변경 이벤트 처리 >>
CMainBlock.prototype.SetChangeBlock = function (nRowIndex, bUpDownFlag) {

    var nBlockCnt = this.m_ChartBlockArray.length;
    var rTempBlock = null;
    var nTempBlockH = null;
    var nTempShowXScaleOption = null;
    var nTempShowXScaleOption1 = null;

    if(bUpDownFlag === true) {

        if(nBlockCnt > nRowIndex && nRowIndex > 0) {

            rTempBlock = this.m_ChartBlockArray[nRowIndex-1];
            this.m_ChartBlockArray[nRowIndex-1] = this.m_ChartBlockArray[nRowIndex];
            this.m_ChartBlockArray[nRowIndex] = rTempBlock;

            nTempBlockH = this.m_BlockSizeRatioArray[nRowIndex-1];
            this.m_BlockSizeRatioArray[nRowIndex-1] = this.m_BlockSizeRatioArray[nRowIndex];
            this.m_BlockSizeRatioArray[nRowIndex] = nTempBlockH;

            if(nRowIndex === nBlockCnt-1) {
                nTempShowXScaleOption = this.m_ChartBlockArray[nRowIndex-1].GetXScaleShowOption();
                nTempShowXScaleOption1 = this.m_ChartBlockArray[nRowIndex].GetXScaleShowOption();

                this.m_ChartBlockArray[nRowIndex-1].SetXScaleShowOption(nTempShowXScaleOption1);
                this.m_ChartBlockArray[nRowIndex].SetXScaleShowOption(nTempShowXScaleOption);
            }
        }
    }
    else{

        if( nRowIndex < nBlockCnt-1) {

            rTempBlock = this.m_ChartBlockArray[nRowIndex+1];
            this.m_ChartBlockArray[nRowIndex+1] = this.m_ChartBlockArray[nRowIndex];
            this.m_ChartBlockArray[nRowIndex] = rTempBlock;

            nTempBlockH = this.m_BlockSizeRatioArray[nRowIndex+1];
            this.m_BlockSizeRatioArray[nRowIndex+1] = this.m_BlockSizeRatioArray[nRowIndex];
            this.m_BlockSizeRatioArray[nRowIndex] = nTempBlockH;

            if(nRowIndex+1 === nBlockCnt-1) {
                nTempShowXScaleOption = this.m_ChartBlockArray[nRowIndex+1].GetXScaleShowOption();
                nTempShowXScaleOption1 = this.m_ChartBlockArray[nRowIndex].GetXScaleShowOption();

                this.m_ChartBlockArray[nRowIndex+1].SetXScaleShowOption(nTempShowXScaleOption1);
                this.m_ChartBlockArray[nRowIndex].SetXScaleShowOption(nTempShowXScaleOption);
            }
        }
    }
}
//LKY 차트 블록 순서 변경 이벤트 처리 <<

CMainBlock.prototype.RemoveAllTool = function () {

    var i, rChartBlock, nLen = this.m_ChartBlockArray.length;
    for ( i = 0; i < nLen; i++ )
    {
        rChartBlock = this.m_ChartBlockArray[i];
        rChartBlock.m_ToolArray = [];
        rChartBlock.m_ShowToolArray = [];
    }
}

CMainBlock.prototype.SaveToolInfo = function ( rRQSet, bRemove ) {

    var rChartBlock, rTool;
    var nCycle = rRQSet.m_RQInfo.m_nCycle;
    var strCode = rRQSet.m_RQInfo.m_strItemCode;
    var i, j, nToolLen, nLen = this.m_ChartBlockArray.length;
    for ( i = 0; i < nLen; i++ )
    {
        rChartBlock = this.m_ChartBlockArray[i];
        nToolLen = rChartBlock.m_ToolArray.length;
        for( j = nToolLen - 1; j >= 0; j-- )
        {
            rTool = rChartBlock.m_ToolArray[j];
            if( rTool !== undefined )
            {
                if( rTool.m_ToolInfo.m_KeyCode === strCode && rTool.m_ToolInfo.m_Cycle === nCycle )
                {
                    this.m_ToolMng.AddToolInfo( rTool );
                    if( bRemove === true )
                        rChartBlock.m_ToolArray.splice(j, 1);
                }
            }
        }
    }
}

CMainBlock.prototype.ReCalcToolXPos = function (rXScaleMng) {

    var rChartBlock, rTool;
    var i, j, nLen = this.m_ChartBlockArray.length;

    for ( i = 0; i < nLen; i++ )
    {
        rChartBlock = this.m_ChartBlockArray[i];
        var nToolLen = rChartBlock.m_ToolArray.length;
        for( j = 0; j < nToolLen; j++ )
        {
            rTool = rChartBlock.m_ToolArray[j];
            if( rTool !== null && rTool !== undefined )
            {
                if( rXScaleMng.GetType() === rTool.m_ToolInfo.m_nXScaleType )
                    rTool.m_ToolInfo.SetToolXPos( rXScaleMng, rChartBlock, false );
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
function CInterval(nInterval) {
    this.m_nInterval = nInterval;
}

///////////////////////////////////////////////////////////////////////////////
function CXScaleMergeIndex() {

    this.m_tStart = null;
    this.m_tEnd = null;
    this.m_nIndex = null;
    this.m_mapRQPacketsItem = {};//rq키로 CRQPacketsItem 저장
    this.m_mapRQPacketDataIndex = {};//rq키로 해당 rq의 PacketData Index를 저장(PacketData에 맞는 위치를 찾기 전까지 찾는 index로 저장)
}

///////////////////////////////////////////////////////////////////////////////
function CXScaleItem() {
    this.m_nStartPos = -1;
    this.m_nDataCount = 0;
}

CXScaleItem.prototype.Init = function () {

    this.m_nStartPos = -1;
    this.m_nDataCount = 0;

}

///////////////////////////////////////////////////////////////////////////////
export function CDateTimeXScaleItem(rDateTimeXScaleMng) {
    CXScaleItem.call(this);
    this.m_nCycle = 0;
    this.m_rInterval = null;
    
    this.m_rDateTimeXScaleMng = rDateTimeXScaleMng;
    
    this.m_tStart = 0;
    this.m_tEnd = 0;
    this.m_dateStart = new Date();
    this.m_dateEnd = new Date();
    this.m_nIndex = 0;//시간이 같은 경우(틱) nIndex 카운트
    this.m_tFindIndexTimeT = null;//CDateTimeXScaleMng.GetDateTimeXScaleItemByIndex 함수내에서 매개변수로 넘어온 nIndex에 해당하는 시간 저장하여 리턴용도로 준비된 변수
    this.m_bFutureTime = false;//CDateTimeXScaleMng.GetDateTimeXScaleItemByIndex 함수내에서 매개변수로 넘어온 nIndex가 미래영역에 위치한 것이라고 판단된 경우 리턴하면서 미래영역임을 알려주기 위한 변수

}
CDateTimeXScaleItem.prototype = new CXScaleItem();
CDateTimeXScaleItem.prototype.constructor = CDateTimeXScaleItem;

CDateTimeXScaleItem.prototype.Init = function () {

    CXScaleItem.prototype.Init.call(this);

    this.m_nCycle = 0;
    this.m_rInterval = null;
    this.m_tStart = 0;
    this.m_tEnd = 0;
    this.m_dateStart.setTime(0);
    this.m_dateEnd.setTime(0);
    this.m_nIndex = 0;//시간이 같은 경우(틱) nIndex 카운트
    this.m_tFindIndexTimeT = null;//CDateTimeXScaleMng.GetDateTimeXScaleItemByIndex 함수내에서 매개변수로 넘어온 nIndex에 해당하는 시간 저장하여 리턴용도로 준비된 변수
    this.m_bFutureTime = false;//CDateTimeXScaleMng.GetDateTimeXScaleItemByIndex 함수내에서 매개변수로 넘어온 nIndex가 미래영역에 위치한 것이라고 판단된 경우 리턴하면서 미래영역임을 알려주기 위한 변수

}

CDateTimeXScaleItem.prototype.GetIndexByDateTimeT = function (tDateTime, bIncludeFuture) {

    ////////////////////////////////////////////////
    //해당시간이 item 시간범위에 들지 않는 경우 체크
    if (tDateTime < this.m_tStart)
        return -2;
    else if (this.m_tEnd < tDateTime && ( bIncludeFuture === undefined || bIncludeFuture === false ))
        return -1;
    ////////////////////////////////////////////////
    else {

        var nFindIndex = null;
        switch (this.GetCycle())//월인 경우
        {
            case 3:
                {
                    var nStartY = this.m_dateStart.getFullYear();
                    var nStartM = this.m_dateStart.getMonth() + 1;
                    var nStartTotalM = (nStartY - 1) * 12 + nStartM;

                    var dateEnd = gTempDate;
                    dateEnd.setTime(tDateTime * 1000);

                    var nEndY = dateEnd.getFullYear();
                    var nEndM = dateEnd.getMonth() + 1;
                    var nEndTotalM = (nEndY - 1) * 12 + nEndM;

                    var nDiffM = nEndTotalM - nStartTotalM;
                    nFindIndex = this.GetStartPos() + Math.floor(nDiffM / this.GetInterval());
                }
                break;

            case 4://년인 경우
                {
                    var nStartY = this.m_dateStart.getFullYear();

                    var dateEnd = gTempDate;
                    dateEnd.setTime(tDateTime * 1000);
                    var nEndY = dateEnd.getFullYear();

                    var nDiffY = nEndY - nStartY;
                    nFindIndex = this.GetStartPos() + Math.floor(nDiffY / this.GetInterval());
                }
                break;
            case 1://일 주기
                {
                    var dateEnd = gTempDate;
                    dateEnd.setTime(tDateTime * 1000);

                    var nDiffD = Math.floor((dateEnd.getTime() - this.m_dateStart.getTime()) / 1000 / 60 / 60 / 24);
                    nFindIndex = this.GetStartPos() + Math.floor(nDiffD / this.GetInterval());
                }
                break;
            case 2://주 주기
                {
                    var dateEnd = gTempDate;
                    dateEnd.setTime(tDateTime * 1000);

                    var nDiffW = Math.floor((dateEnd.getTime() - this.m_dateStart.getTime()) / 1000 / 60 / 60 / 24 / 7);
                    nFindIndex = this.GetStartPos() + Math.floor(nDiffW / this.GetInterval());
                }
                break;
            case 5://분 주기
                {
                    var dateEnd = gTempDate;
                    dateEnd.setTime(tDateTime * 1000);

                    var nDiffMin = Math.floor((dateEnd.getTime() - this.m_dateStart.getTime()) / 1000 / 60);
                    nFindIndex = this.GetStartPos() + Math.floor(nDiffMin / this.GetInterval());
                }
                break;
            case 6://초 주기
                {
                    var dateEnd = gTempDate;
                    dateEnd.setTime(tDateTime * 1000);

                    var nDiffSec = Math.floor((dateEnd.getTime() - this.m_dateStart.getTime()) / 1000);
                    nFindIndex = this.GetStartPos() + Math.floor(nDiffSec / this.GetInterval());
                }
                break;
            default:
                break;
        }

        return nFindIndex;
    }
}

CDateTimeXScaleItem.prototype.GetDateTimeByIndex = function (nIndex) {
    var tDateTimeT = this.GetDateTimeTByIndex(nIndex);
    var date = new Date();
    date.setTime(tDateTimeT * 1000);
    return date;
}
CDateTimeXScaleItem.prototype.GetDateTimeTByIndex = function (nIndex, bIncludeFuture, nInputIntervalCnt) {

    if (this.m_nStartPos <= nIndex) {//&& nIndex < this.m_nStartPos + this.GetIntervalCnt()) {

        var nIntervalCnt = (nInputIntervalCnt === undefined ? this.GetIntervalCnt() : nInputIntervalCnt);
        if ((nIndex < this.m_nStartPos + nIntervalCnt) || bIncludeFuture === true) {

            var nCycle = this.GetCycle();
            if (nCycle === 3)//월인 경우
            {
                var nStartYear = this.m_dateStart.getFullYear();
                var nStartMonth = this.m_dateStart.getMonth();

                var nNextMonth = (this.GetInterval() * (nIndex - this.m_nStartPos)) + (nStartYear * 12 + nStartMonth);
                var nY = Math.floor(nNextMonth / 12);
                var nM = nNextMonth % 12;

                var nDay = this.m_dateStart.getDate();
                var DatePerMonth = DatePerMonthArray[nM];
                if (DatePerMonth < nDay)
                    nDay = DatePerMonth;

                //var nH = this.m_dateStart.getHours();
                //var nMin = this.m_dateStart.getMinutes();
                //var nSec = this.m_dateStart.getSeconds();
                //var dateLast = new Date(nY, nM, nDay, nH, nMin, nSec);
                //return dateLast.getTime() / 1000;

                gTempDate.setTime(this.m_dateStart.getTime());
                gTempDate.setFullYear(nY, nM, nDay);
                return gTempDate.getTime() / 1000;
            }
            else if (nCycle === 4)//년인 경우
            {
                var nStartYear = this.m_dateStart.getFullYear();

                var nNextYear = (this.GetInterval() * (nIndex - this.m_nStartPos)) + nStartYear;

                //var nM = this.m_dateStart.getMonth();
                //var nDay = this.m_dateStart.getDate();
                //var nH = this.m_dateStart.getHours();
                //var nMin = this.m_dateStart.getMinutes();
                //var nSec = this.m_dateStart.getSeconds();
                //var dateLast = new Date(nNextYear, nM, nDay, nH, nMin, nSec);
                //return dateLast.getTime() / 1000;

                gTempDate.setTime(this.m_dateStart.getTime());
                gTempDate.setFullYear(nNextYear, nM, nDay);
                return gTempDate.getTime() / 1000;
            }
            else {
                var dateUnit = null;
                switch (nCycle)//일 주기
                {
                    case 1://일 주기
                        dateUnit = DayDate; break;
                    case 2://주 주기
                        dateUnit = WeekDate; break;
                    case 5://분 주기
                        dateUnit = MinDate; break;
                    case 6://초 주기
                        dateUnit = SecDate; break;
                    case 7://틱 주기
                        break;
                    default:
                        break;
                }

                if (dateUnit !== null) {
                    var tTime = dateUnit.getTime() / 1000;
                    return (nIndex - this.m_nStartPos) * tTime * this.GetInterval() + this.m_tStart;
                }
                else
                    return -1;
            }
        }
        else
            return -1;
    }
    else
        return -1;
}

CDateTimeXScaleItem.prototype.SetStartPos = function (nStartPos) {
    this.m_nStartPos = nStartPos;
    return this.GetIntervalCnt();
}
CDateTimeXScaleItem.prototype.GetStartPos = function () {
    return this.m_nStartPos;
}
CDateTimeXScaleItem.prototype.GetIntervalCnt = function () {
    var nIntervalCnt = 0;

    var nCycle = this.GetCycle();
    if (nCycle == 3)//월인 경우
    {
        var nStartYear = this.m_dateStart.getFullYear();
        var nEndYear = this.m_dateEnd.getFullYear();

        var nStartMonth = this.m_dateStart.getMonth();
        var nEndMonth = this.m_dateEnd.getMonth();

        var nDiff = (nEndYear * 12 + nEndMonth) - (nStartYear * 12 + nStartMonth);
        nIntervalCnt = Math.floor(nDiff / this.GetInterval());
        return nIntervalCnt;
    }
    else if (nCycle == 4)//년인 경우
    {
        var nStartYear = this.m_dateStart.getFullYear();
        var nEndYear = this.m_dateEnd.getFullYear();

        var nDiff = nEndYear - nStartYear;
        nIntervalCnt = Math.floor(nDiff / this.GetInterval());
        return nIntervalCnt;
    }
    else {
        var dateUnit = null;
        switch (nCycle)//일 주기
        {
            case 1://일 주기
                dateUnit = DayDate; break;
            case 2://주 주기
                dateUnit = WeekDate; break;
            case 5://분 주기
                dateUnit = MinDate; break;
            case 6://초 주기
                dateUnit = SecDate; break;
            case 7://틱 주기
                break;
            default:
                break;
        }
        if (dateUnit != null) {
            var tTime = dateUnit.getTime();
            var fIntervalCnt = (this.m_tEnd - this.m_tStart) / (tTime / 1000 * this.GetInterval());
            nIntervalCnt = Math.floor(fIntervalCnt);
        }
    }
    return nIntervalCnt;
}

CDateTimeXScaleItem.prototype.SetCycle = function (nCycle) {
    this.m_nCycle = nCycle;
}

//this.m_nCycle값을 직접 사용하지 말고 GetCycle함수를 반드시 이용할 것
CDateTimeXScaleItem.prototype.GetCycle = function () {

    return this.m_rDateTimeXScaleMng.CheckMinCycle(this.m_nCycle);
}

CDateTimeXScaleItem.prototype.SetInterval = function (rInterval) {
    this.m_rInterval = rInterval;
}


CDateTimeXScaleItem.prototype.GetInterval = function () {

    var nCycle = this.m_rDateTimeXScaleMng.CheckMinCycle(this.m_nCycle);
    return this.m_rDateTimeXScaleMng.m_MinIntervalArray[nCycle - 1].m_nInterval;
}

CDateTimeXScaleItem.prototype.SetStart = function (tStart) {
    this.m_tStart = tStart;
    this.m_dateStart.setTime(tStart * 1000);
}
CDateTimeXScaleItem.prototype.GetStart = function () {
    return this.m_tStart;
}
CDateTimeXScaleItem.prototype.GetStartString = function () {
    var strStart = this.m_dateStart.getFullYear() + "/" + (this.m_dateStart.getMonth() + 1) + "/" + this.m_dateStart.getDate() + " " +
        this.m_dateStart.getHours() + ":" + this.m_dateStart.getMinutes() + ":" + this.m_dateStart.getSeconds();
    return strStart;
}
CDateTimeXScaleItem.prototype.SetEnd = function (tEnd) {
    this.m_tEnd = tEnd;
    this.m_dateEnd.setTime(tEnd * 1000);
}
CDateTimeXScaleItem.prototype.GetEnd = function () {
    return this.m_tEnd;
}
CDateTimeXScaleItem.prototype.GetEndString = function () {
    var strEnd = this.m_dateEnd.getFullYear() + "/" + (this.m_dateEnd.getMonth() + 1) + "/" + this.m_dateEnd.getDate() + " " +
        this.m_dateEnd.getHours() + ":" + this.m_dateEnd.getMinutes() + ":" + this.m_dateEnd.getSeconds();
    return strEnd;
}
////////////////////////////////////////////////////////////////////////////////////
//CHogaXScaleItem
///////////////////////////////////////////////////////////////////////////////
export function CHogaXScaleItem(rHogaXScaleMng) {
    CXScaleItem.call(this);
    
    this.m_rXScaleMng = rHogaXScaleMng;    
    
    this.m_dHoga = null;    
    this.m_nBuyOrSell = null;//0(매수), 1(매도)
    this.m_nIndex = null;//호가번호(매수,매도포함)
    this.m_mapRQPacketsItem = {};//rq키로 CRQPacketsItem 저장
}
CHogaXScaleItem.prototype = new CXScaleItem();
CHogaXScaleItem.prototype.constructor = CHogaXScaleItem;

CHogaXScaleItem.prototype.Init = function () {

    CXScaleItem.prototype.Init.call(this);

    this.m_dHoga = null;    
    this.m_nBuyOrSell = null;//0(매수), 1(매도)
}

CHogaXScaleItem.prototype.GetHoga = function () {    
    return this.m_dHoga;
}
CHogaXScaleItem.prototype.SetData = function (nIndex, dHoga, nBuyOrSell, strRQ, rRQPacketsItem) {
    this.m_nIndex = nIndex;
    this.m_dHoga = dHoga;
    this.m_nBuyOrSell = nBuyOrSell;
    this.m_mapRQPacketsItem[strRQ] = rRQPacketsItem;
}


/////////////////////////////////////////////////////////////////////////////////////
//CXScaleMng
function CXScaleMng(rChart) {

    this.m_rChart = rChart;
    this.m_nType = 0;
    this.m_strXScalePacketName = "";
    this.m_XScaleItemArray = [];
    this.m_nViewCnt = 0;
    this.m_nViewStartIndex = -1;
    this.m_nViewEndIndex = -1;
    this.m_mapRQSet = {};
    this.m_strTitle = "";//툴팁이나 수치조회에서 보여지는 타이틀
    this.m_strTitleLangKey = null;
    this.m_nTotalMergeCnt = 0;

    this.m_bRemoveXScaleArray = false;//임의의 처리과정에서 XScaleArray가 삭제되었는지 여부를 확인하기 위한 유틸용 프로퍼티
    this.m_bInsertXScaleArray = false;//임의의 처리과정에서 XScaleArray가 추가되었는지 여부를 확인하기 위한 유틸용 프로퍼티

    //속도개선
    this.m_ChartBlockColArray = [];

    //툴팁 및 수치조회용
    this.m_tFindDateTime = null;//마우스 위치의 시간값 저장
}
CXScaleMng.prototype.ChangeLang = function(){

    if(this.m_strTitleLangKey)
        this.m_strTitle = t(this.m_strTitleLangKey);
}
CXScaleMng.prototype.InsertBefore = function (Iterator, NewItem) {
    var nResult = InsertBefore(this.m_XScaleItemArray, Iterator, NewItem);
    if (nResult >= 0)
        this.m_bInsertXScaleArray = true;
    return nResult;
}
CXScaleMng.prototype.InsertAfter = function (nIndex, NewItem) {
    var nResult = InsertAfter(this.m_XScaleItemArray, nIndex, NewItem);
    if (nResult >= 0)
        this.m_bInsertXScaleArray = true;
    return nResult;
}
CXScaleMng.prototype.RemoveXScaleArray = function (nRemoveIndex, nRemoveCnt) {
    this.m_XScaleItemArray.splice(nRemoveIndex, nRemoveCnt);
    this.m_bRemoveXScaleArray = true;
}
CXScaleMng.prototype.InsertXScaleArray = function (nInsertIndex, XScaleItem) {
    this.m_XScaleItemArray.splice(nInsertIndex, 0, XScaleItem);
    this.m_bInsertXScaleArray = true;
}
CXScaleMng.prototype.GetViewDataCnt = function () {
    return (this.m_nViewEndIndex - this.m_nViewStartIndex + 1);
}
CXScaleMng.prototype.AddRQ = function (strRQ, rRQSet) {
    this.m_mapRQSet[strRQ] = rRQSet;
}
CXScaleMng.prototype.Initialize = function (bViewDateTimeInit) {
    //this.m_strXScalePacketName = "";
    this.m_XScaleItemArray.length = 0;
    this.m_nViewCnt = 0;
    this.m_nViewStartIndex = -1;
    this.m_nViewEndIndex = -1;
    //this.m_mapRQSet = null;
    this.m_strTitle = "";//툴팁이나 수치조회에서 보여지는 타이틀
}
CXScaleMng.prototype.GetSelectedRQSet = function () {
    var strRQ;
    var rRQSet = null;
    for (strRQ in this.m_mapRQSet) {
        rRQSet = this.m_mapRQSet[strRQ];
        if (rRQSet.IsSelected() == true)
            return rRQSet;
    }
    return null;
}
CXScaleMng.prototype.SetRQSetMap = function (mapRQSet) {
    this.m_mapRQSet = mapRQSet;
}
CXScaleMng.prototype.ExtractMinMaxValue = function (strRQ, strPacketName, MinMaxInfo, bFullScan) {
}
CXScaleMng.prototype.InitialViewInfo = function (nViewCnt) {

    this.SetViewCnt(nViewCnt);
    var nMergeDataCnt = this.GetMergeDataCnt();
    if (nMergeDataCnt > 0) {
        if (nViewCnt < nMergeDataCnt) {
            this.m_nViewStartIndex = nMergeDataCnt - nViewCnt;
            this.m_nViewEndIndex = nMergeDataCnt - 1;
        }
        else {
            this.m_nViewStartIndex = 0;
            this.m_nViewEndIndex = nMergeDataCnt - 1;
        }
    }
    else {
        this.m_nViewStartIndex = -1;
        this.m_nViewEndIndex = -1;
    }

}
CXScaleMng.prototype.SetViewCnt = function (nViewCnt) {
    this.m_nViewCnt = nViewCnt;
}
CXScaleMng.prototype.GetViewCnt = function () {
    return this.m_nViewCnt;
}
CXScaleMng.prototype.VerifyViewRange = function () {
}
CXScaleMng.prototype.ShiftViewRange = function (nShiftDelta) {
    this.m_nViewStartIndex += nShiftDelta;
    this.m_nViewEndIndex += nShiftDelta;
}
CXScaleMng.prototype.SetViewStartIndex = function (nViewStartIndex) {
    this.m_nViewStartIndex = nViewStartIndex;
}
CXScaleMng.prototype.SetViewEndIndex = function (nViewEndIndex) {
    this.m_nViewEndIndex = nViewEndIndex;
}
CXScaleMng.prototype.GetViewStartIndex = function () {
    return this.m_nViewStartIndex;
}
CXScaleMng.prototype.GetViewEndIndex = function () {
    return this.m_nViewEndIndex;
}
CXScaleMng.prototype.SetViewStartEndIndex = function (nViewStartIndex, nViewEndIndex) {
    this.m_nViewStartIndex = nViewStartIndex;
    this.m_nViewEndIndex = nViewEndIndex;
}
CXScaleMng.prototype.SetRQPacketsItem = function (strRQ, rXScalePacketData, RQPacketsItem) {
}
CXScaleMng.prototype.GetType = function () {
    return this.m_nType;
}
CXScaleMng.prototype.SetXScalePacketName = function (strXScalePacketName) {
    this.m_strXScalePacketName = strXScalePacketName;
}
CXScaleMng.prototype.GetXScalePacketName = function () {
    return this.m_strXScalePacketName;
}
CXScaleMng.prototype.Arrange = function () {
}
CXScaleMng.prototype.Log = function () {
}
CXScaleMng.prototype.GetMergeDataCnt = function () {
    return this.m_nTotalMergeCnt;
}
CXScaleMng.prototype.SetTitle = function (strTitle) {
    this.m_strTitle = strTitle;
}
CXScaleMng.prototype.GetTitle = function () {
    return this.m_strTitle;
}

/////////////////////////////////////////////////////////////////////////////////////
//CHogaXScaleMng
function CHogaXScaleMng(rChart){

    CXScaleMng.call(this, rChart);
    this.m_nType = NUMERIC_TYPE;

    this.m_strTitleLangKey = "chart.price";
    this.m_strTitle = t(this.m_strTitleLangKey);//호가

    this.m_dViewStartHoga = null;
    this.m_dViewEndHoga = null;

    this.m_nDec = null;//진법
    this.m_Unit = null;//최소단위(데이터의 최소 간격의미(예:호가))
    this.m_nDigit = null;//최소자리수
}
CHogaXScaleMng.prototype = new CXScaleMng();
CHogaXScaleMng.prototype.constructor = CHogaXScaleMng;

CHogaXScaleMng.prototype.SetPacketInfo = function(nDec, Unit, nDigit){

    this.m_nDec = nDec;
    this.m_Unit = Unit;
    this.m_nDigit = nDigit;
}
CHogaXScaleMng.prototype.GetIndexByHoga = function (dHoga) {

    var i, rHogaXScaleItem = null, nLength = this.m_XScaleItemArray.length;
    if(nLength <= 0)
        return null;

    for(i = 0 ; i < nLength; i++ )
    {
        rHogaXScaleItem = this.m_XScaleItemArray[i];
        if(dHoga <= rHogaXScaleItem.m_dHoga)
            return i-1;
    }
    return i - 1;
}

CHogaXScaleMng.prototype.VerifyViewRange = function () {

    var nViewCnt = this.GetViewCnt();
    if (nViewCnt <= 0) return;
    var nTotalMergeCnt = this.GetMergeDataCnt();
    if (nViewCnt >= nTotalMergeCnt) {

        //1.View Cout
        this.SetViewCnt(nTotalMergeCnt);

        //2. View Range Index 
        this.m_nViewStartIndex = 0;
        this.m_nViewEndIndex = nTotalMergeCnt - 1;
        
        //3. View Range Hoga
        var rHogaXScale = this.m_XScaleItemArray[this.m_nViewStartIndex];
        this.m_dViewStartHoga = rHogaXScale.m_dHoga;

        rHogaXScale = this.m_XScaleItemArray[this.m_nViewEndIndex];
        this.m_dViewEndHoga = rHogaXScale.m_dHoga;

        return;
    }
    else {

        if (nTotalMergeCnt - 1 < this.m_nViewEndIndex) {

            // View Range Index
            this.m_nViewEndIndex = nTotalMergeCnt - 1;
            this.m_nViewStartIndex = this.m_nViewEndIndex - nViewCnt + 1;
            if (this.m_nViewStartIndex < 0) {
                this.m_nViewStartIndex = 0;
                this.SetViewCnt(this.m_nViewEndIndex - this.m_nViewStartIndex + 1);
            }

            // View End XScaleArray Index & View End Hoga            
            var rXScaleItem = this.m_XScaleItemArray[this.m_nViewEndIndex];
            this.m_dViewEndHoga = rXScaleItem.m_dHoga;

            // View Start XScaleArray Index & View Start Hoga
            var rXScaleItem = this.m_XScaleItemArray[this.m_nViewStartIndex];
            this.m_dViewStartHoga = rXScaleItem.m_dHoga;
        }
        else {

            var rXScaleItem = this.m_XScaleItemArray[this.m_nViewStartIndex];
            this.m_dViewStartHoga = rXScaleItem.m_dHoga;

            var rXScaleItem = this.m_XScaleItemArray[this.m_nViewEndIndex];
            this.m_dViewEndHoga = rXScaleItem.m_dHoga;

            this.SetViewCnt(this.m_nViewEndIndex - this.m_nViewStartIndex + 1);
        }
    }
}

CHogaXScaleMng.prototype.ShiftViewRange = function (nShiftDelta) {

    CXScaleMng.prototype.ShiftViewRange.call(this, nShiftDelta);

    var rXScaleItem = this.m_XScaleItemArray[this.m_nViewStartIndex];
    this.m_dViewStartHoga = rXScaleItem.m_dHoga;

    rXScaleItem = this.m_XScaleItemArray[this.m_nViewEndIndex];
    this.m_dViewEndHoga = rXScaleItem.m_dHoga;
}

CHogaXScaleMng.prototype.InitialViewInfo = function (nViewCnt) {

    CXScaleMng.prototype.InitialViewInfo.call(this, nViewCnt);

    var rXScaleItem = this.m_XScaleItemArray[this.m_nViewStartIndex];
    this.m_dViewStartHoga = rXScaleItem.m_dHoga;

    rXScaleItem = this.m_XScaleItemArray[this.m_nViewEndIndex];
    this.m_dViewEndHoga = rXScaleItem.m_dHoga;
}

CHogaXScaleMng.prototype.Initialize = function (bViewInfoInit) {

    CXScaleMng.prototype.Initialize.call(this, bViewInfoInit);

    if(bViewInfoInit)
    {
        this.m_dViewStartHoga = null;
        this.m_dViewEndHoga = null;
    }
}

CHogaXScaleMng.prototype.ExtractMinMaxValue = function (strRQ, strPacketName, MinMaxInfo, bFullScan) {

    var rRQSet = this.m_mapRQSet[strRQ];
    if (rRQSet == undefined) {

        MinMaxInfo.m_Max = null;
        MinMaxInfo.m_Min = null;
        MinMaxInfo.m_nStartIndex = this.m_nViewStartIndex;
        MinMaxInfo.m_nEndIndex = this.m_nViewEndIndex;

        return false;
    }

    var i;
    var rSelectPacketData = null;
    var rHogaXPacketData = null;
    var length = rRQSet.m_PacketDataArray.length;
    for (i = 0; i < length; i++) {
        var rPacketData = rRQSet.m_PacketDataArray[i];
        if (rPacketData.m_strPacketName == strPacketName) {
            //패킷이 숫자타입이 아닌 경우
            if (rPacketData.m_nPacketType != NUMERIC_TYPE) {

                MinMaxInfo.m_Max = null;
                MinMaxInfo.m_Min = null;
                MinMaxInfo.m_nStartIndex = this.m_nViewStartIndex;
                MinMaxInfo.m_nEndIndex = this.m_nViewEndIndex;

                return false;
            }

            rSelectPacketData = rPacketData;
        }
        else if (rPacketData.m_strPacketName == this.m_strXScalePacketName) {
            rHogaXPacketData = rPacketData;
        }
    }

    //해당 rq에 원하는 패킷명이 없는 경우
    if (rSelectPacketData == null || rHogaXPacketData == null) {

        MinMaxInfo.m_Max = null;
        MinMaxInfo.m_Min = null;
        MinMaxInfo.m_nStartIndex = this.m_nViewStartIndex;
        MinMaxInfo.m_nEndIndex = this.m_nViewEndIndex;

        return false;
    }

    //같은 범위를 이미 조사한 경우 저장해놓은 값으로 셋팅하고 리턴
    if (rSelectPacketData.m_nViewStartIndex == this.m_nViewStartIndex &&
        rSelectPacketData.m_nViewEndIndex == this.m_nViewEndIndex) {
        MinMaxInfo.m_Max = rSelectPacketData.m_ViewMaxValue;
        MinMaxInfo.m_Min = rSelectPacketData.m_ViewMinValue;
        MinMaxInfo.m_nStartIndex = rSelectPacketData.m_nViewStartIndex;
        MinMaxInfo.m_nEndIndex = rSelectPacketData.m_nViewEndIndex;

        return true;
    }

    var fMax, fMin;
    var nMinMaxCountIndex = 0;
    var nMinMaxItemStartIndex = null, nMinMaxItemEndIndex = null;
    var nViewIndex = this.m_nViewStartIndex;

    if (bFullScan && !rSelectPacketData.ExtractMinMaxValue(this, rHogaXPacketData, this.m_nViewStartIndex, this.m_nViewEndIndex)) {
        MinMaxInfo.m_Max = null;
        MinMaxInfo.m_Min = null;
        MinMaxInfo.m_nStartIndex = this.m_nViewStartIndex;
        MinMaxInfo.m_nEndIndex = this.m_nViewEndIndex;
        return false;
    }

    MinMaxInfo.m_Max = rSelectPacketData.m_MinMaxMng.m_ViewMaxValue;
    MinMaxInfo.m_Min = rSelectPacketData.m_MinMaxMng.m_ViewMinValue;
    MinMaxInfo.m_nStartIndex = this.m_nViewStartIndex;
    MinMaxInfo.m_nEndIndex = this.m_nViewEndIndex;

    return true;
}
CHogaXScaleMng.prototype.SetRQPacketsItem = function (strRQ, rHogaPacketItemData, RQPacketsItem) {
    
    rHogaPacketItemData.m_rRQPacketsItem = RQPacketsItem;
}

CHogaXScaleMng.prototype.GetRQPacketsByIndex = function (strRQ, nIndex) {

    if(nIndex < 0 || this.m_XScaleItemArray.length <= nIndex)
        return null;
    
    var rXScaleItem = this.m_XScaleItemArray[nIndex];
    if(!rXScaleItem)
        return null;

    var rRQPacketsItem = rXScaleItem.m_mapRQPacketsItem[strRQ];
    if(!rRQPacketsItem)
        return null;

    return rRQPacketsItem;
}

CHogaXScaleMng.prototype.Merge = function (rHogaXPacketData) 
{
    if (!rHogaXPacketData || rHogaXPacketData.m_nPacketType !== NUMERIC_TYPE)
        return false;

    var i;
    var rHogaDataArray = rHogaXPacketData.GetDataArray();
    var rHogaFlagDataArray = null;
    var strRQ = rHogaXPacketData.m_rRQSet.GetRQ();
    var rHogaFlagPacketData = rHogaXPacketData.m_rRQSet.GetPacketData("_SELLFLAG_");
    if(rHogaFlagPacketData){
        rHogaFlagDataArray = rHogaFlagPacketData.GetDataArray();
    }

    this.m_XScaleItemArray = [];
	
    for (i = 0; i < rHogaDataArray.length; i++) {

        var rHogaItemData = rHogaDataArray[i];
        var rHogaFlagItemData = rHogaFlagDataArray[i];
        
        var NewXScaleItem = new CHogaXScaleItem(this);
        NewXScaleItem.SetData(i, rHogaItemData.m_Data, rHogaFlagItemData.m_Data, strRQ, rHogaItemData.m_rRQPacketsItem);

        this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewXScaleItem;
    }

    this.m_nTotalMergeCnt = this.m_XScaleItemArray.length;
}
/////////////////////////////////////////////////////////////////////////////////////
//CDateTimeXScaleMng
function CDateTimeXScaleMng(rChart) {

    CXScaleMng.call(this, rChart);
    this.m_nType = DATETIME_TYPE;
    this.m_MinIntervalArray = [new CInterval(0), new CInterval(0), new CInterval(0), new CInterval(0),
    new CInterval(0), new CInterval(0), new CInterval(0)];
    this.m_tTimeArray = [];

    this.m_strTitleLangKey = "chart.dateTimeXScaleTitle";    
    this.m_strTitle = t(this.m_strTitleLangKey);//(일자)툴팁이나 수치조회에서 보여지는 타이틀

    this.m_tViewStartDateTime = null;
    this.m_tViewEndDateTime = null;

    this.m_rViewStartXScaleItemIndex = null;
    this.m_rViewEndXScaleItemIndex = null;

    //Merge시 잠시 사용되는 변수
    this.m_rCurDateTimeData4Merge = null;

    //Merge Array
    this.m_XScaleMergeArray = [];
}

CDateTimeXScaleMng.prototype = new CXScaleMng();
CDateTimeXScaleMng.prototype.constructor = CDateTimeXScaleMng;

CDateTimeXScaleMng.prototype.CheckMinCycle = function(nCycle){

	//현재 분주기이고 초주기가 존재하는 경우는 초주기를 현재 주기로 리턴한다(분주기 이하에서는 가장 최소주기를 리턴토록 처리)
    if (nCycle === 5 && this.m_MinIntervalArray[6 - 1].m_nInterval !== 0)
        return 6;

    return nCycle;
}

//Start와 End 시간 사이에 rq 데이터가 존재하지 않는 범위는 최소봉단위로 계산을 시도한다.
CDateTimeXScaleMng.prototype.GetIndexByDateTimeT = function (tDateTime, bIncludeFuture) {
    var i, nLength = this.m_XScaleItemArray.length;
    for (i = 0; i < nLength; i++) {
        var rDateTimeXScaleItem = this.m_XScaleItemArray[i];
        var nResultIndex = rDateTimeXScaleItem.GetIndexByDateTimeT(tDateTime, false);
        if (nResultIndex == -2)//-2는 이전 XScaleItem 범위라는 의미, -1은 현재 XScaleItem범위보다 최근 시간의 범위로 이동
        {
            // 처음 데이터에서 -2가 나오면 전체 데이터 범위에 없다는 뜻
            if( i === 0 )
                return null;
            // 중간에 -2가 나오는건 중간에 데이터가 없는 경우이므로 시작 위치를 반환
            else
                return rDateTimeXScaleItem.GetStartPos();
        }
        else if (0 <= nResultIndex)
            return nResultIndex;
        
        // 미래영역 Index 찾기
        if( bIncludeFuture && i === nLength - 1 && nResultIndex === -1 )
        {
            return rDateTimeXScaleItem.GetIndexByDateTimeT(tDateTime, true);
        }
    }
    return null;
}
CDateTimeXScaleMng.prototype.VerifyViewRange = function () {

    var nViewCnt = this.GetViewCnt();
    if (nViewCnt <= 0) return;
    var nTotalMergeCnt = this.GetMergeDataCnt();
    if (nViewCnt >= nTotalMergeCnt) {

        //1.View Cout
        this.SetViewCnt(nTotalMergeCnt);

        //2. View Range Index
        this.m_nViewStartIndex = 0;
        this.m_nViewEndIndex = nTotalMergeCnt - 1;

        //3. View Start/End  XScaleArray Index
        this.m_rViewStartXScaleItemIndex = 0;
        this.m_rViewEndXScaleItemIndex = this.m_XScaleItemArray.length - 1;

        //4. View Range Time
        //var rDateTimeStartXScaleItem = this.m_XScaleItemArray[this.m_rViewStartXScaleItemIndex];
        //this.m_tViewStartDateTime = rDateTimeStartXScaleItem.GetStart();
        var rXScaleMergeIndex = this.m_XScaleMergeArray[this.m_nViewStartIndex];
        this.m_tViewStartDateTime = rXScaleMergeIndex.m_tStart;

        //var rDateTimeEndXScaleItem = this.m_XScaleItemArray[this.m_rViewEndXScaleItemIndex];
        //this.m_tViewEndDateTime = rDateTimeEndXScaleItem.GetEnd();
        var rXScaleMergeIndex = this.m_XScaleMergeArray[this.m_nViewEndIndex];
        this.m_tViewEndDateTime = rXScaleMergeIndex.m_tStart;

        return;
    }
    else {

        if (nTotalMergeCnt - 1 < this.m_nViewEndIndex) {

            // View Range Index
            this.m_nViewEndIndex = nTotalMergeCnt - 1;
            this.m_nViewStartIndex = this.m_nViewEndIndex - nViewCnt + 1;
            if (this.m_nViewStartIndex < 0) {
                this.m_nViewStartIndex = 0;
                this.SetViewCnt(this.m_nViewEndIndex - this.m_nViewStartIndex + 1);
            }

            // View End XScaleArray Index & View End Time
            this.m_rViewEndXScaleItemIndex = this.m_XScaleItemArray.length - 1;
            var rDateTimeXScaleItem = this.m_XScaleItemArray[this.m_rViewEndXScaleItemIndex];
            this.m_tViewEndDateTime = rDateTimeXScaleItem.GetEnd();


            // View Start XScaleArray Index & View Start Time
            for (var nXScaleIndex = this.m_rViewEndXScaleItemIndex; nXScaleIndex >= 0; nXScaleIndex--) {

                rDateTimeXScaleItem = this.m_XScaleItemArray[nXScaleIndex];
                var nStartIndex = rDateTimeXScaleItem.GetStartPos();
                var nEndIndex = nStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;
                if (nStartIndex <= this.m_nViewStartIndex && this.m_nViewStartIndex <= nEndIndex) {
                    this.m_rViewStartXScaleItemIndex = nXScaleIndex;
                    this.m_tViewStartDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewStartIndex);
                    break;
                }
            }
            if (nXScaleIndex < 0) {
                this.m_nViewStartIndex = 0;
                this.m_rViewStartXScaleItemIndex = 0;
                this.m_tViewStartDateTime = this.m_XScaleItemArray[this.m_rViewStartXScaleItemIndex].GetStart();
                this.SetViewCnt(this.m_nViewEndIndex - this.m_nViewStartIndex + 1);
            }
        }
        else {

            if (this.m_XScaleItemArray.length <= this.m_rViewStartXScaleItemIndex) {

                var bStartSet = false, bEndSet = false;
                for (var nXScaleIndex = this.m_XScaleItemArray.length - 1; nXScaleIndex >= 0; nXScaleIndex--) {

                    var rDateTimeXScaleItem = this.m_XScaleItemArray[nXScaleIndex];
                    var nStartIndex = rDateTimeXScaleItem.GetStartPos();
                    var nEndIndex = nStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;

                    if (nStartIndex <= this.m_nViewStartIndex && this.m_nViewStartIndex <= nEndIndex) {
                        this.m_rViewStartXScaleItemIndex = nXScaleIndex;
                        this.m_tViewStartDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewStartIndex);
                        bStartSet = true;
                        if (bEndSet == true)
                            break;
                    }
                    if (nStartIndex <= this.m_nViewEndIndex && this.m_nViewEndIndex <= nEndIndex) {
                        this.m_rViewEndXScaleItemIndex = nXScaleIndex;
                        this.m_tViewEndDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewEndIndex);
                        bEndSet = true;
                        if (bStartSet === true)
                            break;
                    }
                }
                if (nXScaleIndex < 0) {
                    //1.View Cout
                    this.SetViewCnt(nTotalMergeCnt);

                    //2. View Range Index
                    this.m_nViewStartIndex = 0;
                    this.m_nViewEndIndex = nTotalMergeCnt - 1;

                    //3. View Start/End  XScaleArray Index
                    this.m_rViewStartXScaleItemIndex = 0;
                    this.m_rViewEndXScaleItemIndex = this.m_XScaleItemArray.length - 1;

                    //4. View Range Time
                    var rDateTimeStartXScaleItem = this.m_XScaleItemArray[this.m_rViewStartXScaleItemIndex];
                    this.m_tViewStartDateTime = rDateTimeStartXScaleItem.GetStart();

                    var rDateTimeEndXScaleItem = this.m_XScaleItemArray[this.m_rViewEndXScaleItemIndex];
                    this.m_tViewEndDateTime = rDateTimeEndXScaleItem.GetEnd();

                    return;
                }
            }
            else if (this.m_XScaleItemArray.length <= this.m_rViewEndXScaleItemIndex) {

                for (var nXScaleIndex = this.m_XScaleItemArray.length - 1; nXScaleIndex >= 0; nXScaleIndex--) {

                    var rDateTimeXScaleItem = this.m_XScaleItemArray[nXScaleIndex];
                    var nStartIndex = rDateTimeXScaleItem.GetStartPos();
                    var nEndIndex = nStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;

                    if (nStartIndex <= this.m_nViewEndIndex && this.m_nViewEndIndex <= nEndIndex) {
                        this.m_rViewEndXScaleItemIndex = nXScaleIndex;
                        this.m_tViewEndDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewEndIndex);
                        break;
                    }
                }

                if (nXScaleIndex < 0) {

                    this.m_nViewEndIndex = nTotalMergeCnt - 1;
                    this.m_rViewEndXScaleItemIndex = this.m_XScaleItemArray.length - 1;
                    this.m_tViewEndDateTime = this.m_XScaleItemArray[this.m_rViewEndXScaleItemIndex].GetEnd();
                    this.SetViewCnt(this.m_nViewEndIndex - this.m_nViewStartIndex + 1);
                    return;
                }
            }

            //////////////////////////////////////////////////
            //Start
            var bStartError = false;
            var rDateTimeXScaleItem = this.m_XScaleItemArray[this.m_rViewStartXScaleItemIndex];
            var nStartIndex = rDateTimeXScaleItem.GetStartPos();
            var nEndIndex = nStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;
            
            if (this.m_nViewStartIndex < nStartIndex) {

                for (var nXScaleIndex = this.m_rViewStartXScaleItemIndex - 1; nXScaleIndex >= 0; nXScaleIndex--) {

                    var rDateTimeXScaleItem = this.m_XScaleItemArray[nXScaleIndex];
                    var nStartIndex = rDateTimeXScaleItem.GetStartPos();
                    var nEndIndex = nStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;
                    
                    if (nStartIndex <= this.m_nViewStartIndex && this.m_nViewStartIndex <= nEndIndex) {
                        this.m_rViewStartXScaleItemIndex = nXScaleIndex;
                        this.m_tViewStartDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewStartIndex);
                        break;
                    }
                }
                if (nXScaleIndex < 0) {
                    bStartError = true;
                }
            }
            else if (nEndIndex < this.m_nViewStartIndex) {

                var nLength = this.m_XScaleItemArray.length;
                for (var nXScaleIndex = this.m_rViewStartXScaleItemIndex + 1; nXScaleIndex < nLength; nXScaleIndex++) {

                    var rDateTimeXScaleItem = this.m_XScaleItemArray[nXScaleIndex];
                    var nStartIndex = rDateTimeXScaleItem.GetStartPos();
                    var nEndIndex = nStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;
                    
                    if (nStartIndex <= this.m_nViewStartIndex && this.m_nViewStartIndex <= nEndIndex) {
                        this.m_rViewStartXScaleItemIndex = nXScaleIndex;
                        this.m_tViewStartDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewStartIndex);
                        break;
                    }
                }
                if (nXScaleIndex >= nLength) {
                    bStartError = true;
                }
            }
            else {

                this.m_tViewStartDateTime = this.m_XScaleItemArray[this.m_rViewStartXScaleItemIndex].GetDateTimeTByIndex(this.m_nViewStartIndex);
            }
            if (bStartError) {

                this.m_nViewStartIndex = 0;
                this.m_rViewStartXScaleItemIndex = 0;
                this.m_tViewStartDateTime = this.m_XScaleItemArray[this.m_rViewStartXScaleItemIndex].GetStart();
            }

            ////////////////////////////////////////////////////////////
            //End
            var bEndError = false;
            var rDateTimeXScaleItem = this.m_XScaleItemArray[this.m_rViewEndXScaleItemIndex];
            var nStartIndex = rDateTimeXScaleItem.GetStartPos();
            var nEndIndex = nStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;
            

            if (this.m_nViewEndIndex < nStartIndex) {

                for (var nXScaleIndex = this.m_rViewEndXScaleItemIndex - 1; nXScaleIndex >= this.m_rViewStartXScaleItemIndex; nXScaleIndex--) {

                    var rDateTimeXScaleItem = this.m_XScaleItemArray[nXScaleIndex];
                    var nStartIndex = rDateTimeXScaleItem.GetStartPos();
                    var nEndIndex = nStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;

                    if (nStartIndex <= this.m_nViewEndIndex && this.m_nViewEndIndex <= nEndIndex) {
                        this.m_rViewEndXScaleItemIndex = nXScaleIndex;
                        this.m_tViewEndDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewEndIndex);
                        break;
                    }
                }
                if (nXScaleIndex < this.m_rViewStartXScaleItemIndex) {
                    bEndError = true;
                }
            }
            else if (nEndIndex < this.m_nViewEndIndex) {

                var nLength = this.m_XScaleItemArray.length;
                for (var nXScaleIndex = this.m_rViewEndXScaleItemIndex + 1; nXScaleIndex < nLength; nXScaleIndex++) {

                    var rDateTimeXScaleItem = this.m_XScaleItemArray[nXScaleIndex];
                    var nStartIndex = rDateTimeXScaleItem.GetStartPos();
                    var nEndIndex = nStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;
                    
                    if (nStartIndex <= this.m_nViewEndIndex && this.m_nViewEndIndex <= nEndIndex) {
                        this.m_rViewEndXScaleItemIndex = nXScaleIndex;
                        this.m_tViewEndDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewEndIndex);
                        break;
                    }
                }
                if (nXScaleIndex >= nLength) {
                    bEndError = true;
                }
            }
            else {

                this.m_tViewEndDateTime = this.m_XScaleItemArray[this.m_rViewEndXScaleItemIndex].GetDateTimeTByIndex(this.m_nViewEndIndex);
            }

            if (bEndError) {
                this.m_nViewEndIndex = nTotalMergeCnt - 1;
                this.m_rViewEndXScaleItemIndex = this.m_XScaleItemArray.length - 1;
                this.m_tViewEndDateTime = this.m_XScaleItemArray[this.m_rViewEndXScaleItemIndex].GetEnd();
            }

            if (bStartError || bEndError)
                this.SetViewCnt(this.m_nViewEndIndex - this.m_nViewStartIndex + 1);

        }
    }
}
CDateTimeXScaleMng.prototype.ShiftViewRange = function (nShiftDelta) {

    CXScaleMng.prototype.ShiftViewRange.call(this, nShiftDelta);

    var nXScaleItemEndIndex = null;
    if (this.m_rViewStartXScaleItemIndex != null) {
        var rDateTimeXScaleItem = this.m_XScaleItemArray[this.m_rViewStartXScaleItemIndex];
        var nXScaleItemStartIndex = rDateTimeXScaleItem.GetStartPos();
        nXScaleItemEndIndex = nXScaleItemStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;
        
        if (nXScaleItemStartIndex <= this.m_nViewStartIndex && this.m_nViewStartIndex <= nXScaleItemEndIndex) {
            this.m_tViewStartDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewStartIndex);
        }
        else {

            var nLength = this.m_XScaleItemArray.length;
            if (nShiftDelta > 0) {
                var nXScaleItemIndex = this.m_rViewStartXScaleItemIndex + 1;
                for (; nXScaleItemIndex < nLength; nXScaleItemIndex++) {
                    rDateTimeXScaleItem = this.m_XScaleItemArray[nXScaleItemIndex];

                    nXScaleItemStartIndex = rDateTimeXScaleItem.GetStartPos();
                    nXScaleItemEndIndex = nXScaleItemStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;
                    
                    if (nXScaleItemStartIndex <= this.m_nViewStartIndex && this.m_nViewStartIndex <= nXScaleItemEndIndex) {
                        this.m_tViewStartDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewStartIndex);
                        this.m_rViewStartXScaleItemIndex = nXScaleItemIndex;
                        break;
                    }
                }

                if (nXScaleItemIndex >= nLength) {
                    this.m_tViewStartDateTime = null;
                    this.m_rViewStartXScaleItemIndex = null;
                }
            }
            else {
                var nXScaleItemIndex = this.m_rViewStartXScaleItemIndex - 1;
                for (; nXScaleItemIndex >= 0; nXScaleItemIndex--) {
                    rDateTimeXScaleItem = this.m_XScaleItemArray[nXScaleItemIndex];

                    nXScaleItemStartIndex = rDateTimeXScaleItem.GetStartPos();
                    nXScaleItemEndIndex = nXScaleItemStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;
                    
                    if (nXScaleItemStartIndex <= this.m_nViewStartIndex && this.m_nViewStartIndex <= nXScaleItemEndIndex) {
                        this.m_tViewStartDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewStartIndex);
                        this.m_rViewStartXScaleItemIndex = nXScaleItemIndex;
                        break;
                    }
                }

                if (nXScaleItemIndex < 0) {
                    this.m_tViewStartDateTime = null;
                    this.m_rViewStartXScaleItemIndex = null;
                }
            }
        }
    }

    if (this.m_rViewEndXScaleItemIndex != null) {
        var rDateTimeXScaleItem = this.m_XScaleItemArray[this.m_rViewEndXScaleItemIndex];
        var nXScaleItemStartIndex = rDateTimeXScaleItem.GetStartPos();
        nXScaleItemEndIndex = nXScaleItemStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;
        
        if (nXScaleItemStartIndex <= this.m_nViewEndIndex && this.m_nViewEndIndex <= nXScaleItemEndIndex) {
            this.m_tViewEndDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewEndIndex);
        }
        else {

            var nLength = this.m_XScaleItemArray.length;
            if (nShiftDelta > 0) {

                var nXScaleItemIndex = this.m_rViewEndXScaleItemIndex + 1;

                for (; nXScaleItemIndex < nLength; nXScaleItemIndex++) {
                    rDateTimeXScaleItem = this.m_XScaleItemArray[nXScaleItemIndex];

                    nXScaleItemStartIndex = rDateTimeXScaleItem.GetStartPos();
                    nXScaleItemEndIndex = nXScaleItemStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;
                    
                    if (nXScaleItemStartIndex <= this.m_nViewEndIndex && this.m_nViewEndIndex <= nXScaleItemEndIndex) {
                        this.m_tViewEndDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewEndIndex);
                        this.m_rViewEndXScaleItemIndex = nXScaleItemIndex;
                        break;
                    }
                }

                if (nXScaleItemIndex >= nLength) {
                    this.m_tViewEndDateTime = null;
                    this.m_rViewEndXScaleItemIndex = null;
                }
            }
            else {

                var nXScaleItemIndex = this.m_rViewEndXScaleItemIndex - 1;

                for (; nXScaleItemIndex >= 0; nXScaleItemIndex--) {
                    rDateTimeXScaleItem = this.m_XScaleItemArray[nXScaleItemIndex];

                    nXScaleItemStartIndex = rDateTimeXScaleItem.GetStartPos();
                    nXScaleItemEndIndex = nXScaleItemStartIndex + rDateTimeXScaleItem.GetIntervalCnt() - 1;
                    
                    if (nXScaleItemStartIndex <= this.m_nViewEndIndex && this.m_nViewEndIndex <= nXScaleItemEndIndex) {
                        this.m_tViewEndDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewEndIndex);
                        this.m_rViewEndXScaleItemIndex = nXScaleItemIndex;
                        break;
                    }
                }

                if (nXScaleItemIndex < 0) {
                    this.m_tViewEndDateTime = null;
                    this.m_rViewEndXScaleItemIndex = null;
                }
            }
        }
    }
}

CDateTimeXScaleMng.prototype.InitialViewInfo = function (nViewCnt) {

    CXScaleMng.prototype.InitialViewInfo.call(this, nViewCnt);

    this.m_tViewStartDateTime = null;
    this.m_tViewEndDateTime = null;

    if (this.m_nViewStartIndex >= 0) {
        var i, nXScalePosIndex = 0, nNextIndex = 0;
        var rDateTimeXScaleItem = new CDateTimeXScaleItem(this);
        var nXScaleItemArrayIndex = this.GetDateTimeXScaleItemByIndex(this.m_nViewStartIndex, 0, this.m_XScaleItemArray.length, rDateTimeXScaleItem);
        if (nXScaleItemArrayIndex < 0 || rDateTimeXScaleItem == null)
            return;

        this.m_rViewStartXScaleItemIndex = nXScaleItemArrayIndex;
        this.m_tViewStartDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewStartIndex);

        do {
            var nXScaleItemEndIndex = rDateTimeXScaleItem.GetStartPos() + rDateTimeXScaleItem.GetIntervalCnt() - 1;
            
            if (nXScaleItemEndIndex >= this.m_nViewEndIndex) {

                this.m_rViewEndXScaleItemIndex = nXScaleItemArrayIndex;
                this.m_tViewEndDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(this.m_nViewEndIndex);
                return;
            }

            if (this.m_XScaleItemArray.length <= nXScaleItemArrayIndex + 1) {

                this.m_rViewEndXScaleItemIndex = nXScaleItemArrayIndex;
                this.m_tViewEndDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(nXScaleItemEndIndex);
                return;
            }

            rDateTimeXScaleItem = this.m_XScaleItemArray[++nXScaleItemArrayIndex];

        } while (1);
    }
}
CDateTimeXScaleMng.prototype.Initialize = function (bViewDateTimeInit) {

    CXScaleMng.prototype.Initialize.call(this, bViewDateTimeInit);

    var i, nLength = this.m_MinIntervalArray.length;
    for (i = 0; i < nLength; i++) {
        this.m_MinIntervalArray[i].m_nInterval = 0;
    }

    this.m_tTimeArray.length = 0;
    
    this.m_XScaleMergeArray.length = 0;

    if (bViewDateTimeInit == true) {
        this.m_tViewStartDateTime = null;
        this.m_tViewEndDateTime = null;
        this.m_rViewStartXScaleItemIndex = null;
        this.m_rViewEndXScaleItemIndex = null;
    }
}
CDateTimeXScaleMng.prototype.GetRQPacketsByIndex = function (strRQ, nIndex) {
    var tDateTime = this.GetDateTimeTByIndex(nIndex);
    if (this.m_tTimeArray[tDateTime] != undefined) {
        var RQPackets = this.m_tTimeArray[tDateTime][strRQ];
        if (RQPackets != undefined) {
            return RQPackets;
        }
    }
    return null;
}

CDateTimeXScaleMng.prototype.GetDateTimeXScaleItemByIndex = function (nFindIndex, nStartSearchIndex, nEndSearchIndex, rOutDateTimeXScaleItem, bIncludeFuture) {

    if (nStartSearchIndex < nEndSearchIndex) {
        
        var i, length = this.m_XScaleItemArray.length;
        var nLastIndex = length - 1;

        if (length - 1 < nEndSearchIndex)
            nEndSearchIndex = length - 1;
        if (nStartSearchIndex < 0)
            nStartSearchIndex = 0;

        for (i = nStartSearchIndex; i <= nEndSearchIndex; i++) {

            var rDateTimeXScaleItem = this.m_XScaleItemArray[i];
            if (rDateTimeXScaleItem.GetCycle() == 0 && rDateTimeXScaleItem.GetInterval() == 0)
                continue;

            var nStartPos = rDateTimeXScaleItem.GetStartPos();
            var nLastPos = nStartPos + rDateTimeXScaleItem.GetIntervalCnt() - 1;
            
            var tFindIndexTimeT = rDateTimeXScaleItem.GetDateTimeTByIndex(nFindIndex, (bIncludeFuture === true && i === nLastIndex ? bIncludeFuture : false));
            if (tFindIndexTimeT < 0) {
                if (nFindIndex < nStartPos)
                    break;
            }
            else {
                rOutDateTimeXScaleItem.m_nStartPos = rDateTimeXScaleItem.m_nStartPos;
                rOutDateTimeXScaleItem.m_nDataCount = rDateTimeXScaleItem.m_nDataCount;
                rOutDateTimeXScaleItem.m_nCycle = rDateTimeXScaleItem.m_nCycle;
                rOutDateTimeXScaleItem.m_rInterval = rDateTimeXScaleItem.m_rInterval;
                rOutDateTimeXScaleItem.m_tStart = rDateTimeXScaleItem.m_tStart;
                rOutDateTimeXScaleItem.m_tEnd = rDateTimeXScaleItem.m_tEnd;
                rOutDateTimeXScaleItem.m_dateStart = rDateTimeXScaleItem.m_dateStart;
                rOutDateTimeXScaleItem.m_dateEnd = rDateTimeXScaleItem.m_dateEnd;
                rOutDateTimeXScaleItem.m_nIndex = rDateTimeXScaleItem.m_nIndex;//시간이 같은 경우(틱) nIndex 카운트
                rOutDateTimeXScaleItem.m_tFindIndexTimeT = tFindIndexTimeT;//nFindIndex에 해당하는 시간/1000
                rOutDateTimeXScaleItem.m_bFutureTime = (nFindIndex > nLastPos ? true : false);//nFindIndex가 미래 영역임을 의미
                return i;
            }
        }
    }
    else {//뒤쪽 INDEX부터 검색하는 것이 더 빠를 경우 nStartSearchIndex에 큰 값, nEndSearchIndex에 작은 값을 할당하여 뒤부터 검색하도록 사용한다
        var i, length = this.m_XScaleItemArray.length;
        var nLastIndex = length - 1;

        if (length - 1 < nStartSearchIndex)
            nStartSearchIndex = length - 1;
        if (nEndSearchIndex < 0)
            nEndSearchIndex = 0;

        for (i = nStartSearchIndex; i >= nEndSearchIndex; i--) {

            var rDateTimeXScaleItem = this.m_XScaleItemArray[i];
            if (rDateTimeXScaleItem.GetCycle() == 0 && rDateTimeXScaleItem.GetInterval() == 0)
                continue;

            var nStartPos = rDateTimeXScaleItem.GetStartPos();
            var nLastPos = nStartPos + rDateTimeXScaleItem.GetIntervalCnt() - 1;
            
            var tFindIndexTimeT = rDateTimeXScaleItem.GetDateTimeTByIndex(nFindIndex, (bIncludeFuture === true && i === nLastIndex ? bIncludeFuture : false));
            if (tFindIndexTimeT < 0) {
                if (nLastPos < nFindIndex)
                    break;
            }
            else {
                rOutDateTimeXScaleItem.m_nStartPos = rDateTimeXScaleItem.m_nStartPos;
                rOutDateTimeXScaleItem.m_nDataCount = rDateTimeXScaleItem.m_nDataCount;
                rOutDateTimeXScaleItem.m_nCycle = rDateTimeXScaleItem.m_nCycle;
                rOutDateTimeXScaleItem.m_rInterval = rDateTimeXScaleItem.m_rInterval;
                rOutDateTimeXScaleItem.m_tStart = rDateTimeXScaleItem.m_tStart;
                rOutDateTimeXScaleItem.m_tEnd = rDateTimeXScaleItem.m_tEnd;
                rOutDateTimeXScaleItem.m_dateStart = rDateTimeXScaleItem.m_dateStart;
                rOutDateTimeXScaleItem.m_dateEnd = rDateTimeXScaleItem.m_dateEnd;
                rOutDateTimeXScaleItem.m_nIndex = rDateTimeXScaleItem.m_nIndex;//시간이 같은 경우(틱) nIndex 카운트
                rOutDateTimeXScaleItem.m_tFindIndexTimeT = tFindIndexTimeT;//nFindIndex에 해당하는 시간/1000
                rOutDateTimeXScaleItem.m_bFutureTime = (nFindIndex > nLastPos ? true : false);//nFindIndex가 미래 영역임을 의미
                return i;
            }
        }
    }
    rOutDateTimeXScaleItem = null;
    return -1;
}

CDateTimeXScaleMng.prototype.GetDateTimeTByIndex = function (nIndex) {
    
    var rXScaleMergeIndex = this.m_XScaleMergeArray[nIndex];
    if (rXScaleMergeIndex !== undefined)
        return rXScaleMergeIndex.m_tStart;

    return -1;
}

CDateTimeXScaleMng.prototype.GetDateTimeByIndex = function (nIndex) {
    
    var tDateTime = this.GetDateTimeTByIndex(nIndex);
    if (tDateTime < 0)
        return null;
        
    var date = new Date();
    date.setTime(tDateTime * 1000);
    return date;
}

CDateTimeXScaleMng.prototype.ExtractMinMaxValue = function (strRQ, strPacketName, MinMaxInfo, bFullScan) {

    var rRQSet = this.m_mapRQSet[strRQ];
    if (rRQSet == undefined) {

        MinMaxInfo.m_Max = null;
        MinMaxInfo.m_Min = null;
        MinMaxInfo.m_nStartIndex = this.m_nViewStartIndex;
        MinMaxInfo.m_nEndIndex = this.m_nViewEndIndex;

        return false;
    }

    var i;
    var rSelectPacketData = null;
    var rDateTimePacketData = null;
    var length = rRQSet.m_PacketDataArray.length;
    for (i = 0; i < length; i++) {
        var rPacketData = rRQSet.m_PacketDataArray[i];
        if (rPacketData.m_strPacketName == strPacketName) {
            //패킷이 숫자타입이 아닌 경우
            if (rPacketData.m_nPacketType != NUMERIC_TYPE) {

                MinMaxInfo.m_Max = null;
                MinMaxInfo.m_Min = null;
                MinMaxInfo.m_nStartIndex = this.m_nViewStartIndex;
                MinMaxInfo.m_nEndIndex = this.m_nViewEndIndex;

                return false;
            }

            rSelectPacketData = rPacketData;
        }
        else if (rPacketData.m_strPacketName == this.m_strXScalePacketName) {
            rDateTimePacketData = rPacketData;
        }
    }

    //해당 rq에 원하는 패킷명이 없는 경우
    if (rSelectPacketData == null || rDateTimePacketData == null) {

        MinMaxInfo.m_Max = null;
        MinMaxInfo.m_Min = null;
        MinMaxInfo.m_nStartIndex = this.m_nViewStartIndex;
        MinMaxInfo.m_nEndIndex = this.m_nViewEndIndex;

        return false;
    }

    //같은 범위를 이미 조사한 경우 저장해놓은 값으로 셋팅하고 리턴
    if (rSelectPacketData.m_nViewStartIndex == this.m_nViewStartIndex &&
        rSelectPacketData.m_nViewEndIndex == this.m_nViewEndIndex) {
        MinMaxInfo.m_Max = rSelectPacketData.m_ViewMaxValue;
        MinMaxInfo.m_Min = rSelectPacketData.m_ViewMinValue;
        MinMaxInfo.m_nStartIndex = rSelectPacketData.m_nViewStartIndex;
        MinMaxInfo.m_nEndIndex = rSelectPacketData.m_nViewEndIndex;

        return true;
    }

    var fMax, fMin;
    var nMinMaxCountIndex = 0;
    var nMinMaxItemStartIndex = null, nMinMaxItemEndIndex = null;
    var nViewIndex = this.m_nViewStartIndex;

    if (bFullScan && !rSelectPacketData.ExtractMinMaxValue(this, rDateTimePacketData, this.m_nViewStartIndex, this.m_nViewEndIndex)) {
        MinMaxInfo.m_Max = null;
        MinMaxInfo.m_Min = null;
        MinMaxInfo.m_nStartIndex = this.m_nViewStartIndex;
        MinMaxInfo.m_nEndIndex = this.m_nViewEndIndex;
        return false;
    }

    MinMaxInfo.m_Max = rSelectPacketData.m_MinMaxMng.m_ViewMaxValue;
    MinMaxInfo.m_Min = rSelectPacketData.m_MinMaxMng.m_ViewMinValue;
    MinMaxInfo.m_nStartIndex = this.m_nViewStartIndex;
    MinMaxInfo.m_nEndIndex = this.m_nViewEndIndex;

    return true;
}
CDateTimeXScaleMng.prototype.SetRQPacketsItem = function (strRQ, rDateTimeData, RQPacketsItem) {
    
    var tStartTime = rDateTimeData.GetDateTimeT();
    var tEndTime = CalcDateTimeT(tStartTime, RQPacketsItem.m_nCycle, RQPacketsItem.m_nInterval);
    if (this.m_tTimeArray[tStartTime] === undefined)
        this.m_tTimeArray[tStartTime] = {};

    RQPacketsItem.m_tStartTime = tStartTime;
    RQPacketsItem.m_tEndTime = tEndTime;
    this.m_tTimeArray[tStartTime][strRQ] = RQPacketsItem;
    rDateTimeData.m_rRQPacketsItem = RQPacketsItem;
}

CDateTimeXScaleMng.prototype.Arrange = function () {

    var i, j, nDataIndex;
    this.m_nTotalMergeCnt = null;
    
    var nStartPos = 0;
    var nNextStartPos = 0;
    var nLength = this.m_XScaleItemArray.length;

    var nCnt = null;
    var nXIndex = null;
    var rSelectXScaleItem = null;
    var nXScaleItemStartPos = null;
    var nXScaleItemPos = null;
    var nXScaleItemCnt = null;
    ///////////////////
    //Add MergeArray
    this.m_XScaleMergeArray.length = 0;

    for (i = 0; i < nLength; i++ ) {

        var rXScaleItem = this.m_XScaleItemArray[i];

        nXScaleItemPos = nStartPos;
        nCnt = rXScaleItem.SetStartPos(nStartPos);
        nStartPos += nCnt;

        for (; nXScaleItemPos < nStartPos; nXScaleItemPos++) {

            var tDateTime = rXScaleItem.GetDateTimeTByIndex(nXScaleItemPos);

            var XScaleMergeIndex = new CXScaleMergeIndex();
            XScaleMergeIndex.m_tStart = tDateTime;
            XScaleMergeIndex.m_nIndex = nXScaleItemPos;
            this.m_XScaleMergeArray[this.m_XScaleMergeArray.length] = XScaleMergeIndex;
        }
    }
    this.m_nTotalMergeCnt = nStartPos;
    ///////////////////

    var nMergeArrayLength = this.m_XScaleMergeArray.length;
    
    var nRQLength = Object.keys(this.m_mapRQSet).length;
    if (nRQLength === 1) {

        for (var strRQ in this.m_mapRQSet) {

            var rRQSet = this.m_mapRQSet[strRQ];
            var nRQCycle = rRQSet.GetCycle();
            var nRQInterval = rRQSet.GetInterval();

            var rXScalePacketData = rRQSet.GetPacketData(this.m_strXScalePacketName);
            var nPacketDataSize = rXScalePacketData.GetDataArraySize();

            i = 0;
            nStartPos = 0;
            nXScaleItemPos = 0;
            
            for (nDataIndex = 0; nDataIndex < nPacketDataSize; nDataIndex++) {

                var rDateTimeData = rXScalePacketData.GetData(nDataIndex);
                var tStartTime = rDateTimeData.GetDateTimeT();

                for (; nXScaleItemPos < nMergeArrayLength; nXScaleItemPos++) {

                    var rXScaleMergeIndex = this.m_XScaleMergeArray[nXScaleItemPos];
                    if (tStartTime <= rXScaleMergeIndex.m_tStart) {

                        rXScaleMergeIndex.m_mapRQPacketsItem[strRQ] = rDateTimeData.m_rRQPacketsItem;
                        rDateTimeData.m_rRQPacketsItem.m_rXScaleMergeIndex = rXScaleMergeIndex;
                        nXScaleItemPos++;
                        break;
                    }
                }
            }
        }
    }
    else if (nRQLength > 1) {//복수 rq인 경우만 동작

        for (var strRQ in this.m_mapRQSet) {

            var rRQSet = this.m_mapRQSet[strRQ];
            var nRQCycle = rRQSet.GetCycle();
            var nRQInterval = rRQSet.GetInterval();

            var rXScalePacketData = rRQSet.GetPacketData(this.m_strXScalePacketName);
            var nPacketDataSize = rXScalePacketData.GetDataArraySize();

            i = 0;
            nStartPos = 0;
            nXScaleItemPos = 0;

            var strRQTime = strRQ + "_TIME";
            var nPrevXScaleItemIndex = null;
            var tPrevStartDateTime = null;
            var tPrevEndDateTime = null;
            var rPrevRQPackets = null;

            for (nDataIndex = 0; nDataIndex < nPacketDataSize; nDataIndex++) {

                var rDateTimeData = rXScalePacketData.GetData(nDataIndex);
                var tStartTime = rDateTimeData.GetDateTimeT();

                for (; nXScaleItemPos < nMergeArrayLength; nXScaleItemPos++) {

                    var rXScaleMergeIndex = this.m_XScaleMergeArray[nXScaleItemPos];

                    rXScaleMergeIndex.m_mapRQPacketDataIndex[strRQ] = nDataIndex;//매우 중요!!(복수rq RealArrange에서 사용)

                    if (tStartTime <= rXScaleMergeIndex.m_tStart) {

                        rXScaleMergeIndex.m_mapRQPacketsItem[strRQ] = rDateTimeData.m_rRQPacketsItem;
                        rDateTimeData.m_rRQPacketsItem.m_rXScaleMergeIndex = rXScaleMergeIndex;

                        if (rPrevRQPackets !== null) {
                            rPrevRQPackets.m_nRelativeEndIndex = nXScaleItemPos - nPrevXScaleItemIndex;
                            rPrevRQPackets = null;
                        }

                        tPrevEndDateTime = CalcNextTime(tStartTime, nRQCycle, nRQInterval);
                        tPrevStartDateTime = tStartTime;

                        rPrevRQPackets = rDateTimeData.m_rRQPacketsItem;
                        nPrevXScaleItemIndex = nXScaleItemPos;

                        nXScaleItemPos++;

                        //작은주기 봉이 모여 구성된 큰주기의 봉 내부 좌측부분에서 추세선이 한번 멈추는 현상 수정
                        if (tStartTime < rXScaleMergeIndex.m_tStart) {

                            if (this.m_tTimeArray[rXScaleMergeIndex.m_tStart] === undefined)
                                this.m_tTimeArray[rXScaleMergeIndex.m_tStart] = {};
                            this.m_tTimeArray[rXScaleMergeIndex.m_tStart][strRQTime] = tPrevStartDateTime;
                        }
                        break;
                    }
                    else {

                        if (tPrevEndDateTime !== null && tPrevEndDateTime <= rXScaleMergeIndex.m_tStart) {

                            tPrevEndDateTime = null;
                            tPrevStartDateTime = null;
                            if (rPrevRQPackets !== null) {
                                rPrevRQPackets.m_nRelativeEndIndex = nXScaleItemPos - nPrevXScaleItemIndex;
                                rPrevRQPackets = null;
                            }
                        }
                        else if (tPrevStartDateTime !== null && tPrevEndDateTime !== null) {
                            if (this.m_tTimeArray[rXScaleMergeIndex.m_tStart] === undefined)
                                this.m_tTimeArray[rXScaleMergeIndex.m_tStart] = {};
                            this.m_tTimeArray[rXScaleMergeIndex.m_tStart][strRQTime] = tPrevStartDateTime;
                        }
                    }
                }
            }
            if (rPrevRQPackets !== null) {

                for (; nXScaleItemPos < nMergeArrayLength; nXScaleItemPos++) {

                    var rXScaleMergeIndex = this.m_XScaleMergeArray[nXScaleItemPos];

                    rXScaleMergeIndex.m_mapRQPacketDataIndex[strRQ] = nDataIndex;//매우 중요!!(복수rq RealArrange에서 사용)

                    if (tPrevEndDateTime !== null && tPrevEndDateTime <= rXScaleMergeIndex.m_tStart) {

                        tPrevEndDateTime = null;
                        tPrevStartDateTime = null;
                        rPrevRQPackets.m_nRelativeEndIndex = nXScaleItemPos - nPrevXScaleItemIndex;
                        rPrevRQPackets = null;
                        break;
                    }
                    else if (tPrevStartDateTime !== null && tPrevEndDateTime !== null) {
                        if (this.m_tTimeArray[rXScaleMergeIndex.m_tStart] === undefined)
                            this.m_tTimeArray[rXScaleMergeIndex.m_tStart] = {};
                        this.m_tTimeArray[rXScaleMergeIndex.m_tStart][strRQTime] = tPrevStartDateTime;
                    }
                }

                if (nXScaleItemPos >= nMergeArrayLength)
                    rPrevRQPackets.m_nRelativeEndIndex = nXScaleItemPos - nPrevXScaleItemIndex;
            }
        }
    }
    return this.m_nTotalMergeCnt;//전체개수
}

CDateTimeXScaleMng.prototype.RealArrange = function (rDateTimePacketData) {

    var i, j;

    //복수 rq인 경우만 동작
    var nRQLength = Object.keys(this.m_mapRQSet).length;
    if (nRQLength > 1) {

        var rRQSet = rDateTimePacketData.GetRQSet();
        var strCurRQ = rRQSet.m_strRQ;
        var nRQCycle = rRQSet.GetCycle();
        var nRQInterval = rRQSet.GetInterval();

        var nPrevXScaleItemIndex = null;
        var tPrevStartDateTime = null;
        var tPrevEndDateTime = null;
        var rPrevRQPackets = null;

        var nXScaleArrayLength = this.m_XScaleItemArray.length;

        var nPacketDataSize = rDateTimePacketData.GetDataArraySize();
        if (nPacketDataSize <= 0)
            return;
        
        var tStartTime = null;
        var tEndTime = null;

        var nLastMergeIndex = null;
        var tTime = null;
        var rXMergeIndex = null;
        var rRQPacketsItemArray = [];
        var bFindXScaleItem = false;
        var nStartIndex = null;
        var nEndIndex = null;
        var rXScaleItem = null;
        var rDateTimeXScaleItem = null;
        var nStartXScaleItemIndex = null;

        var nMergeArrayLength = this.m_XScaleMergeArray.length;
        if (nMergeArrayLength > 0) {

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //RealMerge단계에서 실시간추가되는 시간을 기존시계열에 머지한 후 m_XScaleItemArray에 반영한 후 현재 위치까지 오게된다
            //m_XScaleItemArray 중에 어디부터 변경되었는지 검색하는 처음단계
            //XScaleItemArray와 XScaleMergeArray를 비교하여 같은 index의 시간이 변경되었으면 arrange 범위에 포함시킨다
            //최근시간부터 찾아나간다
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for (i = nXScaleArrayLength - 1; i >= 0; i--) {

                rXScaleItem = this.m_XScaleItemArray[i];
                nStartIndex = rXScaleItem.GetStartPos();

                //XScaleItem의 시작부분의 시간이 다른 경우 다음index는 당연히 변경되었을 것이므로 바로 다음XScaleItem으로 넘어간다(처리시간속도 개선을 위해)
                //(시작부분이 다르면 뒤는 당연히 다를 것이므로)
                if (this.m_XScaleMergeArray.length <= nStartIndex) {

                    rDateTimeXScaleItem = rXScaleItem;
                    nStartXScaleItemIndex = i;
                    nLastMergeIndex = nStartIndex;
                    continue;
                }

                rXMergeIndex = this.m_XScaleMergeArray[nStartIndex];
                tTime = rXScaleItem.GetDateTimeTByIndex(nStartIndex);

                //시작부분의 시간이 변하지 않은 XScaleItem을 찾았으므로 XScaleItem시간범위 안에 index중에 시간변경이 일어난 곳을 다음루틴에서 찾는다
                if (rXMergeIndex.m_tStart === tTime)
                    break;

                rDateTimeXScaleItem = rXScaleItem;
                nStartXScaleItemIndex = i;
                nLastMergeIndex = nStartIndex;
            }
            
            if(i >= 0){//시작부분의 시간이 변하지 않은 rXScaleItem을 찾은 경우
            
                nEndIndex = nStartIndex + rXScaleItem.GetIntervalCnt() - 1;

                //위에서 찾아낸 XScaleItem의 시간범위를 뒤에서 부터 검색하며 변하지 않는 정확한 시간위치를 찾는다
                for (j = nEndIndex; j >= nStartIndex; j--) {

                    if (this.m_XScaleMergeArray.length <= j) {
                        nLastMergeIndex = j;
                        continue;
                    }

                    rXMergeIndex = this.m_XScaleMergeArray[j];
                    tTime = rXScaleItem.GetDateTimeTByIndex(j);
                    if (rXMergeIndex.m_tStart === tTime) {//시간이 변하지 않은 index를 찾는다

                        bFindXScaleItem = true;
                        break;
                    }
                    
                    nLastMergeIndex = j;
                }

                if (bFindXScaleItem === true) {

                    if (j < nEndIndex) {

                        rDateTimeXScaleItem = rXScaleItem;
                        nStartXScaleItemIndex = i;
                    }
                }
            }
        }
        //XScaleMergeArray 길이가 0인 경우
        else {

            rDateTimeXScaleItem = this.m_XScaleItemArray[nXScaleArrayLength - 1];
            nStartXScaleItemIndex = nXScaleArrayLength - 1;
            nLastMergeIndex = 0;
        }

        //===============================================================================================================================================================//
        //rDateTimeXScaleItem이 null인 경우는 XScaleItemArray와 XScaleMergeArray 둘 다 실시간 Append 하기 전과 변화가 없는 경우 이므로 XScaleMergeArray Add할 필요 없다!!
        if (rDateTimeXScaleItem !== null) {

            //XScaleMergeArray 추가
            rXScaleItem = rDateTimeXScaleItem;
            var nCnt = rXScaleItem.GetStartPos() + rXScaleItem.GetIntervalCnt();
            var nIndex = nLastMergeIndex;
            var rXScaleMergeIndex = null;

            i = nStartXScaleItemIndex;

            do {

                for (; nIndex < nCnt; nIndex++) {

                    var tDateTime = rXScaleItem.GetDateTimeTByIndex(nIndex);

                    if (nIndex < this.m_XScaleMergeArray.length) {

                        rXScaleMergeIndex = this.m_XScaleMergeArray[nIndex];
                        rXScaleMergeIndex.m_tStart = tDateTime;
                        rXScaleMergeIndex.m_nIndex = nIndex;
                        rXScaleMergeIndex.m_mapRQPacketsItem = {};
                        rXScaleMergeIndex.m_mapRQPacketDataIndex = {};
                    }
                    else {

                        rXScaleMergeIndex = new CXScaleMergeIndex();
                        rXScaleMergeIndex.m_tStart = tDateTime;
                        rXScaleMergeIndex.m_nIndex = nIndex;
                        this.m_XScaleMergeArray[this.m_XScaleMergeArray.length] = rXScaleMergeIndex;
                    }
                }

                i++;
                if (i >= nXScaleArrayLength)
                    break;

                rXScaleItem = this.m_XScaleItemArray[i];
                nCnt = rXScaleItem.GetStartPos() + rXScaleItem.GetIntervalCnt();

            } while (1);
        }

        ///////////////////////////////////////////////////////////////////////////////
        //MergeArray와 각 rq의 DateTime PacketData 매칭 Arrange 작업
        var strRQ = null;
        nMergeArrayLength = this.m_XScaleMergeArray.length;

        var nDataStartIndex, nDataIndex;
        var rDateTimeData, strRQTime, nXScaleItemPos;

        //XScaleItemArray와 XScaleMergeArray 시간변화가 시작된 Index 바로 전 Index 값 저장변수
        var nFindStartMergeIndex = nLastMergeIndex > 0 ? nLastMergeIndex - 1 : null;

        for (strRQ in this.m_mapRQSet) {

            rRQSet = this.m_mapRQSet[strRQ];

            var rXScalePacketData = rRQSet.GetPacketData(this.m_strXScalePacketName);
            nPacketDataSize = rXScalePacketData.GetDataArraySize();
            if (nPacketDataSize <= 0)
                continue;

            nRQCycle = rRQSet.GetCycle();
            nRQInterval = rRQSet.GetInterval();

            strRQTime = strRQ + "_TIME";

            nPrevXScaleItemIndex = null;
            tPrevStartDateTime = null;
            tPrevEndDateTime = null;
            rPrevRQPackets = null;

            rDateTimeData = null;

            //XScaleItemArray와 XScaleMergeArray 둘 다 아무변화가 없었음을 의미
            if (rDateTimeXScaleItem === null) {

                nDataStartIndex = nPacketDataSize - 1;
                rDateTimeData = rXScalePacketData.GetData(nDataStartIndex);

                //XScaleItemArray와 XScaleMergeArray 둘 다 아무변화가 없는 상태에서 패킷 마지막 데이터의 m_rRQPacketsItem.m_rXScaleMergeIndex 가 null이 아닌 경우는 추가된 데이터가 없는 rq이므로 스킵
                if (rDateTimeData.m_rRQPacketsItem.m_rXScaleMergeIndex !== null)
                    continue;

                //rDateTimeData.m_rRQPacketsItem.m_rXScaleMergeIndex === null 인 경우는 현재 rDateTimeData가 새로 추가된 데이터임을 의미하므로
                //이전 rDateTimeData를 얻어 해당 시간범위 end위치의 index를 계산해낸다 => 다음 로직에서 end위치가 데이터 부족으로 강제계산 된것인지 시간범위를 벗어나서 end 위치가 정상 계산된 것인지 판단
                var rPrevRQPacketsItem = null;
                if (rDateTimeData.m_rRQPacketsItem.m_rPrevRQPacketsItem !== null) {

                    rPrevRQPacketsItem = rDateTimeData.m_rRQPacketsItem.m_rPrevRQPacketsItem;
                    nFindStartMergeIndex = rPrevRQPacketsItem.m_rXScaleMergeIndex.m_nIndex + rPrevRQPacketsItem.m_nRelativeEndIndex ;
                }
            }

            if (nFindStartMergeIndex !== null) {

                nXScaleItemPos = nFindStartMergeIndex;
                rXScaleMergeIndex = this.m_XScaleMergeArray[nXScaleItemPos];
                nDataStartIndex = rXScaleMergeIndex.m_mapRQPacketDataIndex[strRQ];

                //PacketData 매칭을 모두 하고 XScaleMergeArray 아이템이 남았다는 의미
                if (nDataStartIndex === undefined) {

                    nDataStartIndex = nPacketDataSize - 1;
                    rDateTimeData = rXScalePacketData.GetData(nDataStartIndex);

                    //실시간으로 새로 추가된 rDateTimeData인 경우
                    if (rDateTimeData.m_rRQPacketsItem.m_rXScaleMergeIndex === null && nDataStartIndex > 0) {

                        nDataStartIndex--;
                        rDateTimeData = rXScalePacketData.GetData(nDataStartIndex);
                    }
                }
                else if (nDataStartIndex > 0) {

                    nDataStartIndex--;
                    rDateTimeData = rXScalePacketData.GetData(nDataStartIndex);
                }

                if (rDateTimeData !== null) {

                    tPrevStartDateTime = rDateTimeData.GetDateTimeT();
                    tPrevEndDateTime = CalcNextTime(tPrevStartDateTime, nRQCycle, nRQInterval);

                    //직전위치의 MergeIndex를 얻어내 MergeIndex의 시간이 rDateTimeData의 시간범위 end 위치 시간보다 작은지 체크
                    //MergeIndex의 시간이 작으면 아직 rDateTimeData의 시간범위를 벗어나지 못한 것이므로 시간범위를 벗어나는지 검사하기 위해 rPrevRQPackets에 저장
                    rXScaleMergeIndex = this.m_XScaleMergeArray[nXScaleItemPos - 1];
                    if (tPrevEndDateTime > rXScaleMergeIndex.m_tStart) {

                        rPrevRQPackets = rDateTimeData.m_rRQPacketsItem;
                        nPrevXScaleItemIndex = rDateTimeData.m_rRQPacketsItem.m_rXScaleMergeIndex.m_nIndex;
                    }
                    else {

                        tPrevStartDateTime = null;
                        tPrevEndDateTime = null;
                        nDataStartIndex++;
                    }
                }
            }
            else {

                nDataStartIndex = 0;
                nXScaleItemPos = 0;
            }

            if (rPrevRQPackets !== null) {

                nDataStartIndex++;

                for (; nXScaleItemPos < nMergeArrayLength; nXScaleItemPos++) {

                    rXScaleMergeIndex = this.m_XScaleMergeArray[nXScaleItemPos];

                    if (nDataStartIndex < nPacketDataSize)
                        rXScaleMergeIndex.m_mapRQPacketDataIndex[strRQ] = nDataStartIndex;//매우 중요!!(복수rq RealArrange에서 사용)

                    if (tPrevEndDateTime !== null && tPrevEndDateTime <= rXScaleMergeIndex.m_tStart) {

                        tPrevEndDateTime = null;
                        tPrevStartDateTime = null;
                        rPrevRQPackets.m_nRelativeEndIndex = nXScaleItemPos - nPrevXScaleItemIndex;
                        rPrevRQPackets = null;
                        break;
                    }
                    else if (tPrevStartDateTime !== null && tPrevEndDateTime !== null) {
                        if (this.m_tTimeArray[rXScaleMergeIndex.m_tStart] === undefined)
                            this.m_tTimeArray[rXScaleMergeIndex.m_tStart] = {};
                        this.m_tTimeArray[rXScaleMergeIndex.m_tStart][strRQTime] = tPrevStartDateTime;
                    }
                }

                if (rPrevRQPackets !== null)
                    rPrevRQPackets.m_nRelativeEndIndex = nXScaleItemPos - nPrevXScaleItemIndex;
            }

            for (nDataIndex = nDataStartIndex; nDataIndex < nPacketDataSize; nDataIndex++) {

                rDateTimeData = rXScalePacketData.GetData(nDataIndex);
                tStartTime = rDateTimeData.GetDateTimeT();

                for (; nXScaleItemPos < nMergeArrayLength; nXScaleItemPos++) {

                    rXScaleMergeIndex = this.m_XScaleMergeArray[nXScaleItemPos];

                    rXScaleMergeIndex.m_mapRQPacketDataIndex[strRQ] = nDataIndex;//매우 중요!!(복수rq RealArrange에서 사용)

                    if (tStartTime <= rXScaleMergeIndex.m_tStart) {

                        rXScaleMergeIndex.m_mapRQPacketsItem[strRQ] = rDateTimeData.m_rRQPacketsItem;
                        rDateTimeData.m_rRQPacketsItem.m_rXScaleMergeIndex = rXScaleMergeIndex;

                        if (rPrevRQPackets !== null) {

                            var nDelta = nXScaleItemPos - nPrevXScaleItemIndex;
                            if (nDelta > 0) {//nDelta === 0 인 경우 가능 (마지막 위치인 경우)
                                rPrevRQPackets.m_nRelativeEndIndex = nXScaleItemPos - nPrevXScaleItemIndex;
                                rPrevRQPackets = null;
                            }
                        }

                        tPrevEndDateTime = CalcNextTime(tStartTime, nRQCycle, nRQInterval);
                        tPrevStartDateTime = tStartTime;

                        rPrevRQPackets = rDateTimeData.m_rRQPacketsItem;
                        nPrevXScaleItemIndex = nXScaleItemPos;

                        nXScaleItemPos++;

                        //작은주기 봉이 모여 구성된 큰주기의 봉 내부 좌측부분에서 추세선이 한번 멈추는 현상 수정
                        if (tStartTime < rXScaleMergeIndex.m_tStart) {

                            if (this.m_tTimeArray[rXScaleMergeIndex.m_tStart] === undefined)
                                this.m_tTimeArray[rXScaleMergeIndex.m_tStart] = {};
                            this.m_tTimeArray[rXScaleMergeIndex.m_tStart][strRQTime] = tPrevStartDateTime;
                        }
                        break;
                    }
                    else {

                        if (tPrevEndDateTime !== null && tPrevEndDateTime <= rXScaleMergeIndex.m_tStart) {

                            tPrevEndDateTime = null;
                            tPrevStartDateTime = null;
                            if (rPrevRQPackets !== null) {
                                rPrevRQPackets.m_nRelativeEndIndex = nXScaleItemPos - nPrevXScaleItemIndex;
                                rPrevRQPackets = null;
                            }
                        }
                        else if (tPrevStartDateTime !== null && tPrevEndDateTime !== null) {
                            if (this.m_tTimeArray[rXScaleMergeIndex.m_tStart] === undefined)
                                this.m_tTimeArray[rXScaleMergeIndex.m_tStart] = {};
                            this.m_tTimeArray[rXScaleMergeIndex.m_tStart][strRQTime] = tPrevStartDateTime;
                        }
                    }
                }
            }
            if (rPrevRQPackets !== null) {

                for (; nXScaleItemPos < nMergeArrayLength; nXScaleItemPos++) {

                    rXScaleMergeIndex = this.m_XScaleMergeArray[nXScaleItemPos];

                    rXScaleMergeIndex.m_mapRQPacketDataIndex[strRQ] = nDataIndex;//매우 중요!!(복수rq RealArrange에서 사용)

                    if (tPrevEndDateTime !== null && tPrevEndDateTime <= rXScaleMergeIndex.m_tStart) {

                        tPrevEndDateTime = null;
                        tPrevStartDateTime = null;
                        rPrevRQPackets.m_nRelativeEndIndex = nXScaleItemPos - nPrevXScaleItemIndex;
                        rPrevRQPackets = null;
                        break;
                    }
                    else if (tPrevStartDateTime !== null && tPrevEndDateTime !== null) {
                        if (this.m_tTimeArray[rXScaleMergeIndex.m_tStart] === undefined)
                            this.m_tTimeArray[rXScaleMergeIndex.m_tStart] = {};
                        this.m_tTimeArray[rXScaleMergeIndex.m_tStart][strRQTime] = tPrevStartDateTime;
                    }
                }

                if (rPrevRQPackets !== null)
                    rPrevRQPackets.m_nRelativeEndIndex = nXScaleItemPos - nPrevXScaleItemIndex;
            }
        }
    }
}

CDateTimeXScaleMng.prototype.CalcTotalMergeDataCnt = function () {
    var i;
    var nTotalMergeCnt = 0;
    for (i = 0; i < this.m_XScaleItemArray.length; i++) {
        var rDateTimeItem = this.m_XScaleItemArray[i];
        var nCnt = rDateTimeItem.GetIntervalCnt();
        nTotalMergeCnt += nCnt;
    }
    this.m_nTotalMergeCnt = nTotalMergeCnt;
    return nTotalMergeCnt;//전체개수
}

CDateTimeXScaleMng.prototype.Log = function () {
    var sLine;
    for (var i = 0; i < this.m_XScaleItemArray.length; i++) {
        var rXScaleItem = this.m_XScaleItemArray[i];
        sLine = "Start:" + rXScaleItem.GetStartString() + " End:" + rXScaleItem.GetEndString() + " 주기:" + rXScaleItem.GetCycle() + " 간격:" + rXScaleItem.GetInterval();
        //console.log( sLine );
    }
}

CDateTimeXScaleMng.prototype.IsSmallerCycleThen = function (nCycle, nThenCycle) {
    if (nThenCycle !== 0 && (nCycle === 1 && nThenCycle < 5 ||
        nCycle === 2 && (2 < nThenCycle && nThenCycle < 5) ||
        nCycle === 3 && nThenCycle === 4 ||
        nCycle === 5 && nThenCycle < 5 ||
        nCycle === 6 && nThenCycle < 6))
        return true;
    else
        return false;
}
CDateTimeXScaleMng.prototype.IsLargerCycleThen = function (nCycle, nThenCycle) {
    if (nThenCycle !== 0 && (nCycle === 1 && nThenCycle >= 5 ||
        nCycle === 2 && (2 > nThenCycle || nThenCycle >= 5) ||
        nCycle === 3 && nThenCycle !== 4 ||
        nCycle === 4 ||
        nCycle === 5 && nThenCycle > 5 ||
        nCycle === 6 && nThenCycle > 6))
        return true;
    else
        return false;
}

//처리1 >>
CDateTimeXScaleMng.prototype.StartSTXStartAndXStartSTEndAndEndSTXEnd = function (nCycle, nInterval, tStart, tEnd, rXScaleItemArrayIndex, rDateTimeArrayIndex) {

    var XScaleItem = this.m_XScaleItemArray[rXScaleItemArrayIndex.m_nIndex];
    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();

    if (nCycle === nXScaleItemCycle)//주기 같은 경우
    {
        var pos1 = rXScaleItemArrayIndex.m_nIndex - 1;
        if (pos1 >= 0) {
            var PrevDateTime = this.m_XScaleItemArray[pos1];

            var nPrevCycle = PrevDateTime.GetCycle();
            var nPrevInterval = PrevDateTime.GetInterval();
            var tPrevStart = PrevDateTime.GetStart();
            var tPrevEnd = PrevDateTime.GetEnd();

            var pos2 = pos1 - 1;

            if (nPrevCycle === nCycle) {

                if (tStart <= tPrevEnd) {

                    this.RemoveXScaleArray(pos1, 1);
                    rXScaleItemArrayIndex.m_nIndex--;

                    XScaleItem.SetStart(tPrevStart);
                }
                else {
                    XScaleItem.SetStart(tStart);
                }

                XScaleItem.SetInterval(this.m_MinIntervalArray[nCycle - 1]);
                rXScaleItemArrayIndex.m_nIndex--;

                return true;
            }
            else {

                if (this.IsSmallerCycleThen(nCycle, nPrevCycle)) {

                    var tPrevStart = CalcPrevStart(tStart, tPrevXScaleEnd, nPrevCycle, this.m_MinIntervalArray[nPrevCycle - 1].m_nInterval);
                    if (tPrevXScaleStart < tPrevStart) {

                        this.SetXScaleItem(PrevDateTime, nPrevCycle, nCycle, tPrevXScaleStart, tPrevStart, tPrevXScaleStart, tPrevStart);
                        this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);
                    }
                    else {

                        this.RemoveXScaleArray(pos1, 1);
                        rXScaleItemArrayIndex.m_nIndex--;

                        this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);
                    }

                    rXScaleItemArrayIndex.m_nIndex--;

                    return true;
                }
                else { //this.IsLargerCycleThen(nCycle, nPrevCycle))

                    var tNextStart = CalcNextStart(tStart, tPrevXScaleItemEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                    if (tNextStart < tXScaleItemStart) {

                        this.SetXScaleItem(PrevDateTime, nCycle, nPrevCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tNextStart);
                        this.SetXScaleItem(XScaleItem, nCycle, nCycle, tNextStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                    }

                    rXScaleItemArrayIndex.m_nIndex--;

                    return true;
                }
            }
        }
        else {

            this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
            
            rXScaleItemArrayIndex.m_nIndex--;

            return true;
        }
    }
    else {
        
        if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle))
        {
            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

            var pos1 = rXScaleItemArrayIndex.m_nIndex - 1;
            if (pos1 >= 0) {

                var PrevXScaleItem = this.m_XScaleItemArray[pos1];
                var nPrevCycle = PrevXScaleItem.GetCycle();
                var nPrevInterval = PrevXScaleItem.GetInterval();
                var tPrevXScaleStart = PrevXScaleItem.GetStart();
                var tPrevXScaleEnd = PrevXScaleItem.GetEnd();

                if (tPrevXScaleEnd < tStart) {
                    //현재 조건으로 들어왔다는 의미는 nCycle 주기가 nXScaleItemCycle주기보다 무조건 작다고 고려해도 됨 (예: nCycle(분), nXScaleItemCycle(일))
                    var tNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                    if (tNextStart < tXScaleItemEnd) {

                        var NewItem = new CDateTimeXScaleItem(this);
                        this.SetXScaleItem(NewItem, nXScaleItemCycle, nCycle, tStart, tEnd, tStart, tNextStart);
                        this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                        this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tNextStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);

                        rXScaleItemArrayIndex.m_nIndex--;
                    }
                    else {

                        this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tStart, tXScaleItemEnd);
                    }

                    return true;
                }
                else if (tPrevXScaleStart < tStart && tStart < tPrevXScaleEnd) {

                    if (nCycle === nPrevCycle) {

                        this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

                        var tNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                        if (tNextStart < tXScaleItemEnd) {

                            SetXScaleItem(PrevXScaleItem, nXScaleItemCycle, nPrevCycle, tPrevXScaleStart, tEnd, tPrevXScaleStart, tNextStart);
                            SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tNextStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);

                            rXScaleItemArrayIndex.m_nIndex--;
                        }
                        else {

                            this.SetXScaleItem(PrevXScaleItem, nXScaleItemCycle, nPrevCycle, tPrevXScaleStart, tEnd, tPrevXScaleStart, tXScaleItemEnd);

                            this.RemoveXScaleArray(rXScaleItemArrayIndex.m_nIndex, 1);
                            rXScaleItemArrayIndex.m_nIndex--;
                        }

                        return true;
                    }
                    else {
                        //작은 주기(nCycle)를 큰 주기(nPrevCycle)에 삽입
                        if (this.IsSmallerCycleThen(nCycle, nPrevCycle)) {

                            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

                            var tNextStart = CalcPrevStart(tStart, tPrevXScaleEnd, nPrevCycle, this.m_MinIntervalArray[nPrevCycle - 1].m_nInterval);
                            if (tPrevXScaleStart < tNextStart) {

                                this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tNextStart, tPrevXScaleStart, tNextStart);

                                var tNextNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                                if (tNextNextStart < tXScaleItemEnd) {

                                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tNextNextStart, tXScaleItemEnd, tNextNextStart, tXScaleItemEnd);

                                    var NewItem = new CDateTimeXScaleItem(this);
                                    this.SetXScaleItemCompare2Cycle(NewItem, nPrevCycle, nCycle, nXScaleItemCycle, tStart, tEnd, tNextStart, tNextNextStart);
                                    
                                    this.InsertBefore(rXScaleItemArrayIndex, NewItem);
                                }
                                else {

                                    this.SetXScaleItemCompare2Cycle(XScaleItem, nPrevCycle, nCycle, nXScaleItemCycle, tStart, tEnd, tNextStart, tXScaleItemEnd);
                                }
                            }
                            else {

                                var tNextNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                                if (tNextNextStart < tXScaleItemEnd) {

                                    this.SetXScaleItemCompare2Cycle(PrevXScaleItem, nPrevCycle, nCycle, nXScaleItemCycle, tStart, tEnd, tPrevXScaleStart, tNextNextStart);
                                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tNextNextStart, tXScaleItemEnd, tNextNextStart, tXScaleItemEnd);
                                    
                                    rXScaleItemArrayIndex.m_nIndex--;
                                }
                                else {

                                    this.RemoveXScaleArray(pos1, 1);
                                    rXScaleItemArrayIndex.m_nIndex--;

                                    this.SetXScaleItemCompare2Cycle(XScaleItem, nPrevCycle, nCycle, nXScaleItemCycle, tStart, tEnd, tPrevXScaleStart, tXScaleItemEnd);
                                }
                            }

                            return true;
                        }
                        //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nPrevCycle:이미 등록된 주기)
                        else if (this.IsLargerCycleThen(nCycle, nPrevCycle)) {

                            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

                            var tNextStart = CalcNextStart(tStart, tPrevXScaleEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                            if (tNextStart < tXScaleItemStart) {

                                this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tNextStart);

                                var tNextNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                                if (tNextNextStart < tXScaleItemEnd) {

                                    var NewItem = new CDateTimeXScaleItem(this);
                                    this.SetXScaleItem(NewItem, nXScaleItemCycle, nCycle, tNextStart, tEnd, tNextStart, tNextNextStart);
                                    this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tNextNextStart, tXScaleItemEnd, tNextNextStart, tXScaleItemEnd);
                                }
                                else {

                                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tNextStart, tEnd, tNextStart, tXScaleItemEnd);
                                }
                            }
                            else {

                                this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tXScaleItemStart);

                                var tNextNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                                if (tNextNextStart < tXScaleItemEnd) {

                                    var NewItem = new CDateTimeXScaleItem(this);
                                    this.SetXScaleItem(NewItem, nXScaleItemCycle, nCycle, tXScaleItemStart, tEnd, tXScaleItemStart, tXScaleItemEnd);
                                    this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tNextNextStart, tXScaleItemEnd, tNextNextStart, tXScaleItemEnd);
                                }
                                else {

                                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tXScaleItemStart, tEnd, tXScaleItemStart, tXScaleItemEnd);
                                }

                                rXScaleItemArrayIndex.m_nIndex--;
                            }
                            return true;
                        }
                    }
                }
                else if (tPrevXScaleEnd === tStart) {

                    if (nCycle === nPrevCycle) {

                        this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

                        var tNextNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                        if (tNextNextStart < tXScaleItemEnd) {

                            this.SetXScaleItem(PrevXScaleItem, nXScaleItemCycle, nCycle, tPrevXScaleStart, tEnd, tPrevXScaleStart, tNextNextStart);
                            this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tNextNextStart, tXScaleItemEnd, tNextNextStart, tXScaleItemEnd);

                            rXScaleItemArrayIndex.m_nIndex--;
                        }
                        else {

                            this.SetXScaleItem(PrevXScaleItem, nXScaleItemCycle, nCycle, tPrevXScaleStart, tEnd, tPrevXScaleStart, tXScaleItemEnd);

                            this.RemoveXScaleArray(rXScaleItemArrayIndex.m_nIndex, 1);
                            rXScaleItemArrayIndex.m_nIndex--;
                        }

                        return true;
                    }
                    else {
                        //작은 주기(nCycle)를 큰 주기(nPrevCycle)에 삽입하는 경우 또는 큰주기(nCycle)를 작은 주기(nCycle)에 삽입하는 경우
                        this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

                        var tNextNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                        if (tNextNextStart < tXScaleItemEnd) {

                            var NewItem = new CDateTimeXScaleItem(this);
                            this.SetXScaleItem(NewItem, nXScaleItemCycle, nCycle, tStart, tEnd, tStart, tNextNextStart);
                            this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                            this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tNextNextStart, tXScaleItemEnd, tNextNextStart, tXScaleItemEnd);
                        }
                        else {

                            this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tStart, tXScaleItemEnd);
                        }
                        return true;
                    }
                }
                //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            }
            else {	//새로운 아이템 추가

                var tNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                if (tNextStart < tXScaleItemEnd) {

                    var NewItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewItem, nXScaleItemCycle, nCycle, tStart, tEnd, tStart, tNextStart);
                    this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tNextStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);

                    rXScaleItemArrayIndex.m_nIndex--;
                }
                else {

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tStart, tXScaleItemEnd);
                }

                return true;
            }
        }
        else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
            
            var pos1 = rXScaleItemArrayIndex.m_nIndex - 1;
            if (pos1 >= 0) {
                var PrevXScaleItem = this.m_XScaleItemArray[pos1];
                var nPrevCycle = PrevXScaleItem.GetCycle();
                var nPrevInterval = PrevXScaleItem.GetInterval();
                var tPrevXScaleStart = PrevXScaleItem.GetStart();
                var tPrevXScaleEnd = PrevXScaleItem.GetEnd();

                if (tPrevXScaleEnd < tStart) {

                    var tNextStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                    if (tStart < tNextStart) {

                        var NewItem = new CDateTimeXScaleItem(this);
                        this.SetXScaleItem(NewItem, nCycle, nCycle, tStart, tNextStart, tStart, tNextStart);
                        this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                        this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                        
                        rXScaleItemArrayIndex.m_nIndex--;
                    }
                    else {

                        this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tStart, tXScaleItemEnd);

                        rXScaleItemArrayIndex.m_nIndex--;
                    }
					
                    return true;
                }
                else if (tPrevXScaleStart < tStart && tStart < tPrevXScaleEnd) {

                    if (nCycle === nPrevCycle) {

                        var tNextStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                        if (tPrevXScaleStart < tNextStart) {

                            this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tNextStart, tPrevXScaleStart, tNextStart);
                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);

                            rXScaleItemArrayIndex.m_nIndex--;
                        }
                        else {

                            this.RemoveXScaleArray(pos1, 1);
                            rXScaleItemArrayIndex.m_nIndex -= 2;

                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                        }
                    	   
                        return true;
                    }
                    else {

                        //작은 주기(nCycle)를 큰 주기(nPrevCycle)에 삽입
                        if (this.IsSmallerCycleThen(nCycle, nPrevCycle))
                        {

                            var tNextStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                            if (tStart < tNextStart) {

                                var tPrevNextStart = CalcPrevStart(tStart, tPrevXScaleEnd, nPrevCycle, this.m_MinIntervalArray[nPrevCycle - 1].m_nInterval);
                                if (tPrevXScaleStart < tPrevNextStart) {

                                    this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tPrevNextStart, tPrevXScaleStart, tPrevNextStart);
                                    
                                    var NewItem = new CDateTimeXScaleItem(this);
                                    this.SetXScaleItem(NewItem, nPrevCycle, nCycle, tStart, tNextStart, tPrevNextStart, tNextStart);
                                    this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                                    
                                    rXScaleItemArrayIndex.m_nIndex--;
                                }
                                else {

                                    this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nCycle, tStart, tNextStart, tPrevXScaleStart, tNextStart);
                                    rXScaleItemArrayIndex.m_nIndex--;
                                }
                            }
                            else {

                                rXScaleItemArrayIndex.m_nIndex--;
                            }

                            return true;
                        }
                        //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nPrevCycle:이미 등록된 주기)
                        else if (this.IsLargerCycleThen(nCycle, nPrevCycle)) {

                            var tPrevStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                            if (tPrevXScaleEnd < tPrevStart) {

                                var tNextStart = CalcNextStart(tStart, tPrevXScaleEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                                if (tNextStart < tPrevStart) {

                                    var NewItem = new CDateTimeXScaleItem(this);
                                    this.SetXScaleItem(NewItem, nCycle, nCycle, tNextStart, tPrevStart, tNextStart, tPrevStart);
                                    this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                                    rXScaleItemArrayIndex.m_nIndex--;
                                }
                                else {

                                    this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tNextStart);
                                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);

                                    rXScaleItemArrayIndex.m_nIndex--;
                                }
                            }
                            else {

                                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevXScaleEnd, tXScaleItemEnd);
                                rXScaleItemArrayIndex.m_nIndex--;
                            }
                            return true;
                        }
                    }
                }
                else if (tPrevXScaleEnd === tStart) {

                    if (nCycle === nPrevCycle) {

                        var tNextStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                        if (tStart < tNextStart) {

                            this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tNextStart, tPrevXScaleStart, tNextStart);
                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                        }
                        else {

                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tStart, tXScaleItemEnd);

                            rXScaleItemArrayIndex.m_nIndex--;
                        }

                        return true;
                    }
                    else {
                        //작은 주기(nCycle)를 큰 주기(nPrevCycle)에 삽입 또는 큰주기를 작은 주기에 삽입
                        if (this.IsSmallerCycleThen(nCycle, nPrevCycle) || this.IsLargerCycleThen(nCycle, nPrevCycle)) {

                            var tNextStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                            if (tStart < tNextStart) {

                                var NewXScaleItem = new CDateTimeXScaleItem(this);
                                this.SetXScaleItem(NewXScaleItem, nCycle, nCycle, tStart, tNextStart, tStart, tNextStart);
                                this.InsertBefore(rXScaleItemArrayIndex, NewXScaleItem);

                                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);

                                rXScaleItemArrayIndex.m_nIndex--;
                            }
                            else {

                                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tStart, tXScaleItemEnd);

                                rXScaleItemArrayIndex.m_nIndex--;
                            }
                            return true;
                        }
                    }
                }
            }
            else//pXScaleItem 이전이 없는 경우
            {
                var tNextStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                if (tStart < tNextStart) {

                    var NewXScaleItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewXScaleItem, nCycle, nCycle, tStart, tNextStart, tStart, tNextStart);
                    this.InsertBefore(rXScaleItemArrayIndex, NewXScaleItem);

                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);

                    rXScaleItemArrayIndex.m_nIndex--;
                }
                else {

                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tStart, tXScaleItemEnd);

                    rXScaleItemArrayIndex.m_nIndex--;
                }
                return true;
            }
        }
    }

    return false;
}//처리1 <<

CDateTimeXScaleMng.prototype.SetXScaleItem = function (rXScaleItem, nLargeCycle, nSmallCycle, tTrgStart, tTrgEnd, tPrevStart, tNextStart) {

    if (nLargeCycle === 5 && nSmallCycle === 6) {

        var nDiffInterval = CalcInterval(tPrevStart, tNextStart, nSmallCycle);
        this.m_MinIntervalArray[nSmallCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nSmallCycle - 1].m_nInterval);

        rXScaleItem.SetStart(tPrevStart);
        rXScaleItem.SetEnd(tNextStart);
        rXScaleItem.SetCycle(nSmallCycle);
        rXScaleItem.SetInterval(this.m_MinIntervalArray[nSmallCycle - 1]);
    }
    else {

        var nDiffInterval = CalcInterval(tTrgStart, tTrgEnd, nSmallCycle);
        this.m_MinIntervalArray[nSmallCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nSmallCycle - 1].m_nInterval);

        rXScaleItem.SetStart(tTrgStart);
        rXScaleItem.SetEnd(tTrgEnd);
        rXScaleItem.SetCycle(nSmallCycle);
        rXScaleItem.SetInterval(this.m_MinIntervalArray[nSmallCycle - 1]);
    }

}

CDateTimeXScaleMng.prototype.SetXScaleItemCompare2Cycle = function (rXScaleItem, nStartCycle, nCycle, nEndCycle, tTrgStart, tTrgEnd, tPrevStart, tNextStart) {

    if (nStartCycle === 5 && nCycle === 6) {

        if (nCycle === 6 && nEndCycle === 5) {

            var nDiffInterval = CalcInterval(tPrevStart, tNextStart, nCycle);
            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

            rXScaleItem.SetStart(tPrevStart);
            rXScaleItem.SetEnd(tNextStart);
            rXScaleItem.SetCycle(nCycle);
            rXScaleItem.SetInterval(this.m_MinIntervalArray[nCycle - 1]);
        }
        else {

            var nDiffInterval = CalcInterval(tPrevStart, tTrgEnd, nCycle);
            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

            rXScaleItem.SetStart(tPrevStart);
            rXScaleItem.SetEnd(tTrgEnd);
            rXScaleItem.SetCycle(nCycle);
            rXScaleItem.SetInterval(this.m_MinIntervalArray[nCycle - 1]);
        }
        
    }
    else {

        if (nCycle === 6 && nEndCycle === 5) {

            var nDiffInterval = CalcInterval(tTrgStart, tNextStart, nCycle);
            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

            rXScaleItem.SetStart(tTrgStart);
            rXScaleItem.SetEnd(tNextStart);
            rXScaleItem.SetCycle(nCycle);
            rXScaleItem.SetInterval(this.m_MinIntervalArray[nCycle - 1]);
        }
        else {

            var nDiffInterval = CalcInterval(tTrgStart, tTrgEnd, nCycle);
            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

            rXScaleItem.SetStart(tTrgStart);
            rXScaleItem.SetEnd(tTrgEnd);
            rXScaleItem.SetCycle(nCycle);
            rXScaleItem.SetInterval(this.m_MinIntervalArray[nCycle - 1]);
        }
    }
}
//처리 >>
CDateTimeXScaleMng.prototype.StartSTXStartAndXEndSTEnd = function (nCycle, nInterval, tStart, tEnd, rXScaleItemArrayIndex, rDateTimeArrayIndex) {

    var XScaleItem = this.m_XScaleItemArray[rXScaleItemArrayIndex.m_nIndex];
    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();

    ///////////////////////////////////
    var bPrevXEndSTStart = false;
    var nDiffInterval = null;
    var pos1 = rXScaleItemArrayIndex.m_nIndex - 1;
    if (pos1 >= 0) {

        var PrevXScaleItem = this.m_XScaleItemArray[pos1];
        var nPrevCycle = PrevXScaleItem.GetCycle();
        var nPrevInterval = PrevXScaleItem.GetInterval();
        var tPrevXScaleStart = PrevXScaleItem.GetStart();
        var tPrevXScaleEnd = PrevXScaleItem.GetEnd();

        if (tPrevXScaleEnd < tStart) {

            if (nCycle === nXScaleItemCycle) {

                this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                
                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tStart;
                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval;

                return false;//false를 리턴하여 CurDateTimeData4Merge의 남아있는 시간을 다음 XScaleItem과 비교할 수 있도록 한다
            }
            else {

                if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {
                    
                    this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);

                    this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                    this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;

                    return false;//false를 리턴하여 CurDateTimeData4Merge의 남아있는 시간을 다음 XScaleItem과 비교할 수 있도록 한다
                }
                else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

                    var tXStart = tXScaleItemStart, tXEnd = tXScaleItemEnd;

                    ///////////////////////////////////////////////////////////////////////////////////////
                    //과거쪽(시간블록좌측)
                    var tPrevStartTime = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                    if (tStart < tPrevStartTime) {

                        var NewXScaleItem = new CDateTimeXScaleItem(this);
                        this.SetXScaleItem(NewXScaleItem, nCycle, nCycle, tStart, tPrevStartTime, tStart, tPrevStartTime);
                        this.InsertBefore(rXScaleItemArrayIndex, NewXScaleItem);
                        
                        tXStart = tPrevStartTime;

                        rXScaleItemArrayIndex.m_nIndex++;
                    }
                    else {

                        tXStart = tStart;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    //최신쪽(시간블록우측)
                    if (nCycle === 5 && nXScaleItemCycle === 6) {

                        this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tXScaleItemEnd);

                        this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nXScaleItemCycle;
                        this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                        this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval;

                        return false;//false를 리턴하여 CurDateTimeData4Merge의 남아있는 시간을 다음 XScaleItem과 비교할 수 있도록 한다
                    }
                    else {

	                    var tNextStartTime = CalcNextStart(tStart, tXScaleItemEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
	                    if (tNextStartTime < tEnd) {
	
	                        this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tNextStartTime);
	                        
	                        this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tNextStartTime;
	                        this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
	
	                        return false;//false를 리턴하여 CurDateTimeData4Merge의 남아있는 시간을 다음 XScaleItem과 비교할 수 있도록 한다
	                    }
	                    else {
	
	                        this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tEnd);
	                        return true;
	                    }
	                }
	            }
	        }
        }
        else if (tPrevXScaleStart < tStart && tStart < tPrevXScaleEnd) {

            if (nCycle === nXScaleItemCycle) {

                if (nCycle === nPrevCycle) {

                    this.RemoveXScaleArray(rXScaleItemArrayIndex.m_nIndex, 1);
                    rXScaleItemArrayIndex.m_nIndex--;

                    this.SetXScaleItem(PrevXScaleItem, nCycle, nCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);

                    this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                    this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;

                    return false;
                }
                else {
                    //작은 주기(nCycle)를 큰 주기(nPrevCycle)에 삽입
                    if (this.IsSmallerCycleThen(nCycle, nPrevCycle)) {

                        var tPrevStart = CalcPrevStart(tStart, tPrevXScaleEnd, nPrevCycle, this.m_MinIntervalArray[nPrevCycle - 1].m_nInterval);
                        if (tPrevXScaleStart < tPrevStart) {

                            this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tPrevStart, tPrevXScaleStart, tPrevStart);
                            this.SetXScaleItem(XScaleItem, nPrevCycle, nCycle, tStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);

                            this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                            this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                        }
                        else {

                            this.RemoveXScaleArray(pos1, 1);
                            rXScaleItemArrayIndex.m_nIndex--;

                            this.SetXScaleItem(XScaleItem, nPrevCycle, nCycle, tStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                            
                            this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                            this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                        }

                        return false;
                    }
                    //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nPrevCycle:이미 등록된 주기)
                    else if (this.IsLargerCycleThen(nCycle, nPrevCycle)) {

                        var tNextStart = CalcNextStart(tStart, tPrevXScaleEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                        if (tNextStart < tXScaleItemStart) {

                            this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tNextStart);
                            this.SetXScaleItem(XScaleItem, nCycle, nCycle, tNextStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                            
                            this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                            this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                        }
                        else {

                            this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tXScaleItemStart);

                            this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                            this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                        }
                        return false;
                    }
                }
            }
            else {
                //작은 주기(nCycle)를 큰 주기(nXScaleItemCycle)에 삽입
                if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

                    if (nCycle === nPrevCycle) {

                        this.SetXScaleItem(PrevXScaleItem, nCycle, nCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);

                        this.RemoveXScaleArray(rXScaleItemArrayIndex.m_nIndex, 1);
                        rXScaleItemArrayIndex.m_nIndex--;

                        nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
                        this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                        this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                        this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;

                        return false;
                    }
                    else {

                        if (this.IsSmallerCycleThen(nCycle, nPrevCycle)) {

                            var tPrevStart = CalcPrevStart(tStart, tPrevXScaleEnd, nPrevCycle, this.m_MinIntervalArray[nPrevCycle - 1].m_nInterval);
                            if (tPrevXScaleStart < tPrevStart) {

                                this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tPrevStart, tPrevXScaleStart, tPrevStart);
                                this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);
                                
                                nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
                                this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                            }
                            else {

                                this.RemoveXScaleArray(pos1, 1);
                                rXScaleItemArrayIndex.m_nIndex--;

                                this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                                
                                nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
                                this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                            }

                            return false;
                        }
                        else if (this.IsLargerCycleThen(nCycle, nPrevCycle)) {

                            var tNextStart = CalcNextStart(tStart, tPrevXScaleEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                            if (tNextStart < tXScaleItemStart) {

                                this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tNextStart);
                                this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tNextStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                                
                                nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
                                this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                            }
                            else {

                                this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tXScaleItemStart);
                                this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tXScaleItemEnd);

                                nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
                                this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                            }

                            return false;
                        }
                    }
                }
                //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)
                else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

                    if (nCycle === nPrevCycle) {

                        var tXStart = tXScaleItemStart;
                        var tXEnd = tXScaleItemEnd;
                        var tPrevStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                        if (tPrevXScaleEnd < tPrevStart) {

                            this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tPrevStart, tPrevXScaleStart, tPrevStart);
                            
                            tXStart = tPrevStart;
                        }
                        else {

                            tXStart = tPrevXScaleEnd;
                        }

                        if (nCycle === 5 && nXScaleItemCycle === 6) {

                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tXScaleItemEnd);

                            this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nXScaleItemCycle;
                            this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                            this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval;

                            return false;//false를 리턴하여 CurDateTimeData4Merge의 남아있는 시간을 다음 XScaleItem과 비교할 수 있도록 한다
                        }
                        else {

	                        var tNextStart = CalcNextStart(tStart, tXScaleItemEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
	                        if (tNextStart < tEnd) {
	
	                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tNextStart);
	
	                            nDiffInterval = CalcInterval(tNextStart, tEnd, nCycle);
	                            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
	                            this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tNextStart;
	                            this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
	
	                            return false;
	                        }
	                        else {
	
	                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tEnd);
	                            return true;
	                        }
	                    }
                    }
                    else {
                        //작은 주기(nCycle)를 큰 주기(nPrevCycle)에 삽입
                        if (this.IsSmallerCycleThen(nCycle, nPrevCycle)) {

                            var tXStart = tXScaleItemStart;
                            var tXEnd = tXScaleItemEnd;
                            var tPrevStart = CalcPrevStart(tStart, tPrevXScaleEnd, nPrevCycle, this.m_MinIntervalArray[nPrevCycle - 1].m_nInterval);
                            if (tPrevXScaleStart < tPrevStart) {

                                this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tPrevStart, tPrevXScaleStart, tPrevStart);

                                var tPrevStartInCycle = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                                if (tPrevXScaleEnd < tPrevStartInCycle) {

                                    var NewItem = new CDateTimeXScaleItem(this);
                                    this.SetXScaleItemCompare2Cycle(NewItem, nPrevCycle, nCycle, nXScaleItemCycle, tStart, tPrevStartInCycle, tPrevStart, tPrevStartInCycle);
                                    this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                                    tXStart = tPrevStartInCycle;
                                }
                                else {

                                    var NewItem = new CDateTimeXScaleItem(this);
                                    this.SetXScaleItem(NewItem, nPrevCycle, nCycle, tStart, tPrevXScaleEnd, tPrevStart, tPrevXScaleEnd);
                                    this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                                    tXStart = tPrevXScaleEnd;
                                }
                            }
                            else {

                                var tPrevStartInCycle = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                                if (tPrevXScaleEnd < tPrevStartInCycle) {

                                    this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nCycle, tStart, tPrevStartInCycle, tPrevXScaleStart, tPrevStartInCycle);
                                    
                                    tXStart = tPrevStartInCycle;
                                }
                                else {

                                    this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nCycle, tStart, tPrevXScaleEnd, tPrevXScaleStart, tPrevXScaleEnd);

                                    tXStart = tPrevXScaleEnd;
                                }
                            }

                            ///////////////////////////////////////////////////////////////////////
                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tXScaleItemEnd);

                            //////////////////////////////////////////////////////////////////////
                            nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
                            var nDiffInterval1 = Math.ceil(nDiffInterval);
                            if (nDiffInterval1 === nDiffInterval) {//tXScaleItemEnd와 tEnd 사이시간간격이 nCycle주기에 정확하게 맞을 경우 nCycle 유지

                                this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                                this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nCycle;
                                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                            }
                            else {

                                nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nXScaleItemCycle);
                                this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                                this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nXScaleItemCycle;
                                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval;
                            }

                            return false;
                        }
                        //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nPrevCycle:이미 등록된 주기)
                        else if (this.IsLargerCycleThen(nCycle, nPrevCycle)) {

                            var tXStart = tXScaleItemStart;
                            var tXEnd = tXScaleItemEnd;
                            var tNextStart = CalcNextStart(tStart, tPrevXScaleEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                            if (tNextStart < tXScaleItemStart) {

                                this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tNextStart);

                                var tPrevStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                                if (tNextStart < tPrevStart) {

                                    var NewXScaleItem = new CDateTimeXScaleItem(this);
                                    this.SetXScaleItemCompare2Cycle(NewXScaleItem, nPrevCycle, nCycle, nXScaleItemCycle, tNextStart, tPrevStart, tNextStart, tPrevStart);
                                    this.InsertBefore(rXScaleItemArrayIndex, NewXScaleItem);

                                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);
                                }
                                else if (tNextStart === tPrevStart ) {

                                    if (nPrevCycle === nXScaleItemCycle) {

                                        this.RemoveXScaleArray(pos1, 1);
                                        rXScaleItemArrayIndex.m_nIndex--;

                                        this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                                    }
                                    else {

                                        this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);
                                    }
                                }
                                else {

                                    if (nPrevCycle === nXScaleItemCycle) {

                                        this.RemoveXScaleArray(pos1, 1);
                                        rXScaleItemArrayIndex.m_nIndex--;

                                        this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                                    }
                                    else if (this.IsSmallerCycleThen(nPrevCycle, nXScaleItemCycle)) {

                                        this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tXScaleItemStart, tPrevXScaleStart, tXScaleItemStart);
                                        this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tXScaleItemEnd);
                                    }
                                    else {

                                        this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tPrevXScaleEnd, tXScaleItemEnd, tPrevXScaleEnd, tXScaleItemEnd);
                                    }
                                }
                            }
                            else if (tNextStart === tXScaleItemStart) {

                                if (nPrevCycle === nXScaleItemCycle) {

                                    this.RemoveXScaleArray(pos1, 1);
                                    rXScaleItemArrayIndex.m_nIndex--;

                                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                                }
                                else {

                                    this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tXScaleItemStart);
                                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tXScaleItemEnd);
                                }
                            }
                            else {//tNextStart가 XScaleItem의 시간범위를 침범해 들어간 경우

                                if (nPrevCycle === nXScaleItemCycle) {//같은 주기면 하나로 머지

                                    this.RemoveXScaleArray(pos1, 1);
                                    rXScaleItemArrayIndex.m_nIndex--;

                                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                                }
                                else if (this.IsSmallerCycleThen(nPrevCycle, nXScaleItemCycle)) {

                                    this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tXScaleItemStart);
                                }
                                else {//nPrevCycle주기가 nXScaleItemCycle 주기보다 큰 주기인 경우

                                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tPrevXScaleEnd, tXScaleItemEnd, tPrevXScaleEnd, tXScaleItemEnd);
                                }
                            }

                            ////////////////////////////////////////////////////////////////////////////////
                            nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
                            var nDiffInterval1 = Math.ceil(nDiffInterval);
                            if (nDiffInterval1 === nDiffInterval) {//tXScaleItemEnd와 tEnd 사이시간간격이 nCycle주기에 정확하게 맞을 경우 nCycle 유지
                                
                                this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                                this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nCycle;
                                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                            }
                            else {

                                nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nXScaleItemCycle);
                                this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                                this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nXScaleItemCycle;
                                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval;

                            }
                            
                            return false;
                        }
                    }
                }
            }
        }
        else if (tPrevXScaleEnd === tStart) {

            if (nCycle === nXScaleItemCycle) {

                if (nCycle === nPrevCycle) {

                    this.RemoveXScaleArray(pos1, 1);
                    rXScaleItemArrayIndex.m_nIndex--;

                    this.SetXScaleItem(XScaleItem, nCycle, nCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);

                    nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
                    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                    this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                    this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                }
                else {

                    this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                    
                    nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
                    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                    this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                    this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                }

                return false;
            }
            else {

                //작은 주기(nCycle)를 큰 주기(nXScaleItemCycle)에 삽입
                if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

                    if (nCycle === nPrevCycle) {

                        this.RemoveXScaleArray(pos1, 1);
                        rXScaleItemArrayIndex.m_nIndex--;

                        this.SetXScaleItem(XScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);

                        nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
                        this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                        this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                        this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                    }
                    else {

                        this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);

                        nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
                        this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                        this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                        this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
                    }

                    return false;
                }
                //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)
                else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

                    if (nCycle === nPrevCycle) {

                        var tXStart = tXScaleItemStart;
                        var tPrevStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                        if (tStart < tPrevStart) {

                            this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tPrevStart, tPrevXScaleStart, tPrevStart);

                            tXStart = tPrevStart;
                        }
                        else {

                            tXStart = tStart;
                        }

                        if (nCycle === 5 && nXScaleItemCycle === 6) {

                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tXScaleItemEnd);

                            this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nXScaleItemCycle;
                            this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                            this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval;

                            return false;//false를 리턴하여 CurDateTimeData4Merge의 남아있는 시간을 다음 XScaleItem과 비교할 수 있도록 한다
                        }
                        else {

	                        var tNextStart = CalcNextStart(tStart, tXScaleItemEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
	                        if (tNextStart < tEnd) {
	
	                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tNextStart);
	
	                            nDiffInterval = CalcInterval(tNextStart, tEnd, nCycle);
	                            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
	                            this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tNextStart;
	                            this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nCycle;
	                            this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
	
	                            return false;
	                        }
	                        else {
	
	                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tEnd);
	
	                            return true;
	                        }
                        }
                        ////////////////////////////////////////////////////////////////////////////////
                    }
                    else {//작은주기나 큰 주기 삽입시

                        var tXStart = tXScaleItemStart;
                        var tPrevStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                        if (tStart < tPrevStart) {

                            var NewItem = new CDateTimeXScaleItem(this);
                            this.SetXScaleItem(NewItem, nCycle, nCycle, tStart, tPrevStart, tStart, tPrevStart);
                            this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                            tXStart = tPrevStart;
                        }
                        else {

                            tXStart = tStart;
                        }

                        if (nCycle === 5 && nXScaleItemCycle === 6) {

                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tXScaleItemEnd);

                            this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nXScaleItemCycle;
                            this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                            this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval;

                            return false;//false를 리턴하여 CurDateTimeData4Merge의 남아있는 시간을 다음 XScaleItem과 비교할 수 있도록 한다
                        }
                        else {

	                        var tNextStart = CalcNextStart(tStart, tXScaleItemEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
	                        if (tNextStart < tEnd) {
	
	                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tNextStart);
	
	                            nDiffInterval = CalcInterval(tNextStart, tEnd, nCycle);
	                            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
	                            this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tNextStart;
	                            this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nCycle;
	                            this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
	
	                            return false;
	                        }
	                        else {
	
	                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXStart, tEnd);
	
	                            return true;
	                        }
	                    }
	                }
	            }
	        }
	    }
    }
    return false;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.StartSTXStartAndXEndEqEnd = function (nCycle, nInterval, tStart, tEnd, rXScaleItemArrayIndex, rDateTimeArrayIndex) {
    var XScaleItem = this.m_XScaleItemArray[rXScaleItemArrayIndex.m_nIndex];
    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();

    //var nIntervalGCD = nInterval;
    //if (nInterval != nXScaleItemInterval)//주기, interval 모두같은 경우(시작 시간이 다를 수 있다)
    //    nIntervalGCD = CalcGCD(nInterval, nXScaleItemInterval);
    //var nDifferenceStart = CalcInterval(tXScaleItemStart, tStart, nCycle);
    //nIntervalGCD = CalcGCD(nDifferenceStart, nIntervalGCD);//최대공약수

    ///////////////////////////////////
    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

    var nDiffInterval = null;
    var bProcess = false;
    var pos1 = rXScaleItemArrayIndex.m_nIndex - 1;
    if (pos1 >= 0) {

        var PrevXScaleItem = this.m_XScaleItemArray[pos1];
        var nPrevXScaleCycle = PrevXScaleItem.GetCycle();
        var nPrevXScaleInterval = PrevXScaleItem.GetInterval();
        var tPrevXScaleStart = PrevXScaleItem.GetStart();
        var tPrevXScaleEnd = PrevXScaleItem.GetEnd();

        if (tPrevXScaleEnd < tStart) {

            if (nCycle === nXScaleItemCycle)//주기 같은 경우
            {
                this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                return true;
            }
            else {
                if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

                    this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                    return true;
                }
                else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

                    var tPrevStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                    if (tStart < tPrevStart) {

                        var NewItem = new CDateTimeXScaleItem(this);
                        this.SetXScaleItem(NewItem, nCycle, nCycle, tStart, tPrevStart, tStart, tPrevStart);
                        this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                        this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);
                    }
                    else {

                        this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                    }

                    return true;
                }
            }
        }
        else if (tPrevXScaleStart < tStart && tStart < tPrevXScaleEnd) {

            if (nCycle === nXScaleItemCycle)//주기 같은 경우
            {
                if (nCycle === nPrevXScaleCycle) {

                    this.RemoveXScaleArray(pos1, 1);
                    rXScaleItemArrayIndex.m_nIndex--;

                    this.SetXScaleItem(XScaleItem, nCycle, nCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                    return true;
                }
                else {
                    if (this.IsSmallerCycleThen(nCycle, nPrevXScaleCycle)) {

                        var tPrevStart = CalcPrevStart(tStart, tPrevXScaleEnd, nPrevXScaleCycle, this.m_MinIntervalArray[nPrevXScaleCycle - 1].m_nInterval);
                        if (tPrevXScaleStart < tPrevStart) {

                            this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nPrevXScaleCycle, tPrevXScaleStart, tPrevStart, tPrevXScaleStart, tPrevStart);
                            this.SetXScaleItem(XScaleItem, nPrevXScaleCycle, nCycle, tStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);
                        }
                        else {

                            this.RemoveXScaleArray(pos1, 1);
                            rXScaleItemArrayIndex.m_nIndex--;

                            this.SetXScaleItem(XScaleItem, nPrevXScaleCycle, nCycle, tStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                        }
                        return true;
                    }
                    else if (this.IsLargerCycleThen(nCycle, nPrevXScaleCycle)) {

                        var tNextStart = CalcNextStart(tStart, tPrevXScaleEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                        if (tNextStart < tXScaleItemStart) {

                            this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tNextStart);
                            this.SetXScaleItem(XScaleItem, nCycle, nCycle, tNextStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                        }
                        else{

                            this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tNextStart);
                        }
                        return true;
                    }
                }
            }
            else {
                if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

                    if (nCycle === nPrevXScaleCycle) {

                        this.RemoveXScaleArray(rXScaleItemArrayIndex.m_nIndex, 1);
                        rXScaleItemArrayIndex.m_nIndex--;

                        this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nPrevXScaleCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                    }
                    else {
                        if (this.IsSmallerCycleThen(nCycle, nPrevXScaleCycle)) {

                            var tPrevStart = CalcPrevStart(tStart, tPrevXScaleEnd, nPrevXScaleCycle, this.m_MinIntervalArray[nPrevXScaleCycle - 1].m_nInterval);
                            if (tPrevXScaleStart < tPrevStart) {

                                this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nPrevXScaleCycle, tPrevXScaleStart, tPrevStart, tPrevXScaleStart, tPrevStart);
                                this.SetXScaleItem(XScaleItem, nPrevXScaleCycle, nCycle, tStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);
                            }
                            else {

                                this.RemoveXScaleArray(pos1, 1);
                                rXScaleItemArrayIndex.m_nIndex--;

                                this.SetXScaleItem(XScaleItem, nPrevXScaleCycle, nCycle, tStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                            }
                        }
                        else {

                            var tNextStart = CalcNextStart(tStart, tPrevXScaleEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                            if (tNextStart < tXScaleItemStart) {

                                this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevXScaleCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tNextStart);
                                this.SetXScaleItem(XScaleItem, nCycle, nCycle, tNextStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                            }
                            else {

                                this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevXScaleCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tXScaleItemStart);
                                this.SetXScaleItem(XScaleItem, nCycle, nCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tXScaleItemEnd);
                            }
                        }
                    }
                    return true;
                }
                else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

                    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

                    if (nCycle === nPrevXScaleCycle) {

                        var tNextStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                        if (tPrevXScaleEnd < tNextStart) {

                            this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nPrevXScaleCycle, tPrevXScaleStart, tNextStart, tPrevXScaleStart, tNextStart);
                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                        }
                        else {

                            this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nPrevXScaleCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tPrevXScaleEnd);
                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevXScaleEnd, tXScaleItemEnd);
                        }
                        return true;
                    }
                    else {
                        
                        if (this.IsSmallerCycleThen(nCycle, nPrevXScaleCycle)) {

                            var tPrevStart = CalcPrevStart(tStart, tPrevXScaleEnd, nPrevXScaleCycle, this.m_MinIntervalArray[nPrevXScaleCycle - 1].m_nInterval);
                            if (tPrevXScaleStart < tPrevStart) {

                                this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nPrevXScaleCycle, tPrevXScaleStart, tPrevStart, tPrevXScaleStart, tPrevStart);

                                var tNextStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                                if (tPrevXScaleEnd < tNextStart) {

                                    var NewItem = new CDateTimeXScaleItem(this);
                                    this.SetXScaleItem(NewItem, nPrevXScaleCycle, nCycle, tStart, tNextStart, tPrevStart, tNextStart);
                                    this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                                }
                                else if (tPrevXScaleEnd >= tNextStart) {

                                    var NewItem = new CDateTimeXScaleItem(this);
                                    this.SetXScaleItem(NewItem, nPrevXScaleCycle, nCycle, tStart, tPrevXScaleEnd, tPrevStart, tPrevXScaleEnd);
                                    this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevXScaleEnd, tXScaleItemEnd);
                                }
                            }
                            else {

                                var tNextStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                                if (tPrevXScaleEnd < tNextStart) {

                                    this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nCycle, tStart, tNextStart, tPrevXScaleStart, tNextStart);
                                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                                }
                                else if (tPrevXScaleEnd >= tNextStart) {

                                    this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nCycle, nXScaleItemCycle, tStart, tPrevXScaleEnd, tPrevXScaleStart, tPrevXScaleEnd);
                                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevXScaleEnd, tXScaleItemEnd);
                                }
                            }
                            return true;
                        }
                        else if (this.IsLargerCycleThen(nCycle, nPrevXScaleCycle)) {

                            var tNextStart = CalcNextStart(tStart, tPrevXScaleEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                            var tNextNextStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

                            if (tNextStart < tNextNextStart) {

                                this.SetXScaleItem(PrevXScaleItem, nCycle, nPrevXScaleCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tNextStart);

                                var NewXScaleItem = new CDateTimeXScaleItem(this);
                                this.SetXScaleItem(NewXScaleItem, nCycle, nCycle, tNextStart, tNextNextStart, tNextStart, tNextNextStart);
                                this.InsertBefore(rXScaleItemArrayIndex, NewXScaleItem);

                                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tNextNextStart, tXScaleItemEnd);
                            }
                            else if (tNextStart === tNextNextStart) {

                                if (nPrevXScaleCycle === nXScaleItemCycle) {

                                    this.RemoveXScaleArray(pos1, 1);
                                    rXScaleItemArrayIndex.m_nIndex--;

                                    this.SetXScaleItem(XScaleItem, nPrevXScaleCycle, nPrevXScaleCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                                }
                                else {

                                    this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nPrevXScaleCycle, tPrevXScaleStart, tPrevXScaleEnd, tPrevXScaleStart, tNextStart);
                                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                                }
                            }
                            else {

                                if (nPrevXScaleCycle === nXScaleItemCycle) {

                                    this.RemoveXScaleArray(pos1, 1);
                                    rXScaleItemArrayIndex.m_nIndex--;

                                    this.SetXScaleItem(XScaleItem, nPrevXScaleCycle, nPrevXScaleCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                                }
                                else if (this.IsSmallerCycleThen(nPrevXScaleCycle, nXScaleItemCycle)) {

                                    this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nPrevXScaleCycle, tPrevXScaleStart, tXScaleItemStart, tPrevXScaleStart, tXScaleItemStart);
                                }
                                else {

                                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tPrevXScaleEnd, tXScaleItemEnd, tPrevXScaleEnd, tXScaleItemEnd);
                                }
                            }
                            return true;
                        }
                    }
                }
            }
        }
        else if (tPrevXScaleEnd === tStart) {

            if (nCycle === nXScaleItemCycle) {

                if (nCycle === nPrevXScaleCycle) {

                    this.RemoveXScaleArray(pos1, 1);
                    rXScaleItemArrayIndex.m_nIndex--;

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                }
                else {

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                }
                return true;
            }
            else {

                if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

                    if (nCycle === nPrevXScaleCycle) {

                        this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nPrevXScaleCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                        
                        this.RemoveXScaleArray(rXScaleItemArrayIndex.m_nIndex, 1);
                        rXScaleItemArrayIndex.m_nIndex--;
                    }
                    else {

                        this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                    }
                    return true;
                }
                else {// if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle))

                    if (nCycle === nPrevXScaleCycle) {

                        var tPrevStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                        if (tStart < tPrevStart) {

                            this.SetXScaleItem(PrevXScaleItem, nPrevXScaleCycle, nPrevXScaleCycle, tPrevXScaleStart, tPrevStart, tPrevXScaleStart, tPrevStart);
                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);
                        }
                        else {

                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                        }
                        return true;
                    }
                    else if (this.IsSmallerCycleThen(nCycle, nPrevXScaleCycle)) {

                        var tPrevStart = CalcPrevStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                        if (tStart < tPrevStart) {

                            var NewItem = new CDateTimeXScaleItem(this);
                            this.SetXScaleItem(NewItem, nCycle, nCycle, tStart, tPrevStart, tStart, tPrevStart);
                            this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);
                        }
                        else {

                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                        }
                        return true;
                    }
                    else {//this.IsLargerCycleThen(nCycle, nPrevXScaleCycle)

                        var tPrevStart = CalcPrevStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                        if (tStart < tPrevStart) {

                            var NewItem = new CDateTimeXScaleItem(this);
                            this.SetXScaleItem(NewItem, nCycle, nCycle, tStart, tPrevStart, tStart, tPrevStart);
                            this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                            nDiffInterval = CalcInterval(tPrevStart, tXScaleItemEnd, nXScaleItemCycle);
                            this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                            XScaleItem.SetStart(tPrevStart);
                        }
                        else {

                            this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                        }
                        return true;
                    }
                }
            }
        }
    }
    else//삽입되어 있는 pXScaleItem 이전 봉이 없는 경우
    {
        if (nCycle === nXScaleItemCycle) {

            this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
            return true;
        }
        else {
            if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

                this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                return true;
            }
            else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

                var tNextStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                if (tStart < tNextStart) {

                    var NewItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewItem, nCycle, nCycle, tStart, tNextStart, tStart, tNextStart);
                    this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                }
                else {

                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                }
                return true;
            }
        }
    }

    return false;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.StartSTXStartAndEndSTXStart = function (nCycle, nInterval, tStart, tEnd, rXScaleItemArrayIndex, rDateTimeArrayIndex) {

    var XScaleItem = this.m_XScaleItemArray[rXScaleItemArrayIndex.m_nIndex];
    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();

    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

    var bProcess = false;
    var pos1 = rXScaleItemArrayIndex.m_nIndex - 1;
    if (pos1 >= 0) {
        var PrevXScaleItem = this.m_XScaleItemArray[pos1];
        var nPrevCycle = PrevXScaleItem.GetCycle();
        var nPrevInterval = PrevXScaleItem.GetInterval();
        var tPrevXScaleStart = PrevXScaleItem.GetStart();
        var tPrevXScaleEnd = PrevXScaleItem.GetEnd();
        
        if (tPrevXScaleEnd < tStart) {

            var NewItem = new CDateTimeXScaleItem(this);
            this.SetXScaleItem(NewItem, nCycle, nCycle, tStart, tEnd, tStart, tEnd);
            this.InsertBefore(rXScaleItemArrayIndex, NewItem);

            rXScaleItemArrayIndex.m_nIndex--;

            return true;
        }
        else if (tPrevXScaleEnd === tStart) {

            if (nCycle === nPrevCycle) {

                this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tEnd, tPrevXScaleStart, tEnd);
                
                rXScaleItemArrayIndex.m_nIndex--;

                return true;
            }
            else {

                var NewItem = new CDateTimeXScaleItem(this);
                this.SetXScaleItem(NewItem, nCycle, nCycle, tStart, tEnd, tStart, tEnd);
                this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                rXScaleItemArrayIndex.m_nIndex--;

                return true;
            }
        }
    }
    else {

        var NewItem = new CDateTimeXScaleItem(this);
        this.SetXScaleItem(NewItem, nCycle, nCycle, tStart, tEnd, tStart, tEnd);
        this.InsertBefore(rXScaleItemArrayIndex, NewItem);

        rXScaleItemArrayIndex.m_nIndex--;

        return true;
    }

    return false;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.StartSTXStartAndEndEqXStart = function (nCycle, nInterval, tStart, tEnd, rXScaleItemArrayIndex, rDateTimeArrayIndex) {

    var XScaleItem = this.m_XScaleItemArray[rXScaleItemArrayIndex.m_nIndex];

    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();

    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

    var pos1 = rXScaleItemArrayIndex.m_nIndex - 1;
    if (pos1 >= 0) {

        var PrevXScaleItem = this.m_XScaleItemArray[pos1];
        var nPrevCycle = PrevXScaleItem.GetCycle();
        var nPrevInterval = PrevXScaleItem.GetInterval();
        var tPrevXScaleStart = PrevXScaleItem.GetStart();
        var tPrevXScaleEnd = PrevXScaleItem.GetEnd();

        if (tPrevXScaleEnd < tStart) {

            if (nCycle === nXScaleItemCycle) {

                this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);

                rXScaleItemArrayIndex.m_nIndex--;
                
                return true;
            }
            else {

                var NewXScaleItem = new CDateTimeXScaleItem(this);
                this.SetXScaleItem(NewXScaleItem, nCycle, nCycle, tStart, tEnd, tStart, tEnd);
                this.InsertBefore(rXScaleItemArrayIndex, NewXScaleItem);

                rXScaleItemArrayIndex.m_nIndex--;

                return true;
            }
        }
        else if (tPrevXScaleEnd === tStart) {

            if (nCycle === nXScaleItemCycle) {

                if (nCycle === nPrevCycle) {

                    this.RemoveXScaleArray(pos1, 1);
                    rXScaleItemArrayIndex.m_nIndex--;

                    this.SetXScaleItem(XScaleItem, nCycle, nCycle, tPrevXScaleStart, tXScaleItemEnd, tPrevXScaleStart, tXScaleItemEnd);
                    rXScaleItemArrayIndex.m_nIndex--;

                    return true;
                }
                else {

                    this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
                    rXScaleItemArrayIndex.m_nIndex--;

                    return true;
                }
            }
            else {
                //작은 주기(nCycle)를 큰 주기(nXScaleItemCycle)에 삽입
                if (nCycle === nPrevCycle) {

                    this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevXScaleStart, tEnd, tPrevXScaleStart, tEnd);
                    
                    rXScaleItemArrayIndex.m_nIndex--;

                    return true;
                }
                else {
                    
                    var NewXScaleItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewXScaleItem, nCycle, nCycle, tStart, tEnd, tStart, tEnd);
                    this.InsertBefore(rXScaleItemArrayIndex, NewXScaleItem);

                    rXScaleItemArrayIndex.m_nIndex--;

                    return true;
                }
                
            }
        }
    }
    else//pXScaleItem 앞에 등록되어 있는 XScaleItem이 없는 경우
    {
        if (nCycle === nXScaleItemCycle) {

            this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);

            rXScaleItemArrayIndex.m_nIndex--;

            return true;
        }
        else {

            var NewXScaleItem = new CDateTimeXScaleItem(this);
            this.SetXScaleItem(NewXScaleItem, nCycle, nCycle, tStart, tEnd, tStart, tEnd);
            this.InsertBefore(rXScaleItemArrayIndex, NewXScaleItem);

            rXScaleItemArrayIndex.m_nIndex--;

            return true;
        }
    }
    return false;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.XStartSTStartAndStartSTXEndAndXEndSTEnd = function (nCycle, nInterval, tStart, tEnd, rXScaleItemArrayIndex, rDateTimeArrayIndex) {

    var XScaleItem = this.m_XScaleItemArray[rXScaleItemArrayIndex.m_nIndex];

    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();
    var nDiffInterval = null;
    var tPrevStart = null, tNextStart = null;

    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

    if (nCycle === nXScaleItemCycle) {

        nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
        this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

        this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
        this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;

        return false;
    }
    else {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //작은 주기를 큰 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)(예:분주기를 일주기에 삽입할 경우)
        //일,주,월,년 주기는 Interval은 1만 존재한다고 가정하며 분의 Interval값에 제한을 두어 일주기를 넘어설 수 없다고 가정한다
        //1 이상의 값을 가질 수 있게 되면 interval값을 크게하여 작은 주기에서 큰 주기를 넘어서는 현상이 발생하게 되며
        //그 경우 제대로 처리하기 위해서는 해당 주, 월, 년에 실제 영업일수, 실제 영업일이 포함된 주수 등의 정보를 서버로 부터 받아야 한다
        if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

            var tPrevStart = CalcPrevStart(tStart, tXScaleItemEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
            if (tXScaleItemStart < tPrevStart) {

                var NewItem = new CDateTimeXScaleItem(this);
                this.SetXScaleItem(NewItem, nXScaleItemCycle, nXScaleItemCycle, tXScaleItemStart, tPrevStart, tXScaleItemStart, tPrevStart);
                this.InsertBefore(rXScaleItemArrayIndex, NewItem);

                this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);
            }
            else {

                this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tXScaleItemEnd, tXScaleItemStart, tXScaleItemEnd);
            }

            nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

            this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
            this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;

            return false;
        }
        //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)
        else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

            if (nCycle === 5 && nXScaleItemCycle === 6) {

                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tXScaleItemEnd);

                this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nXScaleItemCycle;
                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval;

                return false;//false를 리턴하여 CurDateTimeData4Merge의 남아있는 시간을 다음 XScaleItem과 비교할 수 있도록 한다
            }
            else {
	
	            var tNextStart = CalcNextStart(tStart, tXScaleItemEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
	            if (tNextStart < tEnd) {
	
	                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tNextStart);
	
	                nDiffInterval = CalcInterval(tNextStart, tEnd, nCycle);
	                this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
	                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tNextStart;
	                this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nCycle;
	                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
	
	                return false;
	            }
	            else {
	
	                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tEnd);
	
	                return true;
	            }
	        }
	    }
    }

    return false;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.XStartSTStartAndEndSTXEnd = function (nCycle, nInterval, tStart, tEnd, rXScaleItemArrayIndex, rDateTimeArrayIndex) {

    var XScaleItem = this.m_XScaleItemArray[rXScaleItemArrayIndex.m_nIndex];

    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();
    var nDiffInterval = null;
    var tPrevStart = null, tNextStart = null;

    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

    if (nCycle === nXScaleItemCycle) {

        rXScaleItemArrayIndex.m_nIndex--;

        return true;
    }
    else {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //작은 주기를 큰 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)(예:분주기를 일주기에 삽입할 경우)
        //일,주,월,년 주기는 Interval은 1만 존재한다고 가정하며 분의 Interval값에 제한을 두어 일주기를 넘어설 수 없다고 가정한다
        //1 이상의 값을 가질 수 있게 되면 interval값을 크게하여 작은 주기에서 큰 주기를 넘어서는 현상이 발생하게 되며
        //그 경우 제대로 처리하기 위해서는 해당 주, 월, 년에 실제 영업일수, 실제 영업일이 포함된 주수 등의 정보를 서버로 부터 받아야 한다
        if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

            //큰 주기 영역 중에 작은 주기와 겹치지 않는 앞쪽 영역이 있다면 큰 주기 영역으로 분리생성
            var tNewStart = CalcPrevStart(tStart, tXScaleItemEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
            if (tXScaleItemStart < tNewStart) {

                var NewXScaleItem = new CDateTimeXScaleItem(this);
                this.SetXScaleItem(NewXScaleItem, nXScaleItemCycle, nXScaleItemCycle, tXScaleItemStart, tNewStart, tXScaleItemStart, tNewStart);
                this.InsertBefore(rXScaleItemArrayIndex, NewXScaleItem);

                tNextStart = CalcNextStart(tNewStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                if (tNextStart < tXScaleItemEnd) {

                    NewXScaleItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewXScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tNewStart, tNextStart);
                    this.InsertBefore(rXScaleItemArrayIndex, NewXScaleItem);

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tNextStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                }
                else {

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tNewStart, tXScaleItemEnd);
                }

                rXScaleItemArrayIndex.m_nIndex--;

                return true;
            }
            else {

                tNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                if (tNextStart < tXScaleItemEnd) {
                    
                    NewXScaleItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewXScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tXScaleItemStart, tNextStart);
                    this.InsertBefore(rXScaleItemArrayIndex, NewXScaleItem);

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tNextStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                }
                else {

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tXScaleItemStart, tXScaleItemEnd);
                }

                rXScaleItemArrayIndex.m_nIndex--;

                return true;
            }
        }
        //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)
        else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

            this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

            rXScaleItemArrayIndex.m_nIndex--;

            return true;
        }
    }

    return false;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.XStartSTStartAndXEndEqEnd = function (nCycle, nInterval, tStart, tEnd, rXScaleItemArrayIndex, rDateTimeArrayIndex) {

    var XScaleItem = this.m_XScaleItemArray[rXScaleItemArrayIndex.m_nIndex];

    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();
    var nDiffInterval = null;
    var tPrevStart = null, tNextStart = null;

    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

    if (nCycle === nXScaleItemCycle) {

        return true;
    }
    else {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //작은 주기를 큰 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)(예:분주기를 일주기에 삽입할 경우)
        if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

            //큰 주기 영역 중에 작은 주기와 겹치지 않는 앞쪽 영역이 있다면 큰 주기 영역으로 분리생성
            var tNewStart = CalcPrevStart(tStart, tXScaleItemEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
            if (tXScaleItemStart < tNewStart) {

                var NewXScaleItem = new CDateTimeXScaleItem(this);
                this.SetXScaleItem(NewXScaleItem, nXScaleItemCycle, nXScaleItemCycle, tXScaleItemStart, tNewStart, tXScaleItemStart, tNewStart);
                this.InsertBefore(rXScaleItemArrayIndex, NewXScaleItem);

                this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tNewStart, tEnd);
                return true;
            }
            else {

                this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tXScaleItemStart, tEnd);
                return true;
            }
        }
        //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)
        else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

            return true;
        }
    }

    return false;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.XStartEqStartAndXEndEqEnd = function (nCycle, nInterval, tStart, tEnd, rXScaleItemArrayIndex, rDateTimeArrayIndex) {

    var XScaleItem = this.m_XScaleItemArray[rXScaleItemArrayIndex.m_nIndex];

    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();

    if (nCycle == nXScaleItemCycle) {

        return true;
    }
    else {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //작은 주기를 큰 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)(예:분주기를 일주기에 삽입할 경우)
        //일,주,월,년 주기는 Interval은 1만 존재한다고 가정하며 분의 Interval값에 제한을 두어 일주기를 넘어설 수 없다고 가정한다
        //1 이상의 값을 가질 수 있게 되면 interval값을 크게하여 작은 주기에서 큰 주기를 넘어서는 현상이 발생하게 되며
        //그 경우 제대로 처리하기 위해서는 해당 주, 월, 년에 실제 영업일수, 실제 영업일이 포함된 주수 등의 정보를 서버로 부터 받아야 한다
        this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

        var pos1 = rXScaleItemArrayIndex.m_nIndex - 1;
        if (pos1 >= 0) {
            var PrevXScaleItem = this.m_XScaleItemArray[pos1];

            var tPrevStart = PrevXScaleItem.GetStart();
            var tPrevEnd = PrevXScaleItem.GetEnd();
            var nPrevCycle = PrevXScaleItem.GetCycle();
            var nPrevInterval = PrevXScaleItem.GetInterval();

            if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

                if (tPrevEnd === tStart && nCycle === nPrevCycle) {

                    this.RemoveXScaleArray(pos1, 1);
                    rXScaleItemArrayIndex.m_nIndex--;

                    this.SetXScaleItem(XScaleItem, nCycle, nCycle, tPrevStart, tXScaleItemEnd, tPrevStart, tXScaleItemEnd);
                }
                else if (tPrevEnd < tStart) {

                    this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tEnd, tStart, tEnd);
                }
            }
        }
        else {

            if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

                this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tEnd, tStart, tEnd);
            }
        }
        return true;
    }

    return false;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.XStartEqStartAndXEndSTEnd = function (nCycle, nInterval, tStart, tEnd, rXScaleItemArrayIndex, rDateTimeArrayIndex) {

    var XScaleItem = this.m_XScaleItemArray[rXScaleItemArrayIndex.m_nIndex];

    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();
    var nDiffInterval = null;

    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

    if (nCycle === nXScaleItemCycle) {

        nDiffInterval = CalcInterval(tXScaleItemEnd, tEnd, nCycle);
        this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

        this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
        this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;

        return false;
    }
    else {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //작은 주기를 큰 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)(예:분주기를 일주기에 삽입할 경우)
        //일,주,월,년 주기는 Interval은 1만 존재한다고 가정하며 분의 Interval값에 제한을 두어 일주기를 넘어설 수 없다고 가정한다
        //1 이상의 값을 가질 수 있게 되면 interval값을 크게하여 작은 주기에서 큰 주기를 넘어서는 현상이 발생하게 되며
        //그 경우 제대로 처리하기 위해서는 해당 주, 월, 년에 실제 영업일수, 실제 영업일이 포함된 주수 등의 정보를 서버로 부터 받아야 한다
        //따라서 아래 조건문의 경우는 발생하면 안됨!!
        if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

            this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tXScaleItemEnd, tStart, tXScaleItemEnd);
            
            this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
            this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;

            return false;
        }
        //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)
        else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

            if (nCycle === 5 && nXScaleItemCycle === 6) {
                
                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tXScaleItemEnd);
                
                this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nXScaleItemCycle;
                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tXScaleItemEnd;
                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval;

                return false;//false를 리턴하여 CurDateTimeData4Merge의 남아있는 시간을 다음 XScaleItem과 비교할 수 있도록 한다
            }
            else {

	            var tNextStart = CalcNextStart(tStart, tXScaleItemEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
	            if (tNextStart < tEnd) {
	
	                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tNextStart);
	
	                nDiffInterval = CalcInterval(tNextStart, tEnd, nXScaleItemCycle);
	                this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
	
	                this.m_rCurDateTimeData4Merge.m_tStartTime4Merge = tNextStart;
	                this.m_rCurDateTimeData4Merge.m_nCycle4Merge = nCycle;
	                this.m_rCurDateTimeData4Merge.m_nInterval4Merge = this.m_MinIntervalArray[nCycle - 1].m_nInterval;
	
	                return false;
	            }
	            else {
	
	                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tEnd);
	                return true;
	            }
	        }
	    }
    }

    return false;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.XStartEqStartAndEndSTXEnd = function (nCycle, nInterval, tStart, tEnd, rXScaleItemArrayIndex, rDateTimeArrayIndex) {
    var XScaleItem = this.m_XScaleItemArray[rXScaleItemArrayIndex.m_nIndex];

    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();
    var nDiffInterval = null;
    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

    if (nCycle === nXScaleItemCycle) {

        rXScaleItemArrayIndex.m_nIndex--;

        return true;
    }
    else {

        if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

            var bProcess = false;
            ///////////////////////////////////////////////////////////////
            //기존 아이템의 시작시간 변경
            var tXScaleItemNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
            if (tXScaleItemNextStart < tXScaleItemEnd) {

                var pos1 = rXScaleItemArrayIndex.m_nIndex - 1;
                if (pos1 >= 0) {
                    var PrevXScaleItem = this.m_XScaleItemArray[pos1];

                    var tPrevStart = PrevXScaleItem.GetStart();
                    var tPrevEnd = PrevXScaleItem.GetEnd();
                    var nPrevCycle = PrevXScaleItem.GetCycle();
                    var nPrevInterval = PrevXScaleItem.GetInterval();

                    if (tPrevEnd === tStart && nPrevCycle === nCycle) {

                        this.SetXScaleItem(PrevXScaleItem, nPrevCycle, nPrevCycle, tPrevStart, tEnd, tPrevStart, tXScaleItemNextStart);
                        bProcess = true;
                    }
                }

                if (!bProcess) {

                    nDiffInterval = CalcInterval(tStart, tXScaleItemNextStart, nCycle);
                    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

                    var NewItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewItem, nXScaleItemCycle, nCycle, tStart, tEnd, tStart, tXScaleItemNextStart);
                    this.InsertBefore(rXScaleItemArrayIndex, NewItem);
                }

                this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tXScaleItemNextStart, tXScaleItemEnd, tXScaleItemNextStart, tXScaleItemEnd);
                
                rXScaleItemArrayIndex.m_nIndex--;

                return true;
            }
            else {

                var pos1 = rXScaleItemArrayIndex.m_nIndex - 1;
                if (pos1 >= 0) {

                    var PrevXScaleItem = this.m_XScaleItemArray[pos1];

                    var tPrevStart = PrevXScaleItem.GetStart();
                    var tPrevEnd = PrevXScaleItem.GetEnd();
                    var nPrevCycle = PrevXScaleItem.GetCycle();
                    var nPrevInterval = PrevXScaleItem.GetInterval();

                    if (tPrevEnd == tStart && nPrevCycle == nCycle) {

                        this.RemoveXScaleArray(pos1, 1);
                        rXScaleItemArrayIndex.m_nIndex--;

                        this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tPrevStart, tEnd, tPrevStart, tXScaleItemEnd);
                        
                        bProcess = true;
                    }
                }

                if (!bProcess) {

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tStart, tXScaleItemEnd);
                }

                rXScaleItemArrayIndex.m_nIndex--;

                return true;
            }
        }
        //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)
        else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {
            
            rXScaleItemArrayIndex.m_nIndex--;

            return true;
        }
    }

    return false;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.AppendXItemXEndSTStart = function (nCycle, nInterval, tStart, tEnd, rNextTime, rPrevItem) {
    
    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

    var NewXScaleItem = new CDateTimeXScaleItem(this);
    NewXScaleItem.SetCycle(nCycle);
    NewXScaleItem.SetInterval(this.m_MinIntervalArray[nCycle - 1]);
    NewXScaleItem.SetStart(tStart);
    NewXScaleItem.SetEnd(tEnd);
    this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewXScaleItem;

    rNextTime.m_tTime = tEnd;
    rPrevItem = NewXScaleItem;

    return true;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.AppendXItemXEndEqStart = function (nCycle, nInterval, tStart, tEnd, rNextTime, rPrevItem) {

    var bProcess = false;

    var XScaleItem = this.m_XScaleItemArray[this.m_XScaleItemArray.length - 1];

    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();

    if (nCycle === nXScaleItemCycle) {

        var nDiffInterval = CalcInterval(tXScaleItemStart, tEnd, nCycle);
        this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nDiffInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

        XScaleItem.SetEnd(tEnd);
        rNextTime.m_tTime = tEnd;
        rPrevItem = XScaleItem;

        bProcess = true;
    }
    else {

        this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

        var NewXScaleItem = new CDateTimeXScaleItem(this);
        NewXScaleItem.SetCycle(nCycle);
        NewXScaleItem.SetInterval(this.m_MinIntervalArray[nCycle - 1]);
        NewXScaleItem.SetStart(tStart);
        NewXScaleItem.SetEnd(tEnd);
        this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewXScaleItem;

        rNextTime.m_tTime = tEnd;
        rPrevItem = NewXScaleItem;

        bProcess = true;
    }

    return bProcess;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.AppendXItemXStartSTStartAndStartSTXEnd = function (nCycle, nInterval, tStart, tEnd, rNextTime, rPrevItem) {

    var bProcess = false;

    if (this.m_XScaleItemArray.length <= 0) {
        var NewXScaleItem = new CDateTimeXScaleItem(this);
        NewXScaleItem.SetStart(tStart);
        NewXScaleItem.SetEnd(tEnd);
        NewXScaleItem.SetCycle(nCycle);
        NewXScaleItem.SetInterval(this.m_MinIntervalArray[nCycle - 1]);
        this.m_XScaleItemArray.push(NewXScaleItem);

        return true;
    }

    var XScaleItem = this.m_XScaleItemArray[this.m_XScaleItemArray.length - 1];

    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();

    if (tXScaleItemEnd < tEnd) {

        if (nCycle === nXScaleItemCycle) {

            this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tXScaleItemStart, tEnd, tXScaleItemStart, tEnd);
            
            rNextTime.m_tTime = tEnd;
            rPrevItem = XScaleItem;

            bProcess = true;
        }
        else {

            //작은 주기(nCycle)를 큰 주기(nXScaleItemCycle)에 삽입
            if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

                var tNextStart = CalcPrevStart(tStart, tXScaleItemEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                if (tXScaleItemStart < tNextStart) {

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tXScaleItemStart, tNextStart, tXScaleItemStart, tNextStart);
                    
                    NewXScaleItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewXScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tNextStart, tEnd);
                    this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewXScaleItem;

                    rNextTime.m_tTime = tEnd;
                    rPrevItem = NewXScaleItem;
                }
                else {

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tXScaleItemStart, tEnd);
                    
                    rNextTime.m_tTime = tEnd;
                    rPrevItem = XScaleItem;
                }

                bProcess = true;
            }
            //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)
            else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

                var tNextStart = CalcNextStart(tStart, tXScaleItemEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                if (tNextStart < tEnd) {

                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tNextStart);

                    NewXScaleItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewXScaleItem, nCycle, nCycle, tNextStart, tEnd);
                    this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewXScaleItem;

                    rNextTime.m_tTime = tEnd;
                    rPrevItem = NewXScaleItem;
                }
                else {

                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tEnd);
                    
                    rNextTime.m_tTime = tEnd;
                    rPrevItem = XScaleItem;
                }

                bProcess = true;
            }
        }
    }
    else if (tXScaleItemEnd === tEnd) {

        if (nCycle === nXScaleItemCycle) {

            rNextTime.m_tTime = tEnd;
            rPrevItem = XScaleItem;
        }
        else {
            //작은 주기(nCycle)를 큰 주기(nXScaleItemCycle)에 삽입
            if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

                var tNextStart = CalcPrevStart(tStart, tXScaleItemEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                if (tXScaleItemStart < tNextStart) {

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tXScaleItemStart, tNextStart, tXScaleItemStart, tNextStart);
                    
                    var NewXScaleItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewXScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tNextStart, tEnd);
                    this.m_XScaleItemArray[this.m_XScaleItemArray] = NewXScaleItem;

                    rNextTime.m_tTime = tEnd;
                    rPrevItem = NewXScaleItem;
                }
                else {

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tXScaleItemStart, tEnd);
                    
                    rNextTime.m_tTime = tEnd;
                    rPrevItem = XScaleItem;
                }
            }
            //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)
            else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

                rNextTime.m_tTime = tEnd;
                rPrevItem = XScaleItem;
            }
        }

        bProcess = true;
    }
    else {// tEnd < tXScaleItemEnd

        if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

            var tPrevStart = CalcPrevStart(tStart, tXScaleItemEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
            if (tXScaleItemStart < tPrevStart) {

                this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tXScaleItemStart, tPrevStart, tXScaleItemStart, tPrevStart);

                var tNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                if (tNextStart < tXScaleItemEnd) {

                    var NewItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewItem, nXScaleItemCycle, nCycle, tStart, tEnd, tPrevStart, tNextStart);
                    this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewItem;

                    NewItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewItem, nXScaleItemCycle, nXScaleItemCycle, tNextStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                    this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewItem;
                    
                    rNextTime.m_tTime = tXScaleItemEnd;
                    rPrevItem = NewItem;
                }
                else {

                    NewItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewItem, nXScaleItemCycle, nCycle, tStart, tEnd, tPrevStart, tXScaleItemEnd);
                    this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewItem;

                    rNextTime.m_tTime = NewItem.GetEnd();
                    rPrevItem = NewItem;
                }

                bProcess = true;
            }
            else {

                var tNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
                if (tNextStart < tXScaleItemEnd) {

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tXScaleItemStart, tNextStart);

                    var NewItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewItem, nXScaleItemCycle, nXScaleItemCycle, tNextStart, tXScaleItemEnd, tNextStart, tXScaleItemEnd);
                    this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewItem;

                    rNextTime.m_tTime = tEnd;
                    rPrevItem = NewItem;
                }
                else {

                    this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tXScaleItemStart, tXScaleItemEnd);

                    rNextTime.m_tTime = tEnd;
                    rPrevItem = XScaleItem;
                }

                bProcess = true;
            }
        }
        else {

            bProcess = true;
        }
    }
    return bProcess;
}//처리 <<

//처리 >>
CDateTimeXScaleMng.prototype.AppendXItemStartSTXStart = function (nCycle, nInterval, tStart, tEnd, rNextTime, rPrevItem) {
    var bProcess = false;

    var XScaleItem = this.m_XScaleItemArray[this.m_XScaleItemArray.length - 1];

    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();
    var nDiffInterval = null;

    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

    if (tXScaleItemEnd < tEnd) {

        if (nCycle === nXScaleItemCycle) {

            this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nXScaleItemCycle, tStart, tEnd, tStart, tEnd);

            rNextTime.m_tTime = tEnd;
            rPrevItem = XScaleItem;

            bProcess = true;
        }
        else {
            //작은 주기(nCycle)를 큰 주기(nXScaleItemCycle)에 삽입
            if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

                var PrevItem = null;
                if (this.m_XScaleItemArray.length >= 2) {

                    PrevItem = this.m_XScaleItemArray[this.m_XScaleItemArray.length - 2];

                    var tPrevXScaleItemStart = PrevItem.GetStart();
                    var tPrevXScaleItemEnd = PrevItem.GetEnd();
                    var nPrevXScaleItemCycle = PrevItem.GetCycle();
                    var nPrevXScaleItemInterval = PrevItem.GetInterval();

                    if (nPrevXScaleItemCycle === nCycle && tPrevXScaleItemEnd === tXscaleItemStart) {
                        
                        this.RemoveXScaleArray(this.m_XScaleItemArray.length - 1, 1);

                        this.SetXScaleItem(prevItem, nPrevXScaleItemCycle, nPrevXScaleItemCycle, tPrevXScaleItemStart, tEnd, tPrevXScaleItemStart, tEnd);

                        rNextTime.m_tTime = tEnd;
                        rPrevItem = PrevItem;
                        bProcess = true;
                    }
                }

                if (bProcess === false) {

                    this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tEnd, tStart, tEnd);
                    
                    rNextTime.m_tTime = tEnd;
                    rPrevItem = XScaleItem;

                    bProcess = true;
                }
                
            }
            //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)
            else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

                var tPrevStart = CalcPrevStart(tXScaleItemStart, tEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                var tNextStart = CalcNextStart(tStart, tXScaleItemEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                if (tStart < tPrevStart) {

                    var PrevItem = null;
                    if (this.m_XScaleItemArray.length >= 2) {

                        PrevItem = this.m_XScaleItemArray[this.m_XScaleItemArray.length - 2];

                        var tPrevXScaleItemStart = PrevItem.GetStart();
                        var tPrevXScaleItemEnd = PrevItem.GetEnd();
                        var nPrevXScaleItemCycle = PrevItem.GetCycle();
                        var nPrevXScaleItemInterval = PrevItem.GetInterval();

                        if (nPrevXScaleItemCycle === nCycle && tPrevXScaleItemEnd === tStart) {

                            this.SetXScaleItem(PrevItem, nPrevXScaleItemCycle, nPrevXScaleItemCycle, tPrevXScaleItemStart, tPrevStart);

                            if (tNextStart < tEnd) {

                                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevStart, tNextStart);

                                var NewItem = new CDateTimeXScaleItem(this);
                                this.SetXScaleItem(NewItem, nCycle, nCycle, tNextStart, tEnd, tNextStart, tEnd);
                                this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewItem;

                                rNextTime.m_tTime = tEnd;
                                rPrevItem = NewItem;

                                bProcess = true;
                            }
                            else {

                                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tPrevStart, tEnd);

                                rNextTime.m_tTime = XScaleItem.GetEnd();
                                rPrevItem = XScaleItem;

                                bProcess = true;
                            }
                        }
                    }
                }
                else {

                    var PrevItem = null;
                    if (this.m_XScaleItemArray.length >= 2) {

                        PrevItem = this.m_XScaleItemArray[this.m_XScaleItemArray.length - 2];

                        var tPrevXScaleItemStart = PrevItem.GetStart();
                        var tPrevXScaleItemEnd = PrevItem.GetEnd();
                        var nPrevXScaleItemCycle = PrevItem.GetCycle();
                        var nPrevXScaleItemInterval = PrevItem.GetInterval();
    
                        {

                            if (tNextStart < tEnd) {

                                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tXScaleItemStart, tNextStart);

                                var NewItem = new CDateTimeXScaleItem(this);
                                this.SetXScaleItem(NewItem, nCycle, nCycle, tNextStart, tEnd, tNextStart, tEnd);
                                this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewItem;

                                rNextTime.m_tTime = tEnd;
                                rPrevItem = NewItem;

                                bProcess = true;
                            }
                            else {

                                this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tXScaleItemStart, tXScaleItemEnd, tStart, tEnd);

                                rNextTime.m_tTime = tEnd;
                                rPrevItem = XScaleItem;

                                bProcess = true;
                            }
                        }
                    }
                }
            }
        }
    }

    return bProcess;
}//처리 <<

//처리 >>20190107 작업할 위치 >>
CDateTimeXScaleMng.prototype.AppendXItemXStartEqStart = function (nCycle, nInterval, tStart, tEnd, rNextTime, rPrevItem) {

    var bProcess = false;

    var XScaleItem = this.m_XScaleItemArray[this.m_XScaleItemArray.length - 1];

    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();

    if (tXScaleItemEnd < tEnd) {

        if (nCycle == nXScaleItemCycle) {

            this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tEnd, tStart, tEnd);
            
            rNextTime.m_tTime = tEnd;
            rPrevItem = XScaleItem;

            bProcess = true;
        }
        else {
            //작은 주기(nCycle)를 큰 주기(nXScaleItemCycle)에 삽입
            if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

                var PrevItem = null;
                if (this.m_XScaleItemArray.length >= 2) {

                    PrevItem = this.m_XScaleItemArray[this.m_XScaleItemArray.length - 2];

                    var tPrevXScaleItemStart = PrevItem.GetStart();
                    var tPrevXScaleItemEnd = PrevItem.GetEnd();
                    var nPrevXScaleItemCycle = PrevItem.GetCycle();
                    var nPrevXScaleItemInterval = PrevItem.GetInterval();

                    //연속된 경우
                    if (nPrevXScaleItemCycle === nCycle && tPrevXScaleItemEnd === tStart) {

                        this.SetXScaleItem(PrevItem, nCycle, nCycle, tPrevXScaleItemStart, tEnd, tPrevXScaleItemStart, tEnd);
                        this.RemoveXScaleArray(this.m_XScaleItemArray.length - 1, 1);

                        rNextTime.m_tTime = tEnd;
                        rPrevItem = PrevItem;

                        bProcess = true;
                    }
                }

                if (bProcess === false) {

                    this.SetXScaleItem(XScaleItem, nCycle, nCycle, tStart, tEnd, tStart, tEnd);

                    rNextTime.m_tTime = tEnd;
                    rPrevItem = XScaleItem;

                    bProcess = true;
                }
            }
            //큰 주기를 작은 주기에 삽입할 경우(nCycle:삽입할 주기, nXScaleItemCycle:이미 등록된 주기)
            else if (this.IsLargerCycleThen(nCycle, nXScaleItemCycle)) {

                var tNextStart = CalcNextStart(tStart, tXScaleItemEnd, nCycle, this.m_MinIntervalArray[nCycle - 1].m_nInterval);
                if (tNextStart < tEnd) {

                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tStart, tXScaleItemEnd, tStart, tNextStart);
                    
                    var NewXScaleItem = new CDateTimeXScaleItem(this);
                    this.SetXScaleItem(NewXScaleItem, nCycle, nCycle, tNextStart, tEnd, tNextStart, tEnd);
                    this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewXScaleItem;

                    rNextTime.m_tTime = tEnd;
                    rPrevItem = NewXScaleItem;

                    bProcess = true;
                }
                else {

                    this.SetXScaleItem(XScaleItem, nCycle, nXScaleItemCycle, tStart, tXScaleItemEnd, tStart, tEnd);

                    rNextTime.m_tTime = tEnd;
                    rPrevItem = XScaleItem;

                    bProcess = true;
                }
            }
        }
    }
    else if (tXScaleItemEnd === tEnd) {

        if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

            var PrevItem = null;
            if (this.m_XScaleItemArray.length >= 2) {

                PrevItem = this.m_XScaleItemArray[this.m_XScaleItemArray.length - 2];

                var tPrevXScaleItemStart = PrevItem.GetStart();
                var tPrevXScaleItemEnd = PrevItem.GetEnd();
                var nPrevXScaleItemCycle = PrevItem.GetCycle();
                var nPrevXScaleItemInterval = PrevItem.GetInterval();

                //연속된 경우
                if (nPrevXScaleItemCycle === nCycle && tPrevXScaleItemEnd === tStart) {

                    this.SetXScaleItem(PrevItem, nCycle, nCycle, tPrevXScaleItemStart, tEnd, tPrevXScaleItemStart, tEnd);

                    this.RemoveXScaleArray(this.m_XScaleItemArray.length - 1, 1);

                    rNextTime.m_tTime = tEnd;
                    rPrevItem = PrevItem;
                }
            }

            if (bProcess === false) {

                this.SetXScaleItem(PrevItem, nCycle, nCycle, tStart, tEnd, tStart, tEnd);
                
                rNextTime.m_tTime = tEnd;
                rPrevItem = PrevItem;
            }
        }

        bProcess = true;
    }
    else {// tEnd < tXScaleItemEnd

        if (nCycle === nXScaleItemCycle) {

            bProcess = true;
        }
        else if (this.IsSmallerCycleThen(nCycle, nXScaleItemCycle)) {

            var tNextStart = CalcNextStart(tXScaleItemStart, tEnd, nXScaleItemCycle, this.m_MinIntervalArray[nXScaleItemCycle - 1].m_nInterval);
            if (tNextStart < tXScaleItemEnd) {

                this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tStart, tNextStart);
                
                var NewItem = new CDateTimeXScaleItem(this);
                this.SetXScaleItem(NewItem, nCycle, nCycle, tNextStart, tEnd, tNextStart, tEnd);
                this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewItem;

                rNextTime.m_tTime = tEnd;
                rPrevItem = NewItem;
            }
            else {

                this.SetXScaleItem(XScaleItem, nXScaleItemCycle, nCycle, tStart, tEnd, tStart, tXScaleItemEnd);

                rNextTime.m_tTime = tEnd;
                rPrevItem = NewItem;
            }

            bProcess = true;
        }
        else {//this.IsLargerCycleThen(nCycle, nXScaleItemCycle)

            bProcess = true;
        }
    }
    return bProcess;
}//처리 <<

CDateTimeXScaleMng.prototype.StartSTXStart = function (nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex) {
    var XScaleItem = this.m_XScaleItemArray[XScaleItemArrayIndex.m_nIndex];
    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();

    if (tXScaleItemStart < tEnd && tEnd < tXScaleItemEnd) {
        if (this.StartSTXStartAndXStartSTEndAndEndSTXEnd(nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex))
            return true;
    }
    else if (tXScaleItemEnd < tEnd) {
        if (this.StartSTXStartAndXEndSTEnd(nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex))
            return true;
    }
    else if (tXScaleItemEnd === tEnd)
    {
        if (this.StartSTXStartAndXEndEqEnd(nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex))
            return true;
    }
    else if (tEnd < tXScaleItemStart) {
        if (this.StartSTXStartAndEndSTXStart(nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex))
            return true;
    }
    else if (tEnd === tXScaleItemStart) {
        if (this.StartSTXStartAndEndEqXStart(nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex))
            return true;
    }

    return false;
}

CDateTimeXScaleMng.prototype.XStartSTStart = function (nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex) {
    var XScaleItem = this.m_XScaleItemArray[XScaleItemArrayIndex.m_nIndex];
    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();

    if (tStart < tXScaleItemEnd && tXScaleItemEnd < tEnd) {
        if (this.XStartSTStartAndStartSTXEndAndXEndSTEnd(nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex))
            return true;
    }
    else if (tEnd < tXScaleItemEnd) {
        if (this.XStartSTStartAndEndSTXEnd(nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex))
            return true;
    }
    else if (tXScaleItemEnd === tEnd) {
        if(this.XStartSTStartAndXEndEqEnd(nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex))
            return true;
    }

    return false;
}

CDateTimeXScaleMng.prototype.XStartEqStart = function (nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex) {
    var XScaleItem = this.m_XScaleItemArray[XScaleItemArrayIndex.m_nIndex];
    var tXScaleItemStart = XScaleItem.GetStart();
    var tXScaleItemEnd = XScaleItem.GetEnd();
    var nXScaleItemCycle = XScaleItem.GetCycle();
    var nXScaleItemInterval = XScaleItem.GetInterval();

    if (tXScaleItemEnd === tEnd) {
        if (this.XStartEqStartAndXEndEqEnd(nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex))
            return true;
    }
    else if (tXScaleItemEnd < tEnd) {
        if (this.XStartEqStartAndXEndSTEnd(nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex))
            return true;
    }
    else if (tEnd < tXScaleItemEnd) {
        if (this.XStartEqStartAndEndSTXEnd(nCycle, nInterval, tStart, tEnd, XScaleItemArrayIndex, DateTimeArrayIndex))
            return true;
    }

    return false;
}

CDateTimeXScaleMng.prototype.AppendXItem = function (nCycle, nInterval, tStart, tEnd, rNextTime, rPrevItem) {

    var bProcess = false;

    this.m_MinIntervalArray[nCycle - 1].m_nInterval = CalcGCD(nInterval, this.m_MinIntervalArray[nCycle - 1].m_nInterval);

    if (rPrevItem !== null && rPrevItem.m_tEnd === tStart && rPrevItem.GetCycle() === nCycle)//데이터 시간이 연속적인 경우
    {
        rPrevItem.SetEnd(tEnd);
        rNextTime.m_tTime = tEnd;

        bProcess = true;
    }
    else {

        var pos1 = this.m_XScaleItemArray.length - 1;
        if (pos1 >= 0) {

            var XScaleItem = this.m_XScaleItemArray[pos1];
            var tXScaleItemStart = XScaleItem.GetStart();
            var tXScaleItemEnd = XScaleItem.GetEnd();
            var nXScaleItemCycle = XScaleItem.GetCycle();
            var nXScaleItemInterval = XScaleItem.GetInterval();

            if (tXScaleItemEnd < tStart) {
                bProcess = this.AppendXItemXEndSTStart(nCycle, nInterval, tStart, tEnd, rNextTime, rPrevItem);
            }
            else if (tXScaleItemEnd === tStart) {
                bProcess = this.AppendXItemXEndEqStart(nCycle, nInterval, tStart, tEnd, rNextTime, rPrevItem);
            }
            else if (tXScaleItemStart < tStart && tStart < tXScaleItemEnd) {
                bProcess = this.AppendXItemXStartSTStartAndStartSTXEnd(nCycle, nInterval, tStart, tEnd, rNextTime, rPrevItem);
            }
            else if (tStart < tXScaleItemStart) {
                bProcess = this.AppendXItemStartSTXStart(nCycle, nInterval, tStart, tEnd, rNextTime, rPrevItem);
            }
            else if (tXScaleItemStart === tStart) {
                bProcess = this.AppendXItemXStartEqStart(nCycle, nInterval, tStart, tEnd, rNextTime, rPrevItem);
            }
        }
    }

    return bProcess;
}

var gI = new CIterator(0);
var gJ = new CIterator(0);

CDateTimeXScaleMng.prototype.Merge = function (rDateTimePacketData, bAppend, nReceiveCnt)
{
    if (!rDateTimePacketData || rDateTimePacketData.m_nPacketType !== 2)
        return false;

    var i = gI;
    var j = gJ;
    var nCycle = rDateTimePacketData.GetCycle();
    var nInterval = rDateTimePacketData.GetInterval();
    var rDateTimeArray = rDateTimePacketData.GetDataArray();

    if (this.m_XScaleItemArray.length <= 0)
	{
        var tNextTime = 0;
        var PrevItem = null;
        this.m_MinIntervalArray[nCycle - 1].m_nInterval = nInterval;

        for (i.m_nIndex = 0; i.m_nIndex < rDateTimeArray.length; i.m_nIndex++) {
            var rDateTimeData = rDateTimeArray[i.m_nIndex];

            var strDateTime = rDateTimeData.GetDateTimeString();
            var tStart = rDateTimeData.GetDateTimeT();
            var tEnd = CalcDateTimeT(tStart, nCycle, nInterval);

            if (tNextTime === tStart && PrevItem !== null) {
                PrevItem.SetEnd(tEnd);
                tNextTime = tEnd;
            }
            else
            {
                var NewXScaleItem = new CDateTimeXScaleItem(this);
                NewXScaleItem.SetCycle(nCycle);
                NewXScaleItem.SetInterval(this.m_MinIntervalArray[nCycle - 1]);
                NewXScaleItem.SetStart(tStart);
                NewXScaleItem.SetEnd(tEnd);

                //console.log("NewXScaleItem strDateTime:" + strDateTime + " , Start:" + NewXScaleItem.m_dateStart.toLocaleString() + ", End:" + NewXScaleItem.m_dateEnd.toLocaleString());

                this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewXScaleItem;

                tNextTime = tEnd;
                PrevItem = NewXScaleItem;
            }
        }
    }
    else
	{
        var PrevItem = null;
        var rNextTime = new CTimeT();

        j.m_nIndex = -1;

        if (!bAppend)
		{

            for (i.m_nIndex = 0; i.m_nIndex < rDateTimeArray.length; i.m_nIndex++)
			{
                var rDateTimeData = rDateTimeArray[i.m_nIndex];
                var tStart = rDateTimeData.GetDateTimeT();
                var tEnd = CalcDateTimeT(tStart, nCycle, nInterval);
                var strStartDateTime = rDateTimeData.GetDateTimeString();
                var bBreak = false;

                ////////////////////////////////////////////////////////
                //머지를 위한 준비
                if (rDateTimeData.m_tStartTime4Merge === null)
                    rDateTimeData.m_tStartTime4Merge = tStart;
                if (rDateTimeData.m_nCycle4Merge === null)
                    rDateTimeData.m_nCycle4Merge = nCycle;
                if (rDateTimeData.m_nInterval4Merge === null)
                    rDateTimeData.m_nInterval4Merge = nInterval;

                this.m_rCurDateTimeData4Merge = rDateTimeData;
                ////////////////////////////////////////////////////////

                for (j.m_nIndex++; j.m_nIndex < this.m_XScaleItemArray.length; j.m_nIndex++)
				{
                    var rXScaleItem = this.m_XScaleItemArray[j.m_nIndex];
                    var tXScaleItemStart = rXScaleItem.GetStart();
                    var tXScaleItemEnd = rXScaleItem.GetEnd();
                    var nXScaleItemCycle = rXScaleItem.GetCycle();
                    var nXScaleItemInterval = rXScaleItem.GetInterval();

                    if (rDateTimeData.m_tStartTime4Merge < tXScaleItemStart)
					{
                        if (this.StartSTXStart(rDateTimeData.m_nCycle4Merge, rDateTimeData.m_nInterval4Merge, rDateTimeData.m_tStartTime4Merge, tEnd, j, i))
                        {
                            bBreak = true;
                            break;
                        }
                    }
                    else if (tXScaleItemStart < rDateTimeData.m_tStartTime4Merge)
					{
                        if (this.XStartSTStart(rDateTimeData.m_nCycle4Merge, rDateTimeData.m_nInterval4Merge, rDateTimeData.m_tStartTime4Merge, tEnd, j, i))
                        {
                            bBreak = true;
                            break;
                        }
                    }
                    else if (tXScaleItemStart === rDateTimeData.m_tStartTime4Merge)
					{
                        if (this.XStartEqStart(rDateTimeData.m_nCycle4Merge, rDateTimeData.m_nInterval4Merge, rDateTimeData.m_tStartTime4Merge, tEnd, j, i))
                        {
                            bBreak = true;
                            break;
                        }
                    }
                }

                if (bBreak === false)
				{
                    this.AppendXItem(rDateTimeData.m_nCycle4Merge, rDateTimeData.m_nInterval4Merge, rDateTimeData.m_tStartTime4Merge, tEnd, rNextTime, PrevItem);
                }
                else
				{
                    PrevItem = null;
                }
            }
		}
		else
		{//추가부르기
		
            if (nReceiveCnt)
			{

                if (nReceiveCnt > rDateTimeArray.length)
                    nReceiveCnt = rDateTimeArray.length;

                for (i.m_nIndex = 0; i.m_nIndex < nReceiveCnt; i.m_nIndex++)
				{
                    var rDateTimeData = rDateTimeArray[i.m_nIndex];
                    var tStart = rDateTimeData.GetDateTimeT();
                    var tEnd = CalcDateTimeT(tStart, nCycle, nInterval);
                    var strStartDateTime = rDateTimeData.GetDateTimeString();
                    var bBreak = false;
                    
                    ////////////////////////////////////////////////////////
                    //머지를 위한 준비
                    if (rDateTimeData.m_tStartTime4Merge === null)
                        rDateTimeData.m_tStartTime4Merge = tStart;
                    if (rDateTimeData.m_nCycle4Merge === null)
                        rDateTimeData.m_nCycle4Merge = nCycle;
                    if (rDateTimeData.m_nInterval4Merge === null)
                        rDateTimeData.m_nInterval4Merge = nInterval;

                    this.m_rCurDateTimeData4Merge = rDateTimeData;
                ////////////////////////////////////////////////////////

                    for (j.m_nIndex++; j.m_nIndex < this.m_XScaleItemArray.length; j.m_nIndex++)
					{
                        var rXScaleItem = this.m_XScaleItemArray[j.m_nIndex];
                        var tXScaleItemStart = rXScaleItem.GetStart();
                        var tXScaleItemEnd = rXScaleItem.GetEnd();
                        var nXScaleItemCycle = rXScaleItem.GetCycle();
                        var nXScaleItemInterval = rXScaleItem.GetInterval();

                        if (rDateTimeData.m_tStartTime4Merge < tXScaleItemStart)
						{
                            if (this.StartSTXStart(rDateTimeData.m_nCycle4Merge, rDateTimeData.m_nInterval4Merge, rDateTimeData.m_tStartTime4Merge, tEnd, j, i))
                            {
                                bBreak = true;
                                break;
                            }
                        }
                        else if (tXScaleItemStart < rDateTimeData.m_tStartTime4Merge)
						{
                            if (this.XStartSTStart(rDateTimeData.m_nCycle4Merge, rDateTimeData.m_nInterval4Merge, rDateTimeData.m_tStartTime4Merge, tEnd, j, i))
                            {
                                bBreak = true;
                                break;
                            }
                        }
                        else if (tXScaleItemStart === rDateTimeData.m_tStartTime4Merge)
						{
                            if (this.XStartEqStart(rDateTimeData.m_nCycle4Merge, rDateTimeData.m_nInterval4Merge, rDateTimeData.m_tStartTime4Merge, tEnd, j, i))
                            {
                                bBreak = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    return true;
}

CDateTimeXScaleMng.prototype.RealMerge = function (strRQ, rDateTimePacketData) {

    var i = gI;
    var j = gJ;

    var nCycle = rDateTimePacketData.GetCycle();
    var nInterval = rDateTimePacketData.GetInterval();
    var rDateTimeArray = rDateTimePacketData.GetDataArray();

    //rq가 하나인 경우 또는 XScaleItem이 하나도 없는 경우(최근에 상장되어 거래가 이루어지지 않았던 종목이 실시간 거래되는 상황)
    if (Object.keys(this.m_mapRQSet).length === 1 || this.m_XScaleItemArray.length <= 0) {

        var bNewXScaleItem = true;
        this.m_MinIntervalArray[nCycle - 1].m_nInterval = nInterval;

        var rDateTimeData = rDateTimeArray[rDateTimeArray.length - 1];
        var tStart = rDateTimeData.GetDateTimeT();
        var tEnd = CalcDateTimeT(tStart, nCycle, nInterval);

        //rq가 하나이고 XScaleItem 데이터가 존재하는 경우
        if (this.m_XScaleItemArray.length > 0) {

            var rDateTimeXScaleItem = this.m_XScaleItemArray[this.m_XScaleItemArray.length - 1];
            var tXScaleItemEnd = rDateTimeXScaleItem.GetEnd();
            if (tXScaleItemEnd == tStart) {

                rDateTimeXScaleItem.SetEnd(tEnd);
                bNewXScaleItem = false;

                this.m_nTotalMergeCnt++;
            }
        }

        if (bNewXScaleItem) {

            var NewXScaleItem = new CDateTimeXScaleItem(this);
            NewXScaleItem.SetCycle(nCycle);
            NewXScaleItem.SetInterval(this.m_MinIntervalArray[nCycle - 1]);
            NewXScaleItem.SetStart(tStart);
            NewXScaleItem.SetEnd(tEnd);
            this.m_XScaleItemArray[this.m_XScaleItemArray.length] = NewXScaleItem;

            NewXScaleItem.SetStartPos(this.m_nTotalMergeCnt);
            this.m_nTotalMergeCnt += NewXScaleItem.GetIntervalCnt();
        }

        //Add Merge (rq 1개인 경우 속도를 고려해서 함수호출 하지 않고 여기서 직접 MergeIndex 추가 및 셋팅)
        var XScaleMergeIndex = new CXScaleMergeIndex();
        XScaleMergeIndex.m_tStart = tStart;
        XScaleMergeIndex.m_nIndex = this.m_XScaleMergeArray.length;
        this.m_XScaleMergeArray[this.m_XScaleMergeArray.length] = XScaleMergeIndex;

        XScaleMergeIndex.m_mapRQPacketsItem[strRQ] = rDateTimeData.m_rRQPacketsItem;
        rDateTimeData.m_rRQPacketsItem.m_rXScaleMergeIndex = XScaleMergeIndex;
        
    }
    else {//rq가 복수개 존재하는 경우

        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        this.m_bInsertXScaleArray = false;
        this.m_bRemoveXScaleArray = false;

        var bMergeFinish = false;
        var rXScaleItem = null, tXScaleItemStart = null, tXScaleItemEnd = null, nXScaleItemCycle = null, nXScaleItemInterval = null;

        //DateTimePacketData 정보 얻어오기
        i.m_nIndex = rDateTimeArray.length - 1;


        var rDateTimeData = rDateTimeArray[i.m_nIndex];
        var tStart = rDateTimeData.GetDateTimeT();
        var tEnd = CalcDateTimeT(tStart, nCycle, nInterval);

        ////////////////////////////////////////////////////////////
        //XScaleItem 루프의 적절한 시작위치를 찾기 위한 처리로직
        ////////////////////////////////////////////////////////////
        j.m_nIndex = this.m_XScaleItemArray.length - 1;
        for (; j.m_nIndex >= 0; j.m_nIndex--) {

            rXScaleItem = this.m_XScaleItemArray[j.m_nIndex];

            tXScaleItemStart = rXScaleItem.GetStart();
            tXScaleItemEnd = rXScaleItem.GetEnd();

            if (tXScaleItemStart <= tStart) {

                if (tStart < tXScaleItemEnd) {
                    break;
                }
                else if (tXScaleItemEnd <= tStart) {
                    j.m_nIndex++;
                    break;
                }
            }
        }
        if (j.m_nIndex < 0)
            j.m_nIndex = 0;
        ///////////////////////////////////////////////////////////////

        var nFindXScaleIndex = j.m_nIndex;

        //머지시작위치로 부터 머지 시작
        ////////////////////////////////////////////////////////
        //머지를 위한 준비
        rDateTimeData.m_tStartTime4Merge = tStart;
        rDateTimeData.m_nCycle4Merge = nCycle;
        rDateTimeData.m_nInterval4Merge = nInterval;

        this.m_rCurDateTimeData4Merge = rDateTimeData;
        ////////////////////////////////////////////////////////

        for (; j.m_nIndex < this.m_XScaleItemArray.length; j.m_nIndex++) {//for문 루프내에서 머지 내부로직 상 this.m_XScaleItemArray Length가 증가할 수 있으므로 직접 length 프로퍼티 사용!!

            rXScaleItem = this.m_XScaleItemArray[j.m_nIndex];
            tXScaleItemStart = rXScaleItem.GetStart();
            tXScaleItemEnd = rXScaleItem.GetEnd();
            nXScaleItemCycle = rXScaleItem.GetCycle();
            nXScaleItemInterval = rXScaleItem.GetInterval();

            if (rDateTimeData.m_tStartTime4Merge < tXScaleItemStart) {
                if (this.StartSTXStart(rDateTimeData.m_nCycle4Merge, rDateTimeData.m_nInterval4Merge, rDateTimeData.m_tStartTime4Merge, tEnd, j, i)) {
                    bMergeFinish = true;
                    break;
                }
            }
            else if (tXScaleItemStart < rDateTimeData.m_tStartTime4Merge) {
                if (this.XStartSTStart(rDateTimeData.m_nCycle4Merge, rDateTimeData.m_nInterval4Merge, rDateTimeData.m_tStartTime4Merge, tEnd, j, i)) {
                    bMergeFinish = true;
                    break;
                }
            }
            else if (tXScaleItemStart === rDateTimeData.m_tStartTime4Merge) {
                if (this.XStartEqStart(rDateTimeData.m_nCycle4Merge, rDateTimeData.m_nInterval4Merge, rDateTimeData.m_tStartTime4Merge, tEnd, j, i)) {
                    bMergeFinish = true;
                    break;
                }
            }
        }

        if (bMergeFinish === false)
            this.AppendXItem(rDateTimeData.m_nCycle4Merge, rDateTimeData.m_nInterval4Merge, rDateTimeData.m_tStartTime4Merge, tEnd, gNextTime, null);

        //////////////////////////////////////////////////////////////////////////////////////////////////////////
        //전체개수 재계산

        var nXScaleItemArrayLength = this.m_XScaleItemArray.length;

        var nStartPos = null;
        var nCountDataCntStartIndexOnReal = nFindXScaleIndex - 3;//머지 로직상 시작위치(nFindXScaleIndex)로부터 이전으로 2개 index 이전에는 머지영향을 주지 않는다
        if (nCountDataCntStartIndexOnReal < 0) {
            nCountDataCntStartIndexOnReal = 0;
            nStartPos = 0;
        }
        else {

            rXScaleItem = this.m_XScaleItemArray[nCountDataCntStartIndexOnReal];
            nStartPos = rXScaleItem.GetStartPos() + rXScaleItem.GetIntervalCnt();
            nCountDataCntStartIndexOnReal++;
        }

        for (var nXScaleIndex = nCountDataCntStartIndexOnReal; nXScaleIndex < nXScaleItemArrayLength; nXScaleIndex++) {

            rXScaleItem = this.m_XScaleItemArray[nXScaleIndex];

            rXScaleItem.SetStartPos(nStartPos);
            nStartPos += rXScaleItem.GetIntervalCnt();
        }
        this.m_nTotalMergeCnt = nStartPos;

        this.RealArrange(rDateTimePacketData);

        //////////////////////////////////////////////////////////////////////////////////////////////////////////

        this.VerifyViewRange();//뷰 범위 조정..
    }

    return true;
}
/////////////////////////////////////////////////////////////////////////////////////////
//차트 하단 스크롤바 컨트롤 클래스
function CHTMLScrollCtrl(rChartCtrl, nScrollType) {
    //console.log("_________________"+rChartCtrl+"____________________");
    this.m_rChart = rChartCtrl;
    this.m_rGlobalProperty = this.m_rChart.m_GlobalProperty;
    this.m_nType = SCROLL_HORZ;
    this.m_rectPosition = new CRect();
    this.m_rectLeftBtn = new CRect();
    this.m_rectRightBtn = new CRect();
    this.m_rectTrackBtn = new CRect();
console.log("CHTMLScrollCtrl > " + nScrollType);
    //공현욱 스크롤컨트롤 크기타입 : 0 - General Type, 1 - Thin Type
    if( nScrollType === undefined || nScrollType == 0){
        this.m_nBtnWidth = 18;
        this.m_nScrollBarType = SCROLL_GENERAL_TYPE;
    }
    else{
        this.m_nBtnWidth = 0;
        this.m_nScrollBarType = nScrollType;
    }

    this.m_Min = null;
    this.m_Max = null;
    this.m_Page = null;
    this.m_Pos = null;
    this.m_nTimerID = 0;

    this.m_TrackBtnClickXPos = null;
    this.m_TrackBtnClickYPos = null;

    this.m_clrBack = this.m_rChart.GetColorByKey("background");
    if (this.m_clrBack === null)
        this.m_clrBack = "rgb(241, 241, 241)";

    this.m_clrBtn = "rgb(225,225,225)";
    this.m_clrArrow = "rgb(80, 80, 80)";
    //공현욱 General Type 기본 트랙버튼색상 변경(트랙오버 색상과 동일) >>
    // this.m_clrTrack = "rgb(255, 255, 255)";
    //this.m_clrTrack = "rgb(168,168,168)";

    this.m_clrTrack = this.m_rChart.GetColorByKey("clrTrack");
    if(this.m_clrTrack === null)
        this.m_clrTrack = "#c5c8cb";

    this.m_clrTrackAllBong = this.m_rChart.GetColorByKey("background");
    if (this.m_clrTrackAllBong === null)
        this.m_clrTrackAllBong = "rgb(255, 255, 255)";
    //공현욱 General Type 기본 트랙버튼색상 변경(트랙오버 색상과 동일) <<

    this.m_clrBtnClick = "rgb(120,120,120)";
    this.m_clrArrowClick = "rgb(255,255,255)";
    this.m_clrTrackClick = "rgb(120,120,120)";

    this.m_clrBtnOver = "rgb(210,210,210)";
    this.m_clrArrowOver = "rgb(80,80,80)";
    //this.m_clrTrackOver = "rgb(168,168,168)";
    this.m_clrTrackOver = "rgb(168,168,168)";

    this.m_clrBtnDisable = "rgb(241,241,241)";
    this.m_clrArrowDisable = "rgb(163,163,163)";

    //0:일반적인 스크롤 show상태, 1:좌측 버튼 마우스 오버상태, 2:좌측 버튼 마우스 클릭상태, 3:우측버튼 마우스 오버상태, 4:우측버튼 마우스 클릭상태, 5:썸 오버상태, 6:썸 클릭상태, 7:썸 좌측여백클릭, 8:썸 우측여백클릭, 9:프로그램 좌측스크롤 제어, 10:프로그램으로 우측스크롤 제어, 11:모바일터치용 죄측autoscroll, 12:모바일터치용 우측autoscroll
    this.m_ScrollStatus = 0;

   

    this.m_fMouseMove = null;
    this.m_fMouseUp = null;


    //현재 스크롤 컨트롤과 연결되어 있는 XScaleMng
    this.m_rXScaleMng = null;

    //모바일 터치용 자동 스크롤 기능 구현을 위해 필요한 멤버변수
    this.m_AutoVelocity = null;//속도
    this.m_AutoAccel = null;//가속도
    this.m_AutoDecel = null;
    this.m_nAutoScrollPrevTime = null;
    this.m_nAutoScrollCurTime = null;
    this.m_TimeInterval = 0;
    this.m_AutoMovePixel = 0;

    //엣지,ie에서 부드러운 스크롤 처리를 위해 타이머 사용하며 타이머에서 참고할 마우스 좌표 저장변수
    this.m_MouseMoveX = null;
    this.m_MouseMoveY = null;
};

CHTMLScrollCtrl.prototype.SetGlobalPropertyToChart = function () {

    this.m_clrBack = this.m_rGlobalProperty.m_clrBack;
}
CHTMLScrollCtrl.prototype.SetTimer = function () {
    var self = this;

    //console.log("CHTMLScrollCtrl.prototype.SetTimer");

    this.m_nTimerID = setInterval(function () {
        self.OnTimer();
    }, 100);
}
CHTMLScrollCtrl.prototype.KillTimer = function () {

    if (this.m_nTimerID != null) {
        clearInterval(this.m_nTimerID);
        this.m_nTimerID = null;

        //console.log("CHTMLScrollCtrl.prototype.KillTimer");
    }
}
CHTMLScrollCtrl.prototype.OnMouseDown = function (e) {
    
    var X = e.ChartXPos;
    var Y = e.ChartYPos;

    var nYMargin = 2;

    if (X < this.m_rectPosition.m_nLeft || this.m_rectPosition.m_nRight < X) {
        return false;
    }
    if (Y < this.m_rectPosition.m_nTop - nYMargin || nYMargin + this.m_rectPosition.m_nBottom < Y) {
        return false;
    }

    if ((this.m_rectLeftBtn.m_nLeft <= X && X <= this.m_rectLeftBtn.m_nRight) &&
        (this.m_rectLeftBtn.m_nTop - nYMargin <= Y && Y <= this.m_rectLeftBtn.m_nBottom + nYMargin)) {

        if (this.m_ScrollStatus != 2) {

            this.m_ScrollStatus = 2;
            this.SetTimer();
            this.Draw(this.m_rChart.m_DrawingInfo);
            this.m_rChart.BitBlt();
            //console.log("CHTMLScrollCtrl.prototype.OnMouseDown status=" + this.m_ScrollStatus);
        }
    }
    else if ((this.m_rectRightBtn.m_nLeft <= X && X <= this.m_rectRightBtn.m_nRight) &&
        (this.m_rectRightBtn.m_nTop - nYMargin <= Y && Y <= this.m_rectRightBtn.m_nBottom + nYMargin )) {

        if (this.m_ScrollStatus != 4) {
            this.m_ScrollStatus = 4;
            this.SetTimer();
            this.Draw(this.m_rChart.m_DrawingInfo);
            this.m_rChart.BitBlt();
        }
    }
    else if ((this.m_rectLeftBtn.m_nRight < X && X < this.m_rectTrackBtn.m_nLeft) &&
        (this.m_rectPosition.m_nTop - nYMargin <= Y && Y <= this.m_rectPosition.m_nBottom + nYMargin)) {

        if (this.m_ScrollStatus != 7) {
            this.m_ScrollStatus = 7;
            this.SetTimer();
        }
    }
    else if ((this.m_rectTrackBtn.m_nRight < X && X <= this.m_rectRightBtn.m_nLeft) &&
        (this.m_rectPosition.m_nTop - nYMargin <= Y && Y <= this.m_rectPosition.m_nBottom + nYMargin)) {

        if (this.m_ScrollStatus != 8) {
            this.m_ScrollStatus = 8;
            this.SetTimer();
        }
    }
    else if ((this.m_rectTrackBtn.m_nLeft <= X && X <= this.m_rectTrackBtn.m_nRight) &&
        (this.m_rectTrackBtn.m_nTop - nYMargin <= Y && Y <= this.m_rectTrackBtn.m_nBottom + nYMargin)) {

        if (this.m_ScrollStatus != 6) {

            this.m_ScrollStatus = 6;
            this.m_TrackBtnClickXPos = X;
            this.m_TrackBtnClickYPos = Y;
            
            var self = this;
            
            if (!this.m_fMouseMove) {

                this.m_fMouseMove = function (e) {

                    //ie,엣지 스크롤 예외처리
                    if (self.m_rChart.GetBrowserType() == 2) {

                        e.ChartXPos = e.offsetX - self.m_rChart.m_nMainBlockMargin;
                        e.ChartYPos = e.offsetY - self.m_rChart.m_nMainBlockMargin;

                        self.m_MouseMoveX = e.ChartXPos;
                        self.m_MouseMoveY = e.ChartYPos;
                    }
                    else
                        self.m_rChart.OnMouseMove(e);

                    //console.log("[scroll mousemove] X:" + self.m_MouseMoveX + ", Y:" + self.m_MouseMoveY);
                }
            }
            if (!this.m_fMouseUp) {

                this.m_fMouseUp = function (e) {

                    self.m_rChart.OnMouseUp(e);
                    
                    document.removeEventListener("mousemove", self.m_fMouseMove);
                    document.removeEventListener("mouseup", self.m_fMouseUp);

                    //ie,엣지 스크롤 예외처리
                    if (self.m_rChart.GetBrowserType() == 2) {
                        self.KillTimer();
                    }

                    self.m_rChart.SetEventReg();
                    //console.log("[scroll mouseup!!!]");
                }
            }

            if (this.m_fMouseMove) {

                if (this.m_rChart.m_DrawingInfo.m_ScreenCanvas.onmousemove)
                    this.m_rChart.m_DrawingInfo.m_ScreenCanvas.onmousemove = null;

                if (this.m_rChart.m_DrawingInfo.m_ScreenCanvas.onmouseout)
                    this.m_rChart.m_DrawingInfo.m_ScreenCanvas.onmouseout = null;
                    
                document.addEventListener("mousemove", this.m_fMouseMove);

                //ie,엣지 스크롤 예외처리
                if (this.m_rChart.GetBrowserType() == 2) {
                    this.m_MouseMoveX = e.ChartXPos;
                    this.m_MouseMoveY = e.ChartYPos;
                    this.SetTimer();//ie,엣지에서는 스크롤버튼 드래그시 타이머 동작시킴(끊어짐 현상 심하게 나타남)
                }
            }
            if (this.m_fMouseUp) {

                if (this.m_rChart.m_DrawingInfo.m_ScreenCanvas.onmouseup)
                    this.m_rChart.m_DrawingInfo.m_ScreenCanvas.onmouseup = null;

                document.addEventListener("mouseup", this.m_fMouseUp);
            }
        

            this.Draw(this.m_rChart.m_DrawingInfo);
            this.m_rChart.BitBlt();
        }
    }

    return true;
}
CHTMLScrollCtrl.prototype.OnMouseUp = function (e) {

    var X = e.ChartXPos;
    var Y = e.ChartYPos;

    this.KillTimer();

    if (this.m_ScrollStatus == 6)
        this.CalcTrackBtnSize(this.m_Min, this.m_Max, this.m_Page, this.m_Pos);

    this.m_ScrollStatus = 0;

    this.m_TrackBtnClickXPos = null;
    this.m_TrackBtnClickYPos = null;

    if (X < this.m_rectPosition.m_nLeft || this.m_rectPosition.m_nRight < X) {
        return false;
    }
    if (Y < this.m_rectPosition.m_nTop || this.m_rectPosition.m_nBottom < Y) {
        return false;
    }

    this.Draw(this.m_rChart.m_DrawingInfo);
    this.m_rChart.BitBlt();
    //console.log("CHTMLScrollCtrl.prototype.OnMouseUp");

    return true;
}

CHTMLScrollCtrl.prototype.OnMouseMove = function (e) {

    var X = e.ChartXPos;
    var Y = e.ChartYPos;

    //console.log("CHTMLScrollCtrl.prototype.OnMouseMove status= " + this.m_ScrollStatus);

    if (this.m_ScrollStatus == 6) {

        if (this.m_nType == SCROLL_HORZ) {

            var Delta = X - this.m_TrackBtnClickXPos;

            var nPrevLeft = this.m_rectTrackBtn.m_nLeft;
            var nPrevRight = this.m_rectTrackBtn.m_nRight;

            this.m_rectTrackBtn.m_nLeft += Delta;
            this.m_rectTrackBtn.m_nRight += Delta;

            if (Delta > 0 && this.m_rectTrackBtn.m_nRight > this.m_rectRightBtn.m_nLeft) {
                var Diff = this.m_rectTrackBtn.m_nRight - this.m_rectRightBtn.m_nLeft;
                this.m_rectTrackBtn.m_nLeft -= Diff;
                this.m_rectTrackBtn.m_nRight -= Diff;
            }
            else if (Delta < 0 && this.m_rectTrackBtn.m_nLeft < this.m_rectLeftBtn.m_nRight) {
                var Diff = this.m_rectLeftBtn.m_nRight - this.m_rectTrackBtn.m_nLeft;
                this.m_rectTrackBtn.m_nLeft += Diff;
                this.m_rectTrackBtn.m_nRight += Diff;
            }

            Delta = this.m_rectTrackBtn.m_nLeft - nPrevLeft;
            this.m_TrackBtnClickXPos += Delta;

            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //썸버튼의 픽셀 이동 정보를 이용하여 스크롤의 Position정보를 계산
            var nRealRangeWidth = this.m_rectPosition.Width() - this.m_rectLeftBtn.Width() - this.m_rectRightBtn.Width() - this.m_rectTrackBtn.Width();
            var nRealTrackXPos = this.m_rectTrackBtn.m_nLeft - this.m_rectLeftBtn.m_nRight;

            var dScrollPos = 0;
            if (nRealRangeWidth > 0) {
                dScrollPos = nRealTrackXPos / nRealRangeWidth * (this.m_Max - this.m_Min - this.m_Page);

                if (dScrollPos < this.m_Min)
                    dScrollPos = this.m_Min;
                else if (this.m_Max < dScrollPos)
                    dScrollPos = this.m_Max;
            }
            else
                dScrollPos = 0;

            var nScrollPos = Math.floor(dScrollPos);

            if (this.m_rChart.OnHScroll(this.m_ScrollStatus, this.m_Pos, nScrollPos - this.m_Pos)) {
                this.m_Pos = nScrollPos;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            this.Draw(this.m_rChart.m_DrawingInfo);
            this.m_rChart.BitBlt();
        }
        else if (this.m_nType == SCROLL_VERT) {

            var Delta = Y - this.m_TrackBtnClickYPos;

            var nPrevTop = this.m_rectTrackBtn.m_nTop;
            var nPrevBottom = this.m_rectTrackBtn.m_nBottom;

            this.m_rectTrackBtn.m_nTop += Delta;
            this.m_rectTrackBtn.m_nBottom += Delta;

            if (Delta > 0 && this.m_rectTrackBtn.m_nBottom > this.m_rectRightBtn.m_nTop) {
                var Diff = this.m_rectTrackBtn.m_nBottom - this.m_rectRightBtn.m_nTop;
                this.m_rectTrackBtn.m_nTop -= Diff;
                this.m_rectTrackBtn.m_nBottom -= Diff;
            }
            else if (Delta < 0 && this.m_rectTrackBtn.m_nTop < this.m_rectLeftBtn.m_nBottom) {
                var Diff = this.m_rectLeftBtn.m_nBottom - this.m_rectTrackBtn.m_nTop;
                this.m_rectTrackBtn.m_nTop += Diff;
                this.m_rectTrackBtn.m_nBottom += Diff;
            }

            Delta = this.m_rectTrackBtn.m_nTop - nPrevTop;
            this.m_TrackBtnClickYPos += Delta;

            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //썸버튼의 픽셀 이동 정보를 이용하여 스크롤의 Position정보를 계산
            var nRealRangeHeight = this.m_rectPosition.Height() - this.m_rectLeftBtn.Height() - this.m_rectRightBtn.Height() - this.m_rectTrackBtn.Height();
            var nRealTrackYPos = this.m_rectTrackBtn.m_nTop - this.m_rectLeftBtn.m_nBottom;

            var dScrollPos = 0;
            if (nRealRangeHeight > 0) {
                dScrollPos = nRealTrackYPos / nRealRangeHeight * (this.m_Max - this.m_Min - this.m_Page);

                if (dScrollPos < this.m_Min)
                    dScrollPos = this.m_Min;
                else if (this.m_Max < nScrollPos)
                    dScrollPos = this.m_Max;
            }
            else
                dScrollPos = 0;

            var nScrollPos = Math.floor(dScrollPos);

            if (this.m_rChart.OnVScroll(this.m_ScrollStatus, this.m_Pos, nScrollPos - this.m_Pos)) {
                this.m_Pos = nScrollPos;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            this.Draw(this.m_rChart.m_DrawingInfo);
            this.m_rChart.BitBlt();
        }

        return true;
    }

    if (X < this.m_rectPosition.m_nLeft || this.m_rectPosition.m_nRight < X) {

        this.KillTimer();

        if (this.m_ScrollStatus != 0) {
            this.m_ScrollStatus = 0;
            this.Draw(this.m_rChart.m_DrawingInfo);
            this.m_rChart.BitBlt();
        }
        return false;
    }
    if (Y < this.m_rectPosition.m_nTop || this.m_rectPosition.m_nBottom < Y) {

        this.KillTimer();

        if (this.m_ScrollStatus != 0) {
            this.m_ScrollStatus = 0;
            this.Draw(this.m_rChart.m_DrawingInfo);
            this.m_rChart.BitBlt();
        }

        return false;
    }

    if (this.m_ScrollStatus != 1 && this.m_ScrollStatus != 2 && (this.m_rectLeftBtn.m_nLeft <= X && X <= this.m_rectLeftBtn.m_nRight) &&
        (this.m_rectLeftBtn.m_nTop <= Y && Y <= this.m_rectLeftBtn.m_nBottom)) {
        this.m_ScrollStatus = 1;
        this.Draw(this.m_rChart.m_DrawingInfo);
        this.m_rChart.BitBlt();
    }
    else if (this.m_ScrollStatus != 3 && this.m_ScrollStatus != 4 && (this.m_rectRightBtn.m_nLeft <= X && X <= this.m_rectRightBtn.m_nRight) &&
        (this.m_rectRightBtn.m_nTop <= Y && Y <= this.m_rectRightBtn.m_nBottom)) {
        this.m_ScrollStatus = 3;
        this.Draw(this.m_rChart.m_DrawingInfo);
        this.m_rChart.BitBlt();
    }
    else if (this.m_ScrollStatus != 5 && this.m_ScrollStatus != 6 && (this.m_rectTrackBtn.m_nLeft <= X && X <= this.m_rectTrackBtn.m_nRight) &&
        (this.m_rectTrackBtn.m_nTop <= Y && Y <= this.m_rectTrackBtn.m_nBottom)) {
        this.m_ScrollStatus = 5;
        this.Draw(this.m_rChart.m_DrawingInfo);
        this.m_rChart.BitBlt();
    }
    else if (this.m_ScrollStatus != 0 && ((X < this.m_rectLeftBtn.m_nLeft || this.m_rectLeftBtn.m_nRight < X || Y < this.m_rectLeftBtn.m_nTop || this.m_rectLeftBtn.m_nBottom < Y) &&
        (X < this.m_rectRightBtn.m_nLeft || this.m_rectRightBtn.m_nRight < X || Y < this.m_rectRightBtn.m_nTop || this.m_rectRightBtn.m_nBottom < Y) &&
        (X < this.m_rectTrackBtn.m_nLeft || this.m_rectTrackBtn.m_nRight < X || Y < this.m_rectTrackBtn.m_nTop || this.m_rectTrackBtn.m_nBottom < Y))) {
        this.m_ScrollStatus = 0;
        this.Draw(this.m_rChart.m_DrawingInfo);
        this.m_rChart.BitBlt();
    }

    return true;
}

CHTMLScrollCtrl.prototype.OnMouseOut = function () {

    this.KillTimer();

    if (this.m_ScrollStatus != 0 && this.m_ScrollStatus != 6) {

        this.m_ScrollStatus = 0;
        this.Draw(this.m_rChart.m_DrawingInfo);

        this.m_rChart.BitBlt();
    }
}

CHTMLScrollCtrl.prototype.AutoSetTimer = function (TimeInterval) {

    var self = this;

    //console.log("CHTMLScrollCtrl.prototype.AutoSetTimer : " + TimeInterval);
    //this.m_rChart.m_strLog += ("\r\nCHTMLScrollCtrl.prototype.AutoSetTimer : " + TimeInterval);

    this.m_TimeInterval = TimeInterval;
    
    this.m_nTimerID = setInterval(function () {
        self.OnTimer();
    }, TimeInterval);

    this.m_nAutoScrollPrevTime = Date.now();//현재시간
};
//nDirectX//방향(멈춤:0, 좌측:-1, 우측:1)
CHTMLScrollCtrl.prototype.AutoScroll = function (IntervalTime, MovePixel, Velocity, Accel, nDirectX) {
    
    this.m_AutoVelocity = Velocity;
    this.m_AutoAccel = Accel;

    if (nDirectX > 0)
        this.m_ScrollStatus = 12;
    else
        this.m_ScrollStatus = 11;

    this.m_AutoMovePixel = MovePixel;
    
    this.AutoSetTimer(100);

};
CHTMLScrollCtrl.prototype.AutoScrollStop = function () {

    this.m_AutoVelocity = null;//속도
    this.m_AutoAccel = null;//가속도
    this.m_AutoDecel = null;//감속
    this.m_nAutoScrollPrevTime = null;
    this.m_nAutoScrollCurTime = null;
    this.m_ScrollStatus = 0;
    this.m_TimerInterval = 0;
    this.m_AutoMovePixel = 0;
    this.KillTimer();
};

CHTMLScrollCtrl.prototype.Scroll = function (nDelta, bDraw) {

    let nDiff = 0;
    if (0 < nDelta) {
        var nUpper = this.m_Max - this.m_Page;
        if (this.m_Pos <= nUpper) {

            nDiff = nUpper - (this.m_Pos + nDelta);
            if (nDiff < 0)
                nDelta += nDiff;

            var nOldScrollStatus = this.m_ScrollStatus;
            this.m_ScrollStatus = 10;

            if (this.m_rChart.OnHScroll(this.m_ScrollStatus, this.m_Pos, nDelta)) {
                this.m_Pos += nDelta;
                if (nUpper < this.m_Pos) this.m_Pos = nUpper;
                this.CalcTrackBtnSize(this.m_Min, this.m_Max, this.m_Page, this.m_Pos);

                //console.log("OnTimer status=4 this.CalcTrackBtnSize(this.m_Min(" + this.m_Min + "), this.m_Max(" + this.m_Max + "), this.m_Page(" + this.m_Page + "), this.m_Pos(" + this.m_Pos + ");");
                if(bDraw !== false)
                {
                    this.Draw(this.m_rChart.m_DrawingInfo);
                    this.m_rChart.BitBlt();
                }
            }
            this.m_ScrollStatus = nOldScrollStatus;
        }
    }
    else if (nDelta < 0) {

        if (this.m_Min <= this.m_Pos) {

            nDiff = (this.m_Pos + nDelta) - this.m_Min;
            if (nDiff < 0)
                nDelta -= nDiff;

            var nOldScrollStatus = this.m_ScrollStatus;
            this.m_ScrollStatus = 9;

            if (this.m_rChart.OnHScroll(this.m_ScrollStatus, this.m_Pos, -nDelta)) {
                this.m_Pos += nDelta;
                if (this.m_Min > this.m_Pos) this.m_Pos = this.m_Min;
                this.CalcTrackBtnSize(this.m_Min, this.m_Max, this.m_Page, this.m_Pos);

                //console.log("OnTimer status=2 this.CalcTrackBtnSize(this.m_Min(" + this.m_Min + "), this.m_Max(" + this.m_Max + "), this.m_Page(" + this.m_Page + "), this.m_Pos(" + this.m_Pos + ");");
                if(bDraw !== false)
                {
                    this.Draw(this.m_rChart.m_DrawingInfo);
                    this.m_rChart.BitBlt();
                }
            }

            this.m_ScrollStatus = nOldScrollStatus;
        }
    }
    return nDelta;//경계구간에서 실제 이동가능한 nDelta로 계산되므로 실제 이동한 nDelta를 리턴하여 외부에서도 필요시 참고할 수 있도록 한다
}
CHTMLScrollCtrl.prototype.OnTimer = function () {

    //console.log("CHTMLScrollCtrl.prototype.OnTimer");

    if (this.m_ScrollStatus == 2) {
        if (this.m_Min < this.m_Pos) {

            if (this.m_rChart.OnHScroll(this.m_ScrollStatus, this.m_Pos, 1)) {
                this.m_Pos--;
                if (this.m_Min > this.m_Pos) this.m_Pos = this.m_Min;
                this.CalcTrackBtnSize(this.m_Min, this.m_Max, this.m_Page, this.m_Pos);

                //console.log("OnTimer status=2 this.CalcTrackBtnSize(this.m_Min(" + this.m_Min + "), this.m_Max(" + this.m_Max + "), this.m_Page(" + this.m_Page + "), this.m_Pos(" + this.m_Pos + ");");
                this.Draw(this.m_rChart.m_DrawingInfo);

                this.m_rChart.BitBlt();
            }
        }
        else {

            this.KillTimer();
            this.m_rChart.SendEvent("Event_Scroll");
            //console.log("CHTMLScrollCtrl.prototype.OnTimer ScrollStatus=2 , this.m_rChart.SendEvent(Event_Scroll);");
        }
    }
    else if (this.m_ScrollStatus == 4) {

        var nUpper = this.m_Max - this.m_Page;
        if (nUpper > this.m_Pos) {

            if (this.m_rChart.OnHScroll(this.m_ScrollStatus, this.m_Pos, 1)) {
                this.m_Pos++;
                if (nUpper < this.m_Pos) this.m_Pos = nUpper;
                this.CalcTrackBtnSize(this.m_Min, this.m_Max, this.m_Page, this.m_Pos);

                //console.log("OnTimer status=4 this.CalcTrackBtnSize(this.m_Min(" + this.m_Min + "), this.m_Max(" + this.m_Max + "), this.m_Page(" + this.m_Page + "), this.m_Pos(" + this.m_Pos + ");");
                this.Draw(this.m_rChart.m_DrawingInfo);

                this.m_rChart.BitBlt();
            }
        }
        else {
            this.KillTimer();
        }
    }
    //엣지하고 ie에서 trackpos 드래그시 차트 스크롤 처리를 위해 추가
    else if (this.m_ScrollStatus == 6) {

        var X = this.m_MouseMoveX;
        var Y = this.m_MouseMoveY;

        if (this.m_nType == SCROLL_HORZ) {

            //console.log("CHTMLScroll OnTimer 6 X:" + X + ", Y:" + Y);

            var Delta = X - this.m_TrackBtnClickXPos;

            var nPrevLeft = this.m_rectTrackBtn.m_nLeft;
            var nPrevRight = this.m_rectTrackBtn.m_nRight;

            this.m_rectTrackBtn.m_nLeft += Delta;
            this.m_rectTrackBtn.m_nRight += Delta;

            if (Delta > 0 && this.m_rectTrackBtn.m_nRight > this.m_rectRightBtn.m_nLeft) {
                var Diff = this.m_rectTrackBtn.m_nRight - this.m_rectRightBtn.m_nLeft;
                this.m_rectTrackBtn.m_nLeft -= Diff;
                this.m_rectTrackBtn.m_nRight -= Diff;
            }
            else if (Delta < 0 && this.m_rectTrackBtn.m_nLeft < this.m_rectLeftBtn.m_nRight) {
                var Diff = this.m_rectLeftBtn.m_nRight - this.m_rectTrackBtn.m_nLeft;
                this.m_rectTrackBtn.m_nLeft += Diff;
                this.m_rectTrackBtn.m_nRight += Diff;
            }

            Delta = this.m_rectTrackBtn.m_nLeft - nPrevLeft;
            this.m_TrackBtnClickXPos += Delta;

            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //썸버튼의 픽셀 이동 정보를 이용하여 스크롤의 Position정보를 계산
            var nRealRangeWidth = this.m_rectPosition.Width() - this.m_rectLeftBtn.Width() - this.m_rectRightBtn.Width() - this.m_rectTrackBtn.Width();
            var nRealTrackXPos = this.m_rectTrackBtn.m_nLeft - this.m_rectLeftBtn.m_nRight;

            var dScrollPos = 0;
            if (nRealRangeWidth > 0) {
                dScrollPos = nRealTrackXPos / nRealRangeWidth * (this.m_Max - this.m_Min - this.m_Page);

                if (dScrollPos < this.m_Min)
                    dScrollPos = this.m_Min;
                else if (this.m_Max < dScrollPos)
                    dScrollPos = this.m_Max;
            }
            else
                dScrollPos = 0;

            var nScrollPos = Math.floor(dScrollPos);

            if (this.m_rChart.OnHScroll(this.m_ScrollStatus, this.m_Pos, nScrollPos - this.m_Pos)) {
                this.m_Pos = nScrollPos;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            this.Draw(this.m_rChart.m_DrawingInfo);
            this.m_rChart.BitBlt();
        }
        else if (this.m_nType == SCROLL_VERT) {

            var Delta = Y - this.m_TrackBtnClickYPos;

            var nPrevTop = this.m_rectTrackBtn.m_nTop;
            var nPrevBottom = this.m_rectTrackBtn.m_nBottom;

            this.m_rectTrackBtn.m_nTop += Delta;
            this.m_rectTrackBtn.m_nBottom += Delta;

            if (Delta > 0 && this.m_rectTrackBtn.m_nBottom > this.m_rectRightBtn.m_nTop) {
                var Diff = this.m_rectTrackBtn.m_nBottom - this.m_rectRightBtn.m_nTop;
                this.m_rectTrackBtn.m_nTop -= Diff;
                this.m_rectTrackBtn.m_nBottom -= Diff;
            }
            else if (Delta < 0 && this.m_rectTrackBtn.m_nTop < this.m_rectLeftBtn.m_nBottom) {
                var Diff = this.m_rectLeftBtn.m_nBottom - this.m_rectTrackBtn.m_nTop;
                this.m_rectTrackBtn.m_nTop += Diff;
                this.m_rectTrackBtn.m_nBottom += Diff;
            }

            Delta = this.m_rectTrackBtn.m_nTop - nPrevTop;
            this.m_TrackBtnClickYPos += Delta;

            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //썸버튼의 픽셀 이동 정보를 이용하여 스크롤의 Position정보를 계산
            var nRealRangeHeight = this.m_rectPosition.Height() - this.m_rectLeftBtn.Height() - this.m_rectRightBtn.Height() - this.m_rectTrackBtn.Height();
            var nRealTrackYPos = this.m_rectTrackBtn.m_nTop - this.m_rectLeftBtn.m_nBottom;

            var dScrollPos = 0;
            if (nRealRangeHeight > 0) {
                dScrollPos = nRealTrackYPos / nRealRangeHeight * (this.m_Max - this.m_Min - this.m_Page);

                if (dScrollPos < this.m_Min)
                    dScrollPos = this.m_Min;
                else if (this.m_Max < nScrollPos)
                    dScrollPos = this.m_Max;
            }
            else
                dScrollPos = 0;

            var nScrollPos = Math.floor(dScrollPos);

            if (this.m_rChart.OnVScroll(this.m_ScrollStatus, this.m_Pos, nScrollPos - this.m_Pos)) {
                this.m_Pos = nScrollPos;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            this.Draw(this.m_rChart.m_DrawingInfo);
            this.m_rChart.BitBlt();
        }

        return true;
    }
    else if (this.m_ScrollStatus == 7) {
        if (this.m_Min < this.m_Pos) {

            if (this.m_rChart.OnHScroll(this.m_ScrollStatus, this.m_Pos, this.m_Page)) {
                this.m_Pos -= this.m_Page;
                if (this.m_Min > this.m_Pos) this.m_Pos = this.m_Min;
                this.CalcTrackBtnSize(this.m_Min, this.m_Max, this.m_Page, this.m_Pos);

                //console.log("OnTimer status=2 this.CalcTrackBtnSize(this.m_Min(" + this.m_Min + "), this.m_Max(" + this.m_Max + "), this.m_Page(" + this.m_Page + "), this.m_Pos(" + this.m_Pos + ");");
                this.Draw(this.m_rChart.m_DrawingInfo);

                this.m_rChart.BitBlt();
            }
        }
        else {

            this.KillTimer();
            this.m_rChart.SendEvent("Event_Scroll");
            //console.log("CHTMLScrollCtrl.prototype.OnTimer  ScrollStatus=7 , this.m_rChart.SendEvent(Event_Scroll);");

        }
    }
    else if (this.m_ScrollStatus == 8) {

        var nUpper = this.m_Max - this.m_Page;
        if (nUpper > this.m_Pos) {

            if (this.m_rChart.OnHScroll(this.m_ScrollStatus, this.m_Pos, this.m_Page)) {
                this.m_Pos += this.m_Page;
                if (nUpper < this.m_Pos) this.m_Pos = nUpper;
                this.CalcTrackBtnSize(this.m_Min, this.m_Max, this.m_Page, this.m_Pos);

                //console.log("OnTimer status=4 this.CalcTrackBtnSize(this.m_Min(" + this.m_Min + "), this.m_Max(" + this.m_Max + "), this.m_Page(" + this.m_Page + "), this.m_Pos(" + this.m_Pos + ");");
                this.Draw(this.m_rChart.m_DrawingInfo);

                this.m_rChart.BitBlt();
            }
        }
		else {
            this.KillTimer();
        }
    }
    else if (this.m_ScrollStatus == 11 || this.m_ScrollStatus == 12) {

        var rXScaleMng = this.m_rChart.GetSelectedXScaleMng();
        if (!rXScaleMng) {
            this.AutoScrollStop();
            return;
        }
        if (!this.m_rChart.m_MainBlock.m_SelectedChartBlock) {
            this.AutoScrollStop();
            return;
        }

        var rectGraphRegion = this.m_rChart.m_MainBlock.m_SelectedChartBlock.m_rectGraphRegion;
        var nGraphRegionWidth = rectGraphRegion.Width();

        if (rXScaleMng.m_nType == DATETIME_TYPE) {

            if (nGraphRegionWidth > 0) {

                var nTotalCnt = rXScaleMng.GetMergeDataCnt();

                this.m_nAutoScrollCurTime = Date.now();
                var nDiffTime = this.m_nAutoScrollCurTime - this.m_nAutoScrollPrevTime;
                //var MovePixel = nDiffTime * this.m_AutoVelocity;
                var MovePixel = this.m_TimeInterval * this.m_AutoVelocity;

                //X pixel 좌표값으로부터 최소시간단위봉의 index 얻어냄
                var nStartXIndex, nEndXIndex;
                if (this.m_ScrollStatus == 12) {//과거데이터 보이는 방향으로 스크롤(좌에서 우)
                    nStartXIndex = GetXIndexByXPos(1, rectGraphRegion, rXScaleMng.m_nViewStartIndex, rXScaleMng.m_nViewEndIndex);
                    nEndXIndex = GetXIndexByXPos(1 + MovePixel, rectGraphRegion, rXScaleMng.m_nViewStartIndex, rXScaleMng.m_nViewEndIndex);
                }
                else {//최신데이터 보이는 방향으로 스크롤(우에서 좌)
                    nStartXIndex = GetXIndexByXPos(1 + MovePixel, rectGraphRegion, rXScaleMng.m_nViewStartIndex, rXScaleMng.m_nViewEndIndex);
                    nEndXIndex = GetXIndexByXPos(1, rectGraphRegion, rXScaleMng.m_nViewStartIndex, rXScaleMng.m_nViewEndIndex);
                }

                if (nTotalCnt <= nStartXIndex)
                    nStartXIndex = nTotalCnt - 1;
                else if (nStartXIndex < 0)
                    nStartXIndex = 0;

                if (nTotalCnt <= nEndXIndex)
                    nEndXIndex = nTotalCnt - 1;
                else if (nEndXIndex < 0)
                    nEndXIndex = 0;

                var nMoveScroll = nStartXIndex - nEndXIndex;

                if (nMoveScroll > 0) {
                    var nNextEndXIndex = rXScaleMng.m_nViewEndIndex + nMoveScroll;
                    var nDiff = nNextEndXIndex - (nTotalCnt - 1);
                    if (nDiff > 0) {
                        nMoveScroll -= nDiff;
                        this.AutoScrollStop();
                        return;
                    }

                }
                else if (nMoveScroll < 0) {
                    var nPrevStartXIndex = rXScaleMng.m_nViewStartIndex + nMoveScroll;
                    if (nPrevStartXIndex < 0) {
                        nMoveScroll -= nPrevStartXIndex;
                        this.AutoScrollStop();
                        return;
                    }
                }

                this.m_rChart.ExtractYScaleMinMax(true);
                this.Scroll(nMoveScroll);
                this.m_rChart.Draw(DRAW_CASE_RESIZE);

                if (!this.m_AutoDecel)
                    this.m_AutoDecel = 0.001;
                else
                    this.m_AutoDecel = this.m_AutoDecel * 2.5;//마찰력을 일정하다고 가정하고 가속도를 마찰력만큼 감소시킨다

                var NextVelocity = this.m_AutoVelocity - (this.m_AutoDecel * this.m_TimeInterval);

                //this.m_rChart.m_strLog += ("\r\nthis.m_AutoDecel:" + this.m_AutoDecel + ", 이전속도:" + this.m_AutoVelocity + ", 이후속도:" + NextVelocity);

                this.m_AutoVelocity = NextVelocity;

                if (this.m_AutoVelocity < 0) {
                    this.m_AutoVelocity = 0;
                    this.AutoScrollStop();
                    return;
                }

                this.m_nAutoScrollPrevTime = this.m_nAutoScrollCurTime;
                
                return;
            }
        }
        
        this.KillTimer();
    }
}
CHTMLScrollCtrl.prototype.SetType = function (nScrollType) {
    this.m_nType = nScrollType;
}
CHTMLScrollCtrl.prototype.SetRect = function (nLeft, nTop, nRight, nBottom) {
    this.m_rectPosition.SetRect(nLeft, nTop, nRight, nBottom);
}
CHTMLScrollCtrl.prototype.GetRect = function (rectScroll) {
    if (rectScroll == null || rectScroll == undefined)
        return false;

    rectScroll.SetRect(this.m_rect.m_nLeft, this.m_rect.m_nTop, this.m_rect.m_nRight, this.m_rect.m_nBottom);
    return true;
}
CHTMLScrollCtrl.prototype.SetSize = function (nLeft, nTop, nRight, nBottom) {
    this.m_rectPosition.SetRect(nLeft, nTop, nRight, nBottom);
    this.m_rectLeftBtn.SetRect(nLeft, nTop, nLeft + this.m_nBtnWidth, nBottom);
    this.m_rectRightBtn.SetRect(nRight - this.m_nBtnWidth, nTop, nRight, nBottom);

    this.CalcTrackBtnSize(this.m_Min, this.m_Max, this.m_Page, this.m_Pos);
}
CHTMLScrollCtrl.prototype.CalcTrackBtnSize = function (Min, Max, Page, Pos) {

    var Range = Max - Min;
    if (Range == 0) {
        this.m_rectTrackBtn.SetRect(0, this.m_rectPosition.m_nTop, 0, this.m_rectPosition.m_nBottom);
    }
    else {
        var nScrollWidth = this.m_rectPosition.Width() - this.m_rectLeftBtn.Width() - this.m_rectRightBtn.Width();
        if (nScrollWidth < 0) nScrollWidth = 0;
        var nTrackBtnWidth = nScrollWidth * (Page / Range);
        var nTrackXPos = this.m_rectLeftBtn.m_nRight + nScrollWidth * (Pos / Range);
        this.m_rectTrackBtn.SetRect(nTrackXPos, this.m_rectPosition.m_nTop, nTrackXPos + nTrackBtnWidth, this.m_rectPosition.m_nBottom);
    }

}
CHTMLScrollCtrl.prototype.SetScrollInfo = function (rXScaleMng, Min, Max, Page, Pos, bDraw) {

    this.m_rXScaleMng = rXScaleMng;

    var Diff = Max - Min;
    if (Page > Diff) {
        Page = Diff;
        Pos = 0;
    }

    this.m_Min = Min;
    this.m_Max = Max;
    this.m_Page = Page;
    this.m_Pos = Pos;

    this.CalcTrackBtnSize(this.m_Min, this.m_Max, this.m_Page, this.m_Pos);

    if (bDraw == true)
        this.Draw(this.m_rChart.m_DrawingInfo);
}
CHTMLScrollCtrl.prototype.Draw = function (DrawingInfo) {

    var nHorzMargin = this.m_rectLeftBtn.Width() - this.m_rectLeftBtn.Width() * 1 / 2;
    var nVertMargin = this.m_rectLeftBtn.Height() - this.m_rectLeftBtn.Height() * 1 / 2;

    var nHalfHorzMargin = nHorzMargin / 2;
    var nHalfVertMargin = nVertMargin / 2;

    var clrTrackBtn = this.m_clrTrack;
    var clrLeftBtn = 0, clrRightBtn = 0;
    var clrLeftArrow = 0, clrRightArrow = 0;
    var clrBtnOutLine = "#E1E1E1";

    DrawingInfo.m_Context.beginPath();
    DrawingInfo.m_Context.strokeStyle = clrBtnOutLine;
    DrawingInfo.m_Context.fillStyle = this.m_clrBack;

    DrawingInfo.m_Context.fillRect(this.m_rectPosition.m_nLeft, this.m_rectPosition.m_nTop, this.m_rectPosition.Width(), this.m_rectPosition.Height());
    //DrawingInfo.m_Context.strokeRect(this.m_rectPosition.m_nLeft + 0.5, this.m_rectPosition.m_nTop - 0.5, this.m_rectPosition.Width(), this.m_rectPosition.Height());

    DrawingInfo.m_Context.closePath();
    DrawingInfo.m_Context.stroke();


    //공현욱 스크롤컨트롤 크기타입 : 0 - General Type, 1 - Thin Type >>
    if( this.m_nScrollBarType === SCROLL_GENERAL_TYPE ){//Scroll General Type
        if (this.m_ScrollStatus == 1) {//좌측 버튼 마우스 오버
            clrLeftBtn = this.m_clrBtnOver;
            clrRightBtn = this.m_clrBtn;
            clrLeftArrow = this.m_clrArrowOver;
            clrRightArrow = this.m_clrArrow;
            clrTrackBtn = this.m_clrTrack;
        }
        else if (this.m_ScrollStatus == 2) {//좌측 버튼 마우스 클릭
            clrLeftBtn = this.m_clrBtnClick;
            clrRightBtn = this.m_clrBtn;
            clrLeftArrow = this.m_clrArrowClick;
            clrRightArrow = this.m_clrArrow;
            clrTrackBtn = this.m_clrTrack;
        }
        else if (this.m_ScrollStatus == 3) {//우측 버튼 마우스 오버
            clrLeftBtn = this.m_clrBtn;
            clrRightBtn = this.m_clrBtnOver;
            clrLeftArrow = this.m_clrArrow;
            clrRightArrow = this.m_clrArrowOver;
            clrTrackBtn = this.m_clrTrack;
        }
        else if (this.m_ScrollStatus == 4) {//우측 버튼 마우스 클릭
            clrLeftBtn = this.m_clrBtn;
            clrRightBtn = this.m_clrBtnClick;
            clrLeftArrow = this.m_clrArrow;
            clrRightArrow = this.m_clrArrowClick;
            clrTrackBtn = this.m_clrTrack;
        }
        else if (this.m_ScrollStatus == 5) {//썸 마우스 오버
            clrLeftBtn = this.m_clrBtn;
            clrRightBtn = this.m_clrBtn;
            clrLeftArrow = this.m_clrArrow;
            clrRightArrow = this.m_clrArrow;
            clrTrackBtn = this.m_clrTrackOver;
        }
        else if (this.m_ScrollStatus == 6) {//썸 마우스 클릭
            clrLeftBtn = this.m_clrBtn;
            clrRightBtn = this.m_clrBtn;
            clrLeftArrow = this.m_clrArrow;
            clrRightArrow = this.m_clrArrow;
            clrTrackBtn = this.m_clrTrackClick;
        }
        else {//일반적인 상황
            clrLeftBtn = this.m_clrBtn;
            clrRightBtn = this.m_clrBtn;
            clrLeftArrow = this.m_clrArrow;
            clrRightArrow = this.m_clrArrow;
            clrTrackBtn = this.m_clrTrack;
        }
    }
    else{//Scroll Thin Type
        //20190122 공현욱 봉전체보기 일 경우 스크롤 트랙버튼을 차트배경색과 동일하게 해준다.
        if( this.m_rectPosition.m_nLeft == this.m_rectTrackBtn.m_nLeft
            && this.m_rectPosition.m_nRight == this.m_rectTrackBtn.m_nRight ){
            clrTrackBtn = this.m_clrTrackAllBong;
        }
        else{
            clrTrackBtn = this.m_clrTrackClick;
        }
    }

    DrawingInfo.m_Context.fillStyle = clrTrackBtn;
    //DrawingInfo.m_Context.fillRect(this.m_rectTrackBtn.m_nLeft + 0.5, this.m_rectTrackBtn.m_nTop - 0.5, this.m_rectTrackBtn.Width(), this.m_rectTrackBtn.Height());
    DrawingInfo.m_Context.fillRect(this.m_rectTrackBtn.m_nLeft, this.m_rectTrackBtn.m_nTop, this.m_rectTrackBtn.Width(), this.m_rectTrackBtn.Height());

    if (this.m_nScrollBarType === SCROLL_GENERAL_TYPE) {

        DrawingInfo.m_Context.fillStyle = clrLeftBtn;
        //DrawingInfo.m_Context.fillRect(this.m_rectLeftBtn.m_nLeft + 0.5, this.m_rectLeftBtn.m_nTop - 0.5, this.m_rectLeftBtn.Width(), this.m_rectLeftBtn.Height());
        DrawingInfo.m_Context.fillRect(this.m_rectLeftBtn.m_nLeft + 0.5, this.m_rectLeftBtn.m_nTop, this.m_rectLeftBtn.Width(), this.m_rectLeftBtn.Height());

        DrawingInfo.m_Context.fillStyle = clrRightBtn;
        //DrawingInfo.m_Context.fillRect(this.m_rectRightBtn.m_nLeft + 0.5, this.m_rectRightBtn.m_nTop - 0.5, this.m_rectRightBtn.Width(), this.m_rectRightBtn.Height());
        DrawingInfo.m_Context.fillRect(this.m_rectRightBtn.m_nLeft + 0.5, this.m_rectRightBtn.m_nTop, this.m_rectRightBtn.Width(), this.m_rectRightBtn.Height());

        DrawingInfo.m_Context.beginPath();
        DrawingInfo.m_Context.strokeStyle = clrLeftArrow;
        DrawingInfo.m_Context.fillStyle = clrLeftArrow;

        DrawingInfo.m_Context.moveTo(this.m_rectLeftBtn.m_nRight - nHalfHorzMargin, this.m_rectLeftBtn.m_nTop + nHalfVertMargin);
        DrawingInfo.m_Context.lineTo(this.m_rectLeftBtn.m_nRight - nHalfHorzMargin, this.m_rectLeftBtn.m_nBottom - nHalfVertMargin);
        DrawingInfo.m_Context.lineTo(this.m_rectLeftBtn.m_nLeft + nHalfHorzMargin, this.m_rectLeftBtn.m_nBottom - this.m_rectLeftBtn.Height() / 2);
        DrawingInfo.m_Context.lineTo(this.m_rectLeftBtn.m_nRight - nHalfHorzMargin, this.m_rectLeftBtn.m_nTop + nHalfVertMargin);

        DrawingInfo.m_Context.closePath();
        DrawingInfo.m_Context.fill();

        DrawingInfo.m_Context.beginPath();
        DrawingInfo.m_Context.strokeStyle = clrRightArrow;
        DrawingInfo.m_Context.fillStyle = clrRightArrow;

        DrawingInfo.m_Context.moveTo(this.m_rectRightBtn.m_nLeft + nHalfHorzMargin, this.m_rectRightBtn.m_nTop + nHalfVertMargin);
        DrawingInfo.m_Context.lineTo(this.m_rectRightBtn.m_nLeft + nHalfHorzMargin, this.m_rectRightBtn.m_nBottom - nHalfVertMargin);
        DrawingInfo.m_Context.lineTo(this.m_rectRightBtn.m_nRight - nHalfHorzMargin, this.m_rectRightBtn.m_nBottom - this.m_rectRightBtn.Height() / 2);
        DrawingInfo.m_Context.lineTo(this.m_rectRightBtn.m_nLeft + nHalfHorzMargin, this.m_rectRightBtn.m_nTop + nHalfVertMargin);

        DrawingInfo.m_Context.closePath();
        DrawingInfo.m_Context.fill();

        DrawingInfo.m_Context.beginPath();
        DrawingInfo.m_Context.strokeStyle = clrBtnOutLine;

        DrawingInfo.m_Context.strokeRect(this.m_rectLeftBtn.m_nLeft + 0.5, this.m_rectLeftBtn.m_nTop, this.m_rectLeftBtn.Width(), this.m_rectLeftBtn.Height());
        DrawingInfo.m_Context.strokeRect(this.m_rectRightBtn.m_nLeft + 0.5, this.m_rectRightBtn.m_nTop, this.m_rectRightBtn.Width(), this.m_rectRightBtn.Height());
        DrawingInfo.m_Context.strokeRect(this.m_rectTrackBtn.m_nLeft + 0.5, this.m_rectTrackBtn.m_nTop, this.m_rectTrackBtn.Width(), this.m_rectTrackBtn.Height());

        DrawingInfo.m_Context.closePath();
        DrawingInfo.m_Context.stroke();
    }

    //공현욱 스크롤컨트롤 크기타입 : 0 - General Type, 1 - Thin Type <<
}
/////////////////////////////////////////////////////////////////////////////////
//CChartProperty
function CChartProperty() {
    this.m_clrBack = "#ffffff";
    this.m_nBlockType = 0;
}

/////////////////////////////////////////////////////////////////////////////////
//CMaxMinValue
function CMaxMinValue() {
    this.m_MaxValue = 0;
    this.m_MinValue = 0;
}


/////////////////////////////////////////////////////////////////////////////////
//CGlobalProperty
export function CGlobalProperty(rChart) {

    //this.m_rChart = rChart;

    //////////////////////////////////////////
    //배경설정창탭 설정
    //////////////////////////////////////////
    if (rChart !== undefined) {

        //배경
        this.m_strKeyOfClrBack = "background";
        this.m_clrBack = rChart.GetColorByKey(this.m_strKeyOfClrBack);
        if (this.m_clrBack === null)
            this.m_clrBack = "#ffffff";

        //세로격자 색
        this.m_strKeyOfClrVertLine = "vertLine";
        this.m_clrVertLine = rChart.GetColorByKey(this.m_clrVertLine);
        if (this.m_clrVertLine === null)
            this.m_clrVertLine = "#dedede";

        //가로격자선 색
        this.m_strKeyOfClrHorzLine = "horzLine";
        this.m_clrHorzLine = rChart.GetColorByKey(this.m_strKeyOfClrHorzLine);
        if (this.m_clrHorzLine === null)
            this.m_clrHorzLine = "#dedede";

        //글자색
        this.m_strKeyOfClrText = "text";
        this.m_clrText = rChart.GetColorByKey(this.m_strKeyOfClrText);
        if (this.m_clrText === null)
            this.m_clrText = "#000000";

        //십자선색
        this.m_strKeyOfClrCrossLine = "crossLine";
        this.m_clrCrossLine = rChart.GetColorByKey(this.m_strKeyOfClrCrossLine);
        if (this.m_clrCrossLine === null)
            this.m_clrCrossLine = "#000000";

        //십자선 데이터박스 배경색
        this.m_strKeyOfClrCrossTextBack = "crossTextBack";
        this.m_clrCrossTextBack = rChart.GetColorByKey(this.m_strKeyOfClrCrossTextBack);
        if (this.m_clrCrossTextBack === null)
            this.m_clrCrossTextBack = "#424242";

        //십자선 데이터 글자색
        this.m_strKeyOfClrCrossText = "crossText";
        this.m_clrCrossText = rChart.GetColorByKey(this.m_strKeyOfClrCrossText);
        if (this.m_clrCrossText === null)
            this.m_clrCrossText = "#000000";

        //마지막데이터 y축 표시 글자색
        this.m_strKeyOfClrLastestDataText = "lastestDataText";
        this.m_clrLastestDataText = rChart.GetColorByKey(this.m_strKeyOfClrLastestDataText);
        if (this.m_clrLastestDataText === null)
            this.m_clrLastestDataText = "#ffffff";

        this.m_strKeyOfClrYAxis = "YAxis";
        this.m_clrYAxis = rChart.GetColorByKey(this.m_strKeyOfClrYAxis);
        if (this.m_clrYAxis === null)
            this.m_clrYAxis = "#dedede";

        this.m_strKeyOfClrXAxis = "XAxis";
        this.m_clrXAxis = rChart.GetColorByKey(this.m_strKeyOfClrXAxis);
        if (this.m_clrXAxis === null)
            this.m_clrXAxis = "#dedede";
    }
    else {
        //배경
        this.m_strKeyOfClrBack = "background";
        this.m_clrBack = "#ffffff";

        //세로격자 색
        this.m_strKeyOfClrVertLine = "vertline";
        this.m_clrVertLine = "#000000";

        //가로격자선 색
        this.m_strKeyOfClrHorzLine = "horzline";
        this.m_clrHorzLine = "#000000";

        //글자색
        this.m_strKeyOfClrText = "text";
        this.m_clrText = "#000000";

        //십자선색
        this.m_strKeyOfClrCrossLine = "crossLine";
        this.m_clrCrossLine = "#000000";

        //십자선 데이터박스 배경색
        this.m_strKeyOfClrCrossTextBack = "crossTextBack";
        this.m_clrCrossTextBack = "#424242";

        //십자선 데이터 글자색
        this.m_strKeyOfClrCrossText = "crossText";
        this.m_clrCrossText = "#000000";

        //마지막데이터 y축 표시 글자색
        this.m_strKeyOfClrLastestDataText = "lastestDataText";
        this.m_clrLastestDataText = "#ffffff";

        this.m_strKeyOfClrYAxis = "YAxis";
        this.m_clrYAxis = "#dedede";

        this.m_strKeyOfClrXAxis = "XAxis";
        this.m_clrXAxis = "#dedede";
    }

    //세로격자선 종류
    this.m_nVertLineType = PS_SOLID;

    //세로격자선 두께
    this.m_nVertLineThickness = 1;

    //가로격자선 종류
    this.m_nHorzLineType = PS_SOLID;

    //가로격자선 두께
    this.m_nHorzLineThickness = 1;

    //십자선 타입
    this.m_nCrossLineType = PS_DOT;

    //십자선 두께
    this.m_nCrossLineThickness = 1;

    //종목의 시고저종값 보이기
    this.m_bShowItemOHLC = false;

    //지표명 보이기
    this.m_bShowIndicatorName = true;

    //지표인자 보이기
    this.m_bShowIndicatorParameter = true;

    //지표값보기
    this.m_bShowIndicatorValue = false;

    //////////////////////////////////////////
    //스케일창탭 설정
    //////////////////////////////////////////
    //Y축 눈금 오른쪽표시
    this.m_bShowRightYAxis = true;

    //Y축 눈금 왼쪽표시
    this.m_bShowLeftYAxis = false;

    //천단위 쉼표
    this.m_bShowThousandComma = true;

    this.m_bShowKUnit = true;//y축이 1000 단위가 넘어가면 1000단위로 보여주고 K뒤에 붙이기 옵션(현재 kovex설정창에는 없음)

    //우측픽셀여백(추세선 그려짐)
    this.m_nRightMargin = 20;//0부터 99까지 가능

    //상하여백(%)-가격차트만 설정
    this.m_nTopBottomMargin = 10;//0부터 50까지 가능

    //가격눈금 위 현재가(등락률)표시여부
    this.m_nShowLatestPriceType = 2;//최신 가격보이기 여부(0:보이지 않기, 1:보이는 영역에서 최신데이터, 2:시세 현재가)

    //현재가 등락률 표시방법
    this.m_nPriceChangeRatioType = 2;//최신 가격보이기 상태에서 등락률 옵션(0:등락률 보이지 않기, 1:전봉 대비 등락률, 2:전일가 대비 등락률 )

    //Y축 반전(가격차트)
    this.m_bInvertPriceYAxis = false;

    //복수개의 가격차트가 추가될 수 있는 구조이며 반전을 별도 y스케일만 셋팅할 수 있도록 ui구성되어 있다.
    //설정창을 통해서는 복수개의 가격차트가 일괄로 반전이 되어야하는 구조이므로 옵션이 변경되었을 경우만 감지해서 반영을 하기위해 해당변수 필요
    this.m_bChangeInvertOption = false;

    //Y축 로그스케일(가격차트)
    this.m_bLogPriceYAxis = false;

    //복수개의 가격차트가 추가될 수 있는 구조이며 로그스케일을 별도 y스케일만 셋팅할 수 있도록 ui구성되어 있다.
    //설정창을 통해서는 복수개의 가격차트가 일괄로 로그스케일 되어야하는 구조이므로 옵션이 변경되었을 경우만 감지해서 반영을 하기위해 해당변수 필요
    this.m_bChangeLogOption = false;

    //마지막 거래량표시
    this.m_nShowLatestVolumeType = 0;//최신 거래량보이기 여부(0:보이지 않기, 1:보이는 영역에서 최신데이터)

    //전거래량 대비 등락률표시
    this.m_nVolumeChangeRatioType = 1;//최신 거래량보이기 상태에서 등락률 옵션(0:등락률 보이지 않기, 1:전봉 대비 등락률);

    //////////////////////////////////////////
    //수치조회 모드(0:보이지 않기, 1:현재 마우스위치의 X시간 기준으로 추가되어 있는 모든 그래프의 데이터 보여주기, 2:현재 마우스위치의 X시간 기준으로 마우스 위치한 블록의 모든 그래프 데이터 보여주기, 3:현재 마우스위치의 X시간 기준으로 추가되어 있는 모든 그래프의 데이터를 차트영역에 보여주기)
    this.m_nShowDataListMode = 0;
    this.m_nDataListOpacity = 1;//0.75;//수치조회 창 투명도

    this.m_bShowCrossLine = true;//십자선 보이기 여부

    // 20190115 전중현 : 기준선, 트레이딩라인 설정정보 관리
    this.m_mapGuideLineProperty = {};
    this.m_rTradingLineProterty = null;

    //LKY 세계시간 인덱스 관리 >>
    this.m_ChartUniversalTime = 9;
    this.m_ChartUniversalIndex = -1;
    //LKY 세계시간 인덱스 관리 <<
    
    // 20190123 남형명 : 하단 메뉴 보이기 여부
    this.m_bShowBottomArea = false;
    // 20190123 남형명 : 하단 메뉴 보이기 여부

    //LKY 스마트 시그널 신호 설정 정보 관리>>
    this.m_SmartSignalLineProperty = new CSmartSignalProperty();

    //pc웹에서 마우스 드래그로 스크롤 여부
    this.m_bUseDragForScroll = true;

    //실봉 or 허봉 여부
    this.m_bRealBong = false;//true(실봉), false(허봉)

    this.m_bUseWheelScroll = true;//휠스크롤 사용여부
}

CGlobalProperty.prototype.GetUseWheelScroll = function () {
    return this.m_bUseWheelScroll;
}
CGlobalProperty.prototype.SetUseWheelScroll = function (bUseWheelScroll) {
    this.m_bUseWheelScroll = bUseWheelScroll;
}

CGlobalProperty.prototype.IsRealBong = function () {
    return this.m_bRealBong;
}
CGlobalProperty.prototype.SetRealBong = function (bRealBong) {
    this.m_bRealBong = bRealBong;
}

CGlobalProperty.prototype.SetUseDragForScroll = function (bUse) {
    this.m_bUseDragForScroll = bUse;
}
CGlobalProperty.prototype.GetUseDragForScroll = function () {
    return this.m_bUseDragForScroll;
}

CGlobalProperty.prototype.SetInvertYScale = function (bInvert) {

    //Y축 반전(가격차트)
    this.m_bInvertPriceYAxis = bInvert;

    //복수개의 가격차트가 추가될 수 있는 구조이며 반전을 별도 y스케일만 셋팅할 수 있도록 ui구성되어 있다.
    //설정창을 통해서는 복수개의 가격차트가 일괄로 반전이 되어야하는 구조이므로 옵션이 변경되었을 경우만 감지해서 반영을 하기위해 해당변수 필요
    this.m_bChangeInvertOption = true;
}
CGlobalProperty.prototype.SetLogYScale = function (bLog) {

    //Y축 로그스케일(가격차트)
    this.m_bLogPriceYAxis = bLog;

    //복수개의 가격차트가 추가될 수 있는 구조이며 로그스케일을 별도 y스케일만 셋팅할 수 있도록 ui구성되어 있다.
    //설정창을 통해서는 복수개의 가격차트가 일괄로 로그스케일 되어야하는 구조이므로 옵션이 변경되었을 경우만 감지해서 반영을 하기위해 해당변수 필요
    this.m_bChangeLogOption = true;
}

CGlobalProperty.prototype.InitChangeOption = function () {
    this.m_bChangeInvertOption = false;
    this.m_bChangeLogOption = false;
}

CGlobalProperty.prototype.SetDefaultColorOfTheme = function (rChart) {

    if (rChart !== undefined) {

        //배경
        this.m_strKeyOfClrBack = "background";
        this.m_clrBack = rChart.GetColorByKey(this.m_strKeyOfClrBack);
        if (this.m_clrBack === null)
            this.m_clrBack = "#ffffff";

        //세로격자 색
        this.m_strKeyOfClrVertLine = "vertLine";
        this.m_clrVertLine = rChart.GetColorByKey(this.m_clrVertLine);
        if (this.m_clrVertLine === null)
            this.m_clrVertLine = "#dedede";

        //가로격자선 색
        this.m_strKeyOfClrHorzLine = "horzLine";
        this.m_clrHorzLine = rChart.GetColorByKey(this.m_strKeyOfClrHorzLine);
        if (this.m_clrHorzLine === null)
            this.m_clrHorzLine = "#dedede";

        //글자색
        this.m_strKeyOfClrText = "text";
        this.m_clrText = rChart.GetColorByKey(this.m_strKeyOfClrText);
        if (this.m_clrText === null)
            this.m_clrText = "#000000";

        //십자선색
        this.m_strKeyOfClrCrossLine = "crossLine";
        this.m_clrCrossLine = rChart.GetColorByKey(this.m_strKeyOfClrCrossLine);
        if (this.m_clrCrossLine === null)
            this.m_clrCrossLine = "#000000";

        //십자선 데이터박스 배경색
        this.m_strKeyOfClrCrossTextBack = "crossTextBack";
        this.m_clrCrossTextBack = rChart.GetColorByKey(this.m_strKeyOfClrCrossTextBack);
        if (this.m_clrCrossTextBack === null)
            this.m_clrCrossTextBack = "#424242";

        //십자선 데이터 글자색
        this.m_strKeyOfClrCrossText = "crossText";
        this.m_clrCrossText = rChart.GetColorByKey(this.m_strKeyOfClrCrossText);
        if (this.m_clrCrossText === null)
            this.m_clrCrossText = "#000000";

        //마지막데이터 y축 표시 글자색
        this.m_strKeyOfClrLastestDataText = "lastestDataText";
        this.m_clrLastestDataText = rChart.GetColorByKey(this.m_strKeyOfClrLastestDataText);
        if (this.m_clrLastestDataText === null)
            this.m_clrLastestDataText = "#ffffff";

        this.m_strKeyOfClrYAxis = "YAxis";
        this.m_clrYAxis = rChart.GetColorByKey(this.m_strKeyOfClrYAxis);
        if (this.m_clrYAxis === null)
            this.m_clrYAxis = "#dedede";

        this.m_strKeyOfClrXAxis = "XAxis";
        this.m_clrXAxis = rChart.GetColorByKey(this.m_strKeyOfClrXAxis);
        if (this.m_clrXAxis === null)
            this.m_clrXAxis = "#dedede";
    }
    else {
        //배경
        this.m_strKeyOfClrBack = "background";
        this.m_clrBack = "#ffffff";

        //세로격자 색
        this.m_strKeyOfClrVertLine = "vertline";
        this.m_clrVertLine = "#000000";

        //가로격자선 색
        this.m_strKeyOfClrHorzLine = "horzline";
        this.m_clrHorzLine = "#000000";

        //글자색
        this.m_strKeyOfClrText = "text";
        this.m_clrText = "#000000";

        //십자선색
        this.m_strKeyOfClrCrossLine = "crossLine";
        this.m_clrCrossLine = "#000000";

        //십자선 데이터박스 배경색
        this.m_strKeyOfClrCrossTextBack = "crossTextBack";
        this.m_clrCrossTextBack = "#424242";

        //십자선 데이터 글자색
        this.m_strKeyOfClrCrossText = "crossText";
        this.m_clrCrossText = "#000000";

        //마지막데이터 y축 표시 글자색
        this.m_strKeyOfClrLastestDataText = "lastestDataText";
        this.m_clrLastestDataText = "#ffffff";

        this.m_strKeyOfClrYAxis = "YAxis";
        this.m_clrYAxis = "#dedede";

        this.m_strKeyOfClrXAxis = "XAxis";
        this.m_clrXAxis = "#dedede";
    }
}

CGlobalProperty.prototype.SetClrXAxis = function (clrXAxis) {

    this.m_strKeyOfClrXAxis = null;//칼라테이블과의 관계를 끊는다
    this.m_clrXAxis = clrXAxis;
}
CGlobalProperty.prototype.SetClrYAxis = function (clrYAxis) {

    this.m_strKeyOfClrYAxis = null;//칼라테이블과의 관계를 끊는다
    this.m_clrYAxis = clrYAxis;
}
CGlobalProperty.prototype.SetClrLastestDataText = function (clrLastestDataText) {

    this.m_strKeyOfClrLastestDataText = null;//칼라테이블과의 관계를 끊는다
    this.m_clrLastestDataText = clrLastestDataText;
}
CGlobalProperty.prototype.SetClrCrossText = function (clrCrossText) {

    this.m_strKeyOfClrCrossText = null;//칼라테이블과의 관계를 끊는다
    this.m_clrCrossText = clrCrossText;
}
CGlobalProperty.prototype.SetClrCrossTextBack = function (clrCrossTextBack) {

    this.m_strKeyOfClrCrossTextBack = null;//칼라테이블과의 관계를 끊는다
    this.m_clrCrossTextBack = clrCrossTextBack;
}
CGlobalProperty.prototype.SetClrCrossLine = function (clrCrossLine) {

    this.m_strKeyOfClrCrossLine = null;//칼라테이블과의 관계를 끊는다
    this.m_clrCrossLine = clrCrossLine;
}
CGlobalProperty.prototype.SetClrText = function (clrText) {

    this.m_strKeyOfClrText = null;//칼라테이블과의 관계를 끊는다
    this.m_clrText = clrText;
}
CGlobalProperty.prototype.SetClrHorzLine = function (clrHorzLine) {

    this.m_strKeyOfClrHorzLine = null;//칼라테이블과의 관계를 끊는다
    this.m_clrHorzLine = clrHorzLine;
}
CGlobalProperty.prototype.SetClrVertLine = function (clrVertLine) {

    this.m_strKeyOfClrVertLine = null;//칼라테이블과의 관계를 끊는다
    this.m_clrVertLine = clrVertLine;
}
CGlobalProperty.prototype.SetClrBack = function (clrBack) {

    this.m_strKeyOfClrBack = null;//칼라테이블과의 관계를 끊는다
    this.m_clrBack = clrBack;
}

CGlobalProperty.prototype.ChangeTheme = function (rChart, bDraw) {

    if (rChart === null || rChart === undefined)
        return;

    //1.배경
    if (this.m_strKeyOfClrBack !== null) {

        this.m_clrBack = rChart.GetColorByKey(this.m_strKeyOfClrBack);
        if (this.m_clrBack === null)
            this.m_clrBack = "#ffffff";
    }

    //2.세로격자 색
    if (this.m_strKeyOfClrVertLine !== null) {

        this.m_clrVertLine = rChart.GetColorByKey(this.m_strKeyOfClrVertLine);
        if (this.m_clrVertLine === null)
            this.m_clrVertLine = "#000000";
    }

    //3.가로격자선 색
    if (this.m_strKeyOfClrHorzLine !== null) {

        this.m_clrHorzLine = rChart.GetColorByKey(this.m_strKeyOfClrHorzLine);
        if (this.m_clrHorzLine === null)
            this.m_clrHorzLine = "#000000";
    }

    if(bDraw === true)
        rChart.Draw(DRAW_CASE_CHANGE_PROPERTY);
}

CGlobalProperty.prototype.GetDataListOpacity = function () {
    return this.m_nDataListOpacity;
}

CGlobalProperty.prototype.GetShowDataListMode = function () {
    return this.m_nShowDataListMode;
}

CGlobalProperty.prototype.SetShowDataListMode = function (value) {
    this.m_nShowDataListMode = value;
}

CGlobalProperty.prototype.IsVisibleCrossLine = function () {
    return this.m_bShowCrossLine;
}

CGlobalProperty.prototype.ShowCrossLine = function (bShowCrossLine) {
    this.m_bShowCrossLine = bShowCrossLine;
}

CGlobalProperty.prototype.GetRightMargin = function () {
    return this.m_nRightMargin;
}

CGlobalProperty.prototype.SetRightMargin = function (nRightMargin) {

    if (isNaN(nRightMargin) || nRightMargin == null)
        return false;
    
    if (nRightMargin < 0 || nRightMargin > 99 )
        return false;

    this.m_nRightMargin = nRightMargin;
    return true;
}

CGlobalProperty.prototype.GetTopBottomMargin = function () {
    return this.m_nTopBottomMargin;
}

CGlobalProperty.prototype.SetTopBottomMargin = function (nTopBottomMargin) {

    if (isNaN(nTopBottomMargin) || nTopBottomMargin == null)
        return false;
    
    if (nTopBottomMargin < 0 || nTopBottomMargin > 50)
        return false;

    this.m_nTopBottomMargin = nTopBottomMargin;
    return true;
}

CGlobalProperty.prototype.Copy = function (srcGlobalProperty) {

    //기본자료형은 아래 루프를 통해 모두 복사
    for (var attr in srcGlobalProperty) {
        
        if (srcGlobalProperty.hasOwnProperty(attr)) {
            if (typeof (srcGlobalProperty[attr]) !== 'object') {//개체는 아래부분에서 별도 복사
                this[attr] = srcGlobalProperty[attr];
            }
        }
    }

	// 20190115 전중현 : 기준선, 트레이딩라인 원본 데이터 생성
    if( srcGlobalProperty.m_rTradingLineProterty !== null && this.m_rTradingLineProterty)
        this.m_rTradingLineProterty.Copy(srcGlobalProperty.m_rTradingLineProterty);
    
    for( var strRQ in srcGlobalProperty.m_mapGuideLineProperty )
    {
        var rSrcGuideLineProperty = srcGlobalProperty.m_mapGuideLineProperty[strRQ];
        if (rSrcGuideLineProperty !== undefined)
        {
            var rGuideLineProperty = this.m_mapGuideLineProperty[strRQ];
            if(rGuideLineProperty !== undefined)
                rGuideLineProperty.Copy(rSrcGuideLineProperty);
        }
    }

    // 20190211 공현욱 스마트 시그널 신호 원본 데이터 생성
    if( srcGlobalProperty.m_SmartSignalLineProperty !== null )
    {
        if(!this.m_SmartSignalLineProperty)
            this.m_SmartSignalLineProperty = new CSmartSignalProperty();
        this.m_SmartSignalLineProperty.Copy(srcGlobalProperty.m_SmartSignalLineProperty);
    }   
}
// 20190214 공현욱 스마트시그널, 매매선(미체결), 알림(지정가), 평균매수가 사용유무 작업 >>
// 스마트시그널
CGlobalProperty.prototype.SetUseSmartSignal = function(bUseSmartSignal){

    this.m_SmartSignalLineProperty.m_bUseSmartSignal = bUseSmartSignal;
}
CGlobalProperty.prototype.GetUseSmartSignal = function(){

    return this.m_SmartSignalLineProperty.m_bUseSmartSignal;
}
// 매매선(미체결)
CGlobalProperty.prototype.SetUseNonContractLine = function(bUseNonContractLine){

    this.m_rTradingLineProterty.m_bShowNonContractLine = bUseNonContractLine;
}
CGlobalProperty.prototype.GetUseNonContractLine = function(){

    return this.m_rTradingLineProterty.m_bShowNonContractLine;
}
// 평균매수가
CGlobalProperty.prototype.SetUseAvgBuyPriceLine = function(bUseAvgBuyPriceLine){

    this.m_rTradingLineProterty.m_bShowAvgBuyPriceLine = bUseAvgBuyPriceLine;
}

CGlobalProperty.prototype.GetUseAvgBuyPriceLine = function(){

    return this.m_rTradingLineProterty.m_bShowAvgBuyPriceLine;
}
// 알림(지정가)
CGlobalProperty.prototype.SetUseAlarmLine = function(bUseAlarmLine){

    this.m_rTradingLineProterty.m_bShowAlarmLine = bUseAlarmLine;
}
CGlobalProperty.prototype.GetUseAlarmLine = function(){

    return this.m_rTradingLineProterty.m_bShowAlarmLine;
}
// 20190214 공현욱 스마트시그널, 매매선(미체결), 알림(지정가), 평균매수가 사용유무 작업 <<

CGlobalProperty.prototype.SetShowLatestPriceTypeForSetupHtml = function (nShowLatestPriceType) {
    if (nShowLatestPriceType === 2 || nShowLatestPriceType === 1) {

        if (this.m_nPriceChangeRatioType === 1)
            nShowLatestPriceType = 1;
        else if (this.m_nPriceChangeRatioType === 2)
            nShowLatestPriceType = 2;
        else {
            this.m_nPriceChangeRatioType = nShowLatestPriceType;
        }
    }
    this.m_nShowLatestPriceType = nShowLatestPriceType;
}
CGlobalProperty.prototype.SetShowLatestPriceTypeWithPriceChangeRatioType = function (nShowLatestPriceType) {

    if (nShowLatestPriceType === 2 || nShowLatestPriceType === 1)
        this.m_nPriceChangeRatioType = nShowLatestPriceType;
    
    this.m_nShowLatestPriceType = nShowLatestPriceType;
}
CGlobalProperty.prototype.SetShowLatestPriceType = function (nShowLatestPriceType) {
    this.m_nShowLatestPriceType = nShowLatestPriceType;
}
CGlobalProperty.prototype.GetShowLatestPriceType = function () {
    return this.m_nShowLatestPriceType;
}

CGlobalProperty.prototype.SetPriceChangeRatioTypeWithShowLatestPriceType = function (nPriceChangeRatioType) {
    this.m_nPriceChangeRatioType = nPriceChangeRatioType;
    if (nPriceChangeRatioType === 1 || nPriceChangeRatioType === 2)
        this.m_nShowLatestPriceType = nPriceChangeRatioType;
}

CGlobalProperty.prototype.SetPriceChangeRatioType = function (nPriceChangeRatioType) {
    this.m_nPriceChangeRatioType = nPriceChangeRatioType;
}
CGlobalProperty.prototype.GetPriceChangeRatioType = function () {
    return this.m_nPriceChangeRatioType;
}

CGlobalProperty.prototype.SetShowLatestVolumeType = function (nShowLatestVolumeType) {
    this.m_nShowLatestVolumeType = nShowLatestVolumeType;
}
CGlobalProperty.prototype.GetShowLatestVolumeType = function () {
    return this.m_nShowLatestVolumeType;
}

CGlobalProperty.prototype.SetVolumeChangeRatioType = function (nVolumeChangeRatioType) {
    this.m_nVolumeChangeRatioType = nVolumeChangeRatioType;
}
CGlobalProperty.prototype.GetVolumeChangeRatioType = function () {
    return this.m_nVolumeChangeRatioType;
}

// 20190115 전중현 : 기준선 설정관리 초기화 함수
// CGlobalProperty에서 GetProperty 사용 후 반드시 호출하여 초기화 해줘야 함
CGlobalProperty.prototype.ClearGuideLineInfo = function () {
    this.m_mapGuideLineProperty = {};
}

// 20190115 전중현 : 기준선 설정관련 >>
CGlobalProperty.prototype.GetGuideLineInfo = function ( strRQ, nLineIndex )
{
    var rLine;
    if( nLineIndex < 0 )
     return rLine;

    var rGuideLineProperty = this.m_mapGuideLineProperty[strRQ];
    if( rGuideLineProperty !== undefined )
        rLine = rGuideLineProperty.m_PriceLineArray[nLineIndex];

    return rLine;
}

CGlobalProperty.prototype.SetGuideLineColor = function (rChart, nLineIndex, clrLine) {

    for (var strRQ in rChart.m_mapRQSet)
    {
        var rLine = this.GetGuideLineInfo(strRQ, nLineIndex);
        if (rLine === undefined)
            continue;

        rLine.SetClrLine(clrLine);
    }
    return true;
}
CGlobalProperty.prototype.SetGuideLineType = function (rChart, nLineIndex, nLineType) {

    for (var strRQ in rChart.m_mapRQSet)
    {
        var rLine = this.GetGuideLineInfo(strRQ, nLineIndex);
        if (rLine === undefined)
            continue;

        rLine.m_nLineType = nLineType;
    }
    return true;
}
CGlobalProperty.prototype.SetGuideLineThickness = function (rChart, nLineIndex, nLineThickness) {

    for (var strRQ in rChart.m_mapRQSet)
    {
        var rLine = this.GetGuideLineInfo(strRQ, nLineIndex);
        if (rLine === undefined)
            continue;

        rLine.m_nThickness = nLineThickness;
    }
    return true;
}
CGlobalProperty.prototype.SetGuideLineShow = function (rChart, nLineIndex, bShow) {

    for (var strRQ in rChart.m_mapRQSet)
    {
        var rLine = this.GetGuideLineInfo(strRQ, nLineIndex);
        if (rLine === undefined)
            continue;

        rLine.m_bShow = bShow;
    }
    return true;
}
CGlobalProperty.prototype.GetGuideLineShowText = function ( strRQ )
{
    var rGuideLineProperty = this.m_mapGuideLineProperty[strRQ];
    return rGuideLineProperty.m_bShowText;
}

CGlobalProperty.prototype.SetGuideLineShowText = function ( strRQ, bShowFlag )
{
    var rGuideLineProperty = this.m_mapGuideLineProperty[strRQ];
    rGuideLineProperty.m_bShowText = bShowFlag;
}

CGlobalProperty.prototype.GetGuideLineShowLine = function ( strRQ )
{
    var rGuideLineProperty = this.m_mapGuideLineProperty[strRQ];
    return rGuideLineProperty.m_bShowLine;
}

CGlobalProperty.prototype.SetGuideLineShowLine = function ( strRQ, bShowFlag )
{
    var rGuideLineProperty = this.m_mapGuideLineProperty[strRQ];
    rGuideLineProperty.m_bShowLine = bShowFlag;
}

CGlobalProperty.prototype.GetGuideLineShowValue = function ( strRQ )
{
    var rGuideLineProperty = this.m_mapGuideLineProperty[strRQ];
    return rGuideLineProperty.m_bShowValue;
}

CGlobalProperty.prototype.SetGuideLineShowValue = function ( strRQ, bShowFlag )
{
    var rGuideLineProperty = this.m_mapGuideLineProperty[strRQ];
    rGuideLineProperty.m_bShowValue = bShowFlag;
}

CGlobalProperty.prototype.GetGuideLineTextPos = function ( strRQ )
{
    var rGuideLineProperty = this.m_mapGuideLineProperty[strRQ];
    return rGuideLineProperty.m_nTextPos;
}

CGlobalProperty.prototype.SetGuideLineTextPos = function ( strRQ, nPosType )
{
    if( nPosType > 2 || nPosType < 0 )
        nPosType = 1;

    var rGuideLineProperty = this.m_mapGuideLineProperty[strRQ];
    rGuideLineProperty.m_nTextPos = nPosType;
}
// 20190115 전중현 : 기준선 설정관련 <<

// 20190115 전중현 : 트레이딩라인 설정
CGlobalProperty.prototype.GetTradingLineInfo = function()
{
    return this.m_rTradingLineProterty;
}
// 20190212 공현욱 : 스마트시그널 신호라인 설정
CGlobalProperty.prototype.GetSmartSignalLineInfo = function()
{
    return this.m_SmartSignalLineProperty;
}

CGlobalProperty.prototype.SetUniversalTime = function(utcUniversalTime , nCheckIndex) {

    this.m_ChartUniversalTime = Number(utcUniversalTime)/60;
    this.m_ChartUniversalIndex = nCheckIndex;
}

CGlobalProperty.prototype.GetUniversalTime = function(){
    return this.m_ChartUniversalIndex;
}

// 20190123 남형명 : 하단 메뉴 보이기 여부 설정
CGlobalProperty.prototype.IsVisibleBottomArea = function () {
    return this.m_bShowBottomArea;
}

CGlobalProperty.prototype.SetShowBottomArea = function (bShowBottomArea) {
    this.m_bShowBottomArea = bShowBottomArea;
}
// 20190123 남형명 : 하단 메뉴 보이기 여부 설정

/////////////////////////////////////////////////////////////////////////////////
//CHTMLChart
export function CHTMLChart(strParentDivId, strScreenCanvasId, nScrollBarType, strThemeName) {
    // 20190123 공현욱 차트그리기 전에 CHTMLChart New할때 매개변수로 스크롤타입값을 .vue파일에서 넘겨줌. fullexchange.vue파일에서 화면별 스크롤바타입을 설정할 수 있음.
    console.log("test chtmlchart");

    this.m_strThemeName = strThemeName === undefined ? "default" : strThemeName;

    /////////////////////////////
    //전체 설정
    this.m_GlobalProperty = new CGlobalProperty(this);
    this.m_strBackupChartFullPropertyInJSON = null;
    //this.m_SmartSignalLineProperty = new CSmartSignalProperty(this);
    this.m_mapUserDefaultProperty = {};//사용자가 설정한 지표 기본값(키(지표명):설정개체)
    /////////////////////////////

    this.m_ChartParentDIV = document.getElementById(strParentDivId);
    
    this.m_mapRQSet = {};
    this.m_mapXScaleMng = {};
    
    this.CreateMainBlock();

    this.m_nScrollBarType = nScrollBarType === undefined ? SCROLL_GENERAL_TYPE : nScrollBarType;   // 20190123 공현욱 스크롤바 타입 초기화. 0 - General Type / 1 - Thin Type

    this.m_DrawingInfo = new CDrawingInfo();
    
    this.SetDefaultFontInfo();
    
    this.m_DrawingInfo.m_strScreenCanvasId = strScreenCanvasId;
    this.m_DrawingInfo.m_ScreenCanvas = document.getElementById(strScreenCanvasId);

    this.m_DrawingInfo.m_rectChart = new CRect();

    if (this.m_DrawingInfo.m_ScreenCanvas) {

        //초기화
        this.m_DrawingInfo.m_ScreenCanvas.width = this.m_DrawingInfo.m_ScreenCanvas.width;

        this.m_DrawingInfo.m_ScreenContext = this.m_DrawingInfo.m_ScreenCanvas.getContext("2d");
        this.m_DrawingInfo.m_ScreenContext.font = this.m_DrawingInfo.m_nFontSize + "px " + this.m_DrawingInfo.m_strFontName;
        this.m_DrawingInfo.m_rectChart.SetRect(this.m_DrawingInfo.m_ScreenCanvas.clientLeft, this.m_DrawingInfo.m_ScreenCanvas.clientTop,
            this.m_DrawingInfo.m_ScreenCanvas.clientLeft + this.m_DrawingInfo.m_ScreenCanvas.clientWidth, this.m_DrawingInfo.m_ScreenCanvas.clientTop + this.m_DrawingInfo.m_ScreenCanvas.clientHeight);

        var size = MeasureText("A", false, this.m_DrawingInfo.m_strFontName, this.m_DrawingInfo.m_nFontSize);
        this.m_DrawingInfo.m_nFontHeight = size[1];

        this.m_DrawingInfo.m_ScreenCanvas.m_HtmlChartCtrl = this;
    }
    else {
        this.m_DrawingInfo.m_ScreenContext = null;
        this.m_DrawingInfo.m_nFontHeight = 0;
    }

    this.m_DrawingInfo.m_rChartParentDIV = this.m_ChartParentDIV;

    this.m_nMainBlockMargin = 3;
    var nMainBlockLeft = this.m_DrawingInfo.m_rectChart.m_nLeft + this.m_nMainBlockMargin;
    var nMainBlockTop = this.m_DrawingInfo.m_rectChart.m_nTop + this.m_nMainBlockMargin;
    var nMainBlockRight = this.m_DrawingInfo.m_rectChart.m_nRight - this.m_nMainBlockMargin;
    var nMainBlockBottom = this.m_DrawingInfo.m_rectChart.m_nBottom - this.m_nMainBlockMargin - this.m_nScrollHeight;
    this.m_MainBlock.SetRect(nMainBlockLeft, nMainBlockTop, nMainBlockRight, nMainBlockBottom);
    
    //공현욱 스크롤컨트롤 크기타입, 화면별 스크롤타입 설정 : 0 - General Type, 1 - Thin Type
    
    this.m_ScrollCtrl = new CHTMLScrollCtrl(this, this.m_nScrollBarType);
    this.SetDefaultScrollHeight();
    this.m_ScrollCtrl.SetSize(nMainBlockLeft, nMainBlockBottom + 1, nMainBlockRight, nMainBlockBottom + this.m_nScrollHeight);
    this.m_ScrollCtrl.SetScrollInfo(null, 0, 1000, 100, 0);

    // 20190115 전중현 : 트레이딩라인 관리자 생성
    this.m_TradingLineMng = new CTradingLineMng(this);

    //LKY 스마트 시그널 신호 관리자 생성
    this.m_mapSmartSignalMng = {};

    //마우스 이벤트 등록
    this.SetEventReg();

    //더블버퍼링용 캔버스, 컨텍스트
    this.m_DrawingInfo.m_Canvas = document.createElement("Canvas");
    this.m_DrawingInfo.m_Context = this.m_DrawingInfo.m_Canvas.getContext("2d");
    if (this.m_DrawingInfo.m_ScreenContext) {
        this.m_DrawingInfo.m_Context.canvas.width = this.m_DrawingInfo.m_ScreenContext.canvas.width;
        this.m_DrawingInfo.m_Context.canvas.height = this.m_DrawingInfo.m_ScreenContext.canvas.height;
        this.m_DrawingInfo.m_Context.font = this.m_DrawingInfo.m_nFontSize + "px " + this.m_DrawingInfo.m_strFontName;

        this.m_DrawingInfo.m_Context.clearRect(0, 0, this.m_DrawingInfo.m_Context.canvas.width, this.m_DrawingInfo.m_Context.canvas.height);
    }

    this.m_bShowDataList = true;

    ////////////////////////////////////////////////
    //차트에서 발생시키는 이벤트 생성
    ////////////////////////////////////////////////
    //그래프 선택시 발생되는 이벤트
    this.m_SelectGraphEvent = document.createEvent('Event');
    this.m_SelectGraphEvent.initEvent('Event_SelectGraph', true, true);
    this.m_SelectGraphEvent.m_rChart = this;

    //스크롤이 마지막에 도달했을 때 발생되는 이벤트
    this.m_ScrollEvent = document.createEvent('Event');
    this.m_ScrollEvent.initEvent('Event_Scroll', true, true);
    this.m_ScrollEvent.m_rChart = this;

    // 20190115 전중현 : TradingLine 선택 이벤트(현재는 알림선 삭제만 제공)
    this.m_SelectTradingLineEvent = document.createEvent('Event');
    this.m_SelectTradingLineEvent.initEvent('Event_SelectTradingLine', true, true);
    this.m_SelectTradingLineEvent.m_rChart = this;

    //LKY 스마트시그널 신호 >>
    this.m_SelectSmartSignalLineEvent = document.createEvent('Event');
    this.m_SelectSmartSignalLineEvent.initEvent('Event_SelectSmartSignalLine', true, true);
    this.m_SelectSmartSignalLineEvent.m_rChart = this;

    // 20190123 남형명 : 하단메뉴 확장 이벤트
    this.m_ExtendBottomAreaEvent = document.createEvent('Event');
    this.m_ExtendBottomAreaEvent.initEvent('Event_ExtendBottomArea', true, true);
    this.m_ExtendBottomAreaEvent.m_GlobalProperty = this.m_GlobalProperty;

    // 20190214 전중현 : 분석툴 설정창 이벤트
    this.m_OpenToolSetupEvent = document.createEvent('Event');
    this.m_OpenToolSetupEvent.initEvent('Event_OpenToolSetup', true, true);
    this.m_OpenToolSetupEvent.m_rChart = this;

    //다국어테이블 로드완료 이벤트
    this.m_LoadLangEndEvent = document.createEvent('Event');
    this.m_LoadLangEndEvent.initEvent('Event_LoadLangEnd', true, true);
    this.m_LoadLangEndEvent.m_rChart = this;

    //차트 초기화 이벤트
    this.m_ResetChartEvent = document.createEvent('Event');
    this.m_ResetChartEvent.initEvent('Event_ResetChart', true, true);
    this.m_ResetChartEvent.m_rChart = this;

    //차트 저장
    this.m_SavePropertyEvent = document.createEvent('Event');
    this.m_SavePropertyEvent.initEvent('Event_SaveProperty', true, true);
    this.m_SavePropertyEvent.m_rChart = this;

    // 20190228 남형명 : 깊이차트 전환 이벤트
    this.m_ChangeDepthChartEvent = document.createEvent('Event');
    this.m_ChangeDepthChartEvent.initEvent('Event_ChangeDepthChart', true, true);
    this.m_ChangeDepthChartEvent.m_rChart = this.this;

    //지표설정창에서 지표추가는 하지 않은 상태에서 지표설정내용을 보여주어야 할 때 사용되는 임시PropertyInfo 저장공간
    this.m_TempDefaultIndicatorPropertyInfo = null;

    //test
    this.m_strLog = "";

    this.m_nXDayTextLen = null;
    this.m_nXWeekTextLen = null;
    this.m_nXMonthTextLen = null;
    this.m_nXYearTextLen = null;
    this.m_nXMinTextLen = null;
    this.m_nXSecTextLen = null;

    this.m_nTextLen = null;
    this.m_n2TextLen = null;
    this.m_n4TextLen = null;
    this.m_n5TextLen = null;
    this.m_n7TextLen = null;
    this.m_n8TextLen = null;

    //1:Chrome, 2:IE, 3:Opera, 4:Firefox, 5:Safari
    this.m_nBrowserType = null;
    this.m_strBrowserName = CheckBrowser();
    switch (this.m_strBrowserName) {
        case "Chrome":
            this.m_nBrowserType = 1; break;
        case "IE":
            this.m_nBrowserType = 2; break;
        case "Opera":
            this.m_nBrowserType = 3; break;
        case "Firefox":
            this.m_nBrowserType = 4; break;
        case "Safari":
            this.m_nBrowserType = 5; break;
    }
}

//이 함수는 일반 가격차트에서는 사용하지 않는다(SetRealData를 사용할 것)
//특수차트에서 실시간으로 현재가를 내부에서 참조해야 할 경우 사용할 수 있다
//현재는 CHogaDepthIndicator를 위해 차트외부에서 현재가를 이 함수를 통해 셋팅하고 있다.
CHTMLChart.prototype.SetRealCurPrice = function(strCode, CurPrice){

    for(var strRQ in this.m_mapRQSet){

        var rRQSet = this.m_mapRQSet[strRQ];
        if(rRQSet.m_RQInfo.m_strItemCode === strCode)
        {
            rRQSet.SetRealCurPrice(CurPrice);
        }
    }
}

CHTMLChart.prototype.ChangeLang = function(){

    var i, nLen = gDateLangKeyArray.length;
    for(i = 0 ; i < nLen; i++ ){
        gDateArray[i] = t(gDateLangKeyArray[i]);
    }
    
    for(var strXScaleKey in this.m_mapXScaleMng){

        var rXScaleMng = this.m_mapXScaleMng[strXScaleKey];
        rXScaleMng.ChangeLang();
    }

    for(var strRQ in this.m_mapRQSet){

        var rRQSet = this.m_mapRQSet[strRQ];
        rRQSet.ChangeLang();
    }

    this.m_MainBlock.ChangeLang();

    // 20190115 전중현 : 트레이딩라인 관리자 생성
    this.m_TradingLineMng.ChangeLang();

    //LKY 스마트 시그널 신호 관리자 생성
    for(var strCode in this.m_mapSmartSignalMng)
    {
        var rSmartSignalMng = this.m_mapSmartSignalMng[strCode];
        rSmartSignalMng.ChangeLang();
    }
}
//생성자 수정시 같이 수정필요(div 추가생성시 삭제처리 코드도 이곳에 추가할 것)
CHTMLChart.prototype.ResetChart = function (strParentDivId, strScreenCanvasId, nScrollBarType, strThemeName) {

    //////////////////////////////////////////////////
    //차트 내부의 div 삭제
    //////////////////////////////////////////////////
    this.HideToolMngBtn();
    this.m_MainBlock.HideToolTip();

    var ChartBlockArray = this.m_MainBlock.m_ChartBlockArray;
    var i,j,k, nChartBlockLen = ChartBlockArray.length;
    for (i = 0; i < nChartBlockLen; i++) {

        var rChartBlock = ChartBlockArray[i];
        rChartBlock.DestroyButton();

        var nGraphLen = rChartBlock.m_GraphArray.length;
        for (j = 0; j < nGraphLen; j++) {

            var rGraph = rChartBlock.m_GraphArray[j];
            var nSubGraphLen = rGraph.m_SubGraphArray.length;
            for (k = 0; k < nSubGraphLen; k++) {

                var rSubGraph = rGraph.m_SubGraphArray[k];
                rSubGraph.DestroyTitle();
            }
        }
    }

    //////////////////////////////////////////////////
    //테마명 설정
    this.m_strThemeName = strThemeName === undefined ? "default" : strThemeName;

    /////////////////////////////
    //전체 설정
    this.m_GlobalProperty = new CGlobalProperty(this);
    this.m_strBackupChartFullPropertyInJSON = null;
    //this.m_SmartSignalLineProperty = new CSmartSignalProperty(this);
    this.m_mapUserDefaultProperty = {};//사용자가 설정한 지표 기본값(키(지표명):설정개체)
    /////////////////////////////
    
    this.m_mapRQSet = {};
    this.m_mapXScaleMng = {};

    this.CreateMainBlock();

    this.m_nScrollBarType = nScrollBarType === undefined ? SCROLL_GENERAL_TYPE : nScrollBarType;   // 20190123 공현욱 스크롤바 타입 초기화. 0 - General Type / 1 - Thin Type

    var rCanvas = this.m_DrawingInfo.m_Canvas;
    var rContext = this.m_DrawingInfo.m_Context;

    this.m_DrawingInfo = new CDrawingInfo();
    this.m_DrawingInfo.m_Canvas = rCanvas;
    this.m_DrawingInfo.m_Context = rContext;

    this.SetDefaultFontInfo();

    this.m_DrawingInfo.m_rectChart = new CRect();

    this.m_DrawingInfo.m_strScreenCanvasId = strScreenCanvasId;
    this.m_DrawingInfo.m_ScreenCanvas = document.getElementById(strScreenCanvasId);

    if (this.m_DrawingInfo.m_ScreenCanvas) {

        this.m_DrawingInfo.m_ScreenContext = this.m_DrawingInfo.m_ScreenCanvas.getContext("2d");
        this.m_DrawingInfo.m_ScreenContext.font = this.m_DrawingInfo.m_nFontSize + "px " + this.m_DrawingInfo.m_strFontName;
        this.m_DrawingInfo.m_rectChart.SetRect(this.m_DrawingInfo.m_ScreenCanvas.clientLeft, this.m_DrawingInfo.m_ScreenCanvas.clientTop,
            this.m_DrawingInfo.m_ScreenCanvas.clientLeft + this.m_DrawingInfo.m_ScreenCanvas.clientWidth, this.m_DrawingInfo.m_ScreenCanvas.clientTop + this.m_DrawingInfo.m_ScreenCanvas.clientHeight);

        this.m_DrawingInfo.m_ScreenContext.clearRect(0, 0, this.m_DrawingInfo.m_ScreenCanvas.width, this.m_DrawingInfo.m_ScreenCanvas.height);

        var size = MeasureText("A", false, this.m_DrawingInfo.m_strFontName, this.m_DrawingInfo.m_nFontSize);
        this.m_DrawingInfo.m_nFontHeight = size[1];

        this.m_DrawingInfo.m_ScreenCanvas.m_HtmlChartCtrl = this;
    }
    else {
        this.m_DrawingInfo.m_ScreenContext = null;
        this.m_DrawingInfo.m_nFontHeight = 0;
    }

    this.m_DrawingInfo.m_rChartParentDIV = this.m_ChartParentDIV;
    
    var nMainBlockLeft = this.m_DrawingInfo.m_rectChart.m_nLeft + this.m_nMainBlockMargin;
    var nMainBlockTop = this.m_DrawingInfo.m_rectChart.m_nTop + this.m_nMainBlockMargin;
    var nMainBlockRight = this.m_DrawingInfo.m_rectChart.m_nRight - this.m_nMainBlockMargin;
    var nMainBlockBottom = this.m_DrawingInfo.m_rectChart.m_nBottom - this.m_nMainBlockMargin - this.m_nScrollHeight;
    this.m_MainBlock.SetRect(nMainBlockLeft, nMainBlockTop, nMainBlockRight, nMainBlockBottom);

    //공현욱 스크롤컨트롤 크기타입, 화면별 스크롤타입 설정 : 0 - General Type, 1 - Thin Type
    
    this.m_ScrollCtrl = new CHTMLScrollCtrl(this, this.m_nScrollBarType);
    this.SetDefaultScrollHeight();
    this.m_ScrollCtrl.SetSize(nMainBlockLeft, nMainBlockBottom + 1, nMainBlockRight, nMainBlockBottom + this.m_nScrollHeight);
    this.m_ScrollCtrl.SetScrollInfo(null, 0, 1000, 100, 0);

    // 20190115 전중현 : 트레이딩라인 관리자 생성
    this.m_TradingLineMng = new CTradingLineMng(this);

    //LKY 스마트 시그널 신호 관리자 생성
    this.m_mapSmartSignalMng = {};

    //더블버퍼링용 캔버스, 컨텍스트
    if (this.m_DrawingInfo.m_ScreenContext && this.m_DrawingInfo.m_Canvas && this.m_DrawingInfo.m_Context) {

        this.m_DrawingInfo.m_Context.canvas.width = this.m_DrawingInfo.m_ScreenContext.canvas.width;
        this.m_DrawingInfo.m_Context.canvas.height = this.m_DrawingInfo.m_ScreenContext.canvas.height;
        this.m_DrawingInfo.m_Context.font = this.m_DrawingInfo.m_nFontSize + "px " + this.m_DrawingInfo.m_strFontName;

        this.m_DrawingInfo.m_Context.clearRect(0, 0, this.m_DrawingInfo.m_Context.canvas.width, this.m_DrawingInfo.m_Context.canvas.height);
    }

    this.m_bShowDataList = true;

    ////////////////////////////////////////////////
    //차트에서 발생시키는 이벤트 생성
    ////////////////////////////////////////////////

    // 20190123 남형명 : 하단메뉴 확장 이벤트
    if (this.m_ExtendBottomAreaEvent)
        this.m_ExtendBottomAreaEvent.m_GlobalProperty = this.m_GlobalProperty;

    //지표설정창에서 지표추가는 하지 않은 상태에서 지표설정내용을 보여주어야 할 때 사용되는 임시PropertyInfo 저장공간
    this.m_TempDefaultIndicatorPropertyInfo = null;

    //test
    this.m_strLog = "";

    this.InitCtrl();

    //this.Resize(this.m_DrawingInfo.m_ScreenContext.canvas.width, this.m_DrawingInfo.m_ScreenContext.canvas.height, false);
}

CHTMLChart.prototype.ResizeUsingProperty = function(rMainBlockProperty, bDraw){
    
    this.m_MainBlock.CheckMaximumBlockUsingProperty(rMainBlockProperty);
    this.Resize(null, null, bDraw);
}

CHTMLChart.prototype.GetBlockRatioArrayFromChartFullProperty = function (rChartFullProperty) {

    var i, BlockRatioInfoArray = [];
    var nLen = rChartFullProperty.m_MainBlockProperty.m_ChartBlockPropertyArray.length;
    for (i = 0; i < nLen; i++) {
        var rChartBlockProperty = rChartFullProperty.m_MainBlockProperty.m_ChartBlockPropertyArray[i];
        BlockRatioInfoArray[i] = rChartBlockProperty.m_nBlockRatio;
    }

    return BlockRatioInfoArray;
}

CHTMLChart.prototype.GetGraphPropertyFromChartFullProperty = function (strRQ, strGraphName, rChartFullProperty) {

    if (rChartFullProperty == null || rChartFullProperty.m_MainBlockProperty == null)
        return null;

    var i, j, rChartBlockProperty, rChartBlockPropertyArray = rChartFullProperty.m_MainBlockProperty.m_ChartBlockPropertyArray;
    var nChartBlockPropArrayLen = rChartBlockPropertyArray.length;
    for (i = 0; i < nChartBlockPropArrayLen; i++) {

        rChartBlockProperty = rChartBlockPropertyArray[i];
        var rGraphProp, nGraphPropArrayLen = rChartBlockProperty.m_GraphPropertyArray.length;
        for (j = 0; j < nGraphPropArrayLen; j++) {

            rGraphProp = rChartBlockProperty.m_GraphPropertyArray[j];
            if (rGraphProp.m_strRQ === strRQ && rGraphProp.m_strGraphName === strGraphName) {
                return rGraphProp;
            }
        }
    }
    return null;
}

CHTMLChart.prototype.GetGraphPropertyArrayFromChartFullProperty = function (rChartFullProperty) {

    if (rChartFullProperty == null || rChartFullProperty.m_MainBlockProperty === null)
        return null;

    var GraphPropertyArray = [];
    var i, j, rChartBlockProperty, rChartBlockPropertyArray = rChartFullProperty.m_MainBlockProperty.m_ChartBlockPropertyArray;
    var nChartBlockPropArrayLen = rChartBlockPropertyArray.length;
    for (i = 0; i < nChartBlockPropArrayLen; i++) {

        rChartBlockProperty = rChartBlockPropertyArray[i];
        var rGraphProp, nGraphPropArrayLen = rChartBlockProperty.m_GraphPropertyArray.length;
        for (j = 0; j < nGraphPropArrayLen; j++)
            GraphPropertyArray[GraphPropertyArray.length] = rChartBlockProperty.m_GraphPropertyArray[j];
    }
    return GraphPropertyArray;
}

CHTMLChart.prototype.CreateBlockLayout = function (rMainBlockProperty) {

    this.m_MainBlock.CreateBlockLayout(rMainBlockProperty);
}

//차트설정창에서 확인버튼 선택시 마지막에 호출하는 함수
CHTMLChart.prototype.OKTotalProperty = function () {

    console.log("OKTotalProperty!!");
    this.SendEvent("Event_SaveProperty");
}

//차트설정창에서 취소버튼 선택시 호출하는 함수
CHTMLChart.prototype.CancelTotalProperty = function () {

    console.log("CancelTotalProperty!!");
    this.RestoreChartFullProperty();
}

//LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 >>>>>>>>>
CHTMLChart.prototype.SetCursor = function (strCursorType) {
    //console.log("SetCursor: %s", strCursorType);
    this.m_DrawingInfo.m_ScreenCanvas.style.cursor = strCursorType;
}
//LKY 블록 마우스 드래그 블록크기 확대축소 처리관련 <<<<<<<<<

CHTMLChart.prototype.GetChartFullProperty = function () {

    var strRQ;

    var ChartFullProperty = gChartFullProperty;

    //RQ 정보
    ChartFullProperty.m_mapRQProperty = {};
    for (strRQ in this.m_mapRQSet) {

        var rRQSet = this.m_mapRQSet[strRQ];
        ChartFullProperty.m_mapRQProperty[strRQ] = rRQSet.GetChartFullProperty();
    }

    //MainBlock 이하 정보
    ChartFullProperty.m_MainBlockProperty = this.m_MainBlock.GetChartFullProperty();

    //GlobalProperty 정보
    ChartFullProperty.m_GlobalProperty = this.m_GlobalProperty;

    ChartFullProperty.m_mapAllToolProperty = this.m_MainBlock.m_ToolMng.m_mapToolXScaleInfo;

    return ChartFullProperty;
}

CHTMLChart.prototype.GetDefaultChartFullProperty = function () {

    var strRQ;

    var ChartFullProperty = gChartFullProperty;

    //RQ 정보
    ChartFullProperty.m_mapRQProperty = {};
    ChartFullProperty.m_mapAllToolProperty = {};

    var strRQ = "RQ100";
    var RQProperty = new CRQProperty;
    RQProperty.SetProperty(strRQ, "", "", 1, 1, 50, true, "00000000", "99999999");
    ChartFullProperty.m_mapRQProperty[strRQ] = RQProperty;

    //MainBlock 이하 정보
    ChartFullProperty.m_MainBlockProperty = new CMainBlockProperty();
    ChartFullProperty.m_MainBlockProperty.m_nBlockType = VERT_BLOCK_TYPE;
    ChartFullProperty.m_MainBlockProperty.m_bBlockMaximize = false;
    ChartFullProperty.m_MainBlockProperty.m_ChartBlockPropertyArray[0] = new CChartBlockProperty();
    ChartFullProperty.m_MainBlockProperty.m_ChartBlockPropertyArray[1] = new CChartBlockProperty();

    //0번 블록설정 셋팅
    var rChartBlockProperty = ChartFullProperty.m_MainBlockProperty.m_ChartBlockPropertyArray[0];
    rChartBlockProperty.m_nColIndex = 0;
    rChartBlockProperty.m_nRowIndex = 0;
    rChartBlockProperty.m_nBlockRatio = 2;
    rChartBlockProperty.m_bBlockMaximize = false;
    rChartBlockProperty.m_BlockSizeRatio = 0.75;
    rChartBlockProperty.m_GraphPropertyArray[0] = new CGraphProperty();
    rChartBlockProperty.m_GraphPropertyArray[1] = new CGraphProperty();

    var rGraphProperty = rChartBlockProperty.m_GraphPropertyArray[0];
    rGraphProperty.m_strRQ = strRQ;
    rGraphProperty.m_strGraphName = "_PRICE_";
    rGraphProperty.m_nColIndex = 0;
    rGraphProperty.m_nRowIndex = 0;
    rGraphProperty.m_nVertScaleIndex = 0;
    rGraphProperty.m_nBlockRatio = 2;
    rGraphProperty.m_PropertyInfo = this.GetDefaultIndicatorProperty(rGraphProperty.m_strGraphName);
    
    var rGraphProperty = rChartBlockProperty.m_GraphPropertyArray[1];
    rGraphProperty.m_strRQ = strRQ;
    rGraphProperty.m_strGraphName = "_MA_";
    rGraphProperty.m_nColIndex = 0;
    rGraphProperty.m_nRowIndex = 0;
    rGraphProperty.m_nVertScaleIndex = 0;
    rGraphProperty.m_nBlockRatio = 2;
    rGraphProperty.m_PropertyInfo = this.GetDefaultIndicatorProperty(rGraphProperty.m_strGraphName);
    //////////////////////////////////////////////////////////////////////////////////////////////////
    //1번 블록설정 셋팅
    rChartBlockProperty = ChartFullProperty.m_MainBlockProperty.m_ChartBlockPropertyArray[1];
    rChartBlockProperty.m_nColIndex = 0;
    rChartBlockProperty.m_nRowIndex = 1;
    rChartBlockProperty.m_nBlockRatio = 1;
    rChartBlockProperty.m_bBlockMaximize = false;
    rChartBlockProperty.m_BlockSizeRatio = 0.25;
    rChartBlockProperty.m_GraphPropertyArray[0] = new CGraphProperty();
    rChartBlockProperty.m_GraphPropertyArray[1] = new CGraphProperty();
    
    var rGraphProperty = rChartBlockProperty.m_GraphPropertyArray[0];
    rGraphProperty.m_strRQ = strRQ;
    rGraphProperty.m_strGraphName = "_VOLUME_";
    rGraphProperty.m_nColIndex = 0;
    rGraphProperty.m_nRowIndex = 1;
    rGraphProperty.m_nVertScaleIndex = 0;
    rGraphProperty.m_nBlockRatio = 1;
    rGraphProperty.m_PropertyInfo = this.GetDefaultIndicatorProperty(rGraphProperty.m_strGraphName);
    
    var rGraphProperty = rChartBlockProperty.m_GraphPropertyArray[1];
    rGraphProperty.m_strRQ = strRQ;
    rGraphProperty.m_strGraphName = "_VMA_";
    rGraphProperty.m_nColIndex = 0;
    rGraphProperty.m_nRowIndex = 1;
    rGraphProperty.m_nVertScaleIndex = 0;
    rGraphProperty.m_nBlockRatio = 1;
    rGraphProperty.m_PropertyInfo = this.GetDefaultIndicatorProperty(rGraphProperty.m_strGraphName);
    /////////////////////////////////////////////////////////////////////////////////////////////////

    //GlobalProperty 정보
    ChartFullProperty.m_GlobalProperty = this.m_GlobalProperty;

    return ChartFullProperty;
}

CHTMLChart.prototype.GetDefaultRQInfo = function(){

    var strRQ;
    for(strRQ in this.m_mapRQSet)
    {
        var rRQSet = this.m_mapRQSet[strRQ];
        return rRQSet.m_RQInfo;//첫번째 등록되어 있는 rq가 default rq이다
    }
    return null;
}

CHTMLChart.prototype.GetChartFullPropertyInJSONString = function () {

    var ChartFullProperty = this.GetChartFullProperty();
    return JSON.stringify(ChartFullProperty);
}

// 20190214 공현욱 스마트시그널, 매매선(미체결), 알림(지정가), 평균매수가 사용유무 작업 >>
CHTMLChart.prototype.SetUseSmartSignal = function (bUseSmartSignal) {

    this.m_GlobalProperty.SetUseSmartSignal(bUseSmartSignal);
}

CHTMLChart.prototype.GetUseSmartSignal = function(){

    return this.m_GlobalProperty.GetUseSmartSignal();
}

CHTMLChart.prototype.SetUseNonContractLine = function(bUseContractLine){

    this.m_GlobalProperty.SetUseNonContractLine(bUseContractLine);
}
CHTMLChart.prototype.GetUseNonContractLine = function(){

    return this.m_GlobalProperty.GetUseNonContractLine();
}

CHTMLChart.prototype.SetUseAlarmLine = function(bUseAlarmLine){

    this.m_GlobalProperty.SetUseAlarmLine(bUseAlarmLine);
}
CHTMLChart.prototype.GetUseAlarmLine = function(){

    return this.m_GlobalProperty.GetUseAlarmLine();
}

CHTMLChart.prototype.SetUseAvgBuyPriceLine = function(bUseAvgBuyPriceLine){

    this.m_GlobalProperty.SetUseAvgBuyPriceLine(bUseAvgBuyPriceLine);
}
CHTMLChart.prototype.GetUseAvgBuyPriceLine = function(){

    return this.m_GlobalProperty.GetUseAvgBuyPriceLine();
}
// 20190214 공현욱 스마트시그널, 매매선(미체결), 알림(지정가), 평균매수가 사용유무 작업 <<

CHTMLChart.prototype.GetIndicatorPropertyInfo = function (strSelGraphKey) {

    let strNames = {};
    let indicatorInfoArray = {};

    for (var i in this.m_MainBlock.m_ChartBlockArray) {

        var rChartBlock = this.m_MainBlock.m_ChartBlockArray[i];
        for (var j in rChartBlock.m_GraphArray) {

            var rGraph = rChartBlock.m_GraphArray[j];
            var PropertyInfo = rGraph.GetPropertyInfo();

            indicatorInfoArray[rGraph.m_strKey] = {
                "m_strName": rGraph.m_strName,
                "isSelected": (rGraph.m_strKey === strSelGraphKey),
                "PropertyInfo": PropertyInfo
            };

            if (!strNames[rGraph.m_strName]) {
                strNames[rGraph.m_strName] = [];
            }
            strNames[rGraph.m_strName].push(rGraph.m_strKey);
        }
    }

    let IndicatorPropertyInfo = {
        "m_strNames": strNames,
        "m_indicatorInfoArray": indicatorInfoArray
    };

    return IndicatorPropertyInfo;
}

CHTMLChart.prototype.ChangeSubGraphSubType = function (strGraphKey, strSubGraphName, nSubGraphSubType, bDraw) {

    this.m_MainBlock.ChangeSubGraphSubType(strGraphKey, strSubGraphName, nSubGraphSubType);
    if (bDraw)
        this.Draw(DRAW_CASE_CHANGE_PROPERTY);
}

CHTMLChart.prototype.ChangeDefaultIndicatorProperty = function (strIndicatorName, DefaultPropertyInfo) {

    this.m_mapUserDefaultProperty[strIndicatorName] = DefaultPropertyInfo;
}

CHTMLChart.prototype.GetDefaultIndicatorProperty = function (strIndicatorName, bCreateClass) {

    var DefaultPropertyInfo = this.m_mapUserDefaultProperty[strIndicatorName];
    if (DefaultPropertyInfo == null) {

        DefaultPropertyInfo = DefaultIndicatorTable[strIndicatorName];
        if (DefaultPropertyInfo === undefined)
            return null;
    }

    if (bCreateClass === true)
    {
        if (strIndicatorName === "_PRICE_" || strIndicatorName === "_VOLUME_") {
            
            var IndicatorPropertyInfo1 = new CGraphPropertyInfo();
            IndicatorPropertyInfo1.SetPropertyInfo(DefaultPropertyInfo);
            IndicatorPropertyInfo1.m_strKey = DEFAULT_INDICATOR_KEY;
            return IndicatorPropertyInfo1;
        }
        else if (strIndicatorName === "_MA_" || strIndicatorName === "_VMA_") {

            var IndicatorPropertyInfo2 = new CMAGroupPropertyInfo();
            IndicatorPropertyInfo2.SetPropertyInfo(DefaultPropertyInfo);
            IndicatorPropertyInfo2.m_strKey = DEFAULT_INDICATOR_KEY;
            return IndicatorPropertyInfo2;
        }
        else {

            var IndicatorPropertyInfo3 = new CIndiPropertyInfo();
            IndicatorPropertyInfo3.SetPropertyInfo(DefaultPropertyInfo);
            IndicatorPropertyInfo3.m_strKey = DEFAULT_INDICATOR_KEY;
            return IndicatorPropertyInfo3;
        }
    }
    else {
        DefaultPropertyInfo.m_strKey = DEFAULT_INDICATOR_KEY;
        return DefaultPropertyInfo;
    }
}

CHTMLChart.prototype.SetDefaultIndicatorPropertyToChart = function (strIndicatorKey, strIndicatorName) {
    
    if (strIndicatorName === undefined) {

        var rCopyPropertyInfo = this.GetPropertyInfo(strIndicatorKey, true);
        if (!rCopyPropertyInfo)
            return null;

        strIndicatorName = rCopyPropertyInfo.m_strName;
    }

    var DefaultPropertyInfo = DefaultIndicatorTable[strIndicatorName];
    if (!DefaultPropertyInfo)
        return null;

    if (this.SetPropertyInfo(strIndicatorKey, DefaultPropertyInfo)) {

        rCopyPropertyInfo = this.GetPropertyInfo(strIndicatorKey, true);

        this.Draw(DRAW_CASE_CHANGE_PROPERTY);

        return rCopyPropertyInfo;
    }

    return null;
}

CHTMLChart.prototype.GetJSONStringFromDefaultIndicatorProp = function () {

    return JSON.stringify(this.m_mapUserDefaultProperty);
}

CHTMLChart.prototype.SetJSONStringToDefaultIndicatorProp = function (strDefaultIndicatorProp) {

    this.m_mapUserDefaultProperty = JSON.parse(strDefaultIndicatorProp);
}

CHTMLChart.prototype.GetTotalIndicatorProp = function () {

    var mapTotalIndicatorProp = {};//"지표명_키"를 키로 하는 설정맵구성

    this.m_MainBlock.GetTotalIndicatorProp(mapTotalIndicatorProp);

    return mapTotalIndicatorProp;
}
CHTMLChart.prototype.GetMainBlockRect = function () {
    return this.m_MainBlock.GetMainBlockRect();
}

CHTMLChart.prototype.SetGlobalPropertyToChart = function (bDraw) {

    //개체와 직접 연결되어 있지 않은 GlobalProperty 변수들을 개체에 적용하기 위한 처리
    this.m_MainBlock.SetGlobalPropertyToChart();
    this.m_ScrollCtrl.SetGlobalPropertyToChart();

    this.m_GlobalProperty.InitChangeOption();

    this.ExtractYScaleMinMax(true);

    if (bDraw === false)
        return;

    this.Draw(DRAW_CASE_SET_GLOBAL_PROPERTY);
}

CHTMLChart.prototype.GetColorByKey = function (strColorKey) {
    var ThemeTable = colorTable[this.m_strThemeName];
    if (ThemeTable === undefined)
        return null;

    var color = ThemeTable[strColorKey];
    if (color === undefined)
        return null;

    return color;
}

//가격차트, 이평, 거래량, 거래량 이평을 제외한 모든 지표 삭제함수
CHTMLChart.prototype.RemoveAllIndicator = function(){

    var strRemoveExceptIndicatorNameArray = ["_PRICE_","_MA_","_VOLUME_","_VMA_"];
    this.m_MainBlock.RemoveAllIndicatorExceptIndicator(strRemoveExceptIndicatorNameArray);
}

CHTMLChart.prototype.SetLogOfGlobalProperty = function () {

    var strRQ, rRQSet, rPriceGraph, bLog = true, bInvert = true, bIsPriceGraph = false;
    for (strRQ in this.m_mapRQSet) {

        rRQSet = this.m_mapRQSet[strRQ];
        rPriceGraph = rRQSet.IsExistGraphName("_PRICE_");
        if (rPriceGraph !== null) {

            bIsPriceGraph = true;
            if (rPriceGraph.GetLog() === false)
                bLog = false;
        }
    }
    
    if (bIsPriceGraph === true) {

        //가격차트가 모두 Log 스케일로 셋팅되어 있는 경우 GlobalProperty의 로그옵션을 true로 강제로 변경시킨다
        if (bLog === true)
            this.m_GlobalProperty.m_bLogPriceYAxis = true;
    }
}

CHTMLChart.prototype.SetInvertOfGlobalProperty = function () {

    var strRQ, rRQSet, rPriceGraph, bLog = true, bInvert = true, bIsPriceGraph = false;
    for (strRQ in this.m_mapRQSet) {

        rRQSet = this.m_mapRQSet[strRQ];
        rPriceGraph = rRQSet.IsExistGraphName("_PRICE_");
        if (rPriceGraph !== null) {

            bIsPriceGraph = true;
            if (rPriceGraph.GetInvert() === false)
                bInvert = false;
        }
    }

    if (bIsPriceGraph === true) {

        //가격차트가 모두 invert 스케일로 셋팅되어 있는 경우 GlobalProperty의 Invert옵션을 true로 강제로 변경시킨다
        if (bInvert === true)
            this.m_GlobalProperty.m_bInvertPriceYAxis = true;
    }

}

CHTMLChart.prototype.SetInvertYScaleByXY = function (X, Y, bInvert) {

    if (this.m_MainBlock.SetInvertYScaleByXY(X, Y, bInvert) !== null) {

        this.SetInvertOfGlobalProperty();

        this.Draw(DRAW_CASE_RESIZE);
    }
}

CHTMLChart.prototype.GetInvertYScaleByXY = function (X, Y) {

    return this.m_MainBlock.GetInvertYScaleByXY(X, Y);
}

CHTMLChart.prototype.SetLogYScaleByXY = function (X, Y, bLog) {

    if (this.m_MainBlock.SetLogYScaleByXY(X, Y, bLog) !== null) {

        this.SetLogOfGlobalProperty();

        this.Draw(DRAW_CASE_RESIZE);
    }
}

CHTMLChart.prototype.GetLogYScaleByXY = function (X, Y) {

    return this.m_MainBlock.GetLogYScaleByXY(X, Y);
}

CHTMLChart.prototype.ShowCrossLine = function (bShowCrossLine) {
    this.m_GlobalProperty.ShowCrossLine(bShowCrossLine);
    this.m_MainBlock.ShowCrossLine(bShowCrossLine);
}

CHTMLChart.prototype.IsRealBong = function () {
    return this.m_GlobalProperty.IsRealBong();
}

CHTMLChart.prototype.IsVisibleCrossLine = function () {
    return this.m_GlobalProperty.IsVisibleCrossLine();
}

CHTMLChart.prototype.GetGlobalProperty = function () {
    return this.m_GlobalProperty;
}

CHTMLChart.prototype.SetGlobalProperty = function (GlobalProperty) {

    this.m_GlobalProperty.Copy(GlobalProperty);
}

CHTMLChart.prototype.GetCloneGlobalProperty = function () {

    gCloneGlobalProperty.Copy(this.m_GlobalProperty);
    return gCloneGlobalProperty;
}

CHTMLChart.prototype.BackupChartFullProperty = function(){

    this.m_strBackupChartFullPropertyInJSON = this.GetChartFullPropertyInJSONString();
}

//설정창에서 취소버튼 클릭시 이전설정으로 모두 돌리기 위한 초기화 작업함수
CHTMLChart.prototype.ResetChartForRestore = function(){

    //////////////////////////////////////////////////
    //차트 내부의 div 삭제
    //////////////////////////////////////////////////
    this.HideToolMngBtn();
    this.m_MainBlock.HideToolTip();

    var ChartBlockArray = this.m_MainBlock.m_ChartBlockArray;
    var i,j,k, nChartBlockLen = ChartBlockArray.length;
    for (i = 0; i < nChartBlockLen; i++) {

        var rChartBlock = ChartBlockArray[i];
        rChartBlock.DestroyButton();

        var nGraphLen = rChartBlock.m_GraphArray.length;
        for (j = 0; j < nGraphLen; j++) {

            var rGraph = rChartBlock.m_GraphArray[j];
            var nSubGraphLen = rGraph.m_SubGraphArray.length;
            for (k = 0; k < nSubGraphLen; k++) {

                var rSubGraph = rGraph.m_SubGraphArray[k];
                rSubGraph.DestroyTitle();
            }
        }
    }

    this.m_GlobalProperty = new CGlobalProperty(this);
    //this.m_SmartSignalLineProperty = new CSmartSignalProperty(this);

    //메인블록 새로 생성
    this.CreateMainBlock();

    //캔버스를 DrawingInfo 새 개체에 셋팅
    var rCanvas = this.m_DrawingInfo.m_Canvas;
    var rContext = this.m_DrawingInfo.m_Context;
    var strScreenCanvasId = this.m_DrawingInfo.m_strScreenCanvasId;

    this.m_DrawingInfo = new CDrawingInfo();
    this.SetDefaultFontInfo();
    this.m_DrawingInfo.m_rectChart = new CRect();

    this.m_DrawingInfo.m_Canvas = rCanvas;
    this.m_DrawingInfo.m_Context = rContext;
    this.m_DrawingInfo.m_strScreenCanvasId = strScreenCanvasId;
    this.m_DrawingInfo.m_ScreenCanvas = document.getElementById(strScreenCanvasId);

    if (this.m_DrawingInfo.m_ScreenCanvas) {

        this.m_DrawingInfo.m_ScreenContext = this.m_DrawingInfo.m_ScreenCanvas.getContext("2d");
        this.m_DrawingInfo.m_ScreenContext.font = this.m_DrawingInfo.m_nFontSize + "px " + this.m_DrawingInfo.m_strFontName;
        this.m_DrawingInfo.m_rectChart.SetRect(this.m_DrawingInfo.m_ScreenCanvas.clientLeft, this.m_DrawingInfo.m_ScreenCanvas.clientTop,
            this.m_DrawingInfo.m_ScreenCanvas.clientLeft + this.m_DrawingInfo.m_ScreenCanvas.clientWidth, this.m_DrawingInfo.m_ScreenCanvas.clientTop + this.m_DrawingInfo.m_ScreenCanvas.clientHeight);

        this.m_DrawingInfo.m_ScreenContext.clearRect(0, 0, this.m_DrawingInfo.m_ScreenCanvas.width, this.m_DrawingInfo.m_ScreenCanvas.height);

        var size = MeasureText("A", false, this.m_DrawingInfo.m_strFontName, this.m_DrawingInfo.m_nFontSize);
        this.m_DrawingInfo.m_nFontHeight = size[1];

        this.m_DrawingInfo.m_ScreenCanvas.m_HtmlChartCtrl = this;
    }
    else {
        this.m_DrawingInfo.m_ScreenContext = null;
        this.m_DrawingInfo.m_nFontHeight = 0;
    }

    this.m_DrawingInfo.m_rChartParentDIV = this.m_ChartParentDIV;
    
    var nMainBlockLeft = this.m_DrawingInfo.m_rectChart.m_nLeft + this.m_nMainBlockMargin;
    var nMainBlockTop = this.m_DrawingInfo.m_rectChart.m_nTop + this.m_nMainBlockMargin;
    var nMainBlockRight = this.m_DrawingInfo.m_rectChart.m_nRight - this.m_nMainBlockMargin;
    var nMainBlockBottom = this.m_DrawingInfo.m_rectChart.m_nBottom - this.m_nMainBlockMargin - this.m_nScrollHeight;
    this.m_MainBlock.SetRect(nMainBlockLeft, nMainBlockTop, nMainBlockRight, nMainBlockBottom);
    
    // 20190115 전중현 : 트레이딩라인 관리자 생성
    this.m_TradingLineMng = new CTradingLineMng(this);

    //LKY 스마트 시그널 신호 관리자 생성
    //this.m_mapSmartSignalMng = {};

    //더블버퍼링용 캔버스, 컨텍스트
    if (this.m_DrawingInfo.m_ScreenContext && this.m_DrawingInfo.m_Canvas && this.m_DrawingInfo.m_Context) {

        this.m_DrawingInfo.m_Context.canvas.width = this.m_DrawingInfo.m_ScreenContext.canvas.width;
        this.m_DrawingInfo.m_Context.canvas.height = this.m_DrawingInfo.m_ScreenContext.canvas.height;
        this.m_DrawingInfo.m_Context.font = this.m_DrawingInfo.m_nFontSize + "px " + this.m_DrawingInfo.m_strFontName;

        this.m_DrawingInfo.m_Context.clearRect(0, 0, this.m_DrawingInfo.m_Context.canvas.width, this.m_DrawingInfo.m_Context.canvas.height);
    }

    this.m_bShowDataList = true;

    this.m_MainBlock.Initialize();
}

CHTMLChart.prototype.RestoreChartFullProperty = function(){

    //1. 설정창 뜨기 전으로 복구하기 위한 차트 초기화
    this.ResetChartForRestore();
    
    //2. JSON 형식 스트링 로드하여 설정 Object 생성
    var ChartFullProperty = JSON.parse(this.m_strBackupChartFullPropertyInJSON);

    //3. 저장되었던 내용으로 차트 블록 구성
    this.CreateBlockLayout(ChartFullProperty.m_MainBlockProperty);

    //4. 저장되었던 지표적용(저장되어 있던 모든 종목 조회가 완료된 후)
    var i, strKey, GraphPropertyArray = this.GetGraphPropertyArrayFromChartFullProperty(ChartFullProperty);
    var nGraphPropLen = GraphPropertyArray.length;
    for (i = 0; i < nGraphPropLen; i++) {

        var rGraphProp = GraphPropertyArray[i];

        strKey = this.AddIndicator(rGraphProp.m_strRQ, rGraphProp.m_strGraphName, rGraphProp.m_nColIndex, rGraphProp.m_nRowIndex,
            rGraphProp.m_nVertScaleIndex, rGraphProp.m_nBlockRatio, rGraphProp.m_PropertyInfo);

        //추가된 지표 계산
        this.IndicatorCalc(rGraphProp.m_strRQ, strKey);
    }

    this.SetGlobalProperty(ChartFullProperty.m_GlobalProperty);

    this.SetGlobalPropertyToChart(false);

    
    for(var strCode in this.m_mapSmartSignalMng)
    {
        var rSmartSignalMng = this.m_mapSmartSignalMng[strCode];
        if(rSmartSignalMng)
        {
            rSmartSignalMng.Reset(this);
        }
    }

    for(var strRQ in this.m_mapRQSet)
    {
        var rRQSet = this.m_mapRQSet[strRQ];
        var rSmartSignalMng = this.m_mapSmartSignalMng[rRQSet.m_RQInfo.m_strItemCode];
        if(rSmartSignalMng)
        {
            var rSmartSignalIndicator = this.m_mapRQSet[rRQSet.m_strRQ].m_rPriceIndicator;
            rSmartSignalIndicator.m_rSmartSignalMng = rSmartSignalMng;
        }
    }

    this.Draw(DRAW_CASE_TR | DRAW_CASE_RESIZE | DRAW_CASE_ADD_CHARTBLOCK);
}

CHTMLChart.prototype.GetBrowserType = function () {
    return this.m_nBrowserType;
}

CHTMLChart.prototype.GetBrowserName = function () {
    return this.m_strBrowserName;
}

//차트 컨트롤 생성 직후 초기화 진행을 위해 호출(생성자에서 처리가 안되는 경우 별도로 초기화 처리)
CHTMLChart.prototype.InitCtrl = function () {

    this.CalcXTextLen();

    this.m_MainBlock.Initialize();
}

CHTMLChart.prototype.CalcXTextLen = function () {

    var size = null;

    size = MeasureText("__00__", false, this.m_DrawingInfo.m_strFontName, this.m_DrawingInfo.m_nFontSize);
    this.m_nXDayTextLen = size[0];
    this.m_nXWeekTextLen = size[0];

    size = MeasureText("__0000__", false, this.m_DrawingInfo.m_strFontName, this.m_DrawingInfo.m_nFontSize);
    this.m_nXMonthTextLen = size[0];
    this.m_nXYearTextLen = size[0];

    size = MeasureText("_00:00_", false, this.m_DrawingInfo.m_strFontName, this.m_DrawingInfo.m_nFontSize);
    this.m_nXMinTextLen = size[0];
    this.m_nXSecTextLen = size[0];

    size = MeasureText("0", false, this.m_DrawingInfo.m_strFontName, this.m_DrawingInfo.m_nFontSize);
    this.m_nTextLen = size[0];

    size = MeasureText("00", false, this.m_DrawingInfo.m_strFontName, this.m_DrawingInfo.m_nFontSize);
    this.m_n2TextLen = size[0];

    size = MeasureText("0000", false, this.m_DrawingInfo.m_strFontName, this.m_DrawingInfo.m_nFontSize);
    this.m_n4TextLen = size[0];

    size = MeasureText("00:00", false, this.m_DrawingInfo.m_strFontName, this.m_DrawingInfo.m_nFontSize);
    this.m_n5TextLen = size[0];

    size = MeasureText("0000/00", false, this.m_DrawingInfo.m_strFontName, this.m_DrawingInfo.m_nFontSize);
    this.m_n7TextLen = size[0];

    size = MeasureText("00/00 00", false, this.m_DrawingInfo.m_strFontName, this.m_DrawingInfo.m_nFontSize);
    this.m_n8TextLen = size[0];

}

CHTMLChart.prototype.CreateMainBlock = function(){
    this.m_MainBlock = new CMainBlock(this, this.m_mapXScaleMng);
}

CHTMLChart.prototype.SetDefaultFontInfo = function () {

    if (!this.m_DrawingInfo)
        this.m_DrawingInfo = new CDrawingInfo();

    this.m_DrawingInfo.m_nFontSize = 11;//18;
    this.m_DrawingInfo.m_strFontName = "돋움";//"굴림";
};
CHTMLChart.prototype.SetDefaultScrollHeight = function () {
    this.m_nScrollHeight = (this.m_nScrollBarType === SCROLL_THIN_TYPE) ? 9 : 18;      //공현욱 스크롤 높이 초기값 설정
};
CHTMLChart.prototype.SetEventReg = function () {
};
CHTMLChart.prototype.ResetVBlockHeight = function () {

    this.m_MainBlock.ResetVBlockHeight();
}

CHTMLChart.prototype.LoadLang = function (lng, bDraw) {
  i18nInit(lng).then(() => {
    this.SendEvent('Event_LoadLangEnd');
    this.ChangeLang();
    this.SetGlobalPropertyToChart(bDraw);
  });
};

CHTMLChart.prototype.SendEvent = function (strEventName, InfoData) {

    switch (strEventName) {
        case 'Event_SelectGraph':
            {
                var rSelectGraph = InfoData;

                this.SelectRQ(rSelectGraph.m_rRQSet.GetRQ());
                rSelectGraph.m_rRQSet.SelectGraph(rSelectGraph);

                this.m_SelectGraphEvent.m_InfoData = InfoData;
                document.dispatchEvent(this.m_SelectGraphEvent);
            }
            break;
        case 'Event_Scroll':
            {
                //var rRqInfoArray = InfoData;//rq별 종목코드와 주기, 마지막날짜 기록

                //////////////////////////////////////////////////////////////////
                var rXScaleMng = this.m_ScrollCtrl.m_rXScaleMng;
                if (rXScaleMng.GetType() == DATETIME_TYPE) {

                    //var strRQ = this.m_rRQSet.GetRQ();

                    var nFindXIndex = 0;
                    var rDateTimeXScaleItem = new CDateTimeXScaleItem(rXScaleMng);
                    var nXScaleItemArrayIndex = rXScaleMng.GetDateTimeXScaleItemByIndex(nFindXIndex, 0, rXScaleMng.m_XScaleItemArray.length, rDateTimeXScaleItem);
                    if (nXScaleItemArrayIndex < 0 || rDateTimeXScaleItem == null)
                        return;

                    this.m_ScrollEvent.m_mapRqInfo = {};

                    var tDateTime = rDateTimeXScaleItem.GetDateTimeTByIndex(nFindXIndex);

                    if (rXScaleMng.m_tTimeArray[tDateTime] != undefined) {

                        for (var strRQ in rXScaleMng.m_mapRQSet) {

                            var rRQPackets = rXScaleMng.m_tTimeArray[tDateTime][strRQ]
                            if (rRQPackets != undefined) {

                                var rRQSet = this.m_mapRQSet[strRQ];
                                if (!rRQSet)
                                    continue;

                                //1.Nextkey 구성(서버상황으로 인해 조회데이터 중 과거 마지막 날짜 이전일자로 구성)
                                //LJH 2019.01.02 strNextKey
                                var strNextKey = rRQSet.m_RQInfo.m_strNextKey;
                                /*
                                var tm = rRQPackets.m_Packets[rRQSet.m_nDateTimePacketIndex].m_DateTime;
                                gTempStartDate.setFullYear(tm.getFullYear());
                                gTempStartDate.setMonth(tm.getMonth());
                                gTempStartDate.setDate(tm.getDate() - 1);

                                var month = gTempStartDate.getMonth() + 1;
                                var day = gTempStartDate.getDate();
                                var sDate = gTempStartDate.getFullYear() + (month >= 10 ? "" + month : "0" + month) + (day >= 10 ? "" + day : "0" + day);
                                */

                                //2. 종목코드
                                var strSymbol = rRQSet.m_RQInfo.m_strItemCode;

                                //3. 주기
                                var nCycle = rRQSet.m_RQInfo.m_nCycle;

                                //4. Interval
                                var nInterval = rRQSet.m_RQInfo.m_nInterval;

                                var rqInfo = new RQInfoForScroll();
                                rqInfo.m_strItemCode = strSymbol;
                                rqInfo.m_nCycle = nCycle;
                                rqInfo.m_nInterval = nInterval;
                                rqInfo.m_strNextKey = strNextKey;

                                this.m_ScrollEvent.m_mapRqInfo[strRQ] = rqInfo;
                            }
                        }
                    }

                    document.dispatchEvent(this.m_ScrollEvent);
                }
                //////////////////////////////////////////////////////////////////
            }
            break;
        //LKY 블럭 삭제시 화면 콤보박스 체크 해제 이벤트 처리>>
        case 'Event_DeleteBlock':
	        {
	            this.m_SelectGraphEvent.m_InfoData = InfoData;
	            document.dispatchEvent(this.m_SelectGraphEvent);
	        }
        	break;
        //LKY 블럭 삭제시 화면 콤보박스 체크 해제 이벤트 처리<<
		// 20190115 전중현 : 트레이딩라인 이벤트처리
        case 'Event_SelectTradingLine':
            {
                this.m_SelectTradingLineEvent.m_InfoData = InfoData;
                document.dispatchEvent(this.m_SelectTradingLineEvent);
            }
            break;
        // 20190123 남형명 : 하단메뉴 확장 이벤트 처리
        case 'Event_ExtendBottomArea':
            {
                this.m_GlobalProperty.SetShowBottomArea(InfoData);
                document.dispatchEvent(this.m_ExtendBottomAreaEvent);
            }
            break;
        // 20190214 전중현 : 분석툴 설정창 이벤트
        case 'Event_OpenToolSetup':
            {
                this.m_OpenToolSetupEvent.m_InfoData = InfoData;
                document.dispatchEvent(this.m_OpenToolSetupEvent);
            }
            break;
        //LKY 스마트 시그널 신호 이벤트 처리
        case 'Event_SelectTradingLine':
            {
                this.m_SelectSmartSignalLineEvent.m_InfoData = InfoData;
                document.dispatchEvent(this.m_SelectSmartSignalLineEvent);
            }
            break;
        case 'Event_LoadLangEnd':
            {
                document.dispatchEvent(this.m_LoadLangEndEvent);
            }
            break;
        case 'Event_ResetChart':
            {
                document.dispatchEvent(this.m_ResetChartEvent);
            }
            break;
        case 'Event_SaveProperty':
            {
                document.dispatchEvent(this.m_SavePropertyEvent);
            }
            break;
        // 20190228 남형명 : 깊이차트 전환 이벤트 처리
        case 'Event_ChangeDepthChart':
            {
                document.dispatchEvent(this.m_ChangeDepthChartEvent);
            }
            break;
    }
}

CHTMLChart.prototype.GetCanvasWidth = function(){
    return this.m_DrawingInfo.m_ScreenCanvas.width;
}
CHTMLChart.prototype.GetCanvasHeight = function(){
    return this.m_DrawingInfo.m_ScreenCanvas.height;
}

CHTMLChart.prototype.Resize = function (nWidth, nHeight, bDraw) {

    if(nWidth !== null) this.m_DrawingInfo.m_ScreenCanvas.width = nWidth;
    if(nHeight !== null) this.m_DrawingInfo.m_ScreenCanvas.height = nHeight;

    this.m_DrawingInfo.m_rectChart.SetRect(this.m_DrawingInfo.m_ScreenCanvas.clientLeft, this.m_DrawingInfo.m_ScreenCanvas.clientTop,
        this.m_DrawingInfo.m_ScreenCanvas.clientLeft + this.m_DrawingInfo.m_ScreenCanvas.clientWidth, this.m_DrawingInfo.m_ScreenCanvas.clientTop + this.m_DrawingInfo.m_ScreenCanvas.clientHeight);

    this.m_DrawingInfo.m_ScreenContext.font = this.m_DrawingInfo.m_nFontSize + "px " + this.m_DrawingInfo.m_strFontName;

    var nMainBlockLeft = this.m_DrawingInfo.m_rectChart.m_nLeft + this.m_nMainBlockMargin;
    var nMainBlockTop = this.m_DrawingInfo.m_rectChart.m_nTop + this.m_nMainBlockMargin;
    var nMainBlockRight = this.m_DrawingInfo.m_rectChart.m_nRight - this.m_nMainBlockMargin;
    var nMainBlockBottom = this.m_DrawingInfo.m_rectChart.m_nBottom - this.m_nMainBlockMargin - this.m_nScrollHeight;
    this.m_MainBlock.SetRect(nMainBlockLeft, nMainBlockTop, nMainBlockRight, nMainBlockBottom);

    this.m_ScrollCtrl.SetSize(nMainBlockLeft, nMainBlockBottom + 1, nMainBlockRight, nMainBlockBottom + this.m_nScrollHeight);

    //더블버퍼링용 캔버스, 컨텍스트
    if (this.m_DrawingInfo.m_Canvas) {

        this.m_DrawingInfo.m_Context.canvas.width = this.m_DrawingInfo.m_ScreenContext.canvas.width;
        this.m_DrawingInfo.m_Context.canvas.height = this.m_DrawingInfo.m_ScreenContext.canvas.height;
        this.m_DrawingInfo.m_Context.font = this.m_DrawingInfo.m_nFontSize + "px " + this.m_DrawingInfo.m_strFontName;
    }

    this.m_MainBlock.ResizeBlocks();

    if(bDraw !== false)
    	this.Draw(DRAW_CASE_RESIZE);
}
CHTMLChart.prototype.SetDrawCase = function (nDrawCase) {
    this.m_DrawingInfo.m_nDrawCase |= nDrawCase;
}
CHTMLChart.prototype.GetDrawCase = function () {
    return this.m_DrawingInfo.m_nDrawCase;
}
CHTMLChart.prototype.InitDrawCase = function () {
    this.m_DrawingInfo.m_nDrawCase = 0;
}
//nRealDataType:가격데이터(=PRICE_REAL_TYPE(1)), 기타등등..(해당 타입에 따라 실시간 데이터 처리방식이 달라지도록 함)
//nXScalePacketIndex:XScale 패킷index
CHTMLChart.prototype.SetRealData = function (nRealDataType, strItemCode, RealDataArray, nXScalePacketIndex) {

    var bAppend = false;
    var bProcess = false;
    var rDateTimeXScaleMng = null;
    var strXScalePacketName, rXScaleMng;

    if(nRealDataType === PRICE_REAL_TYPE)
    {
        for (var strRQ in this.m_mapRQSet) {

            var rRQSet = this.m_mapRQSet[strRQ];
            if (rRQSet.m_RQInfo.m_strItemCode !== strItemCode)
                continue;
            
            var rXScalePacketData = rRQSet.m_PacketDataArray[nXScalePacketIndex];
            var rXScaleMng = this.m_mapXScaleMng[rXScalePacketData.GetPacketName()];
            var nTotalMergeCnt = rXScaleMng.GetMergeDataCnt();
            var nResult = rRQSet.SetRealData(nRealDataType, nXScalePacketIndex, RealDataArray);
            if (nResult >= 0) {//0x0100(MinMaxItem max변화), 0x0200(MinMaxItem min변화), 0x01(view max), 0x02(view min), 0x04(full max), 0x08(full min), 0x10(append data)

                bProcess = true;

                if (nResult & 0x10) {//append 일 경우만 XScale Merge

                    switch (rXScaleMng.GetType()) {

                        case DATETIME_TYPE:
                            rXScaleMng.RealMerge(strRQ, rXScalePacketData);

                            bAppend = true;
                            rDateTimeXScaleMng = rXScaleMng;
                            break;
                    }
                }
            }
        }

        if (bAppend === true && rDateTimeXScaleMng !== null) {

            var nViewCnt = rDateTimeXScaleMng.GetViewCnt();
            var Min = 0;
            var Max = rDateTimeXScaleMng.GetMergeDataCnt();
            var Page = nViewCnt > Max ? Max : nViewCnt;
            this.m_ScrollCtrl.SetScrollInfo(rDateTimeXScaleMng, Min, Max, Page, this.m_ScrollCtrl.m_Pos, false);

            var nMoveScroll = (nViewCnt < Max ? Max - nTotalMergeCnt : 0);//스크롤 이동되어야 할 최소봉폭 개수

            if (nMoveScroll > 0)
                this.m_ScrollCtrl.Scroll(nMoveScroll);
            else//해당 rq의 데이터는 추가된 상태이지만 전체 머지된 데이터개수로는 추가가 아니라 업데이트인 경우
            {
                if (nViewCnt > Max)
                    rDateTimeXScaleMng.InitialViewInfo(nViewCnt);

                this.ExtractYScaleMinMaxOnRealData(true);
                this.Draw(DRAW_CASE_REAL);
            }
        }
        else if (bProcess === true){//update인 경우

            this.ExtractYScaleMinMaxOnRealData(false);
            this.Draw(DRAW_CASE_REAL);
        }
    }
    return bProcess;
}

CHTMLChart.prototype.AddTool = function (nToolType) {
    this.m_MainBlock.AddTool(nToolType);
}
CHTMLChart.prototype.GetDefaultRQ = function () {

    var rDefaultRQSet = this.m_mapRQSet["DEFAULT"];
    if (rDefaultRQSet != undefined)
        return rDefaultRQSet;

    //실제 default rq가 존재하지 않는 경우
    for (var strRQ in this.m_mapRQSet)
        return rDefaultRQSet = this.m_mapRQSet[strRQ];//첫번째 rq를 디폴트rq로 셋팅

    return null;
}

//키에 해당하는 그래프가 위치한 블록의 col, row값을 CPoint 개체로 리턴하는 함수
CHTMLChart.prototype.FindBlockColRowByGraphKey = function (strRQ, strGraphKey) {

    var rRQSet = this.m_mapRQSet[strRQ];
    if (rRQSet === undefined)
        return null;

    var rGraph = rRQSet.FindGraphByKey(strGraphKey);
    var rBlock = null;
    if (rGraph !== null && rGraph.m_rBlock !== null) {

        return rGraph.GetBlockPosInfo();
    }
    return null;
}

//키에 해당하는 그래프가 위치한 블록의 col, row값을 CPoint 개체로 리턴하는 함수
CHTMLChart.prototype.FindBlockColRowByGraphName = function (strRQ, strGraphName) {

    var rRQSet = this.m_mapRQSet[strRQ];
    if (rRQSet === undefined)
        return null;
    
    var rGraph = rRQSet.IsExistGraphName(strGraphName);
    var rBlock = null;
    if (rGraph !== null && rGraph.m_rBlock !== null) {

        return rGraph.GetBlockPosInfo();
    }
    return null;
}

CHTMLChart.prototype.FindGraphByKey = function (strRQ, strGraphKey) {
    var rRQSet = this.m_mapRQSet[strRQ]
    if (rRQSet == undefined)
        return null;

    return rRQSet.FindGraphByKey(strGraphKey);
}
CHTMLChart.prototype.IsExistGraphNameInRQ = function (strRQ, strGraphName) {

    var rRQSet = this.m_mapRQSet[strRQ]
    if (rRQSet == undefined)
        return null;

    return rRQSet.IsExistGraphName(strGraphName);
}
CHTMLChart.prototype.OnHScroll = function (ScrollStatus, CurPos, Delta) {

    if (ScrollStatus == 2) {//좌측 스크롤버튼 클릭시

        var rXScaleMng = this.GetSelectedXScaleMng();
        if (rXScaleMng != null) {

            rXScaleMng.ShiftViewRange(-Delta);

            this.ExtractYScaleMinMax(true);
            this.Draw(DRAW_CASE_SCROLL);
            //this.m_MainBlock.Draw(this.m_DrawingInfo);

        }
    }
    else if (ScrollStatus == 4) {

        var rXScaleMng = this.GetSelectedXScaleMng();
        if (rXScaleMng != null) {

            rXScaleMng.ShiftViewRange(Delta);

            this.ExtractYScaleMinMax(true);
            this.Draw(DRAW_CASE_SCROLL);
            //this.m_MainBlock.Draw(this.m_DrawingInfo);

        }
    }
    else if (ScrollStatus == 7) {

        var rXScaleMng = this.GetSelectedXScaleMng();
        if (rXScaleMng != null) {

            var nDiff = rXScaleMng.m_nViewStartIndex - Delta;
            if (nDiff < 0)
                Delta = Delta + nDiff;

            rXScaleMng.ShiftViewRange(-Delta);

            this.ExtractYScaleMinMax(true);
            this.Draw(DRAW_CASE_SCROLL);
            //this.m_MainBlock.Draw(this.m_DrawingInfo);

        }
    }
    else if (ScrollStatus == 8) {

        var rXScaleMng = this.GetSelectedXScaleMng();
        if (rXScaleMng != null) {

            var nDiff = (rXScaleMng.GetMergeDataCnt() - 1) - (rXScaleMng.m_nViewEndIndex + Delta);
            if (nDiff < 0)
                Delta = Delta + nDiff;

            rXScaleMng.ShiftViewRange(Delta);

            this.ExtractYScaleMinMax(true);
            this.Draw(DRAW_CASE_SCROLL);
            //this.m_MainBlock.Draw(this.m_DrawingInfo);
        }
    }
    else if (ScrollStatus == 6) {

        //console.log("OnHScroll status= " + ScrollStatus + ", CurPos: " + CurPos + ", Delta: " + Delta);

        var rXScaleMng = this.GetSelectedXScaleMng();
        if (rXScaleMng != null) {

            rXScaleMng.ShiftViewRange(Delta);

            this.ExtractYScaleMinMax(true);
            this.Draw(DRAW_CASE_SCROLL);
            //this.m_MainBlock.Draw(this.m_DrawingInfo);
        }

    }
    else if (ScrollStatus == 9) {//프로그램적으로 좌측 스크롤링

        var rXScaleMng = this.GetSelectedXScaleMng();
        if (rXScaleMng != null) {

            rXScaleMng.ShiftViewRange(-Delta);

            this.ExtractYScaleMinMax(true);
            this.Draw(DRAW_CASE_SCROLL);
            //this.m_MainBlock.Draw(this.m_DrawingInfo);

        }
    }
    else if (ScrollStatus == 10) {//프로그램적으로 우측 스크롤링

        var rXScaleMng = this.GetSelectedXScaleMng();
        if (rXScaleMng != null) {

            rXScaleMng.ShiftViewRange(Delta);

            this.ExtractYScaleMinMax(true);
            this.Draw(DRAW_CASE_SCROLL);
            //this.m_MainBlock.Draw(this.m_DrawingInfo);

        }
    }
    return true;
}

CHTMLChart.prototype.OnVScroll = function (ScrollStatus, CurPos, Delta) {

    if (ScrollStatus == 2) {

    }
    else if (ScrollStatus == 4) {

    }
    else if (ScrollStatus == 6) {

    }

    return true;
}

CHTMLChart.prototype.OnMouseDown = function (e) {

    e.ChartXPos = e.offsetX - this.m_nMainBlockMargin;
    e.ChartYPos = e.offsetY - this.m_nMainBlockMargin;

    if (this.m_ScrollCtrl.OnMouseDown(e))
        return;

    if (this.m_MainBlock.OnMouseDown(e))
        return;
}

CHTMLChart.prototype.OnMouseUp = function (e) {

    e.ChartXPos = e.offsetX - this.m_nMainBlockMargin;
    e.ChartYPos = e.offsetY - this.m_nMainBlockMargin;

    if (this.m_ScrollCtrl.OnMouseUp(e))
        return;

    if (this.m_MainBlock.OnMouseUp(e))
        return;
}

CHTMLChart.prototype.OnMouseMove = function (e) {

    e.ChartXPos = e.offsetX - this.m_nMainBlockMargin;
    e.ChartYPos = e.offsetY - this.m_nMainBlockMargin;

    if (this.m_ScrollCtrl.OnMouseMove(e))
        return;

    if (this.m_MainBlock.OnMouseMove(e))
        return;

}

CHTMLChart.prototype.OnMouseOut = function () {

    //console.log("CHTMLChart.prototype.OnMouseOut");

    this.m_ScrollCtrl.OnMouseOut();
    this.m_MainBlock.OnMouseOut();
}

CHTMLChart.prototype.OnLButtonDblclick = function (e) {

    e.ChartXPos = e.offsetX - this.m_nMainBlockMargin;
    e.ChartYPos = e.offsetY - this.m_nMainBlockMargin;

    this.m_MainBlock.OnLButtonDblclick(e);
}

CHTMLChart.prototype.IsShowDataList = function () {
    return this.m_bShowDataList;
}
CHTMLChart.prototype.SelectGraphByKey = function (strRQ, strGraphKey) {
    var rRQSet = this.SelectRQ(strRQ);
    if (rRQSet !== null) {
        return rRQSet.SelectGraphByKey(strGraphKey);
    }
    return null;
}
CHTMLChart.prototype.SelectRQ = function (strRQ) {
    var sRQ;
    var rRQSet;
    for (sRQ in this.m_mapRQSet) {
        rRQSet = this.m_mapRQSet[sRQ];
        if (rRQSet.IsSelected()) {

            if (sRQ === strRQ)
                return rRQSet;

            rRQSet.Select(false);
            break;
        }
    }
    rRQSet = this.m_mapRQSet[strRQ];
    if (rRQSet !== undefined) {
        rRQSet.Select(true);
        return rRQSet;
    }
    else
        return null;
}
CHTMLChart.prototype.GetSelectedGraph = function () {
    var rSelectedRQSet = this.GetSelectedRQSet();
    if (rSelectedRQSet !== null) {
        var rSelectedGraph = rSelectedRQSet.GetSelectedGraph();
        if (rSelectedGraph !== null) {
            return rSelectedGraph;
        }
    }
    return null;
}
CHTMLChart.prototype.GetSelectedGraphKey = function () {
    var rSelectedRQSet = this.GetSelectedRQSet();
    if (rSelectedRQSet !== null) {
        var rSelectedGraph = rSelectedRQSet.GetSelectedGraph();
        if (rSelectedGraph !== null) {
            return rSelectedGraph.GetGraphKey();
        }
    }
    return null;
}
CHTMLChart.prototype.GetSelectedRQSet = function () {
    var sRQ;
    var rRQSet = null;
    var rFirstRQSet = null;
    for (sRQ in this.m_mapRQSet) {
        rRQSet = this.m_mapRQSet[sRQ];

        if (!rFirstRQSet)
            rFirstRQSet = rRQSet;

        if (rRQSet.IsSelected()) {
            return rRQSet;
        }
    }
    return rFirstRQSet;
}

CHTMLChart.prototype.GetSelectedRQInfo = function () {
    var sRQ;
    var rRQSet = null;
    var rFirstRQSet = null;
    var rRQInfo = null;
    for (sRQ in this.m_mapRQSet) {
        rRQSet = this.m_mapRQSet[sRQ];

        if (!rFirstRQSet)
            rFirstRQSet = rRQSet;

        if (rRQSet.IsSelected()) {
            return rRQSet.m_RQInfo;
        }
    }
    return rFirstRQSet ? rFirstRQSet.m_RQInfo : null;
}

CHTMLChart.prototype.GetSelectedRQ = function () {
    var sRQ;
    var rRQSet;
    var rFirstRQSet = null;
    for (sRQ in this.m_mapRQSet) {
        rRQSet = this.m_mapRQSet[sRQ];

        if(!rFirstRQSet)
            rFirstRQSet = rRQSet;

        if (rRQSet.IsSelected()) {
            return rRQSet.GetRQ();
        }
    }
    return rFirstRQSet ? rFirstRQSet.GetRQ() : null;
}
CHTMLChart.prototype.GetSelectedXScaleMng = function () {

    return this.m_MainBlock.GetSelectedXScaleMng();
}
CHTMLChart.prototype.SetBlockType = function (nBlockType) {
    this.m_MainBlock.SetBlockType(nBlockType);
}
CHTMLChart.prototype.GetBlockType = function () {
    return this.m_MainBlock.GetBlockType();
}

CHTMLChart.prototype.ZoomIn = function (nZoomViewCnt) {
    this.m_MainBlock.ZoomIn(nZoomViewCnt);
}
CHTMLChart.prototype.ZoomOut = function (nZoomViewCnt) {
    this.m_MainBlock.ZoomOut(nZoomViewCnt);
}

CHTMLChart.prototype.ExtractYScaleMinMax = function (bFullScan) {
    this.m_MainBlock.ExtractYScaleMinMax(bFullScan);
}
CHTMLChart.prototype.ExtractYScaleMinMaxOnRealData = function (bFullScan) {
    this.m_MainBlock.ExtractYScaleMinMaxOnRealData(bFullScan);
}
CHTMLChart.prototype.InitialViewInfo = function (nViewCnt) {

    for (var strKey in this.m_mapXScaleMng) {
        var rXScaleMng = this.m_mapXScaleMng[strKey];
        if (rXScaleMng !== undefined)
            rXScaleMng.InitialViewInfo(nViewCnt);
    }

    //스크롤 셋팅
    var rXScaleMng = this.GetSelectedXScaleMng();
    if (rXScaleMng !== null) {

        var Min = 0;
        var Max = rXScaleMng.GetMergeDataCnt();
        var Page = nViewCnt > Max ? Max : nViewCnt;
        var Pos = Max - Page;
        this.m_ScrollCtrl.SetScrollInfo(rXScaleMng, Min, Max, Page, Pos, false);
    }

}
CHTMLChart.prototype.SetScrollByXScalePacketName = function (strXScalePacketName) {
    var rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];
    if (rXScaleMng !== undefined) {

        this.SetScroll(rXScaleMng);
        return true;
    }
    return false;
}

//스크롤 셋팅
CHTMLChart.prototype.ReSetScrollAfterAppend = function () {
    var rXScaleMng = this.GetSelectedXScaleMng();
    if (rXScaleMng !== null) {

        var nMin = this.m_ScrollCtrl.m_Min;
        var nMax = this.m_ScrollCtrl.m_Max;
        var nPage = this.m_ScrollCtrl.m_Page;
        var nPos = this.m_ScrollCtrl.m_Pos;

        var nViewCnt = rXScaleMng.GetViewCnt();
        var nMergeDataCnt = rXScaleMng.GetMergeDataCnt();
        if (nViewCnt >= nMergeDataCnt) {

            this.InitialViewInfo(nViewCnt);
            this.ExtractYScaleMinMax(true);
            this.Draw(DRAW_CASE_RESIZE);

        }
        else {

            this.InitialViewInfo(nViewCnt);

            var nMoveScroll =  -this.m_ScrollCtrl.m_Pos;//스크롤 이동되어야 할 최소봉폭 개수

            this.ExtractYScaleMinMax(true);
            this.m_ScrollCtrl.Scroll(nMoveScroll);
            this.Draw(DRAW_CASE_RESIZE);
        }
    }
}

CHTMLChart.prototype.InitialXScaleViewInfo = function (strXScalePacketName, nViewCnt) {
    var rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];
    if (rXScaleMng !== undefined) {
        rXScaleMng.InitialViewInfo(nViewCnt);
    }
}
CHTMLChart.prototype.SetViewCnt = function (nViewCnt) {
    for (var strKey in this.m_mapXScaleMng) {
        var rXScaleMng = this.m_mapXScaleMng[strKey];
        if (rXScaleMng !== undefined)
            rXScaleMng.SetViewCnt(nViewCnt);
    }
}
CHTMLChart.prototype.SetXScaleViewCnt = function (strXScalePacketName, nViewCnt) {
    var rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];
    if (rXScaleMng !== undefined)
        rXScaleMng.SetViewCnt(nViewCnt);
}
CHTMLChart.prototype.GetViewCnt = function (strXScalePacketName) {
    var rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];
    if (rXScaleMng !== undefined)
        return rXScaleMng.GetViewCnt();
}
CHTMLChart.prototype.GetMergeDataCnt = function (strXScalePacketName) {
    var rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];
    if (rXScaleMng !== undefined)
        return rXScaleMng.GetMergeDataCnt();
    else
        return 0;
}
CHTMLChart.prototype.SetRect = function (left, top, width, height) {
    this.m_DrawingInfo.m_rectChart.SetRect(left, top, left + width, top + height);

    this.m_MainBlock.SetRect(this.m_DrawingInfo.m_rectChart.m_nLeft + this.m_nMainBlockMargin, this.m_DrawingInfo.m_rectChart.m_nTop + this.m_nMainBlockMargin,
        this.m_DrawingInfo.m_rectChart.m_nRight - this.m_nMainBlockMargin, this.m_DrawingInfo.m_rectChart.m_nBottom - this.m_nMainBlockMargin);

}

CHTMLChart.prototype.AddRQ = function (strRQ) {
    if (this.m_mapRQSet[strRQ] == undefined) {

        //LKY 첫 생성 RQ는 DefaultRQ 로 명칭 셋팅 >>
        var nRQLength = Object.keys(this.m_mapRQSet).length;
        if(nRQLength === 0)
            this.m_strDefaultRQ = strRQ;
        //LKY 첫 생성 RQ는 DefaultRQ 로 명칭 셋팅 <<

        var RQSet = new CRQSet(this, this.m_mapXScaleMng);
        RQSet.SetRQ(strRQ);
        this.m_mapRQSet[strRQ] = RQSet;
        return true;
    }
    else
        return false;
}

CHTMLChart.prototype.AddRQInfo = function (Info) {

    var strRQ;
    var nRQCnt = Object.keys(this.m_mapRQSet).length;
    strRQ = "RQ" + (Math.floor(Math.random() * (10000 - 1 + 1)) + 1);
    if(nRQCnt <= 0){
        this.m_strDefaultRQ = strRQ;
    }

    if (this.m_mapRQSet[strRQ] == undefined) {
        var RQSet = new CRQSet(this, this.m_mapXScaleMng);
        RQSet.SetRQ(strRQ);
        this.m_mapRQSet[strRQ] = RQSet;
        RQSet.SetRQInfo(Info);
        return strRQ;
    }
    else
        return null;
}

CHTMLChart.prototype.SetRQInfo = function (strRQ, Info) {
    var RQSet = this.m_mapRQSet[strRQ];
    if (RQSet == undefined)
        return false;

    RQSet.SetRQInfo(Info);

    return true;
}

//LJH 2019.01.02 연속조회 키 추가
CHTMLChart.prototype.SetRQInfoNextKey = function (strRQ, strNextKey) {
    var RQSet = this.m_mapRQSet[strRQ];
    if (RQSet == undefined)
        return false;

    RQSet.SetRQInfoNextKey(strNextKey);

    return true;
}

CHTMLChart.prototype.GetRQInfo = function (strRQ, Info) {
    var RQSet = this.m_mapRQSet[strRQ];
    if (RQSet == undefined)
        return false;

    RQSet.GetRQInfo(Info);

    return true;
}

CHTMLChart.prototype.GetRQCount = function(){
    
    return Object.keys(this.m_mapRQSet).length;
}
//nDec : 진법(10:10진법, 16:16진법..)
//Unit : 최소 단위( 데이터의 최소간격 예:호가단위 null일 수 있으며 그 경우는 nDigit 참조하여 계산됨)
//nDigit:표현 소수점 자리수(ex:0.0001 소수점4자리), 정수인 경우(ex: 1000 => 천원단위로 표현할 경우(1234을 1000로 표현))
CHTMLChart.prototype.AddNumPacketInfo = function (strRQ, strPacketName, nPacketDataLen, nPacketUseType, nDec, Unit, strDigit) {
    var RQSet = this.m_mapRQSet[strRQ];
    if (RQSet == undefined)
        return null;

    var nDigit = GetDigit(strDigit);

    return RQSet.AddNumPacketInfo(strPacketName, nPacketDataLen, nPacketUseType, nDec, Unit, nDigit);
}

//nDec : 진법(10:10진법, 16:16진법..)
//Unit : 최소 단위( 데이터의 최소간격 예:호가단위 null일 수 있으며 그 경우는 nDigit 참조하여 계산됨)
//nDigit:표현 소수점 자리수(ex:0.0001 소수점4자리), 정수인 경우(ex: 1000 => 천원단위로 표현할 경우(1234을 1000로 표현))
CHTMLChart.prototype.AddInputNumPacketInfo = function (strRQ, strPacketName, nPacketDataLen, nDec, Unit, strDigit) {
    var RQSet = this.m_mapRQSet[strRQ];
    if (RQSet == undefined)
        return null;

    var nDigit = GetDigit(strDigit);

    return RQSet.AddNumPacketInfo(strPacketName, nPacketDataLen, INPUT_PACKET_USE_TYPE, nDec, Unit, nDigit);
}

CHTMLChart.prototype.AddDateTimePacketInfo = function (strRQ, strPacketName, strPacketSubType, nPacketDataLen) {
    var RQSet = this.m_mapRQSet[strRQ];
    if (RQSet == undefined)
        return null;

    return RQSet.AddDateTimePacketInfo(strPacketName, strPacketSubType, nPacketDataLen, INPUT_PACKET_USE_TYPE);
}

CHTMLChart.prototype.AddTextPacketInfo = function (strRQ, strPacketName, strPacketSubType, nPacketDataLen, nPacketUseType) {
    var RQSet = this.m_mapRQSet[strRQ];
    if (RQSet === undefined)
        return null;
    return RQSet.AddTextPacketInfo(strPacketName, strPacketSubType, nPacketDataLen, nPacketUseType);
}

CHTMLChart.prototype.AddPacketCalculator = function (strRQ, strCalcPacketName, strInputPacketNameArray, nDec, Unit, strDigit) {

    var rRQSet = this.m_mapRQSet[strRQ];
    if (rRQSet === undefined)
        return false;

    var nDigit = GetDigit(strDigit);
    return rRQSet.AddPacketCalculator(strCalcPacketName, strInputPacketNameArray, nDec, Unit, nDigit);
}

CHTMLChart.prototype.AddIndicator = function (strRQ, strIndicatorName, nBlockColIndex, nBlockRowIndex, nVertScaleIndex, BlockRatio, IndicatorPropertyInfo) {
    var RQSet = this.m_mapRQSet[strRQ];
    if (RQSet === undefined)
        return "";
    return this.m_MainBlock.AddIndicator(RQSet, strIndicatorName, nBlockColIndex, nBlockRowIndex, nVertScaleIndex, BlockRatio, IndicatorPropertyInfo);
}
CHTMLChart.prototype.DeleteIndicator = function (strIndicatorKey) {

    return this.m_MainBlock.DeleteIndicator(strIndicatorKey);
}
CHTMLChart.prototype.IndicatorCalc = function (strRQ, strIndicatorKey) {

    var RQSet = this.m_mapRQSet[strRQ];
    if (RQSet === undefined)
        return false;

    var i, nLength = RQSet.m_GraphArray.length;
    for (i = 0; i < nLength; i++) {

        var rGraph = RQSet.m_GraphArray[i];
        if (rGraph.m_strKey === strIndicatorKey) {
            rGraph.Calc();

            rGraph.m_rBlock.ExtractYScaleMinMax(true);

            return true;
        }
    }
    return false;
}
//LJH 2019.1.14 vue에서 호출
CHTMLChart.prototype.SimpleAddIndicator = function (strGraphName, bOnlyOne, rCopyProperty) {

    console.log("ShowIndicator________________: " + strGraphName);

    var nMainBlockCnt = this.m_MainBlock.m_ChartBlockArray.length;
    var rChartBlock = null;
    if(bOnlyOne === true)
    {
        for (var i  = 0; i < nMainBlockCnt; i ++) {
            
            rChartBlock = this.m_MainBlock.m_ChartBlockArray[i];
            var nChartGraphCnt = rChartBlock.m_GraphArray.length;

            for(var j = 0; j < nChartGraphCnt; j++){
                var rGraph = rChartBlock.m_GraphArray[j];

                if (rGraph.m_strName === strGraphName)
                    return rGraph.m_strKey;
            }
        }
    }

    //최대화상태에서 지표를 추가하면 최대화상태 풀어지도록 처리
	if(this.m_MainBlock.m_rMaximumBlock !== null)
		this.m_MainBlock.m_rMaximumBlock.OnDivMaxBtnClick();

    var strRQ = this.GetSelectedRQ();

    var nBlockColIndex = -1;
    var nBlockRowIndex = -1;
    var nVertScaleIndex = -1;

    var DefaultPropertyInfo = this.GetDefaultIndicatorProperty(strGraphName);
    if (DefaultPropertyInfo && DefaultPropertyInfo.m_nAddType === OVERLAY_TYPE) {
        var rBlockPosInfo = this.FindBlockColRowByGraphName(strRQ, DefaultPropertyInfo.m_strOverlayGraphName);
        if (rBlockPosInfo !== null) {
            nBlockColIndex = rBlockPosInfo.m_X;
            nBlockRowIndex = rBlockPosInfo.m_Y;
            nVertScaleIndex = rBlockPosInfo.m_nVertScaleIndex;
        }
    }
    
    var NewProperty;
    if( rCopyProperty !== undefined )
        NewProperty = rCopyProperty.Copy();

    var nBlockRatio = 1;

    var strIndicatorKey = this.AddIndicator(
        strRQ,
        strGraphName,
        nBlockColIndex,
        nBlockRowIndex,
        nVertScaleIndex,
        nBlockRatio,
        NewProperty
    );

    this.IndicatorCalc(strRQ, strIndicatorKey);
    this.m_MainBlock.ResizeBlocks();
    this.Draw(DRAW_CASE_ADD_CHARTBLOCK);

    return strIndicatorKey;
}

CHTMLChart.prototype.GetPriceIndicatorKey = function ( strRQ )
{
    if( strRQ === undefined )
        strRQ = this.GetSelectedRQ();
        
    if( strRQ === null )
        return null;

    var rRQSet = this.m_mapRQSet[strRQ];
    if( rRQSet.m_rPriceIndicator === null )
        return null;
    
    return rRQSet.m_rPriceIndicator.m_strKey;
}

//LJH 2019.1.14 수정 필요 vue에서 호출
CHTMLChart.prototype.SimpleDeleteIndicator = function (GraphName, bOnlyOne) {
    console.log("HideIndicator________________: " + GraphName);

    var bFlag = false;
    var nMainBlockCnt = this.m_MainBlock.m_ChartBlockArray.length;
    if(bOnlyOne === true){
        
        for (var i  = 0; i < nMainBlockCnt; i ++) {
            
            var rChartBlock = this.m_MainBlock.m_ChartBlockArray[i];
            var nChartGraphCnt = rChartBlock.m_GraphArray.length;
            
            for(var j = nChartGraphCnt -1; j >= 0; j--){
                var rGraph = rChartBlock.m_GraphArray[j];
                console.log(rGraph.m_strName + ", " + GraphName);
                if(rGraph.m_strName === GraphName)
                {
                    this.DeleteIndicator(rGraph.m_strKey);
                    this.Draw(DRAW_CASE_DEL_CHARTBLOCK);
                    bFlag = true;
                    break;
                }
            }

            if(bFlag === true)
                break;
        }

    }
}
CHTMLChart.prototype.SettingDeleteIndicator = function(strIndicatorKey) {

    /*var nMainBlockCnt = this.m_MainBlock.m_ChartBlockArray.length;

    for (var i  = 0; i < nMainBlockCnt; i ++) {
        
        var rChartBlock = this.m_MainBlock.m_ChartBlockArray[i];
        var nChartGraphCnt = rChartBlock.m_GraphArray.length;
        
        for(var j = nChartGraphCnt -1; j >= 0; j--){
            var rGraph = rChartBlock.m_GraphArray[j];

            if(rGraph.m_strKey === strIndicatorKey)
            
        }
    }*/

    this.DeleteIndicator(strIndicatorKey);
    this.Draw(DRAW_CASE_DEL_CHARTBLOCK);
}
CHTMLChart.prototype.SetPropertyInfo = function (strIndicatorKey, IndicatorPropertyInfo, bSetup) {

    if (strIndicatorKey === DEFAULT_INDICATOR_KEY) {

        this.m_TempDefaultIndicatorPropertyInfo = IndicatorPropertyInfo.Copy();
        return false;
    }

    return this.m_MainBlock.SetPropertyInfo(strIndicatorKey, IndicatorPropertyInfo, bSetup);
}
CHTMLChart.prototype.GetPropertyInfo = function (strIndicatorKey, bCopy) {

    if (strIndicatorKey === DEFAULT_INDICATOR_KEY) {

        if (!bCopy || !this.m_TempDefaultIndicatorPropertyInfo)
            return this.m_TempDefaultIndicatorPropertyInfo;

        var CopyPropertyInfo = this.m_TempDefaultIndicatorPropertyInfo.Copy();
        return CopyPropertyInfo;
    }

    var PropertyInfo = this.m_MainBlock.GetPropertyInfo(strIndicatorKey);
    if (!bCopy || !PropertyInfo)
        return PropertyInfo;

    var CopyPropertyInfo = PropertyInfo.Copy();
    return CopyPropertyInfo;
}
CHTMLChart.prototype.GetCopyProperty = function (strIndicatorName, rIndicatorPropertyInfo) {

    if( rIndicatorPropertyInfo === undefined )
        return undefined;
    
    if( strIndicatorName === "_MA_" || strIndicatorName === "_VMA_" )
    {
        if( rIndicatorPropertyInfo.length === undefined )
            return undefined;

        var CopyProperty, rSrcProperty;
        var CopyPropertyArray = [];
        for( var i = 0; i < rIndicatorPropertyInfo.length; i++ )
        {
            rSrcProperty = rIndicatorPropertyInfo[i];
            CopyProperty = rSrcProperty.Copy();
            CopyPropertyArray[CopyPropertyArray.length] = CopyProperty;
        }

        return CopyPropertyArray;
    }
    else
    {
        var CopyProperty = rIndicatorPropertyInfo.Copy();
        return CopyProperty;
    }
}
CHTMLChart.prototype.RegXScaleMng = function (strRQ, bAppendRQ) {
    var i;
    var rXScaleMng = null;
    var XScalePacketNameArray = [];
    this.m_MainBlock.GetXScalePacketName(XScalePacketNameArray);

    for (i = 0; i < XScalePacketNameArray.length; i++) {

        var strXScalePacketName = XScalePacketNameArray[i];
        var rRQSet = this.m_mapRQSet[strRQ];
        var rPacketData = rRQSet.GetPacketData(strXScalePacketName);
        if (rPacketData === null)
            continue;

        var XScaleMng = this.m_mapXScaleMng[strXScalePacketName];
        if (XScaleMng === undefined) {
            XScaleMng = CreateXScaleMng(this, strXScalePacketName, rPacketData.m_nPacketType);
            if (XScaleMng !== null) {
                XScaleMng.AddRQ(strRQ, rRQSet);
                this.m_mapXScaleMng[strXScalePacketName] = XScaleMng;
                this.m_MainBlock.SetXScaleMng(strXScalePacketName, XScaleMng);                
            }
        }
        else {

            if (bAppendRQ === false)
                XScaleMng.Initialize();

            XScaleMng.AddRQ(strRQ, rRQSet);
            this.m_MainBlock.SetXScaleMng(strXScalePacketName, XScaleMng);
        }

        //호가패킷이 x축인 경우는 기본정보를 XScaleMng에 넘겨준다
        if(strXScalePacketName === "_HOGA_")
            XScaleMng.SetPacketInfo(rPacketData.m_nDec, rPacketData.m_Unit, rPacketData.m_nDigit);
    }
    return true;
}

//지표 추가나 삭제시 해당지표와 관련있는 XScaleMng 추가 또는 제거처리
CHTMLChart.prototype.RegXScaleMngByIndicator = function () {

    var i, strRQ ;
    var rRQSet, rPacketData;
    var rXScaleMng = null;
    var mapTempXScaleMng = {};
    var XScalePacketNameArray = [];
    var strXScalePacketName;
    for(strXScalePacketName in this.m_mapXScaleMng)
    {
        rXScaleMng = this.m_mapXScaleMng[strXScalePacketName];
        mapTempXScaleMng[strXScalePacketName] = rXScaleMng;
        delete this.m_mapXScaleMng[strXScalePacketName];
    }

    //this.m_mapXScaleMng = {};

    this.m_MainBlock.GetXScalePacketName(XScalePacketNameArray);

    for (i = 0; i < XScalePacketNameArray.length; i++) {

        var strXScalePacketName = XScalePacketNameArray[i];
        var rXScaleMng = mapTempXScaleMng[strXScalePacketName];
        if(rXScaleMng)
        {
            this.m_mapXScaleMng[strXScalePacketName] = rXScaleMng;
            mapTempXScaleMng[strXScalePacketName] = undefined;

            var XScalePacketArray = [];
            for(strRQ in this.m_mapRQSet){
                rRQSet = this.m_mapRQSet[strRQ];
                rPacketData = rRQSet.GetPacketData(strXScalePacketName);
                if(rPacketData)
                    XScalePacketArray[XScalePacketArray.length] = rPacketData;
            }

            var nLen = XScalePacketArray.length;
            for(i = 0 ; i < nLen; i++ )
            {
                rPacketData = XScalePacketArray[i];
                rXScaleMng.AddRQ(rPacketData.m_rRQSet.m_strRQ, rPacketData.m_rRQSet);
            }
        }
        else
        {//지표가 추가되면서 XScale도 추가시켜야 하는 경우
            
            var XScalePacketArray = [];
            
            for(strRQ in this.m_mapRQSet){
                rRQSet = this.m_mapRQSet[strRQ];
                rPacketData = rRQSet.GetPacketData(strXScalePacketName);
                if(rPacketData)
                    XScalePacketArray[XScalePacketArray.length] = rPacketData;
            }

            var nLen = XScalePacketArray.length;
            if(nLen > 0)
            {
                rPacketData = XScalePacketArray[0];
                rXScaleMng = CreateXScaleMng(this, strXScalePacketName, rPacketData.m_nPacketType);
                if(rXScaleMng)
                {
                    this.m_mapXScaleMng[strXScalePacketName] = rXScaleMng;

                    this.m_MainBlock.SetXScaleMng(strXScalePacketName, rXScaleMng);

                    rXScaleMng.AddRQ(rPacketData.m_rRQSet.m_strRQ, rPacketData.m_rRQSet);

                    for(i = 1 ; i < nLen; i++ )
                    {
                        rPacketData = XScalePacketArray[i];
                        rXScaleMng.AddRQ(rPacketData.m_rRQSet.m_strRQ, rPacketData.m_rRQSet);

                    }
                }
            }
            
        }
    }

    //지표가 삭제되면서 XScaleMng도 삭제되어야 하는 경우
    for(strXScalePacketName in mapTempXScaleMng)
    {
        rXScaleMng = mapTempXScaleMng[strXScalePacketName];
        if(rXScaleMng)
        {
            this.m_MainBlock.RemoveXScaleMng(strXScalePacketName);
            delete mapTempXScaleMng[strXScalePacketName];
        }
    }
    
    return true;
}

CHTMLChart.prototype.ArrangeXScaleMng = function () {

    for (var strKey in this.m_mapXScaleMng) {
        var rXScaleMng = this.m_mapXScaleMng[strKey];
        if (rXScaleMng !== undefined) {

            rXScaleMng.Arrange();
        }
    }
}

CHTMLChart.prototype.Draw = function (nDrawCase) {
    if (!this.m_DrawingInfo.m_Canvas || !this.m_DrawingInfo.m_Context ||
        !this.m_DrawingInfo.m_ScreenCanvas || !this.m_DrawingInfo.m_ScreenContext)
        return;

    this.SetDrawCase(nDrawCase);

    this.m_MainBlock.Draw(this.m_DrawingInfo);

    //스크롤 동작이 아닌 경우만 그린다
    if ((nDrawCase & DRAW_CASE_SCROLL) === 0) {
        //리얼데이터가 아닌 경우만 그린다
        if ((nDrawCase & DRAW_CASE_REAL) === 0)
            this.m_ScrollCtrl.Draw(this.m_DrawingInfo);

        this.BitBlt();
    }

    this.InitDrawCase();
}

CHTMLChart.prototype.BitBlt = function () {
    this.m_DrawingInfo.m_ScreenContext.drawImage(this.m_DrawingInfo.m_Context.canvas, 0, 0);
    this.m_MainBlock.DrawTool(this.m_DrawingInfo);
    this.m_MainBlock.DrawMagnifyRect(this.m_DrawingInfo);
    this.m_MainBlock.DrawCrossLine(this.m_DrawingInfo);
}

CHTMLChart.prototype.LogXScaleMng = function () {
    //for( var [ strKey, rXScaleMng ] of this.m_mapXScaleMng )
    for (var strKey in this.m_mapXScaleMng) {
        var rXScaleMng = this.m_mapXScaleMng[strKey];
        if (rXScaleMng != undefined) {
            switch (rXScaleMng.GetType()) {
                case DATETIME_TYPE:
                    {
                        rXScaleMng.Log();
                        break;
                    }
            }
        }
    }
    return true;
}

CHTMLChart.prototype.SetPacketData = function (strRQ, strPacketData, nDataLen, bAppend, bAscendingOrder, bMergeXScale) {
    var RQSet = this.m_mapRQSet[strRQ];
    if (RQSet == undefined)
        return false;

    var bResult = RQSet.SetPacketData(strPacketData, nDataLen, bAppend, bAscendingOrder);
    if (bResult && bMergeXScale) {
        //for( var[strKey, rXScaleMng] of this.m_mapXScaleMng )
        for (var strKey in this.m_mapXScaleMng) {
            var rXScaleMng = this.m_mapXScaleMng[strKey];
            if (rXScaleMng != undefined) {
                var rPacketData = RQSet.GetPacketData(rXScaleMng.GetXScalePacketName());
                switch (rXScaleMng.GetType()) {

                    case DATETIME_TYPE:
					{
                        var nTotalCnt = null;
                        if (bAppend) {
                            var nFindPos = strPacketData.indexOf("!");
                            if (nFindPos >= 0)
                                nTotalCnt = parseInt(strPacketData.substring(0, nFindPos));
                        }

                        rXScaleMng.Merge(rPacketData, bAppend, nTotalCnt);//append일 때만 SetPacketData에서 머지한다(머지 전에 모든 rq에 대한 주기,interval 정보로 m_MinIntervalArray 취합되어야 함)
                    }
                    break;
                    case NUMERIC_TYPE:
                    {
                        if(rXScaleMng.GetXScalePacketName() === "_HOGA_")
                        {
                            rXScaleMng.Merge(rPacketData);
                        }
                    }
                    break;
                }
            }
        }
    }

	//연속조회 처리 추가 >>
    if (bResult && bAppend) {

        this.ArrangeXScaleMng();

        this.ReSetScrollAfterAppend();

        this.ReCalcToolXPos();
    }
	//연속조회 처리 추가 <<

    return true;
}

CHTMLChart.prototype.MergeXScale = function (strRQ) {

    for (var strKey in this.m_mapXScaleMng) {
        var rXScaleMng = this.m_mapXScaleMng[strKey];
        if (rXScaleMng != undefined) {

            for (var sRQ in this.m_mapRQSet) {

                if (strRQ === undefined || strRQ === sRQ) {

                    var RQSet = this.m_mapRQSet[sRQ];
                    var rPacketData = RQSet.GetPacketData(rXScaleMng.GetXScalePacketName());
                    switch (rXScaleMng.GetType()) {

                        case DATETIME_TYPE:

                            var nTotalCnt = null;
                            rXScaleMng.Merge(rPacketData, false, nTotalCnt);//append일 때만 SetPacketData에서 머지한다(머지 전에 모든 rq에 대한 주기,interval 정보로 m_MinIntervalArray 취합되어야 함)

                            break;
                    }

                    //특정rq에 대해서만 머지
                    if (strRQ !== undefined)
                        break;
                }
            }
        }
    }
}

//색상값 변경
CHTMLChart.prototype.ChangeTheme = function (themeName) {

    // 테마명 설정(가장 먼저 테마명 변경할 것!!)
    /*
    this.m_strThemeName = themeName;

    this.m_GlobalProperty.ChangeTheme(this, false);

    // 그려질 차트 색상 변경
    // 글자색(X축, Y축)
    //this.m_DrawingInfo.m_strFontColor = colorTable[themeName].font;

    // 배경색
    //this.m_MainBlock.m_clrBack = color[type].background;

    //스크롤 색상
    this.m_ScrollCtrl.m_clrBack = this.m_GlobalProperty.m_clrBack;

    this.m_ScrollCtrl.m_clrTrackAllBong = this.m_GlobalProperty.m_clrBack;

    // 그려져 있는 차트 색상 변경
    for (var i in this.m_MainBlock.m_ChartBlockArray) {

        var rChartBlock = this.m_MainBlock.m_ChartBlockArray[i];

        // 배경색
        rChartBlock.m_clrBack = this.m_GlobalProperty.m_clrBack;

        // 블록내 버튼 이미지 변경 X
        if (rChartBlock.m_ButtonDiv !== null)
            rChartBlock.m_ButtonDiv.className = "chart_btn_grp " + themeName;
        
        // X 축
        for (var j in rChartBlock.m_XScaleArray) {
            var rXScale = rChartBlock.m_XScaleArray[j];
            rXScale.m_TopXAxis.SetBackColor(this.m_GlobalProperty.m_clrBack);
            rXScale.m_TopXAxis.m_clrText = this.m_GlobalProperty.m_clrText;
            rXScale.m_BottomXAxis.SetBackColor(this.m_GlobalProperty.m_clrBack);
            rXScale.m_BottomXAxis.m_clrText = this.m_GlobalProperty.m_clrText;
        }

        // Y 축
        for (var j in rChartBlock.m_YScaleArray) {

            var rYScale = rChartBlock.m_YScaleArray[j];
            rYScale.m_LeftYAxis.SetBackColor(this.m_GlobalProperty.m_clrBack);
            rYScale.m_LeftYAxis.m_clrText = this.m_GlobalProperty.m_clrText;
            rYScale.m_RightYAxis.SetBackColor(this.m_GlobalProperty.m_clrBack);
            rYScale.m_RightYAxis.m_clrText = this.m_GlobalProperty.m_clrText;
        }

        for (var j in rChartBlock.m_GraphArray) {

            var rGraph = rChartBlock.m_GraphArray[j];
            for (var k in rGraph.m_SubGraphArray) {

                var rSubGraph = rGraph.m_SubGraphArray[k];
                
                // 상단
                if (rSubGraph instanceof CPriceCandleSubGraph) {

                    rSubGraph.m_clrUpturnPlus = colorTable[themeName].upside.up; //상승양봉색상
                    rSubGraph.m_clrUpturnMinus = colorTable[themeName].upside.down; //상승음봉색상
                    rSubGraph.m_clrDropPlus = colorTable[themeName].upside.up; //하락양봉색상
                    rSubGraph.m_clrDropMinus = colorTable[themeName].upside.down; //하락음봉색상
                    rSubGraph.m_clrGapMinus = colorTable[themeName].upside.up; //갭음봉색상
                    rSubGraph.m_clrSteadyTone = colorTable[themeName].upside.up; //보합색상

                    rSubGraph.m_bFill = colorTable[themeName].upside.isFill;
                }
                // 하단
                else if (rSubGraph instanceof CPriceChartBarSubGraph) {

                    console.log(rSubGraph);
                    var priceCandleInfo = rSubGraph.m_rRQSet.m_CommonInfo.PriceCandleInfo;
                    priceCandleInfo.m_clrUpturnPlus = colorTable[themeName].downside.up; //상승양봉색상
                    priceCandleInfo.m_clrUpturnMinus = colorTable[themeName].downside.down; //상승음봉색상
                    priceCandleInfo.m_clrDropPlus = colorTable[themeName].downside.up; //하락양봉색상
                    priceCandleInfo.m_clrDropMinus = colorTable[themeName].downside.down; //하락음봉색상
                    priceCandleInfo.m_clrGapMinus = colorTable[themeName].downside.up; //갭음봉색상
                    priceCandleInfo.m_clrSteadyTone = colorTable[themeName].downside.up; //보합색상

                    rSubGraph.m_bFill = colorTable[themeName].downside.isFill;
                }
                // 그외 지표
                else if (rSubGraph instanceof CPriceChartLineSubGraph) {
                    // do nothing..
                }
            }
        }

        // 지표 그래프 색상 : m_clrSubGraph
    }

    this.Draw(DRAW_CASE_SET_GLOBAL_PROPERTY);
    

    // 하단 네비 이미지 변경
    var chartNavGrp = document.getElementsByClassName("chart_nav_grp");
    for (let i = 0; i < chartNavGrp.length; i++) {
        chartNavGrp[i].className = "chart_nav_grp " + themeName;
    }
    */
}
// 20190123 공현욱 화면별 스크롤바 타입 지정 >>
CHTMLChart.prototype.SetScrollBarType = function (nType) {
    if( nType === undefined ){
        this.m_nScrollBarType = SCROLL_GENERAL_TYPE;
    }
    this.m_nScrollBarType = nType;
}
CHTMLChart.prototype.GetScrollBarType = function () {
    return this.m_nScrollBarType;
}
// 20190123 공현욱 스크롤바 타입 지정 <<

// 20190115 전중현 : 트레이딩 라인 추가/삭제/업데이트
// nLineType - 0:미체결, 1:알림선, 2:평균매수가
CHTMLChart.prototype.AddTraidngLine = function ( nLineType, strKey, strCode, strPrice, nOptValue )
{
    return this.m_TradingLineMng.AddTraidngLine( nLineType, strKey, strCode, strPrice, nOptValue );
}

CHTMLChart.prototype.UpdateTradingLine = function ( nLineType, strKey, strCode, strPrice, nOptValue )
{
    return this.m_TradingLineMng.UpdateTradingLine( nLineType, strKey, strCode, strPrice, nOptValue );
}

CHTMLChart.prototype.RemoveTradingLine = function ( nLineType, strKey, strItemCode )
{
    return this.m_TradingLineMng.RemoveTradingLine( nLineType, strKey, strItemCode )
}

CHTMLChart.prototype.RemoveAllTradingLine = function ( nLineType )
{
    return this.m_TradingLineMng.RemoveAllTradingLine( nLineType );
}

//LKY 스마트시그널 신호 선 추가/삭제/업데이트
CHTMLChart.prototype.SetSmartSignalLine = function( nSignalType, strCode, strBuyingValue, strTargetValue, strStopLossValue, strSellValue){
    
    var rSmartSignalMng = this.m_mapSmartSignalMng[strCode];
    return rSmartSignalMng.SetSmartSignalLine( nSignalType, strCode, strBuyingValue, strTargetValue, strStopLossValue, strSellValue );
}

CHTMLChart.prototype.GetSmartSignal = function(strItemCode){
    
    var rSmartSignalMng = this.m_mapSmartSignalMng[strItemCode];
    return rSmartSignalMng;
}

//strDateTime: 14자리 형태(ex:20190215111011)
CHTMLChart.prototype.SetSmartSignalInfo = function(sRQ, strItemCode, strDateTime, strBuyPrice, strTargetPrice, strStopLossPrice, strSellPrice, bAppend){

    var rSmartSignalMng = this.m_mapSmartSignalMng[strItemCode];

    if(rSmartSignalMng === undefined){
        rSmartSignalMng = new CSmartSignalMng(this);

        this.m_mapSmartSignalMng[strItemCode] = rSmartSignalMng;
    }
    else{   // 20190212 공현욱 : 연속조회 아닐 시 arr에 데이터 초기화루틴 추가 (bAppend).
        if( bAppend !== true )
            rSmartSignalMng.m_SmartSignalInfoArray.length = 0;
    }
    
    var rSmartSignalInfo = new CSmartSignalInfo();

    rSmartSignalInfo.m_strCode = strItemCode;

    rSmartSignalInfo.m_strDateTime = strDateTime;
    
    rSmartSignalInfo.m_strBuyingPrice = strBuyPrice;

    var strBuyingPrice = rSmartSignalInfo.m_strBuyingPrice;
    if(strBuyingPrice === "")
        rSmartSignalInfo.m_strSignalType = "1";
    else
        rSmartSignalInfo.m_strSignalType = "0";
    
    rSmartSignalInfo.m_strTargetPrice = strTargetPrice;
    rSmartSignalInfo.m_strStopLossPrice = strStopLossPrice;
    rSmartSignalInfo.m_strSellPrice = strSellPrice;

    rSmartSignalMng.m_SmartSignalInfoArray[rSmartSignalMng.m_SmartSignalInfoArray.length] = rSmartSignalInfo;
    

    //rSmartSignalIndicator.Calc();
}

CHTMLChart.prototype.UpdateSmartSignalInfo = function(sRQ, strItemCode){

    var rSmartSignalMng = this.m_mapSmartSignalMng[strItemCode];

    if(rSmartSignalMng === undefined)
        return false;

    var rSmartSignalIndicator = this.m_mapRQSet[sRQ].m_rPriceIndicator;
    rSmartSignalIndicator.m_rSmartSignalMng = rSmartSignalMng;

    // 20190212 공현욱 : 스마트시그널 신호 실시간 작업 >>
    rSmartSignalIndicator.ArrangeSignalInfo();
    
    this.Draw(DRAW_CASE_TR);
}

//실시간 용도
//strDateTime: 14자리 형태(ex:20190215111011)
CHTMLChart.prototype.SetRealSmartSignalInfo = function(sRQ, strItemCode, strDateTime, strBuyPrice, strTargetPrice, strStopLossPrice, strSellPrice){

    var rSmartSignalMng = this.m_mapSmartSignalMng[strItemCode];

    if(rSmartSignalMng === undefined){
        rSmartSignalMng = new CSmartSignalMng(this);

        this.m_mapSmartSignalMng[strItemCode] = rSmartSignalMng;
    }

    var rSmartSignalInfo = new CSmartSignalInfo();

    rSmartSignalInfo.m_strCode = strItemCode;

    rSmartSignalInfo.m_strDateTime = strDateTime;
    
    rSmartSignalInfo.m_strBuyingPrice = strBuyPrice;

    var strBuyingPrice = rSmartSignalInfo.m_strBuyingPrice
    if(strBuyingPrice === "")
        rSmartSignalInfo.m_strSignalType = "1";
    else
        rSmartSignalInfo.m_strSignalType = "0";
    
    rSmartSignalInfo.m_strTargetPrice = strTargetPrice;
    rSmartSignalInfo.m_strStopLossPrice = strStopLossPrice;
    rSmartSignalInfo.m_strSellPrice = strSellPrice;

    rSmartSignalMng.m_SmartSignalInfoArray.unshift(rSmartSignalInfo);
   
    var rSmartSignalIndicator = this.m_mapRQSet[sRQ].m_rPriceIndicator;
    rSmartSignalIndicator.m_rSmartSignalMng = rSmartSignalMng;

    rSmartSignalIndicator.RealArrangeSignalInfo();
    
    this.Draw(DRAW_CASE_TR);
}

CHTMLChart.prototype.SetSelectedToolPropertyInfo = function(ToolPropertyInfo, bDraw){

    if( ToolPropertyInfo === undefined )
        return false;

    return this.m_MainBlock.m_ToolMng.SetSelectedToolPropertyInfo( ToolPropertyInfo, bDraw );
}

CHTMLChart.prototype.RollBackToolPropertyInfo = function(){

    return this.m_MainBlock.m_ToolMng.RollBackToolPropertyInfo();
}

CHTMLChart.prototype.RemoveAllTool = function(){

    this.m_MainBlock.RemoveAllTool();
    this.Draw(DRAW_CASE_REAL);
}

CHTMLChart.prototype.RemoveOneTool = function( bFalg ){

    this.m_MainBlock.m_ToolMng.SetDeleteFlag( bFalg );
}

CHTMLChart.prototype.SaveToolInfoByRQ = function( strRQ, bRemove ){

    var rRQSet = this.m_mapRQSet[strRQ];
    if( rRQSet === undefined )
        return false;

    this.m_MainBlock.SaveToolInfo( rRQSet, bRemove );
    
    //if( bRemove === true )
    //    this.Draw(DRAW_CASE_REAL);
}

CHTMLChart.prototype.LoadToolInfoByRQ = function( strRQ, strItemCode, nCycle ){
    
    var rRQSet = this.m_mapRQSet[strRQ];
    if( rRQSet === undefined )
        return false;

    this.m_MainBlock.m_ToolMng.LoadToolInfo( rRQSet, strItemCode, nCycle );
}

CHTMLChart.prototype.LoadAllToolInfo = function( mapAllToolProperty ){

    var bResult = false;
    if( mapAllToolProperty !== undefined )
        bResult = this.m_MainBlock.m_ToolMng.LoadAllToolInfo(mapAllToolProperty);

    return bResult;
}

CHTMLChart.prototype.ReCalcToolXPos = function(){

    for (var strKey in this.m_mapXScaleMng) {
        var rXScaleMng = this.m_mapXScaleMng[strKey];
        if (rXScaleMng !== undefined) {
            this.m_MainBlock.ReCalcToolXPos(rXScaleMng);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// 20190115 전중현 : 기준선 관련 >>
export function CPriceLine()
{
    this.m_bShow = false;          // Draw여부
    this.m_bUsePacket = true;       // 패킷값 사용여부
    this.m_strPacketName = "_CLOSE_";      // 사용 패킷명
    this.m_strBaseValue = "";       // 가격값
    this.m_strKeyOfClrLine = null;  //선색의 키값(테마변경시 색상변경을 위한 기능)
	this.m_strDefaultKeyOfClrLine = null;//기본설정으로 셋팅시 기본색상 얻기위한 기본색상 키값 저장
    this.m_clrLine = "#000000";     // 선색
    this.m_nLineType = PS_SOLID;    // 선타입
    this.m_nThickness = 1;          // 선두깨
}

CPriceLine.prototype.SetClrLine = function (clrLine) {
    this.m_strKeyOfClrLine = null;//사용자 지정으로 인해 색상테이블과의 관계를 끊는다(따라서 이후 테마가 변경되어도 색상은 고정된다)
    this.m_clrLine = clrLine;
}
CPriceLine.prototype.Copy = function( srcPriceLine )
{
    if( srcPriceLine === undefined )
        return;

    //기본자료형은 아래 루프를 통해 모두 복사
    for (var attr in srcPriceLine) {

        if (srcPriceLine.hasOwnProperty(attr)) {
            if (typeof (srcPriceLine[attr]) !== 'object') {//개체는 아래부분에서 별도 복사
                this[attr] = srcPriceLine[attr];
            }
        }
    }
    /*
    this.m_bShow = srcPriceLine.m_bShow;
    this.m_bUsePacket = srcPriceLine.m_bUsePacket;
    this.m_strPacketName = srcPriceLine.m_strPacketName;
    this.m_strBaseValue = srcPriceLine.m_strBaseValue;
    this.m_strKeyOfClrLine = srcPriceLine.m_strKeyOfClrLine;
	this.m_strDefaultKeyOfClrLine = srcPriceLine.m_strDefaultKeyOfClrLine;
    this.m_clrLine = srcPriceLine.m_clrLine;
    this.m_nLineType = srcPriceLine.m_nLineType;
    this.m_nThickness = srcPriceLine.m_nThickness;
    */
}

CPriceLine.prototype.Draw = function( DrawingInfo, xLeftPos, xRightPos, yPos )
{
    switch (this.m_nLineType)
    {
    case PS_SOLID : DrawingInfo.m_Context.setLineDash([0, 0]); break;
    case PS_DASH  : DrawingInfo.m_Context.setLineDash([8, 4]); break;
    case PS_DOT   : DrawingInfo.m_Context.setLineDash([2, 3]); break;
    }

    DrawingInfo.m_Context.strokeStyle = this.m_clrLine;
    DrawingInfo.m_Context.lineWidth = this.m_nThickness;
    
    DrawingInfo.m_Context.beginPath();

    DrawingInfo.m_Context.moveTo(xRightPos, yPos);
    DrawingInfo.m_Context.lineTo(xLeftPos, yPos);

    DrawingInfo.m_Context.stroke();
    DrawingInfo.m_Context.closePath();
}


// 기준선 설정정보를 구성하는 클래스로 기준선 설정창에 해당 클래스를 넘겨서 설정을 변경함
function CGuideLineProperty()
{
    this.m_strRQ = "";
    this.m_nLineCount = 0;

    this.m_bShowLine = true;
    this.m_bShowText = true;
    this.m_bShowValue = true;
    this.m_nTextPos = 1;        // 0 : left, 1 : right, 2 : both
    
    this.m_PriceLineArray = [];
}

CGuideLineProperty.prototype.SetDefaultProperty = function ( rChart )
{
    var rPriceLine = null;
	this.m_nLineCount = this.m_PriceLineArray.length;
    for( var i = 0; i < this.m_nLineCount ; i++ )
    {
        rPriceLine = this.m_PriceLineArray[i];
        if( rPriceLine === undefined)
            continue;

        rPriceLine.m_strKeyOfClrLine = rPriceLine.m_strDefaultKeyOfClrLine;
        rPriceLine.m_clrLine = rChart.GetColorByKey(rPriceLine.m_strDefaultKeyOfClrLine);
        rPriceLine.m_nLineType = PS_SOLID;
        rPriceLine.m_nThickness = 1;
        rPriceLine.m_bShow = false;
    }
}

CGuideLineProperty.prototype.Copy = function ( srcGuideLineProperty )
{
    //기본자료형은 아래 루프를 통해 모두 복사
    for (var attr in srcGuideLineProperty) {

        if (srcGuideLineProperty.hasOwnProperty(attr)) {
            if (typeof (srcGuideLineProperty[attr]) !== 'object') {//개체는 아래부분에서 별도 복사
                this[attr] = srcGuideLineProperty[attr];
            }
        }
    }

    var rSrcPriceLine = null;
    this.m_PriceLineArray = [];
    for( var i = 0; i < srcGuideLineProperty.m_nLineCount; i++ )
    {
        rSrcPriceLine = srcGuideLineProperty.m_PriceLineArray[i];

        var PriceLine = new CPriceLine();
        PriceLine.Copy( rSrcPriceLine );
        this.m_PriceLineArray[this.m_PriceLineArray.length] = PriceLine;
    }
    this.m_nLineCount = this.m_PriceLineArray.length;
}

function CGuideLineMng(rChart)
{
    this.m_rChart = rChart;
    this.m_rGlobalProperty = (this.m_rChart !== null ? this.m_rChart.GetGlobalProperty() : null);

    this.m_strRQ = "";
    this.m_rRQSet = null;
    this.m_rChartBlock = null;
    //this.m_DefaultColorArray = [ "#C5A6E1", "#E36460", "#3E527A", "#FFD0CF", "#A9D22D", "#6A8FBF" ];
    this.m_DefaultColorKeyArray = ["guideOpen", "guideHigh", "guideLow", "guideClose", "guideOHL3", "guideHL2",
                                    "guidePrevOpen", "guidePrevHigh", "guidePrevLow", "guidePrevClose"];
    this.m_DefaultPacketArray = ["_OPEN_", "_HIGH_", "_LOW_", "_CLOSE_", "_OHL3_", "_HL2_",
                                    "_PREOPEN_", "_PREHIGH_", "_PRELOW_", "_PRECLOSE_" ];

    this.m_strTodayOpenLineLangKey = 'chart.todayopenline';
    this.m_strTodayHighLineLangKey = 'chart.todayhighline';
    this.m_strTodayLowLineLangKey = 'chart.todaylowline';
    this.m_strTodayCloseLineLangKey = 'chart.todaycloseline';
    this.m_strTodayOHL3LineLangKey = 'chart.div3openhighlowline';
    this.m_strTodayHL2LineLangKey = 'chart.div2highlowline';
    this.m_strYesterdayOpenLineLangKey = 'chart.preopenline';
    this.m_strYesterdayHighLineLangKey = 'chart.prehighline';
    this.m_strYesterdayLowLineLangKey = 'chart.prelowline';
    this.m_strYesterdayCloseLineLangKey = 'chart.precloseline';
    this.m_strUpperPriceLineLangKey = 'chart.upper';
    this.m_strLowerPriceLineLangKey = 'chart.lower';
    this.m_strUserDefineLineLangKey = 'chart.userdefine';

    this.m_strTodayOpenLine = t(this.m_strTodayOpenLineLangKey);
    this.m_strTodayHighLine = t(this.m_strTodayHighLineLangKey);
    this.m_strTodayLowLine = t(this.m_strTodayLowLineLangKey);
    this.m_strTodayCloseLine = t(this.m_strTodayCloseLineLangKey);
    this.m_strTodayOHL3Line = t(this.m_strTodayOHL3LineLangKey);
    this.m_strTodayHL2Line = t(this.m_strTodayHL2LineLangKey);
    this.m_strYesterdayOpenLine = t(this.m_strYesterdayOpenLineLangKey);
    this.m_strYesterdayHighLine = t(this.m_strYesterdayHighLineLangKey);
    this.m_strYesterdayLowLine = t(this.m_strYesterdayLowLineLangKey);
    this.m_strYesterdayCloseLine = t(this.m_strYesterdayCloseLineLangKey);
    this.m_strUpperPriceLine = t(this.m_strUpperPriceLineLangKey);
    this.m_strLowerPriceLine = t(this.m_strLowerPriceLineLangKey);
    this.m_strUserDefineLine = t(this.m_strUserDefineLineLangKey);

    this.m_GuideLineProperty = null;
}

CGuideLineMng.prototype.ChangeLang = function(){

    this.m_strTodayOpenLine = t(this.m_strTodayOpenLineLangKey);
    this.m_strTodayHighLine = t(this.m_strTodayHighLineLangKey);
    this.m_strTodayLowLine = t(this.m_strTodayLowLineLangKey);
    this.m_strTodayCloseLine = t(this.m_strTodayCloseLineLangKey);
    this.m_strTodayOHL3Line = t(this.m_strTodayOHL3LineLangKey);
    this.m_strTodayHL2Line = t(this.m_strTodayHL2LineLangKey);
    this.m_strYesterdayOpenLine = t(this.m_strYesterdayOpenLineLangKey);
    this.m_strYesterdayHighLine = t(this.m_strYesterdayHighLineLangKey);
    this.m_strYesterdayLowLine = t(this.m_strYesterdayLowLineLangKey);
    this.m_strYesterdayCloseLine = t(this.m_strYesterdayCloseLineLangKey);
    this.m_strUpperPriceLine = t(this.m_strUpperPriceLineLangKey);
    this.m_strLowerPriceLine = t(this.m_strLowerPriceLineLangKey);
    this.m_strUserDefineLine = t(this.m_strUserDefineLineLangKey);
}
CGuideLineMng.prototype.CreateGuideLineMng = function (rRQSet)
{
    var GuideLineProperty = new CGuideLineProperty();
    this.m_GuideLineProperty = GuideLineProperty;

    this.m_rRQSet = rRQSet;
    this.m_strRQ = GuideLineProperty.m_strRQ = rRQSet.GetRQ();
    
	var nLineCount = this.m_DefaultPacketArray.length;
    for (var i = 0; i < nLineCount; i++)
    {
        var PriceLine = new CPriceLine();
        PriceLine.m_strKeyOfClrLine = this.m_DefaultColorKeyArray[i];
		PriceLine.m_strDefaultKeyOfClrLine = PriceLine.m_strKeyOfClrLine;
        PriceLine.m_clrLine = this.m_rChart.GetColorByKey(this.m_DefaultColorKeyArray[i]);
        PriceLine.m_strPacketName = this.m_DefaultPacketArray[i];
        GuideLineProperty.m_PriceLineArray[GuideLineProperty.m_PriceLineArray.length] = PriceLine;
    }
    
    GuideLineProperty.m_nLineCount = GuideLineProperty.m_PriceLineArray.length;

    // 생성할때 GlobarProperty 맵에 GuideLineProperty 연결
	// RQ 삭제시 m_mapGuideLineProperty 에도 삭제 필요
    this.GetPropertyInfo();
}

CGuideLineMng.prototype.SetPropertyInfo = function (PropertyInfo, bSetup )
{
    if( PropertyInfo === undefined || this.m_strRQ !== PropertyInfo.m_strRQ)
        return;

    this.m_GuideLineProperty = PropertyInfo;
}

CGuideLineMng.prototype.GetPropertyInfo = function()
{
    this.m_rGlobalProperty.m_mapGuideLineProperty[this.m_strRQ] = this.m_GuideLineProperty;
}

CGuideLineMng.prototype.Draw = function (DrawingInfo)
{
    if (this.m_rChartBlock === null)
        return;

    var rGuideLineProperty = this.m_GuideLineProperty;

    var xLeftPos, xRightPos, yPos, xPos;
    var rPriceLine = null;
    var strText, strBaseValue, strPrice;

    var rectGraphRegion = this.m_rChartBlock.m_rectGraphRegion;
    var rectGraphBackground = this.m_rChartBlock.m_rectGraphBackground;
    var nGraphRegionHeight = rectGraphRegion.Height();
    
    var rYScale = this.m_rChartBlock.GetSelectedYScale();

    xLeftPos = rectGraphBackground.m_nLeft;
    xRightPos = rectGraphBackground.m_nRight;

    for (var i = 0; i < rGuideLineProperty.m_nLineCount; i++)
    {
        rPriceLine = rGuideLineProperty.m_PriceLineArray[i];

        if (rPriceLine.m_bShow === false) continue;
        
        if (rPriceLine.m_bUsePacket === true)
        {
            var RQInfo = this.m_rRQSet.m_RQInfo;

            switch( rPriceLine.m_strPacketName )
            {
                case '_OPEN_':  strBaseValue = RQInfo.m_OpenPrice;
                                strText = this.m_strTodayOpenLine;  break; //당일시가
                case '_HIGH_':  strBaseValue = RQInfo.m_HighPrice;
                                strText = this.m_strTodayHighLine;  break; //당일고가
                case '_LOW_':   strBaseValue = RQInfo.m_LowPrice;
                                strText = this.m_strTodayLowLine;  break; //당일저가
                case '_CLOSE_': strBaseValue = RQInfo.m_CurPrice;
                                strText = this.m_strTodayCloseLine;  break; //당일종가
                case '_OHL3_': strBaseValue = RQInfo.m_OHL3Price;
                                strText = this.m_strTodayOHL3Line;  break; //(시+고+저)/3
                case '_HL2_': strBaseValue = RQInfo.m_HL2Price;
                                strText = this.m_strTodayHL2Line;  break; //(고+저)/2
                case '_PREOPEN_': strBaseValue = RQInfo.m_PreOpenPrice;
                                strText = this.m_strYesterdayOpenLine;  break; //전일시가
                case '_PREHIGH_': strBaseValue = RQInfo.m_PreHighPrice;
                                strText = this.m_strYesterdayHighLine;  break; //전일고가
                case '_PRELOW_': strBaseValue = RQInfo.m_PreLowPrice;
                                strText = this.m_strYesterdayLowLine;  break; //전일저가
                case '_PRECLOSE_': strBaseValue = RQInfo.m_PrevPrice;
                                strText = this.m_strYesterdayCloseLine;  break; //전일종가
                case '_UPPER_': strBaseValue = RQInfo.m_UpperPrice;
                                strText = this.m_strUpperPriceLine;  break; //상한가
                case '_LOWER_': strBaseValue = RQInfo.m_LowerPrice;
                                strText = this.m_strLowerPriceLine;  break; //하한가
            }
        }
        else
        {
            strBaseValue = rPriceLine.m_strBaseValue;
            strText = this.m_strUserDefineLine;
        }

        //strBaseValue = 135.04;

        if( strBaseValue === null || strBaseValue === undefined )
            continue;

        var yMin, yMax, yDiff, BaseValue;
        var bLog = rYScale.GetLog();
        if (bLog === true) {

            yMin = Log(rYScale.m_MinMaxInfo.m_LowerLimit);
            yMax = Log(rYScale.m_MinMaxInfo.m_UpperLimit);
            BaseValue = Log(strBaseValue);
        }
        else {

            yMin = rYScale.m_MinMaxInfo.m_LowerLimit;
            yMax = rYScale.m_MinMaxInfo.m_UpperLimit;
            BaseValue = strBaseValue;
        }
        
        yDiff = yMax - yMin;

        yPos = rectGraphRegion.m_nBottom - (BaseValue - yMin) / yDiff * nGraphRegionHeight;

        if (rYScale.GetInvert() === true)
            yPos = rectGraphRegion.m_nBottom - yPos + rectGraphRegion.m_nTop;
        
        if (yPos > rectGraphRegion.m_nTop && yPos < rectGraphRegion.m_nBottom)
        {
            DrawingInfo.m_Context.fillStyle = rPriceLine.m_clrLine;
            strPrice = ConvertNumToDigitText(strBaseValue, rYScale.m_nDec, 1, rYScale.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

            if( rGuideLineProperty.m_bShowText === false )
                strText = strPrice;
            else
            {
                if( rGuideLineProperty.m_bShowValue === true )
                    strText += strPrice;
            }

            if( rGuideLineProperty.m_bShowLine === true )
            {
                rPriceLine.Draw( DrawingInfo, xLeftPos, xRightPos, yPos );
            }

            if( rGuideLineProperty.m_bShowText === true || rGuideLineProperty.m_bShowValue === true )
            {
                if( yPos - DrawingInfo.m_nFontHeight < rectGraphRegion.m_nTop )
                {
                    DrawingInfo.m_Context.textBaseline = "top";
                    yPos += 2;
                }
                else
                {
                    DrawingInfo.m_Context.textBaseline = "bottom";
                    yPos -= 1;
                }
                
                if( rGuideLineProperty.m_nTextPos === 0 )
                {
                    xPos = xLeftPos + 1;
                    DrawingInfo.m_Context.textAlign = "left";
                    DrawingInfo.m_Context.fillText(strText, xPos, yPos);
                }
                else if( rGuideLineProperty.m_nTextPos === 1 )
                {
                    xPos = xRightPos - 1;
                    DrawingInfo.m_Context.textAlign = "right";
                    DrawingInfo.m_Context.fillText(strText, xPos, yPos);
                }
                else if( rGuideLineProperty.m_nTextPos === 2 )
                {
                    xPos = xLeftPos + 1;
                    DrawingInfo.m_Context.textAlign = "left";
                    DrawingInfo.m_Context.fillText(strText, xPos, yPos);

                    xPos = xRightPos - 1;
                    DrawingInfo.m_Context.textAlign = "right";
                    DrawingInfo.m_Context.fillText(strText, xPos, yPos);
                }
            }
        }
    }
}
// 20190115 전중현 : 기준선 관련 <<
///////////////////////////////////////////////////////////////////////////////

// 20190115 전중현 : 트레이딩 라인 관련 (미체결, 알림(지정가), 평균매수가) >>

// 미체결 라인
function CNonContractLine()
{
    this.m_strKey = "";         // 키값
    this.m_strItemCode = "";    // 종목코드
    this.m_strPrice = "";       // 체결가격
    this.m_nHolingCount = 0;    // 미체결 수량
}

// 알람 라인
function CAlarmLine()
{
    this.m_strKey = "";         // 키값
    this.m_strItemCode = "";    // 종목코드
    this.m_strPrice = "";       // 지정가격
    this.m_CondType = "";       // 발동조건
}

// 평균매수가 라인
function CAvgBuyPriceLine()
{
    this.m_strKey = "";         // 키값
    this.m_strItemCode = "";    // 종목코드
    this.m_strPrice = "";       // 평균매수가
}

export function CTradingLineProperty(rChart)
{
    this.m_nLineTypeNonContract = PS_SOLID;
    this.m_nLineTypeAlarm = PS_SOLID;
    this.m_nLineTypeAvgBuyPrice = PS_SOLID;

    this.m_nThicknessNonContract = 1;
    this.m_nThicknessAlarm = 1;
    this.m_nThicknessAvgBuyPrice = 1;

    this.m_strKeyOfClrNonContractLine = "nonContractLine";
    this.m_clrNonContractLine = rChart === undefined ? "#C5A6E1" : rChart.GetColorByKey(this.m_strKeyOfClrNonContractLine);
    this.m_strKeyOfClrAlarmLine = "alarmLine";
    this.m_clrAlarmLine = rChart === undefined ? "#E36460" : rChart.GetColorByKey(this.m_strKeyOfClrAlarmLine);
    this.m_strKeyOfClrAvgBuyPriceLine = "avgBuyPriceLine";
    this.m_clrAvgBuyPriceLine = rChart === undefined ? "#E36460" : rChart.GetColorByKey(this.m_strKeyOfClrAvgBuyPriceLine);

    this.m_bShowNonContractLine = false;
    this.m_bShowAlarmLine = false;
    this.m_bShowAvgBuyPriceLine = false;

    this.m_bShowLine = true;
    this.m_bShowText = true;
    this.m_bShowValue = true;
    this.m_nTextPos = 1;        // 0 : left, 1 : right, 2 : both
}
CTradingLineProperty.prototype.SetClrNonContractLine = function (clrNonContractLine) {

    this.m_strKeyOfClrNonContractLine = null;
    this.m_clrNonContractLine = clrNonContractLine;
}
CTradingLineProperty.prototype.SetClrAlarmLine = function (clrAlarmLine) {

    this.m_strKeyOfClrAlarmLine = null;
    this.m_clrAlarmLine = clrAlarmLine;
}
CTradingLineProperty.prototype.SetClrAvgBuyPriceLine = function (clrAvgBuyPriceLine) {

    this.m_strKeyOfClrAvgBuyPriceLine = null;
    this.m_clrAvgBuyPriceLine = clrAvgBuyPriceLine;
}

CTradingLineProperty.prototype.SetDefaultProperty = function ( rChart )
{
    this.m_strKeyOfClrNonContractLine = "nonContractLine";
    this.m_clrNonContractLine = rChart === undefined ? "#C5A6E1" : rChart.GetColorByKey(this.m_strKeyOfClrNonContractLine);
    this.m_strKeyOfClrAlarmLine = "alarmLine";
    this.m_clrAlarmLine = rChart === undefined ? "#E36460" : rChart.GetColorByKey(this.m_strKeyOfClrAlarmLine);
    this.m_strKeyOfClrAvgBuyPriceLine = "avgBuyPriceLine";
    this.m_clrAvgBuyPriceLine = rChart === undefined ? "#E36460" : rChart.GetColorByKey(this.m_strKeyOfClrAvgBuyPriceLine);

    this.m_nLineTypeNonContract = PS_SOLID;
    this.m_nLineTypeAlarm = PS_SOLID;
    this.m_nLineTypeAvgBuyPrice = PS_SOLID;

    this.m_nThicknessNonContract = 1;
    this.m_nThicknessAlarm = 1;
    this.m_nThicknessAvgBuyPrice = 1;

    this.m_bShowNonContractLine = false;
    this.m_bShowAlarmLine = false;
    this.m_bShowAvgBuyPriceLine = false;
}

CTradingLineProperty.prototype.Copy = function ( srcTradingLineProperty )
{
    //기본자료형은 아래 루프를 통해 모두 복사
    for (var attr in srcTradingLineProperty) {

        if (srcTradingLineProperty.hasOwnProperty(attr)) {
            if (typeof (srcTradingLineProperty[attr]) !== 'object') {//개체는 아래부분에서 별도 복사
                this[attr] = srcTradingLineProperty[attr];
            }
        }
    }
}

function CTradingLineMng(rChart)
{
    this.m_rChart = rChart;
    this.m_rGlobalProperty = (this.m_rChart !== null ? this.m_rChart.GetGlobalProperty() : null);
    this.m_rChartBlock = null;

    this.m_TradingLineProperty = new CTradingLineProperty(rChart);

    this.m_NonContractLineArray = [];       // 미체결선 배열
    this.m_NonContractLineArray.m_strLineTitleLangKey = "chart.noncontract";
    this.m_NonContractLineArray.m_strLineTitle = t(this.m_NonContractLineArray.m_strLineTitleLangKey);

    this.m_AlarmLineArray = [];             // 알림선 배열
    this.m_AlarmLineArray.m_strLineTitleLangKey = "chart.pricealert";
    this.m_AlarmLineArray.m_strLineTitle = t(this.m_AlarmLineArray.m_strLineTitleLangKey);

    this.m_AvgBuyPriceArray = [];           // 평균매수가 배열
    this.m_AvgBuyPriceArray.m_strLineTitleLangKey = "chart.avgbuyprice";
    this.m_AvgBuyPriceArray.m_strLineTitle = t(this.m_AvgBuyPriceArray.m_strLineTitleLangKey);

    this.m_rSelectdLine = null;
    this.m_bSelected = false;
    
    this.m_nSelectMargin = 1;
    this.m_nBoxSize = 20;

    this.m_strQtyLabelLangKey = "chart.qty";
    this.m_strQtyLabel = t(this.m_strQtyLabelLangKey);

    this.SetPropertyInfoToGlobalProperty();
}

CTradingLineMng.prototype.ChangeLang = function(){
    
    this.m_NonContractLineArray.m_strLineTitle = t(this.m_NonContractLineArray.m_strLineTitleLangKey);

    this.m_AlarmLineArray.m_strLineTitle = t(this.m_AlarmLineArray.m_strLineTitleLangKey);

    this.m_AvgBuyPriceArray.m_strLineTitle = t(this.m_AvgBuyPriceArray.m_strLineTitleLangKey);

    this.m_strQtyLabel = t(this.m_strQtyLabelLangKey);
}
CTradingLineMng.prototype.SetPropertyInfo = function (PropertyInfo, bSetup )
{
    if( PropertyInfo === undefined )
        return;

    this.m_TradingLineProperty = PropertyInfo;
    this.SetPropertyInfoToGlobalProperty();
}

CTradingLineMng.prototype.SetPropertyInfoToGlobalProperty = function()
{
    this.m_rGlobalProperty.m_rTradingLineProterty = this.m_TradingLineProperty;
}

CTradingLineMng.prototype.SelecteTradingLine = function( rTradingLine )
{
    this.m_rSelectedLine = rTradingLine;
    this.m_bSelected = true;
}

CTradingLineMng.prototype.UnSelectTradingLine = function()
{
    if (this.m_rSelectdLine !== null ) {
        this.m_bSelected = false;
        this.m_rSelectdLine = null;
        return true;
    }
    return false;
}

CTradingLineMng.prototype.OnMouseDown = function (e, rChartBlock)
{
    var bSelect = false;
    var bUnSelect = this.UnSelectTradingLine();

    if( this.m_TradingLineProperty.m_bShowAlarmLine === false || this.m_AlarmLineArray.length === 0 )
        return bSelect;

    var X = e.ChartXPos;
    var Y = e.ChartYPos;

    var xStartPos, xEndPos, yStartPos, yEndPos, yPricePos;
    var rectGraphRegion = rChartBlock.m_rectGraphRegion;
    var rectGraphBackground = rChartBlock.m_rectGraphBackground;
    var nGraphRegionHeight = rectGraphRegion.Height();
    var nMargin = this.m_nSelectMargin;
    var nBoxSize = this.m_nBoxSize;

    xEndPos = rectGraphBackground.m_nRight;
    xStartPos = xEndPos - nBoxSize;

    if( xStartPos <= xEndPos )
    {
        if( X < ( xStartPos - nMargin ) || ( xEndPos + nMargin ) < X )
            return bSelect;
    }
    else
    {
        if( X < ( xEndPos - nMargin ) || ( xStartPos + nMargin ) < X )
            return bSelect;
    }

    var rYScale = rChartBlock.GetSelectedYScale();

    var yMin, yMax, yDiff, Price;
    var bLog = rYScale.GetLog();
    var bInvert = rYScale.GetInvert();
    if (bLog === true) {

        yMin = Log(rYScale.m_MinMaxInfo.m_LowerLimit);
        yMax = Log(rYScale.m_MinMaxInfo.m_UpperLimit);
    }
    else {

        yMin = rYScale.m_MinMaxInfo.m_LowerLimit;
        yMax = rYScale.m_MinMaxInfo.m_UpperLimit;
    }

    yDiff = yMax - yMin;

    // 현재는 알림선 삭제기능 있음
    var i, nLength = this.m_AlarmLineArray.length;
    for( i = 0; i < nLength; i++ )
    {
        var rTradingLine = this.m_AlarmLineArray[i];
        Price = bLog === true ? Log(rTradingLine.m_strPrice) : rTradingLine.m_strPrice;
        yPricePos = rectGraphRegion.m_nBottom - (Price - yMin) / yDiff * nGraphRegionHeight;
        if (bInvert === true)
            yPricePos = rectGraphRegion.m_nBottom - yPricePos + rectGraphRegion.m_nTop;

        yStartPos = yPricePos + (nBoxSize/2);
        yEndPos = yStartPos - nBoxSize;

        if( yStartPos <= yEndPos )
        {
            if( Y < ( yStartPos - nMargin ) || ( yEndPos + nMargin ) < Y )
                continue;
        }
        else
        {
            if( Y < ( yEndPos - nMargin ) || ( yStartPos + nMargin ) < Y )
                continue;
        }
      
        bSelect = true;
        break;
    }

    if( bSelect )
    {
        this.SelecteTradingLine(rTradingLine);
        this.m_rChart.SendEvent("Event_SelectTradingLine", rTradingLine);
    }

    //if( bUnSelect === true || bSelect === true )
    //   this.m_rChart.Draw(DRAW_CASE_SELECT_SUBGRAPH);

    return bSelect;
}

CTradingLineMng.prototype.FindTradingLine = function( nLineType, strKey, strItemCode )
{
    if( nLineType > 2 || nLineType < 0 )
        return undefined;
    
    var rLineArray = undefined;
    var rTradingLine = undefined;

    if( nLineType === 0 )
        rLineArray = this.m_NonContractLineArray;
    else if( nLineType === 1)
        rLineArray = this.m_AlarmLineArray;
    else if( nLineType === 2)
        rLineArray = this.m_AvgBuyPriceArray;

    if( rLineArray === undefined )
        return undefined;

    for( var i = 0; i < rLineArray.length; i++ )
    {
        rTradingLine = rLineArray[i];
        if( rTradingLine !== null && rTradingLine !== undefined )
        {
            if( rTradingLine.m_strKey === strKey && rTradingLine.m_strItemCode === strItemCode )
                return rTradingLine;
        }
    }

    return undefined;
}

CTradingLineMng.prototype.AddTraidngLine = function ( nLineType, strKey, strItemCode, strPrice, nOptValue )
{
    var rTradingLine = this.FindTradingLine( nLineType, strKey, strItemCode );

    if( rTradingLine === undefined )
    {
        switch( nLineType )
        {
        case 0: rTradingLine = new CNonContractLine(); break;
        case 1: rTradingLine = new CAlarmLine(); break;
        case 2: rTradingLine = new CAvgBuyPriceLine(); break;
        }
    }

    rTradingLine.m_strKey = strKey;
    rTradingLine.m_strItemCode = strItemCode;
    rTradingLine.m_strPrice = strPrice;
    
    if( nLineType == 0 )
        rTradingLine.m_nHolingCount = nOptValue;
    
    var rLineArray = null;
    switch( nLineType )
    {
    case 0: rLineArray = this.m_NonContractLineArray; break;
    case 1: rLineArray = this.m_AlarmLineArray; break;
    case 2: rLineArray = this.m_AvgBuyPriceArray; break;
    }

    rLineArray[rLineArray.length] = rTradingLine;

    return true;
}

CTradingLineMng.prototype.UpdateTradingLine = function ( nLineType, strKey, strItemCode, strPrice, nOptValue )
{
    var rTradingLine = this.FindTradingLine( nLineType, strKey, strItemCode );

    if( rTradingLine === undefined )
        return false;

    rTradingLine.m_strKey = strKey;
    rTradingLine.m_strItemCode = strItemCode;
    rTradingLine.m_strPrice = strPrice;
    
    if( nLineType == 0 )
        rTradingLine.m_nHolingCount = nOptValue;

    return true;
}

CTradingLineMng.prototype.RemoveTradingLine = function ( nLineType, strKey, strItemCode )
{
    var rLineArray = null;
    var rTradingLine = undefined;

    switch( nLineType )
    {
    case 0: rLineArray = this.m_NonContractLineArray; break;
    case 1: rLineArray = this.m_AlarmLineArray; break;
    case 2: rLineArray = this.m_AvgBuyPriceArray; break;
    }

    for( var i = 0; i < rLineArray.length; i++ )
    {
        rTradingLine = rLineArray[i];
        if( rTradingLine !== null && rTradingLine !== undefined )
        {
            if( rTradingLine.m_strKey === strKey && rTradingLine.m_strItemCode === strItemCode )
            {
                rLineArray.splice(i, 1);
                return true;
            }
        }
    }
    return false;
}

CTradingLineMng.prototype.RemoveAllTradingLine = function ( nLineType  )
{
    switch( nLineType )
    {
    case 0: this.m_NonContractLineArray.length = 0; break;
    case 1: this.m_AlarmLineArray.length = 0; break;
    case 2: this.m_AvgBuyPriceArray.length = 0; break;
    }

    return true;
}

CTradingLineMng.prototype.Draw = function(DrawingInfo, strItemCode)
{
    if(this.m_rChartBlock === null)
        return;

    var rTradingLineProperty = this.m_TradingLineProperty;

    if( rTradingLineProperty.m_bShowNonContractLine === false && this.m_bShowAlarmLine === false && this.m_bShowAvgBuyPriceLine === false )
        return;

    if( this.m_NonContractLineArray.length === 0 && this.m_AlarmLineArray.length === 0 && this.m_AvgBuyPriceArray.length === 0 )
        return;

    var i, j, nBoxSize = this.m_nBoxSize;
    var strText, strLineType, strPrice, nLineCount;
    var xLeftPos, xRightPos, yPos, xPos;
    
    var rectGraphRegion = this.m_rChartBlock.m_rectGraphRegion;
    var rectGraphBackground = this.m_rChartBlock.m_rectGraphBackground;
    var nGraphRegionHeight = rectGraphRegion.Height();
    
    var rYScale = this.m_rChartBlock.GetSelectedYScale();
    var yMin, yMax, yDiff, Price;
    var bLog = rYScale.GetLog();
    var bInvert = rYScale.GetInvert();

    if (bLog === true) {

        yMin = Log(rYScale.m_MinMaxInfo.m_LowerLimit);
        yMax = Log(rYScale.m_MinMaxInfo.m_UpperLimit);
    }
    else {

        yMin = rYScale.m_MinMaxInfo.m_LowerLimit;
        yMax = rYScale.m_MinMaxInfo.m_UpperLimit;
    }
    yDiff = yMax - yMin;

    xLeftPos = rectGraphBackground.m_nLeft;
    xRightPos = rectGraphBackground.m_nRight;

    var rLineArray = null;
    var bShow, nLineType, nThickness, clrLine;
    var nXSize = nBoxSize/4;
    var nBoxThickness = this.m_rChart.m_nBrowserType == 4 ? 4 : 2;

    //   this.m_NonContractLineArray.m_strLineTitleLangKey = "chart.noncontract";
    //this.m_NonContractLineArray.m_strLineTitle = "매매선(미체결)";

    //this.m_AlarmLineArray = [];             // 알림선 배열
    //this.m_AlarmLineArray.m_strLineTitleLangKey = "chart.pricealert";
    //this.m_AlarmLineArray.m_strLineTitle = "알림(지정가)";

    //this.m_AvgBuyPriceArray = [];           // 평균매수가 배열
    //this.m_AvgBuyPriceArray.m_strLineTitleLangKey = "chart.avgbuyprice";
    //this.m_AvgBuyPriceArray.m_strLineTitle = "평균매수가"; //
    for( j = 0; j < 3; j++ )
    {
        switch( j )
        {
        case 0 :
            {
                rLineArray = this.m_NonContractLineArray;
                bShow = rTradingLineProperty.m_bShowNonContractLine;
                nLineType = rTradingLineProperty.m_nLineTypeNonContract;
                clrLine = rTradingLineProperty.m_clrNonContractLine;
                nThickness = rTradingLineProperty.m_nThicknessNonContract;
                strLineType = rLineArray.m_strLineTitle;
            }break;
        case 1 :
            {
                rLineArray = this.m_AlarmLineArray;
                bShow = rTradingLineProperty.m_bShowAlarmLine;
                nLineType = rTradingLineProperty.m_nLineTypeAlarm;
                clrLine = rTradingLineProperty.m_clrAlarmLine;
                nThickness = rTradingLineProperty.m_nThicknessAlarm;
                strLineType = rLineArray.m_strLineTitle;
            }break;
        case 2 :
            {
                rLineArray = this.m_AvgBuyPriceArray;
                bShow = rTradingLineProperty.m_bShowAvgBuyPriceLine;
                nLineType = rTradingLineProperty.m_nLineTypeAvgBuyPrice;
                clrLine = rTradingLineProperty.m_clrAvgBuyPriceLine;
                nThickness = rTradingLineProperty.m_nThicknessAvgBuyPrice;
                strLineType = rLineArray.m_strLineTitle;
            }break;
        }

        nLineCount = rLineArray.length;
        if( bShow === true && nLineCount > 0 )
        {
            var rTradingLine = null;
            for( i = 0; i < nLineCount; i++ )
            {
                rTradingLine = rLineArray[i];
    
                if( strItemCode !== rTradingLine.m_strItemCode )
                    continue;
    
                Price = bLog === true ? Log(rTradingLine.m_strPrice) : rTradingLine.m_strPrice;
                yPos = rectGraphRegion.m_nBottom - (Price - yMin) / yDiff * nGraphRegionHeight;
                if (bInvert === true)
                    yPos = rectGraphRegion.m_nBottom - yPos + rectGraphRegion.m_nTop;

                if (yPos > rectGraphRegion.m_nTop && yPos < rectGraphRegion.m_nBottom)
                {
                    DrawingInfo.m_Context.fillStyle = clrLine;
                    strPrice = ConvertNumToDigitText(rTradingLine.m_strPrice, rYScale.m_nDec, 1, rYScale.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);

                    if( rTradingLineProperty.m_bShowLine === true )
                    {
                        switch (nLineType)
                        {
                        case PS_SOLID : DrawingInfo.m_Context.setLineDash([0, 0]); break;
                        case PS_DASH  : DrawingInfo.m_Context.setLineDash([8, 4]); break;
                        case PS_DOT   : DrawingInfo.m_Context.setLineDash([2, 3]); break;
                        }
                        
                        DrawingInfo.m_Context.strokeStyle = clrLine;
                        DrawingInfo.m_Context.lineWidth = nThickness;
        
                        DrawingInfo.m_Context.beginPath();
        
                        DrawingInfo.m_Context.moveTo(xRightPos, yPos);
                        DrawingInfo.m_Context.lineTo(xLeftPos, yPos);
        
                        DrawingInfo.m_Context.stroke();
                        DrawingInfo.m_Context.closePath();
                    }
    
                    if( rTradingLineProperty.m_bShowText === true || rTradingLineProperty.m_bShowValue === true )
                    {
                        if( j === 0 )   // 미체결
                        {
                            if( rTradingLineProperty.m_bShowText === false )
                                strText = strPrice + ":" + rTradingLine.m_nHolingCount;
                            else
                            {
                                if( rTradingLineProperty.m_bShowValue === true )
                                    strText = strLineType + strPrice + " " + this.m_strQtyLabel + ":" +  rTradingLine.m_nHolingCount;
                                else
                                    strText = strLineType;
                            }
                        }
                        else    // 알림, 평균매수가
                        {
                            if( rTradingLineProperty.m_bShowText === false )
                                strText = strPrice;
                            else
                            {
                                strText = strLineType;
                                if( rTradingLineProperty.m_bShowValue === true )
                                    strText += strPrice;
                            }
                        }
                        
                        // 상단 타이틀 영역 or 그래프 영역 넘어서지 않도록 예외처리
                        if( yPos - DrawingInfo.m_nFontHeight < rectGraphRegion.m_nTop )
                        {
                            DrawingInfo.m_Context.textBaseline = "top";
                            yPos += 1;
                        }
                        else
                        {
                            DrawingInfo.m_Context.textBaseline = "bottom";
                            yPos -= 1;
                        }

                        if( rTradingLineProperty.m_nTextPos === 0 ) // 왼쪽 텍스트
                        {
                            xPos = xLeftPos + 1;
                            DrawingInfo.m_Context.textAlign = "left";
                            DrawingInfo.m_Context.fillText(strText, xPos, yPos);
                        }
                        else if( rTradingLineProperty.m_nTextPos === 1 ) // 오른쪽 텍스트
                        {
                            DrawingInfo.m_Context.textAlign = "right";
                            if( j === 1 )   // 알림 X박스 옆으로 글자
                            {
                                xPos = xRightPos;
                                DrawingInfo.m_Context.fillText(strText, xPos - (nBoxSize + 2), yPos);
                            }
                            else    // 미체결, 평균매수가
                            {
                                xPos = xRightPos - 1;
                                DrawingInfo.m_Context.fillText(strText, xPos, yPos);
                            }
                        }
                        else if( rTradingLineProperty.m_nTextPos === 2 ) // 양쪽 그리기
                        {
                            xPos = xLeftPos + 1;
                            DrawingInfo.m_Context.textAlign = "left";
                            DrawingInfo.m_Context.fillText(strText, xPos, yPos);
                            
                            DrawingInfo.m_Context.textAlign = "right";
                            if( j === 1 ) // 알림 X박스 옆으로 글자
                            {
                                xPos = xRightPos;
                                DrawingInfo.m_Context.fillText(strText, xPos - (nBoxSize + 2), yPos);
                            }
                            else // 미체결, 평균매수가
                            {
                                xPos = xRightPos - 1;
                                DrawingInfo.m_Context.fillText(strText, xPos, yPos);
                            }
                        }
                    }

                    if( j == 1 ) // 알림 X박스 그리기
                    {
                        xPos = xRightPos;
                        DrawingInfo.m_Context.textAlign = "right";
                        DrawingInfo.m_Context.fillRect(xPos, yPos + (nBoxSize/2), -nBoxSize, -nBoxSize );

                        DrawingInfo.m_Context.lineWidth = nBoxThickness;
                        DrawingInfo.m_Context.strokeStyle = "#FFFFFF";
                        DrawingInfo.m_Context.beginPath();
        
                        DrawingInfo.m_Context.moveTo(xPos - (nBoxSize /2 + nXSize), yPos - nXSize);
                        DrawingInfo.m_Context.lineTo(xPos - nXSize, yPos + nXSize);
        
                        DrawingInfo.m_Context.moveTo(xPos - (nBoxSize /2 + nXSize), yPos + nXSize);
                        DrawingInfo.m_Context.lineTo(xPos - nXSize, yPos - nXSize);

                        DrawingInfo.m_Context.stroke();
                        DrawingInfo.m_Context.closePath();
                    }
                }
            }
        }
    }
}

CTradingLineMng.prototype.GetTradingLineShowFlag = function( nLineType )
{
    var bShowFlag = false;
    switch( nLineType )
    {
    case 0 : bShowFlag = this.m_TradingLineProperty.m_bShowNonContractLine; break;
    case 1:  bShowFlag = this.m_TradingLineProperty.m_bShowAlarmLine; break;
    case 2:  bShowFlag = this.m_TradingLineProperty.m_bShowAvgBuyPriceLine; break;
    }

    return bShowFlag;
}

CTradingLineMng.prototype.SetTradingLineShowFlag = function( nLineType, bShowFlag )
{
    switch( nLineType )
    {
    case 0 : this.m_TradingLineProperty.m_bShowNonContractLine = bShowFlag; break;
    case 1:  this.m_TradingLineProperty.m_bShowAlarmLine = bShowFlag; break;
    case 2:  this.m_TradingLineProperty.m_bShowAvgBuyPriceLine = bShowFlag; break;
    }
}
// 20190115 전중현 :트레이딩 라인 관련 (미체결, 알림(지정가), 평균매수가) <<

//LKY 스마트 시그널 조회 >>
export function CSmartSignalInfo(){

    this.m_strSignalType = "";
    this.m_strCode = "";
    this.m_strDateTime = "";
    this.m_strBuyingPrice = "";
    this.m_strTargetPrice = "";
    this.m_strStopLossPrice = "";
    this.m_strSellPrice = "";
}
function CSmartSignalProperty()
{
    this.m_nLineBuying = PS_SOLID;          // 매수가
    this.m_nLineTargetPrice = PS_SOLID;     // 목표가
    this.m_nLineStopLoss = PS_SOLID;        // 손절가

    this.m_nThicknessBuying = 1;
    this.m_nThicknessTargetPrice = 1;
    this.m_nThicknessStopLoss = 1;

    this.m_clrBuying = "#ff0000";
    this.m_clrTargetPrice = "#ff3a3a";
    this.m_clrStopLoss = "#282887";

    this.m_bShowBuying = false;
    this.m_bShowTargetPrice = false;
    this.m_bShowStopLoss = false;

    this.m_bUseSmartSignal = false;     // 스마트시그널 사용유무

    this.m_nSignalArrowMargin = 2;      //스마트 시그널 화살표 봉과의 간격
    this.m_nSignalArrowMinWidth = 7;    //스마트 시그널 화살표 최소 폭(머리)
    this.m_nSignalArrowMaxWidth = 17;   //스마트 시그널 화살표 최대 폭(머리)

    this.m_clrSignalBuyArrow = "#ff1744";   //스마트 시그널 매수 화살표 색
    this.m_clrSignalSellArrow = "#304ffe";  //스마트 시그널 매도 화살표 색

    this.m_SignalArrowHRatio = 1.53;

    this.m_nTextPos = 1;        // 0 : left, 1 : right, 2 : both
}
// 20190211 공현욱 스마트시그널 신호
CSmartSignalProperty.prototype.Copy = function( srcSmartSignalLineProperty )
{
    //기본자료형은 아래 루프를 통해 모두 복사
    for (var attr in srcSmartSignalLineProperty) {

        if (srcSmartSignalLineProperty.hasOwnProperty(attr)) {
            if (typeof (srcSmartSignalLineProperty[attr]) !== 'object') {//개체는 아래부분에서 별도 복사
                this[attr] = srcSmartSignalLineProperty[attr];
            }
        }
    }
    /*
    this.m_nLineBuying = srcSmartSignalLineProperty.m_nLineBuying;
    this.m_nLineTargetPrice = srcSmartSignalLineProperty.m_nLineTargetPrice;
    this.m_nLineStopLoss = srcSmartSignalLineProperty.m_nLineStopLoss;

    this.m_nThicknessBuying = srcSmartSignalLineProperty.m_nThicknessBuying;
    this.m_nThicknessTargetPrice = srcSmartSignalLineProperty.m_nThicknessTargetPrice;
    this.m_nThicknessStopLoss = srcSmartSignalLineProperty.m_nThicknessStopLoss;

    this.m_clrBuying = srcSmartSignalLineProperty.m_clrBuying;
    this.m_clrTargetPrice = srcSmartSignalLineProperty.m_clrTargetPrice;
    this.m_clrStopLoss = srcSmartSignalLineProperty.m_clm_clrStopLossrBuying;

    this.m_bUseSmartSignal = srcSmartSignalLineProperty.m_bUseSmartSignal;
    this.m_bShowBuying = srcSmartSignalLineProperty.m_bShowBuying;
    this.m_bShowTargetPrice = srcSmartSignalLineProperty.m_bShowTargetPrice;
    this.m_bShowStopLoss = srcSmartSignalLineProperty.m_bShowStopLoss;
    */
}

CSmartSignalProperty.prototype.SetClrBuying = function( clrBuying )
{
    this.m_strKeyOfClrBuying = null;
    this.m_clrBuying = clrBuying;
}
CSmartSignalProperty.prototype.SetClrTargetPrice = function( clrTargetPrice )
{
    this.m_strKeyOfClrTargetPrice = null;
    this.m_clrTargetPrice = clrTargetPrice;
}
CSmartSignalProperty.prototype.SetClrStopLoss = function( clrStopLoss )
{
    this.m_strKeyOfClrStopLoss = null;
    this.m_clrStopLoss = clrStopLoss;
}

CSmartSignalProperty.prototype.SetDefaultProperty = function( rChart )
{
    this.m_strKeyOfClrBuying = "m_clrBuying";
    this.m_clrBuying = rChart === undefined ? "#ff0000" : rChart.GetColorByKey(this.m_strKeyOfClrBuying);
    this.m_strKeyOfClrTargetPrice = "m_clrTargetPrice";
    this.m_clrTargetPrice = rChart === undefined ? "#ff3a3a" : rChart.GetColorByKey(this.m_strKeyOfClrTargetPrice);
    this.m_strKeyOfClrStopLoss = "m_clrStopLoss";
    this.m_clrStopLoss = rChart === undefined ? "#282887" : rChart.GetColorByKey(this.m_strKeyOfClrStopLoss);
   
    this.m_nLineBuying = PS_SOLID;          // 매수가
    this.m_nLineTargetPrice = PS_SOLID;     // 목표가
    this.m_nLineStopLoss = PS_SOLID;        // 손절가

    this.m_nThicknessBuying = 1;
    this.m_nThicknessTargetPrice = 1;
    this.m_nThicknessStopLoss = 1;

    this.m_bUseSmartSignal = false;  // 스마트시그널 사용유무
    this.m_bShowBuying = false;
    this.m_bShowTargetPrice = false;
    this.m_bShowStopLoss = false;
}

function CSmartSignalMng(rChart){

    this.m_rChart = rChart;
    this.m_rGlobalProperty = (this.m_rChart !== null ? this.m_rChart.GetGlobalProperty() : null);
    this.m_rChartBlock = null;

    this.m_SmartSignalInfoArray = [];
    this.m_rSmartSignalProperty = (this.m_rGlobalProperty !== null ? this.m_rGlobalProperty.m_SmartSignalLineProperty : null);

    this.m_rSmartSignalBuying =  new CPriceLine();
    this.m_rSmartSignalTargetPrice =  new CPriceLine();
    this.m_rSmartSignalStoploss =  new CPriceLine();
    this.m_rSmartSignalSell = new CPriceLine();

    this.m_strBuyPriceLineTextLangKey = "chart.buyprice";
    this.m_strTargetPriceLineTextLangKey = "chart.targetprice";
    this.m_strStopLossPriceLineTextLangKey = "chart.stoplossprice";

    this.m_strBuyPriceLineText = t(this.m_strBuyPriceLineTextLangKey);
    this.m_strTargetPriceLineText = t(this.m_strTargetPriceLineTextLangKey);
    this.m_strStopLossPriceLineText = t(this.m_strStopLossPriceLineTextLangKey);
}

CSmartSignalMng.prototype.Reset = function(rChart){

    if(!rChart) return;

    this.m_rChart = rChart;
    this.m_rGlobalProperty = this.m_rChart.GetGlobalProperty();
    this.m_rSmartSignalProperty = this.m_rGlobalProperty.m_SmartSignalLineProperty;
}

CSmartSignalMng.prototype.ChangeLang = function(){

    this.m_strBuyPriceLineText = t(this.m_strBuyPriceLineTextLangKey);
    this.m_strTargetPriceLineText = t(this.m_strTargetPriceLineTextLangKey);
    this.m_strStopLossPriceLineText = t(this.m_strStopLossPriceLineTextLangKey);
}

CSmartSignalMng.prototype.SetSmartSignalLine = function ( nSignalType, strItemCode, strBuying, strTargetPrice, strStopLoss, strSell ){

    if(nSignalType === 0){

        this.m_rSmartSignalBuying.m_strCode = strItemCode;
        this.m_rSmartSignalBuying.m_bShow = true;
        this.m_rSmartSignalBuying.m_bUsePacket = false;
        this.m_rSmartSignalBuying.m_strBaseValue = strBuying;
        this.m_rSmartSignalBuying.m_nLineType = 0;
        this.m_rSmartSignalBuying.m_nThickness = 1;

        this.m_rSmartSignalTargetPrice.m_strCode = strItemCode;
        this.m_rSmartSignalTargetPrice.m_bShow = true;
        this.m_rSmartSignalTargetPrice.m_bUsePacket = false;
        this.m_rSmartSignalTargetPrice.m_strBaseValue = strTargetPrice;
        this.m_rSmartSignalTargetPrice.m_nLineType = 0;
        this.m_rSmartSignalTargetPrice.m_nThickness = 1;

        this.m_rSmartSignalStoploss.m_strCode = strItemCode;
        this.m_rSmartSignalStoploss.m_bShow = true;
        this.m_rSmartSignalStoploss.m_bUsePacket = false;
        this.m_rSmartSignalStoploss.m_strBaseValue = strStopLoss;
        this.m_rSmartSignalStoploss.m_nLineType = 0;
        this.m_rSmartSignalStoploss.m_nThickness = 1;

        this.m_rSmartSignalSell.m_strCode = strItemCode;
        this.m_rSmartSignalSell.m_bUsePacket = false;
        this.m_rSmartSignalSell.m_strBaseValue = strSell;
    }
    else{
        this.m_rSmartSignalBuying.m_bShow = false;
        this.m_rSmartSignalTargetPrice.m_bShow = false;
        this.m_rSmartSignalStoploss.m_bShow = false;
    }

    return true;
}

CSmartSignalMng.prototype.Draw = function(DrawingInfo){

    if( this.m_rChartBlock === null )
        return;
    
    // 20190212 공현욱 스마트시그널신호 값 세팅 >>
    var nSignalType = 0;
    var strItemCode = "";
    var strBuying = "";
    var strTargetPrice = "";
    var strStopLoss = "";
    var strSell = "";
    var rSmartSignalProperty = this.m_rSmartSignalProperty;

    if( rSmartSignalProperty.m_bUseSmartSignal !== true )
        return;

    if( this.m_SmartSignalInfoArray.length > 0)
    {
        strItemCode = this.m_SmartSignalInfoArray[0].m_strCode;
        strBuying = this.m_SmartSignalInfoArray[0].m_strBuyingPrice;
        if( strBuying === "")
            nSignalType = 1;
        else
            nSignalType = 0;
        strSell = this.m_SmartSignalInfoArray[0].m_strSellPrice
        strTargetPrice = this.m_SmartSignalInfoArray[0].m_strTargetPrice;
        strStopLoss = this.m_SmartSignalInfoArray[0].m_strStopLossPrice;
    }
    else
        return;

    var IndicatorArray = [];
    var strRQ, rRQSet;

    for( strRQ in this.m_rChart.m_mapRQSet)
    {
        rRQSet = this.m_rChart.m_mapRQSet[strRQ];
        if(rRQSet.m_RQInfo.m_strItemCode === strItemCode && rRQSet.m_RQInfo.m_nCycle === CYCLE_MIN && rRQSet.m_RQInfo.m_nInterval <= 60)
        {
            IndicatorArray[IndicatorArray.length] = rRQSet.m_rPriceIndicator;
        }
    }
    if(IndicatorArray.length <= 0)
        return;

    this.SetSmartSignalLine(nSignalType, strItemCode, strBuying, strTargetPrice, strStopLoss, strSell);
    // 20190212 공현욱 스마트시그널신호 값 세팅 <<

    var nIndex, nIndex1, YScaleArray = [], nIndiLen = IndicatorArray.length, nYScaleLen ;
    for(nIndex = 0; nIndex < nIndiLen ; nIndex++)
    {
        var rPriceIndicator = IndicatorArray[nIndex];
        nYScaleLen = YScaleArray.length;
        for(nIndex1 = 0; nIndex1 < nYScaleLen; nIndex1++)
        {
            var rYScale = YScaleArray[nIndex1];
            if(rYScale === rPriceIndicator.m_rYScale)
                break;
        }
        if(nIndex1 >= nYScaleLen)
            YScaleArray[YScaleArray.length] = rPriceIndicator.m_rYScale;
    }

    var rectGraphRegion = this.m_rChartBlock.m_rectGraphRegion;
    var rectGraphBackground = this.m_rChartBlock.m_rectGraphBackground;
    var nGraphRegionHeight = rectGraphRegion.Height();

    nYScaleLen = YScaleArray.length;
    for(nIndex = 0; nIndex < nYScaleLen; nIndex++)
    {
        var rYScale = YScaleArray[nIndex];//this.m_rChartBlock.GetSelectedYScale();

        var xLeftPos, xRightPos, yPos, xPos;
        var strText, strBaseValue, strPrice;
        
        var yMin, yMax, yDiff, Price;
        var bLog = rYScale.GetLog();
        var bInvert = rYScale.GetInvert();
        var clrLine, bShow, nLineType, nThickness;

        if (bLog === true) {

            yMin = Log(rYScale.m_MinMaxInfo.m_LowerLimit);
            yMax = Log(rYScale.m_MinMaxInfo.m_UpperLimit);
        }
        else {

            yMin = rYScale.m_MinMaxInfo.m_LowerLimit;
            yMax = rYScale.m_MinMaxInfo.m_UpperLimit;
        }
        yDiff = yMax - yMin;

        xLeftPos = rectGraphBackground.m_nLeft;
        xRightPos = rectGraphBackground.m_nRight;

        for (var i = 0; i < 3; i++){

            switch( i )
            {
                case 0:
                    {
                        //매수가
                        strBaseValue = this.m_rSmartSignalBuying.m_strBaseValue;
                        clrLine = rSmartSignalProperty.m_clrBuying;
                        bShow = rSmartSignalProperty.m_bShowBuying;
                        nLineType = rSmartSignalProperty.m_nLineBuying;
                        nThickness = rSmartSignalProperty.m_nThicknessBuying;
                        strText = this.m_strBuyPriceLineText ;
                        
                    }break;
                case 1:
                    {
                        //목표가
                        strBaseValue = this.m_rSmartSignalTargetPrice.m_strBaseValue;
                        clrLine = rSmartSignalProperty.m_clrTargetPrice;
                        bShow = rSmartSignalProperty.m_bShowTargetPrice;
                        nLineType = rSmartSignalProperty.m_nLineTargetPrice;
                        nThickness = rSmartSignalProperty.m_nThicknessTargetPrice;
                        strText = this.m_strTargetPriceLineText ;
                    }break;
                case 2:
                    {
                        //손절가
                        strBaseValue = this.m_rSmartSignalStoploss.m_strBaseValue;
                        clrLine = rSmartSignalProperty.m_clrStopLoss;
                        bShow = rSmartSignalProperty.m_bShowStopLoss;
                        nLineType = rSmartSignalProperty.m_nLineStopLoss;
                        nThickness = rSmartSignalProperty.m_nThicknessStopLoss;
                        strText = this.m_strStopLossPriceLineText ;
                    }break;
            }

            if( strBaseValue === null || strBaseValue === undefined )
                continue;

            if( bShow === true )
            {
                Price = bLog === true ? Log(strBaseValue) : strBaseValue;
                yPos = rectGraphRegion.m_nBottom - (Price - yMin) / yDiff * nGraphRegionHeight;
                if (bInvert === true)
                    yPos = rectGraphRegion.m_nBottom - yPos + rectGraphRegion.m_nTop;

                if (yPos > rectGraphRegion.m_nTop && yPos < rectGraphRegion.m_nBottom)
                {
                    DrawingInfo.m_Context.fillStyle = clrLine;
                    
                    {
                        switch (nLineType)
                        {
                        case PS_SOLID : DrawingInfo.m_Context.setLineDash([0, 0]); break;
                        case PS_DASH  : DrawingInfo.m_Context.setLineDash([8, 4]); break;
                        case PS_DOT   : DrawingInfo.m_Context.setLineDash([2, 3]); break;
                        }
                        
                        DrawingInfo.m_Context.strokeStyle = clrLine;
                        DrawingInfo.m_Context.lineWidth = nThickness;
        
                        DrawingInfo.m_Context.beginPath();
        
                        DrawingInfo.m_Context.moveTo(xRightPos, yPos);
                        DrawingInfo.m_Context.lineTo(xLeftPos, yPos);
        
                        DrawingInfo.m_Context.stroke();
                        DrawingInfo.m_Context.closePath();
                        
                        strPrice = ConvertNumToDigitText(strBaseValue, rYScale.m_nDec, 1, rYScale.m_nDigit, -1, this.m_rGlobalProperty.m_bShowThousandComma);
                        strText += strPrice;

                        // 상단 타이틀 영역 or 그래프 영역 넘어서지 않도록 예외처리
                        if( yPos - DrawingInfo.m_nFontHeight < rectGraphRegion.m_nTop )
                        {
                            DrawingInfo.m_Context.textBaseline = "top";
                            yPos += 1;
                        }
                        else
                        {
                            DrawingInfo.m_Context.textBaseline = "bottom";
                            yPos -= 1;
                        }

                        if( rSmartSignalProperty.m_nTextPos === 0 ) // 왼쪽 텍스트
                        {
                            xPos = xLeftPos + 1;
                            DrawingInfo.m_Context.textAlign = "left";
                            DrawingInfo.m_Context.fillText(strText, xPos, yPos);
                        }
                        else if( rSmartSignalProperty.m_nTextPos === 1 ) // 오른쪽 텍스트
                        {
                            DrawingInfo.m_Context.textAlign = "right";
                            xPos = xRightPos - 1;
                            DrawingInfo.m_Context.fillText(strText, xPos, yPos);
                        }
                        else if( rSmartSignalProperty.m_nTextPos === 2 ) // 양쪽 그리기
                        {
                            xPos = xLeftPos + 1;
                            DrawingInfo.m_Context.textAlign = "left";
                            DrawingInfo.m_Context.fillText(strText, xPos, yPos);
                            
                            DrawingInfo.m_Context.textAlign = "right";
                            xPos = xRightPos - 1;
                            DrawingInfo.m_Context.fillText(strText, xPos, yPos);
                        }
                    }
                }
            }
        }
    }
}

CSmartSignalMng.prototype.DrawArrow = function(DrawingInfo){
    
    if( this.m_rChartBlock === null )
        return;

}
//LKY 스마트 시그널 조회 <<

CHTMLChart.prototype.ShowToolMngBtn = function (e) {

  const self = this,
  target = e.targetTouches !== undefined ? e.targetTouches[0] : e;
  let chartY = target.clientY || target.ChartYPos,
  chartX = target.clientX || target.ChartXPos;

  this.HideToolMngBtn();

  let html = [];
  html.push('<li><a href="#" id="btn_modify">'+ t('mchart.modify') + '</a></li>');  //수정
  html.push('<li>|</li>');
  html.push('<li><a href="#" id="btn_delete">'+ t('mchart.del') + '</a></li>');  //삭제
  html.push('<li>|</li>');
  html.push('<li><a href="#" id="btn_deleteAll">'+ t('mchart.alldel') + '</a></li>');  //전체삭제

  this.m_ToolMngBtn = document.createElement('ul');
  this.m_ToolMngBtn.className = 'btn_tool_mng';
  this.m_ToolMngBtn.innerHTML = html.join('');
  this.m_ToolMngBtn.style.position = 'absolute';

  let list = this.m_ToolMngBtn.getElementsByTagName('a');
  list[0].addEventListener('click', function () {
    console.log('수정');
    MobileTool(e);
    self.Draw(DRAW_CASE_REAL);
  });

  list[1].addEventListener('click', function () {
    console.log('삭제');
    self.m_MainBlock.m_ToolMng.RemoveOneTool( self.m_MainBlock.m_ToolMng.m_SelectedTool );
    self.m_MainBlock.m_ToolMng.m_SelectedTool = null;
    self.HideToolMngBtn();
  });

  list[2].addEventListener('click', function () {
    console.log('전체삭제');
    self.RemoveAllTool();
    self.HideToolMngBtn();
    self.Draw(DRAW_CASE_REAL);
  });

  var rChartPopupWrapper = document.getElementById('chart-popup-wrapper');
  if (rChartPopupWrapper !== null)
    rChartPopupWrapper.appendChild(this.m_ToolMngBtn);
  //test
  else
    this.m_rChart.m_ChartParentDIV.appendChild(this.m_ToolMngBtn);

  // 버튼 영역이 창 밖으로 벗어나지 않도록 좌표 수정
  let toolMngBtnRight = chartX + this.m_ToolMngBtn.offsetWidth,
  toolMngBtnBottom = chartY + this.m_ToolMngBtn.offsetHeight;

  if (screen.width < toolMngBtnRight) {
    chartX = screen.width - this.m_ToolMngBtn.offsetWidth;
  }
  if (screen.height < toolMngBtnBottom) {
    chartY = screen.height - this.m_ToolMngBtn.offsetHeight;
  }

  this.m_ToolMngBtn.style.top = chartY + 'px';
  this.m_ToolMngBtn.style.left = chartX + 'px';
};

CHTMLChart.prototype.HideToolMngBtn = function () {
    if (this.m_ToolMngBtn != null && this.m_ToolMngBtn.parentNode) {
        this.m_ToolMngBtn.parentNode.removeChild(this.m_ToolMngBtn);
        this.m_ToolMngBtn = null;
    }
}
